var batchServiceClient =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ms_rest_azure_js_1 = __webpack_require__(3);
exports.CloudError = ms_rest_azure_js_1.CloudErrorMapper;
exports.BaseResource = ms_rest_azure_js_1.BaseResourceMapper;
exports.PoolUsageMetrics = {
    serializedName: "PoolUsageMetrics",
    type: {
        name: "Composite",
        className: "PoolUsageMetrics",
        modelProperties: {
            poolId: {
                required: true,
                serializedName: "poolId",
                type: {
                    name: "String"
                }
            },
            startTime: {
                required: true,
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                required: true,
                serializedName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            vmSize: {
                required: true,
                serializedName: "vmSize",
                type: {
                    name: "String"
                }
            },
            totalCoreHours: {
                required: true,
                serializedName: "totalCoreHours",
                type: {
                    name: "Number"
                }
            },
            dataIngressGiB: {
                required: true,
                serializedName: "dataIngressGiB",
                type: {
                    name: "Number"
                }
            },
            dataEgressGiB: {
                required: true,
                serializedName: "dataEgressGiB",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
exports.ImageReference = {
    serializedName: "ImageReference",
    type: {
        name: "Composite",
        className: "ImageReference",
        modelProperties: {
            publisher: {
                serializedName: "publisher",
                type: {
                    name: "String"
                }
            },
            offer: {
                serializedName: "offer",
                type: {
                    name: "String"
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "version",
                type: {
                    name: "String"
                }
            },
            virtualMachineImageId: {
                serializedName: "virtualMachineImageId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.NodeAgentSku = {
    serializedName: "NodeAgentSku",
    type: {
        name: "Composite",
        className: "NodeAgentSku",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            verifiedImageReferences: {
                serializedName: "verifiedImageReferences",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ImageReferenceElementType",
                        type: {
                            name: "Composite",
                            className: "ImageReference"
                        }
                    }
                }
            },
            osType: {
                serializedName: "osType",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "linux",
                        "windows"
                    ]
                }
            }
        }
    }
};
exports.AuthenticationTokenSettings = {
    serializedName: "AuthenticationTokenSettings",
    type: {
        name: "Composite",
        className: "AuthenticationTokenSettings",
        modelProperties: {
            access: {
                serializedName: "access",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "AccessScopeElementType",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "job"
                            ]
                        }
                    }
                }
            }
        }
    }
};
exports.UsageStatistics = {
    serializedName: "UsageStatistics",
    type: {
        name: "Composite",
        className: "UsageStatistics",
        modelProperties: {
            startTime: {
                required: true,
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            lastUpdateTime: {
                required: true,
                serializedName: "lastUpdateTime",
                type: {
                    name: "DateTime"
                }
            },
            dedicatedCoreTime: {
                required: true,
                serializedName: "dedicatedCoreTime",
                type: {
                    name: "TimeSpan"
                }
            }
        }
    }
};
exports.ResourceStatistics = {
    serializedName: "ResourceStatistics",
    type: {
        name: "Composite",
        className: "ResourceStatistics",
        modelProperties: {
            startTime: {
                required: true,
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            lastUpdateTime: {
                required: true,
                serializedName: "lastUpdateTime",
                type: {
                    name: "DateTime"
                }
            },
            avgCPUPercentage: {
                required: true,
                serializedName: "avgCPUPercentage",
                type: {
                    name: "Number"
                }
            },
            avgMemoryGiB: {
                required: true,
                serializedName: "avgMemoryGiB",
                type: {
                    name: "Number"
                }
            },
            peakMemoryGiB: {
                required: true,
                serializedName: "peakMemoryGiB",
                type: {
                    name: "Number"
                }
            },
            avgDiskGiB: {
                required: true,
                serializedName: "avgDiskGiB",
                type: {
                    name: "Number"
                }
            },
            peakDiskGiB: {
                required: true,
                serializedName: "peakDiskGiB",
                type: {
                    name: "Number"
                }
            },
            diskReadIOps: {
                required: true,
                serializedName: "diskReadIOps",
                type: {
                    name: "Number"
                }
            },
            diskWriteIOps: {
                required: true,
                serializedName: "diskWriteIOps",
                type: {
                    name: "Number"
                }
            },
            diskReadGiB: {
                required: true,
                serializedName: "diskReadGiB",
                type: {
                    name: "Number"
                }
            },
            diskWriteGiB: {
                required: true,
                serializedName: "diskWriteGiB",
                type: {
                    name: "Number"
                }
            },
            networkReadGiB: {
                required: true,
                serializedName: "networkReadGiB",
                type: {
                    name: "Number"
                }
            },
            networkWriteGiB: {
                required: true,
                serializedName: "networkWriteGiB",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
exports.PoolStatistics = {
    serializedName: "PoolStatistics",
    type: {
        name: "Composite",
        className: "PoolStatistics",
        modelProperties: {
            url: {
                required: true,
                serializedName: "url",
                type: {
                    name: "String"
                }
            },
            startTime: {
                required: true,
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            lastUpdateTime: {
                required: true,
                serializedName: "lastUpdateTime",
                type: {
                    name: "DateTime"
                }
            },
            usageStats: {
                serializedName: "usageStats",
                type: {
                    name: "Composite",
                    className: "UsageStatistics"
                }
            },
            resourceStats: {
                serializedName: "resourceStats",
                type: {
                    name: "Composite",
                    className: "ResourceStatistics"
                }
            }
        }
    }
};
exports.JobStatistics = {
    serializedName: "JobStatistics",
    type: {
        name: "Composite",
        className: "JobStatistics",
        modelProperties: {
            url: {
                required: true,
                serializedName: "url",
                type: {
                    name: "String"
                }
            },
            startTime: {
                required: true,
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            lastUpdateTime: {
                required: true,
                serializedName: "lastUpdateTime",
                type: {
                    name: "DateTime"
                }
            },
            userCPUTime: {
                required: true,
                serializedName: "userCPUTime",
                type: {
                    name: "TimeSpan"
                }
            },
            kernelCPUTime: {
                required: true,
                serializedName: "kernelCPUTime",
                type: {
                    name: "TimeSpan"
                }
            },
            wallClockTime: {
                required: true,
                serializedName: "wallClockTime",
                type: {
                    name: "TimeSpan"
                }
            },
            readIOps: {
                required: true,
                serializedName: "readIOps",
                type: {
                    name: "Number"
                }
            },
            writeIOps: {
                required: true,
                serializedName: "writeIOps",
                type: {
                    name: "Number"
                }
            },
            readIOGiB: {
                required: true,
                serializedName: "readIOGiB",
                type: {
                    name: "Number"
                }
            },
            writeIOGiB: {
                required: true,
                serializedName: "writeIOGiB",
                type: {
                    name: "Number"
                }
            },
            numSucceededTasks: {
                required: true,
                serializedName: "numSucceededTasks",
                type: {
                    name: "Number"
                }
            },
            numFailedTasks: {
                required: true,
                serializedName: "numFailedTasks",
                type: {
                    name: "Number"
                }
            },
            numTaskRetries: {
                required: true,
                serializedName: "numTaskRetries",
                type: {
                    name: "Number"
                }
            },
            waitTime: {
                required: true,
                serializedName: "waitTime",
                type: {
                    name: "TimeSpan"
                }
            }
        }
    }
};
exports.NameValuePair = {
    serializedName: "NameValuePair",
    type: {
        name: "Composite",
        className: "NameValuePair",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.DeleteCertificateError = {
    serializedName: "DeleteCertificateError",
    type: {
        name: "Composite",
        className: "DeleteCertificateError",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "NameValuePairElementType",
                        type: {
                            name: "Composite",
                            className: "NameValuePair"
                        }
                    }
                }
            }
        }
    }
};
exports.Certificate = {
    serializedName: "Certificate",
    type: {
        name: "Composite",
        className: "Certificate",
        modelProperties: {
            thumbprint: {
                serializedName: "thumbprint",
                type: {
                    name: "String"
                }
            },
            thumbprintAlgorithm: {
                serializedName: "thumbprintAlgorithm",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "active",
                        "deleting",
                        "deletefailed"
                    ]
                }
            },
            stateTransitionTime: {
                serializedName: "stateTransitionTime",
                type: {
                    name: "DateTime"
                }
            },
            previousState: {
                serializedName: "previousState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "active",
                        "deleting",
                        "deletefailed"
                    ]
                }
            },
            previousStateTransitionTime: {
                serializedName: "previousStateTransitionTime",
                type: {
                    name: "DateTime"
                }
            },
            publicData: {
                serializedName: "publicData",
                type: {
                    name: "String"
                }
            },
            deleteCertificateError: {
                serializedName: "deleteCertificateError",
                type: {
                    name: "Composite",
                    className: "DeleteCertificateError"
                }
            }
        }
    }
};
exports.ApplicationPackageReference = {
    serializedName: "ApplicationPackageReference",
    type: {
        name: "Composite",
        className: "ApplicationPackageReference",
        modelProperties: {
            applicationId: {
                required: true,
                serializedName: "applicationId",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "version",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.ApplicationSummary = {
    serializedName: "ApplicationSummary",
    type: {
        name: "Composite",
        className: "ApplicationSummary",
        modelProperties: {
            id: {
                required: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            displayName: {
                required: true,
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            versions: {
                required: true,
                serializedName: "versions",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "stringElementType",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
exports.CertificateAddParameter = {
    serializedName: "CertificateAddParameter",
    type: {
        name: "Composite",
        className: "CertificateAddParameter",
        modelProperties: {
            thumbprint: {
                required: true,
                serializedName: "thumbprint",
                type: {
                    name: "String"
                }
            },
            thumbprintAlgorithm: {
                required: true,
                serializedName: "thumbprintAlgorithm",
                type: {
                    name: "String"
                }
            },
            data: {
                required: true,
                serializedName: "data",
                type: {
                    name: "String"
                }
            },
            certificateFormat: {
                serializedName: "certificateFormat",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "pfx",
                        "cer"
                    ]
                }
            },
            password: {
                serializedName: "password",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.FileProperties = {
    serializedName: "FileProperties",
    type: {
        name: "Composite",
        className: "FileProperties",
        modelProperties: {
            creationTime: {
                serializedName: "creationTime",
                type: {
                    name: "DateTime"
                }
            },
            lastModified: {
                required: true,
                serializedName: "lastModified",
                type: {
                    name: "DateTime"
                }
            },
            contentLength: {
                required: true,
                serializedName: "contentLength",
                type: {
                    name: "Number"
                }
            },
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            },
            fileMode: {
                serializedName: "fileMode",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.NodeFile = {
    serializedName: "NodeFile",
    type: {
        name: "Composite",
        className: "NodeFile",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                type: {
                    name: "String"
                }
            },
            isDirectory: {
                serializedName: "isDirectory",
                type: {
                    name: "Boolean"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "FileProperties"
                }
            }
        }
    }
};
exports.Schedule = {
    serializedName: "Schedule",
    type: {
        name: "Composite",
        className: "Schedule",
        modelProperties: {
            doNotRunUntil: {
                serializedName: "doNotRunUntil",
                type: {
                    name: "DateTime"
                }
            },
            doNotRunAfter: {
                serializedName: "doNotRunAfter",
                type: {
                    name: "DateTime"
                }
            },
            startWindow: {
                serializedName: "startWindow",
                type: {
                    name: "TimeSpan"
                }
            },
            recurrenceInterval: {
                serializedName: "recurrenceInterval",
                type: {
                    name: "TimeSpan"
                }
            }
        }
    }
};
exports.JobConstraints = {
    serializedName: "JobConstraints",
    type: {
        name: "Composite",
        className: "JobConstraints",
        modelProperties: {
            maxWallClockTime: {
                serializedName: "maxWallClockTime",
                type: {
                    name: "TimeSpan"
                }
            },
            maxTaskRetryCount: {
                serializedName: "maxTaskRetryCount",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
exports.ContainerRegistry = {
    serializedName: "ContainerRegistry",
    type: {
        name: "Composite",
        className: "ContainerRegistry",
        modelProperties: {
            registryServer: {
                serializedName: "registryServer",
                type: {
                    name: "String"
                }
            },
            userName: {
                required: true,
                serializedName: "username",
                type: {
                    name: "String"
                }
            },
            password: {
                required: true,
                serializedName: "password",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.TaskContainerSettings = {
    serializedName: "TaskContainerSettings",
    type: {
        name: "Composite",
        className: "TaskContainerSettings",
        modelProperties: {
            containerRunOptions: {
                serializedName: "containerRunOptions",
                type: {
                    name: "String"
                }
            },
            imageName: {
                required: true,
                serializedName: "imageName",
                type: {
                    name: "String"
                }
            },
            registry: {
                serializedName: "registry",
                type: {
                    name: "Composite",
                    className: "ContainerRegistry"
                }
            }
        }
    }
};
exports.ResourceFile = {
    serializedName: "ResourceFile",
    type: {
        name: "Composite",
        className: "ResourceFile",
        modelProperties: {
            blobSource: {
                required: true,
                serializedName: "blobSource",
                type: {
                    name: "String"
                }
            },
            filePath: {
                required: true,
                serializedName: "filePath",
                type: {
                    name: "String"
                }
            },
            fileMode: {
                serializedName: "fileMode",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.EnvironmentSetting = {
    serializedName: "EnvironmentSetting",
    type: {
        name: "Composite",
        className: "EnvironmentSetting",
        modelProperties: {
            name: {
                required: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.ExitOptions = {
    serializedName: "ExitOptions",
    type: {
        name: "Composite",
        className: "ExitOptions",
        modelProperties: {
            jobAction: {
                serializedName: "jobAction",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "none",
                        "disable",
                        "terminate"
                    ]
                }
            },
            dependencyAction: {
                serializedName: "dependencyAction",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "satisfy",
                        "block"
                    ]
                }
            }
        }
    }
};
exports.ExitCodeMapping = {
    serializedName: "ExitCodeMapping",
    type: {
        name: "Composite",
        className: "ExitCodeMapping",
        modelProperties: {
            code: {
                required: true,
                serializedName: "code",
                type: {
                    name: "Number"
                }
            },
            exitOptions: {
                required: true,
                serializedName: "exitOptions",
                type: {
                    name: "Composite",
                    className: "ExitOptions"
                }
            }
        }
    }
};
exports.ExitCodeRangeMapping = {
    serializedName: "ExitCodeRangeMapping",
    type: {
        name: "Composite",
        className: "ExitCodeRangeMapping",
        modelProperties: {
            start: {
                required: true,
                serializedName: "start",
                type: {
                    name: "Number"
                }
            },
            end: {
                required: true,
                serializedName: "end",
                type: {
                    name: "Number"
                }
            },
            exitOptions: {
                required: true,
                serializedName: "exitOptions",
                type: {
                    name: "Composite",
                    className: "ExitOptions"
                }
            }
        }
    }
};
exports.ExitConditions = {
    serializedName: "ExitConditions",
    type: {
        name: "Composite",
        className: "ExitConditions",
        modelProperties: {
            exitCodes: {
                serializedName: "exitCodes",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ExitCodeMappingElementType",
                        type: {
                            name: "Composite",
                            className: "ExitCodeMapping"
                        }
                    }
                }
            },
            exitCodeRanges: {
                serializedName: "exitCodeRanges",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ExitCodeRangeMappingElementType",
                        type: {
                            name: "Composite",
                            className: "ExitCodeRangeMapping"
                        }
                    }
                }
            },
            preProcessingError: {
                serializedName: "preProcessingError",
                type: {
                    name: "Composite",
                    className: "ExitOptions"
                }
            },
            fileUploadError: {
                serializedName: "fileUploadError",
                type: {
                    name: "Composite",
                    className: "ExitOptions"
                }
            },
            default: {
                serializedName: "default",
                type: {
                    name: "Composite",
                    className: "ExitOptions"
                }
            }
        }
    }
};
exports.AutoUserSpecification = {
    serializedName: "AutoUserSpecification",
    type: {
        name: "Composite",
        className: "AutoUserSpecification",
        modelProperties: {
            scope: {
                serializedName: "scope",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "task",
                        "pool"
                    ]
                }
            },
            elevationLevel: {
                serializedName: "elevationLevel",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "nonadmin",
                        "admin"
                    ]
                }
            }
        }
    }
};
exports.UserIdentity = {
    serializedName: "UserIdentity",
    type: {
        name: "Composite",
        className: "UserIdentity",
        modelProperties: {
            userName: {
                serializedName: "username",
                type: {
                    name: "String"
                }
            },
            autoUser: {
                serializedName: "autoUser",
                type: {
                    name: "Composite",
                    className: "AutoUserSpecification"
                }
            }
        }
    }
};
exports.LinuxUserConfiguration = {
    serializedName: "LinuxUserConfiguration",
    type: {
        name: "Composite",
        className: "LinuxUserConfiguration",
        modelProperties: {
            uid: {
                serializedName: "uid",
                type: {
                    name: "Number"
                }
            },
            gid: {
                serializedName: "gid",
                type: {
                    name: "Number"
                }
            },
            sshPrivateKey: {
                serializedName: "sshPrivateKey",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.UserAccount = {
    serializedName: "UserAccount",
    type: {
        name: "Composite",
        className: "UserAccount",
        modelProperties: {
            name: {
                required: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            password: {
                required: true,
                serializedName: "password",
                type: {
                    name: "String"
                }
            },
            elevationLevel: {
                serializedName: "elevationLevel",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "nonadmin",
                        "admin"
                    ]
                }
            },
            linuxUserConfiguration: {
                serializedName: "linuxUserConfiguration",
                type: {
                    name: "Composite",
                    className: "LinuxUserConfiguration"
                }
            }
        }
    }
};
exports.TaskConstraints = {
    serializedName: "TaskConstraints",
    type: {
        name: "Composite",
        className: "TaskConstraints",
        modelProperties: {
            maxWallClockTime: {
                serializedName: "maxWallClockTime",
                type: {
                    name: "TimeSpan"
                }
            },
            retentionTime: {
                serializedName: "retentionTime",
                type: {
                    name: "TimeSpan"
                }
            },
            maxTaskRetryCount: {
                serializedName: "maxTaskRetryCount",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
exports.OutputFileBlobContainerDestination = {
    serializedName: "OutputFileBlobContainerDestination",
    type: {
        name: "Composite",
        className: "OutputFileBlobContainerDestination",
        modelProperties: {
            path: {
                serializedName: "path",
                type: {
                    name: "String"
                }
            },
            containerUrl: {
                required: true,
                serializedName: "containerUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.OutputFileDestination = {
    serializedName: "OutputFileDestination",
    type: {
        name: "Composite",
        className: "OutputFileDestination",
        modelProperties: {
            container: {
                serializedName: "container",
                type: {
                    name: "Composite",
                    className: "OutputFileBlobContainerDestination"
                }
            }
        }
    }
};
exports.OutputFileUploadOptions = {
    serializedName: "OutputFileUploadOptions",
    type: {
        name: "Composite",
        className: "OutputFileUploadOptions",
        modelProperties: {
            uploadCondition: {
                required: true,
                serializedName: "uploadCondition",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "tasksuccess",
                        "taskfailure",
                        "taskcompletion"
                    ]
                }
            }
        }
    }
};
exports.OutputFile = {
    serializedName: "OutputFile",
    type: {
        name: "Composite",
        className: "OutputFile",
        modelProperties: {
            filePattern: {
                required: true,
                serializedName: "filePattern",
                type: {
                    name: "String"
                }
            },
            destination: {
                required: true,
                serializedName: "destination",
                type: {
                    name: "Composite",
                    className: "OutputFileDestination"
                }
            },
            uploadOptions: {
                required: true,
                serializedName: "uploadOptions",
                type: {
                    name: "Composite",
                    className: "OutputFileUploadOptions"
                }
            }
        }
    }
};
exports.JobManagerTask = {
    serializedName: "JobManagerTask",
    type: {
        name: "Composite",
        className: "JobManagerTask",
        modelProperties: {
            id: {
                required: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            commandLine: {
                required: true,
                serializedName: "commandLine",
                type: {
                    name: "String"
                }
            },
            containerSettings: {
                serializedName: "containerSettings",
                type: {
                    name: "Composite",
                    className: "TaskContainerSettings"
                }
            },
            resourceFiles: {
                serializedName: "resourceFiles",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ResourceFileElementType",
                        type: {
                            name: "Composite",
                            className: "ResourceFile"
                        }
                    }
                }
            },
            outputFiles: {
                serializedName: "outputFiles",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "OutputFileElementType",
                        type: {
                            name: "Composite",
                            className: "OutputFile"
                        }
                    }
                }
            },
            environmentSettings: {
                serializedName: "environmentSettings",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "EnvironmentSettingElementType",
                        type: {
                            name: "Composite",
                            className: "EnvironmentSetting"
                        }
                    }
                }
            },
            constraints: {
                serializedName: "constraints",
                type: {
                    name: "Composite",
                    className: "TaskConstraints"
                }
            },
            killJobOnCompletion: {
                serializedName: "killJobOnCompletion",
                type: {
                    name: "Boolean"
                }
            },
            userIdentity: {
                serializedName: "userIdentity",
                type: {
                    name: "Composite",
                    className: "UserIdentity"
                }
            },
            runExclusive: {
                serializedName: "runExclusive",
                type: {
                    name: "Boolean"
                }
            },
            applicationPackageReferences: {
                serializedName: "applicationPackageReferences",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ApplicationPackageReferenceElementType",
                        type: {
                            name: "Composite",
                            className: "ApplicationPackageReference"
                        }
                    }
                }
            },
            authenticationTokenSettings: {
                serializedName: "authenticationTokenSettings",
                type: {
                    name: "Composite",
                    className: "AuthenticationTokenSettings"
                }
            },
            allowLowPriorityNode: {
                serializedName: "allowLowPriorityNode",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
exports.JobPreparationTask = {
    serializedName: "JobPreparationTask",
    type: {
        name: "Composite",
        className: "JobPreparationTask",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            commandLine: {
                required: true,
                serializedName: "commandLine",
                type: {
                    name: "String"
                }
            },
            containerSettings: {
                serializedName: "containerSettings",
                type: {
                    name: "Composite",
                    className: "TaskContainerSettings"
                }
            },
            resourceFiles: {
                serializedName: "resourceFiles",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ResourceFileElementType",
                        type: {
                            name: "Composite",
                            className: "ResourceFile"
                        }
                    }
                }
            },
            environmentSettings: {
                serializedName: "environmentSettings",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "EnvironmentSettingElementType",
                        type: {
                            name: "Composite",
                            className: "EnvironmentSetting"
                        }
                    }
                }
            },
            constraints: {
                serializedName: "constraints",
                type: {
                    name: "Composite",
                    className: "TaskConstraints"
                }
            },
            waitForSuccess: {
                serializedName: "waitForSuccess",
                type: {
                    name: "Boolean"
                }
            },
            userIdentity: {
                serializedName: "userIdentity",
                type: {
                    name: "Composite",
                    className: "UserIdentity"
                }
            },
            rerunOnNodeRebootAfterSuccess: {
                serializedName: "rerunOnNodeRebootAfterSuccess",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
exports.JobReleaseTask = {
    serializedName: "JobReleaseTask",
    type: {
        name: "Composite",
        className: "JobReleaseTask",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            commandLine: {
                required: true,
                serializedName: "commandLine",
                type: {
                    name: "String"
                }
            },
            containerSettings: {
                serializedName: "containerSettings",
                type: {
                    name: "Composite",
                    className: "TaskContainerSettings"
                }
            },
            resourceFiles: {
                serializedName: "resourceFiles",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ResourceFileElementType",
                        type: {
                            name: "Composite",
                            className: "ResourceFile"
                        }
                    }
                }
            },
            environmentSettings: {
                serializedName: "environmentSettings",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "EnvironmentSettingElementType",
                        type: {
                            name: "Composite",
                            className: "EnvironmentSetting"
                        }
                    }
                }
            },
            maxWallClockTime: {
                serializedName: "maxWallClockTime",
                type: {
                    name: "TimeSpan"
                }
            },
            retentionTime: {
                serializedName: "retentionTime",
                type: {
                    name: "TimeSpan"
                }
            },
            userIdentity: {
                serializedName: "userIdentity",
                type: {
                    name: "Composite",
                    className: "UserIdentity"
                }
            }
        }
    }
};
exports.TaskSchedulingPolicy = {
    serializedName: "TaskSchedulingPolicy",
    type: {
        name: "Composite",
        className: "TaskSchedulingPolicy",
        modelProperties: {
            nodeFillType: {
                required: true,
                serializedName: "nodeFillType",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "spread",
                        "pack"
                    ]
                }
            }
        }
    }
};
exports.StartTask = {
    serializedName: "StartTask",
    type: {
        name: "Composite",
        className: "StartTask",
        modelProperties: {
            commandLine: {
                required: true,
                serializedName: "commandLine",
                type: {
                    name: "String"
                }
            },
            containerSettings: {
                serializedName: "containerSettings",
                type: {
                    name: "Composite",
                    className: "TaskContainerSettings"
                }
            },
            resourceFiles: {
                serializedName: "resourceFiles",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ResourceFileElementType",
                        type: {
                            name: "Composite",
                            className: "ResourceFile"
                        }
                    }
                }
            },
            environmentSettings: {
                serializedName: "environmentSettings",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "EnvironmentSettingElementType",
                        type: {
                            name: "Composite",
                            className: "EnvironmentSetting"
                        }
                    }
                }
            },
            userIdentity: {
                serializedName: "userIdentity",
                type: {
                    name: "Composite",
                    className: "UserIdentity"
                }
            },
            maxTaskRetryCount: {
                serializedName: "maxTaskRetryCount",
                type: {
                    name: "Number"
                }
            },
            waitForSuccess: {
                serializedName: "waitForSuccess",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
exports.CertificateReference = {
    serializedName: "CertificateReference",
    type: {
        name: "Composite",
        className: "CertificateReference",
        modelProperties: {
            thumbprint: {
                required: true,
                serializedName: "thumbprint",
                type: {
                    name: "String"
                }
            },
            thumbprintAlgorithm: {
                required: true,
                serializedName: "thumbprintAlgorithm",
                type: {
                    name: "String"
                }
            },
            storeLocation: {
                serializedName: "storeLocation",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "currentuser",
                        "localmachine"
                    ]
                }
            },
            storeName: {
                serializedName: "storeName",
                type: {
                    name: "String"
                }
            },
            visibility: {
                serializedName: "visibility",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "CertificateVisibilityElementType",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "starttask",
                                "task",
                                "remoteuser"
                            ]
                        }
                    }
                }
            }
        }
    }
};
exports.MetadataItem = {
    serializedName: "MetadataItem",
    type: {
        name: "Composite",
        className: "MetadataItem",
        modelProperties: {
            name: {
                required: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                required: true,
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CloudServiceConfiguration = {
    serializedName: "CloudServiceConfiguration",
    type: {
        name: "Composite",
        className: "CloudServiceConfiguration",
        modelProperties: {
            osFamily: {
                required: true,
                serializedName: "osFamily",
                type: {
                    name: "String"
                }
            },
            targetOSVersion: {
                serializedName: "targetOSVersion",
                type: {
                    name: "String"
                }
            },
            currentOSVersion: {
                readOnly: true,
                serializedName: "currentOSVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.OSDisk = {
    serializedName: "OSDisk",
    type: {
        name: "Composite",
        className: "OSDisk",
        modelProperties: {
            caching: {
                serializedName: "caching",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "none",
                        "readonly",
                        "readwrite"
                    ]
                }
            }
        }
    }
};
exports.WindowsConfiguration = {
    serializedName: "WindowsConfiguration",
    type: {
        name: "Composite",
        className: "WindowsConfiguration",
        modelProperties: {
            enableAutomaticUpdates: {
                serializedName: "enableAutomaticUpdates",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
exports.DataDisk = {
    serializedName: "DataDisk",
    type: {
        name: "Composite",
        className: "DataDisk",
        modelProperties: {
            lun: {
                required: true,
                serializedName: "lun",
                type: {
                    name: "Number"
                }
            },
            caching: {
                serializedName: "caching",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "none",
                        "readonly",
                        "readwrite"
                    ]
                }
            },
            diskSizeGB: {
                required: true,
                serializedName: "diskSizeGB",
                type: {
                    name: "Number"
                }
            },
            storageAccountType: {
                serializedName: "storageAccountType",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "standard_lrs",
                        "premium_lrs"
                    ]
                }
            }
        }
    }
};
exports.ContainerConfiguration = {
    serializedName: "ContainerConfiguration",
    type: {
        name: "Composite",
        className: "ContainerConfiguration",
        modelProperties: {
            type: {
                required: true,
                isConstant: true,
                serializedName: "type",
                defaultValue: 'docker',
                type: {
                    name: "String"
                }
            },
            containerImageNames: {
                serializedName: "containerImageNames",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "stringElementType",
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            containerRegistries: {
                serializedName: "containerRegistries",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ContainerRegistryElementType",
                        type: {
                            name: "Composite",
                            className: "ContainerRegistry"
                        }
                    }
                }
            }
        }
    }
};
exports.VirtualMachineConfiguration = {
    serializedName: "VirtualMachineConfiguration",
    type: {
        name: "Composite",
        className: "VirtualMachineConfiguration",
        modelProperties: {
            imageReference: {
                required: true,
                serializedName: "imageReference",
                type: {
                    name: "Composite",
                    className: "ImageReference"
                }
            },
            osDisk: {
                serializedName: "osDisk",
                type: {
                    name: "Composite",
                    className: "OSDisk"
                }
            },
            nodeAgentSKUId: {
                required: true,
                serializedName: "nodeAgentSKUId",
                type: {
                    name: "String"
                }
            },
            windowsConfiguration: {
                serializedName: "windowsConfiguration",
                type: {
                    name: "Composite",
                    className: "WindowsConfiguration"
                }
            },
            dataDisks: {
                serializedName: "dataDisks",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "DataDiskElementType",
                        type: {
                            name: "Composite",
                            className: "DataDisk"
                        }
                    }
                }
            },
            licenseType: {
                serializedName: "licenseType",
                type: {
                    name: "String"
                }
            },
            containerConfiguration: {
                serializedName: "containerConfiguration",
                type: {
                    name: "Composite",
                    className: "ContainerConfiguration"
                }
            }
        }
    }
};
exports.NetworkSecurityGroupRule = {
    serializedName: "NetworkSecurityGroupRule",
    type: {
        name: "Composite",
        className: "NetworkSecurityGroupRule",
        modelProperties: {
            priority: {
                required: true,
                serializedName: "priority",
                type: {
                    name: "Number"
                }
            },
            access: {
                required: true,
                serializedName: "access",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "allow",
                        "deny"
                    ]
                }
            },
            sourceAddressPrefix: {
                required: true,
                serializedName: "sourceAddressPrefix",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.InboundNATPool = {
    serializedName: "InboundNATPool",
    type: {
        name: "Composite",
        className: "InboundNATPool",
        modelProperties: {
            name: {
                required: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            protocol: {
                required: true,
                serializedName: "protocol",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "tcp",
                        "udp"
                    ]
                }
            },
            backendPort: {
                required: true,
                serializedName: "backendPort",
                type: {
                    name: "Number"
                }
            },
            frontendPortRangeStart: {
                required: true,
                serializedName: "frontendPortRangeStart",
                type: {
                    name: "Number"
                }
            },
            frontendPortRangeEnd: {
                required: true,
                serializedName: "frontendPortRangeEnd",
                type: {
                    name: "Number"
                }
            },
            networkSecurityGroupRules: {
                serializedName: "networkSecurityGroupRules",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "NetworkSecurityGroupRuleElementType",
                        type: {
                            name: "Composite",
                            className: "NetworkSecurityGroupRule"
                        }
                    }
                }
            }
        }
    }
};
exports.PoolEndpointConfiguration = {
    serializedName: "PoolEndpointConfiguration",
    type: {
        name: "Composite",
        className: "PoolEndpointConfiguration",
        modelProperties: {
            inboundNATPools: {
                required: true,
                serializedName: "inboundNATPools",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "InboundNATPoolElementType",
                        type: {
                            name: "Composite",
                            className: "InboundNATPool"
                        }
                    }
                }
            }
        }
    }
};
exports.NetworkConfiguration = {
    serializedName: "NetworkConfiguration",
    type: {
        name: "Composite",
        className: "NetworkConfiguration",
        modelProperties: {
            subnetId: {
                serializedName: "subnetId",
                type: {
                    name: "String"
                }
            },
            endpointConfiguration: {
                serializedName: "endpointConfiguration",
                type: {
                    name: "Composite",
                    className: "PoolEndpointConfiguration"
                }
            }
        }
    }
};
exports.PoolSpecification = {
    serializedName: "PoolSpecification",
    type: {
        name: "Composite",
        className: "PoolSpecification",
        modelProperties: {
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            vmSize: {
                required: true,
                serializedName: "vmSize",
                type: {
                    name: "String"
                }
            },
            cloudServiceConfiguration: {
                serializedName: "cloudServiceConfiguration",
                type: {
                    name: "Composite",
                    className: "CloudServiceConfiguration"
                }
            },
            virtualMachineConfiguration: {
                serializedName: "virtualMachineConfiguration",
                type: {
                    name: "Composite",
                    className: "VirtualMachineConfiguration"
                }
            },
            maxTasksPerNode: {
                serializedName: "maxTasksPerNode",
                type: {
                    name: "Number"
                }
            },
            taskSchedulingPolicy: {
                serializedName: "taskSchedulingPolicy",
                type: {
                    name: "Composite",
                    className: "TaskSchedulingPolicy"
                }
            },
            resizeTimeout: {
                serializedName: "resizeTimeout",
                type: {
                    name: "TimeSpan"
                }
            },
            targetDedicatedNodes: {
                serializedName: "targetDedicatedNodes",
                type: {
                    name: "Number"
                }
            },
            targetLowPriorityNodes: {
                serializedName: "targetLowPriorityNodes",
                type: {
                    name: "Number"
                }
            },
            enableAutoScale: {
                serializedName: "enableAutoScale",
                type: {
                    name: "Boolean"
                }
            },
            autoScaleFormula: {
                serializedName: "autoScaleFormula",
                type: {
                    name: "String"
                }
            },
            autoScaleEvaluationInterval: {
                serializedName: "autoScaleEvaluationInterval",
                type: {
                    name: "TimeSpan"
                }
            },
            enableInterNodeCommunication: {
                serializedName: "enableInterNodeCommunication",
                type: {
                    name: "Boolean"
                }
            },
            networkConfiguration: {
                serializedName: "networkConfiguration",
                type: {
                    name: "Composite",
                    className: "NetworkConfiguration"
                }
            },
            startTask: {
                serializedName: "startTask",
                type: {
                    name: "Composite",
                    className: "StartTask"
                }
            },
            certificateReferences: {
                serializedName: "certificateReferences",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "CertificateReferenceElementType",
                        type: {
                            name: "Composite",
                            className: "CertificateReference"
                        }
                    }
                }
            },
            applicationPackageReferences: {
                serializedName: "applicationPackageReferences",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ApplicationPackageReferenceElementType",
                        type: {
                            name: "Composite",
                            className: "ApplicationPackageReference"
                        }
                    }
                }
            },
            applicationLicenses: {
                serializedName: "applicationLicenses",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "stringElementType",
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            userAccounts: {
                serializedName: "userAccounts",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "UserAccountElementType",
                        type: {
                            name: "Composite",
                            className: "UserAccount"
                        }
                    }
                }
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "MetadataItemElementType",
                        type: {
                            name: "Composite",
                            className: "MetadataItem"
                        }
                    }
                }
            }
        }
    }
};
exports.AutoPoolSpecification = {
    serializedName: "AutoPoolSpecification",
    type: {
        name: "Composite",
        className: "AutoPoolSpecification",
        modelProperties: {
            autoPoolIdPrefix: {
                serializedName: "autoPoolIdPrefix",
                type: {
                    name: "String"
                }
            },
            poolLifetimeOption: {
                required: true,
                serializedName: "poolLifetimeOption",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "jobschedule",
                        "job"
                    ]
                }
            },
            keepAlive: {
                serializedName: "keepAlive",
                type: {
                    name: "Boolean"
                }
            },
            pool: {
                serializedName: "pool",
                type: {
                    name: "Composite",
                    className: "PoolSpecification"
                }
            }
        }
    }
};
exports.PoolInformation = {
    serializedName: "PoolInformation",
    type: {
        name: "Composite",
        className: "PoolInformation",
        modelProperties: {
            poolId: {
                serializedName: "poolId",
                type: {
                    name: "String"
                }
            },
            autoPoolSpecification: {
                serializedName: "autoPoolSpecification",
                type: {
                    name: "Composite",
                    className: "AutoPoolSpecification"
                }
            }
        }
    }
};
exports.JobSpecification = {
    serializedName: "JobSpecification",
    type: {
        name: "Composite",
        className: "JobSpecification",
        modelProperties: {
            priority: {
                serializedName: "priority",
                type: {
                    name: "Number"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            usesTaskDependencies: {
                serializedName: "usesTaskDependencies",
                type: {
                    name: "Boolean"
                }
            },
            onAllTasksComplete: {
                serializedName: "onAllTasksComplete",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "noaction",
                        "terminatejob"
                    ]
                }
            },
            onTaskFailure: {
                serializedName: "onTaskFailure",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "noaction",
                        "performexitoptionsjobaction"
                    ]
                }
            },
            constraints: {
                serializedName: "constraints",
                type: {
                    name: "Composite",
                    className: "JobConstraints"
                }
            },
            jobManagerTask: {
                serializedName: "jobManagerTask",
                type: {
                    name: "Composite",
                    className: "JobManagerTask"
                }
            },
            jobPreparationTask: {
                serializedName: "jobPreparationTask",
                type: {
                    name: "Composite",
                    className: "JobPreparationTask"
                }
            },
            jobReleaseTask: {
                serializedName: "jobReleaseTask",
                type: {
                    name: "Composite",
                    className: "JobReleaseTask"
                }
            },
            commonEnvironmentSettings: {
                serializedName: "commonEnvironmentSettings",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "EnvironmentSettingElementType",
                        type: {
                            name: "Composite",
                            className: "EnvironmentSetting"
                        }
                    }
                }
            },
            poolInfo: {
                required: true,
                serializedName: "poolInfo",
                defaultValue: {},
                type: {
                    name: "Composite",
                    className: "PoolInformation"
                }
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "MetadataItemElementType",
                        type: {
                            name: "Composite",
                            className: "MetadataItem"
                        }
                    }
                }
            }
        }
    }
};
exports.RecentJob = {
    serializedName: "RecentJob",
    type: {
        name: "Composite",
        className: "RecentJob",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.JobScheduleExecutionInformation = {
    serializedName: "JobScheduleExecutionInformation",
    type: {
        name: "Composite",
        className: "JobScheduleExecutionInformation",
        modelProperties: {
            nextRunTime: {
                serializedName: "nextRunTime",
                type: {
                    name: "DateTime"
                }
            },
            recentJob: {
                serializedName: "recentJob",
                type: {
                    name: "Composite",
                    className: "RecentJob"
                }
            },
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
exports.JobScheduleStatistics = {
    serializedName: "JobScheduleStatistics",
    type: {
        name: "Composite",
        className: "JobScheduleStatistics",
        modelProperties: {
            url: {
                required: true,
                serializedName: "url",
                type: {
                    name: "String"
                }
            },
            startTime: {
                required: true,
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            lastUpdateTime: {
                required: true,
                serializedName: "lastUpdateTime",
                type: {
                    name: "DateTime"
                }
            },
            userCPUTime: {
                required: true,
                serializedName: "userCPUTime",
                type: {
                    name: "TimeSpan"
                }
            },
            kernelCPUTime: {
                required: true,
                serializedName: "kernelCPUTime",
                type: {
                    name: "TimeSpan"
                }
            },
            wallClockTime: {
                required: true,
                serializedName: "wallClockTime",
                type: {
                    name: "TimeSpan"
                }
            },
            readIOps: {
                required: true,
                serializedName: "readIOps",
                type: {
                    name: "Number"
                }
            },
            writeIOps: {
                required: true,
                serializedName: "writeIOps",
                type: {
                    name: "Number"
                }
            },
            readIOGiB: {
                required: true,
                serializedName: "readIOGiB",
                type: {
                    name: "Number"
                }
            },
            writeIOGiB: {
                required: true,
                serializedName: "writeIOGiB",
                type: {
                    name: "Number"
                }
            },
            numSucceededTasks: {
                required: true,
                serializedName: "numSucceededTasks",
                type: {
                    name: "Number"
                }
            },
            numFailedTasks: {
                required: true,
                serializedName: "numFailedTasks",
                type: {
                    name: "Number"
                }
            },
            numTaskRetries: {
                required: true,
                serializedName: "numTaskRetries",
                type: {
                    name: "Number"
                }
            },
            waitTime: {
                required: true,
                serializedName: "waitTime",
                type: {
                    name: "TimeSpan"
                }
            }
        }
    }
};
exports.CloudJobSchedule = {
    serializedName: "CloudJobSchedule",
    type: {
        name: "Composite",
        className: "CloudJobSchedule",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                type: {
                    name: "String"
                }
            },
            eTag: {
                serializedName: "eTag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "lastModified",
                type: {
                    name: "DateTime"
                }
            },
            creationTime: {
                serializedName: "creationTime",
                type: {
                    name: "DateTime"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "active",
                        "completed",
                        "disabled",
                        "terminating",
                        "deleting"
                    ]
                }
            },
            stateTransitionTime: {
                serializedName: "stateTransitionTime",
                type: {
                    name: "DateTime"
                }
            },
            previousState: {
                serializedName: "previousState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "active",
                        "completed",
                        "disabled",
                        "terminating",
                        "deleting"
                    ]
                }
            },
            previousStateTransitionTime: {
                serializedName: "previousStateTransitionTime",
                type: {
                    name: "DateTime"
                }
            },
            schedule: {
                serializedName: "schedule",
                type: {
                    name: "Composite",
                    className: "Schedule"
                }
            },
            jobSpecification: {
                serializedName: "jobSpecification",
                type: {
                    name: "Composite",
                    className: "JobSpecification"
                }
            },
            executionInfo: {
                serializedName: "executionInfo",
                type: {
                    name: "Composite",
                    className: "JobScheduleExecutionInformation"
                }
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "MetadataItemElementType",
                        type: {
                            name: "Composite",
                            className: "MetadataItem"
                        }
                    }
                }
            },
            stats: {
                serializedName: "stats",
                type: {
                    name: "Composite",
                    className: "JobScheduleStatistics"
                }
            }
        }
    }
};
exports.JobScheduleAddParameter = {
    serializedName: "JobScheduleAddParameter",
    type: {
        name: "Composite",
        className: "JobScheduleAddParameter",
        modelProperties: {
            id: {
                required: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            schedule: {
                required: true,
                serializedName: "schedule",
                type: {
                    name: "Composite",
                    className: "Schedule"
                }
            },
            jobSpecification: {
                required: true,
                serializedName: "jobSpecification",
                defaultValue: {},
                type: {
                    name: "Composite",
                    className: "JobSpecification"
                }
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "MetadataItemElementType",
                        type: {
                            name: "Composite",
                            className: "MetadataItem"
                        }
                    }
                }
            }
        }
    }
};
exports.JobSchedulingError = {
    serializedName: "JobSchedulingError",
    type: {
        name: "Composite",
        className: "JobSchedulingError",
        modelProperties: {
            category: {
                required: true,
                serializedName: "category",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "usererror",
                        "servererror"
                    ]
                }
            },
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "NameValuePairElementType",
                        type: {
                            name: "Composite",
                            className: "NameValuePair"
                        }
                    }
                }
            }
        }
    }
};
exports.JobExecutionInformation = {
    serializedName: "JobExecutionInformation",
    type: {
        name: "Composite",
        className: "JobExecutionInformation",
        modelProperties: {
            startTime: {
                required: true,
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            poolId: {
                serializedName: "poolId",
                type: {
                    name: "String"
                }
            },
            schedulingError: {
                serializedName: "schedulingError",
                type: {
                    name: "Composite",
                    className: "JobSchedulingError"
                }
            },
            terminateReason: {
                serializedName: "terminateReason",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CloudJob = {
    serializedName: "CloudJob",
    type: {
        name: "Composite",
        className: "CloudJob",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            usesTaskDependencies: {
                serializedName: "usesTaskDependencies",
                type: {
                    name: "Boolean"
                }
            },
            url: {
                serializedName: "url",
                type: {
                    name: "String"
                }
            },
            eTag: {
                serializedName: "eTag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "lastModified",
                type: {
                    name: "DateTime"
                }
            },
            creationTime: {
                serializedName: "creationTime",
                type: {
                    name: "DateTime"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "active",
                        "disabling",
                        "disabled",
                        "enabling",
                        "terminating",
                        "completed",
                        "deleting"
                    ]
                }
            },
            stateTransitionTime: {
                serializedName: "stateTransitionTime",
                type: {
                    name: "DateTime"
                }
            },
            previousState: {
                serializedName: "previousState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "active",
                        "disabling",
                        "disabled",
                        "enabling",
                        "terminating",
                        "completed",
                        "deleting"
                    ]
                }
            },
            previousStateTransitionTime: {
                serializedName: "previousStateTransitionTime",
                type: {
                    name: "DateTime"
                }
            },
            priority: {
                serializedName: "priority",
                type: {
                    name: "Number"
                }
            },
            constraints: {
                serializedName: "constraints",
                type: {
                    name: "Composite",
                    className: "JobConstraints"
                }
            },
            jobManagerTask: {
                serializedName: "jobManagerTask",
                type: {
                    name: "Composite",
                    className: "JobManagerTask"
                }
            },
            jobPreparationTask: {
                serializedName: "jobPreparationTask",
                type: {
                    name: "Composite",
                    className: "JobPreparationTask"
                }
            },
            jobReleaseTask: {
                serializedName: "jobReleaseTask",
                type: {
                    name: "Composite",
                    className: "JobReleaseTask"
                }
            },
            commonEnvironmentSettings: {
                serializedName: "commonEnvironmentSettings",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "EnvironmentSettingElementType",
                        type: {
                            name: "Composite",
                            className: "EnvironmentSetting"
                        }
                    }
                }
            },
            poolInfo: {
                serializedName: "poolInfo",
                type: {
                    name: "Composite",
                    className: "PoolInformation"
                }
            },
            onAllTasksComplete: {
                serializedName: "onAllTasksComplete",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "noaction",
                        "terminatejob"
                    ]
                }
            },
            onTaskFailure: {
                serializedName: "onTaskFailure",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "noaction",
                        "performexitoptionsjobaction"
                    ]
                }
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "MetadataItemElementType",
                        type: {
                            name: "Composite",
                            className: "MetadataItem"
                        }
                    }
                }
            },
            executionInfo: {
                serializedName: "executionInfo",
                type: {
                    name: "Composite",
                    className: "JobExecutionInformation"
                }
            },
            stats: {
                serializedName: "stats",
                type: {
                    name: "Composite",
                    className: "JobStatistics"
                }
            }
        }
    }
};
exports.JobAddParameter = {
    serializedName: "JobAddParameter",
    type: {
        name: "Composite",
        className: "JobAddParameter",
        modelProperties: {
            id: {
                required: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            priority: {
                serializedName: "priority",
                type: {
                    name: "Number"
                }
            },
            constraints: {
                serializedName: "constraints",
                type: {
                    name: "Composite",
                    className: "JobConstraints"
                }
            },
            jobManagerTask: {
                serializedName: "jobManagerTask",
                type: {
                    name: "Composite",
                    className: "JobManagerTask"
                }
            },
            jobPreparationTask: {
                serializedName: "jobPreparationTask",
                type: {
                    name: "Composite",
                    className: "JobPreparationTask"
                }
            },
            jobReleaseTask: {
                serializedName: "jobReleaseTask",
                type: {
                    name: "Composite",
                    className: "JobReleaseTask"
                }
            },
            commonEnvironmentSettings: {
                serializedName: "commonEnvironmentSettings",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "EnvironmentSettingElementType",
                        type: {
                            name: "Composite",
                            className: "EnvironmentSetting"
                        }
                    }
                }
            },
            poolInfo: {
                required: true,
                serializedName: "poolInfo",
                defaultValue: {},
                type: {
                    name: "Composite",
                    className: "PoolInformation"
                }
            },
            onAllTasksComplete: {
                serializedName: "onAllTasksComplete",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "noaction",
                        "terminatejob"
                    ]
                }
            },
            onTaskFailure: {
                serializedName: "onTaskFailure",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "noaction",
                        "performexitoptionsjobaction"
                    ]
                }
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "MetadataItemElementType",
                        type: {
                            name: "Composite",
                            className: "MetadataItem"
                        }
                    }
                }
            },
            usesTaskDependencies: {
                serializedName: "usesTaskDependencies",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
exports.TaskContainerExecutionInformation = {
    serializedName: "TaskContainerExecutionInformation",
    type: {
        name: "Composite",
        className: "TaskContainerExecutionInformation",
        modelProperties: {
            containerId: {
                serializedName: "containerId",
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.TaskFailureInformation = {
    serializedName: "TaskFailureInformation",
    type: {
        name: "Composite",
        className: "TaskFailureInformation",
        modelProperties: {
            category: {
                required: true,
                serializedName: "category",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "usererror",
                        "servererror"
                    ]
                }
            },
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "NameValuePairElementType",
                        type: {
                            name: "Composite",
                            className: "NameValuePair"
                        }
                    }
                }
            }
        }
    }
};
exports.JobPreparationTaskExecutionInformation = {
    serializedName: "JobPreparationTaskExecutionInformation",
    type: {
        name: "Composite",
        className: "JobPreparationTaskExecutionInformation",
        modelProperties: {
            startTime: {
                required: true,
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            state: {
                required: true,
                serializedName: "state",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "running",
                        "completed"
                    ]
                }
            },
            taskRootDirectory: {
                serializedName: "taskRootDirectory",
                type: {
                    name: "String"
                }
            },
            taskRootDirectoryUrl: {
                serializedName: "taskRootDirectoryUrl",
                type: {
                    name: "String"
                }
            },
            exitCode: {
                serializedName: "exitCode",
                type: {
                    name: "Number"
                }
            },
            containerInfo: {
                serializedName: "containerInfo",
                type: {
                    name: "Composite",
                    className: "TaskContainerExecutionInformation"
                }
            },
            failureInfo: {
                serializedName: "failureInfo",
                type: {
                    name: "Composite",
                    className: "TaskFailureInformation"
                }
            },
            retryCount: {
                required: true,
                serializedName: "retryCount",
                type: {
                    name: "Number"
                }
            },
            lastRetryTime: {
                serializedName: "lastRetryTime",
                type: {
                    name: "DateTime"
                }
            },
            result: {
                serializedName: "result",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "success",
                        "failure"
                    ]
                }
            }
        }
    }
};
exports.JobReleaseTaskExecutionInformation = {
    serializedName: "JobReleaseTaskExecutionInformation",
    type: {
        name: "Composite",
        className: "JobReleaseTaskExecutionInformation",
        modelProperties: {
            startTime: {
                required: true,
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            state: {
                required: true,
                serializedName: "state",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "running",
                        "completed"
                    ]
                }
            },
            taskRootDirectory: {
                serializedName: "taskRootDirectory",
                type: {
                    name: "String"
                }
            },
            taskRootDirectoryUrl: {
                serializedName: "taskRootDirectoryUrl",
                type: {
                    name: "String"
                }
            },
            exitCode: {
                serializedName: "exitCode",
                type: {
                    name: "Number"
                }
            },
            containerInfo: {
                serializedName: "containerInfo",
                type: {
                    name: "Composite",
                    className: "TaskContainerExecutionInformation"
                }
            },
            failureInfo: {
                serializedName: "failureInfo",
                type: {
                    name: "Composite",
                    className: "TaskFailureInformation"
                }
            },
            result: {
                serializedName: "result",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "success",
                        "failure"
                    ]
                }
            }
        }
    }
};
exports.JobPreparationAndReleaseTaskExecutionInformation = {
    serializedName: "JobPreparationAndReleaseTaskExecutionInformation",
    type: {
        name: "Composite",
        className: "JobPreparationAndReleaseTaskExecutionInformation",
        modelProperties: {
            poolId: {
                serializedName: "poolId",
                type: {
                    name: "String"
                }
            },
            nodeId: {
                serializedName: "nodeId",
                type: {
                    name: "String"
                }
            },
            nodeUrl: {
                serializedName: "nodeUrl",
                type: {
                    name: "String"
                }
            },
            jobPreparationTaskExecutionInfo: {
                serializedName: "jobPreparationTaskExecutionInfo",
                type: {
                    name: "Composite",
                    className: "JobPreparationTaskExecutionInformation"
                }
            },
            jobReleaseTaskExecutionInfo: {
                serializedName: "jobReleaseTaskExecutionInfo",
                type: {
                    name: "Composite",
                    className: "JobReleaseTaskExecutionInformation"
                }
            }
        }
    }
};
exports.TaskCounts = {
    serializedName: "TaskCounts",
    type: {
        name: "Composite",
        className: "TaskCounts",
        modelProperties: {
            active: {
                required: true,
                serializedName: "active",
                type: {
                    name: "Number"
                }
            },
            running: {
                required: true,
                serializedName: "running",
                type: {
                    name: "Number"
                }
            },
            completed: {
                required: true,
                serializedName: "completed",
                type: {
                    name: "Number"
                }
            },
            succeeded: {
                required: true,
                serializedName: "succeeded",
                type: {
                    name: "Number"
                }
            },
            failed: {
                required: true,
                serializedName: "failed",
                type: {
                    name: "Number"
                }
            },
            validationStatus: {
                required: true,
                serializedName: "validationStatus",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "validated",
                        "unvalidated"
                    ]
                }
            }
        }
    }
};
exports.AutoScaleRunError = {
    serializedName: "AutoScaleRunError",
    type: {
        name: "Composite",
        className: "AutoScaleRunError",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "NameValuePairElementType",
                        type: {
                            name: "Composite",
                            className: "NameValuePair"
                        }
                    }
                }
            }
        }
    }
};
exports.AutoScaleRun = {
    serializedName: "AutoScaleRun",
    type: {
        name: "Composite",
        className: "AutoScaleRun",
        modelProperties: {
            timestamp: {
                required: true,
                serializedName: "timestamp",
                type: {
                    name: "DateTime"
                }
            },
            results: {
                serializedName: "results",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "AutoScaleRunError"
                }
            }
        }
    }
};
exports.ResizeError = {
    serializedName: "ResizeError",
    type: {
        name: "Composite",
        className: "ResizeError",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "NameValuePairElementType",
                        type: {
                            name: "Composite",
                            className: "NameValuePair"
                        }
                    }
                }
            }
        }
    }
};
exports.CloudPool = {
    serializedName: "CloudPool",
    type: {
        name: "Composite",
        className: "CloudPool",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                type: {
                    name: "String"
                }
            },
            eTag: {
                serializedName: "eTag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "lastModified",
                type: {
                    name: "DateTime"
                }
            },
            creationTime: {
                serializedName: "creationTime",
                type: {
                    name: "DateTime"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "active",
                        "deleting",
                        "upgrading"
                    ]
                }
            },
            stateTransitionTime: {
                serializedName: "stateTransitionTime",
                type: {
                    name: "DateTime"
                }
            },
            allocationState: {
                serializedName: "allocationState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "steady",
                        "resizing",
                        "stopping"
                    ]
                }
            },
            allocationStateTransitionTime: {
                serializedName: "allocationStateTransitionTime",
                type: {
                    name: "DateTime"
                }
            },
            vmSize: {
                serializedName: "vmSize",
                type: {
                    name: "String"
                }
            },
            cloudServiceConfiguration: {
                serializedName: "cloudServiceConfiguration",
                type: {
                    name: "Composite",
                    className: "CloudServiceConfiguration"
                }
            },
            virtualMachineConfiguration: {
                serializedName: "virtualMachineConfiguration",
                type: {
                    name: "Composite",
                    className: "VirtualMachineConfiguration"
                }
            },
            resizeTimeout: {
                serializedName: "resizeTimeout",
                type: {
                    name: "TimeSpan"
                }
            },
            resizeErrors: {
                serializedName: "resizeErrors",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ResizeErrorElementType",
                        type: {
                            name: "Composite",
                            className: "ResizeError"
                        }
                    }
                }
            },
            currentDedicatedNodes: {
                serializedName: "currentDedicatedNodes",
                type: {
                    name: "Number"
                }
            },
            currentLowPriorityNodes: {
                serializedName: "currentLowPriorityNodes",
                type: {
                    name: "Number"
                }
            },
            targetDedicatedNodes: {
                serializedName: "targetDedicatedNodes",
                type: {
                    name: "Number"
                }
            },
            targetLowPriorityNodes: {
                serializedName: "targetLowPriorityNodes",
                type: {
                    name: "Number"
                }
            },
            enableAutoScale: {
                serializedName: "enableAutoScale",
                type: {
                    name: "Boolean"
                }
            },
            autoScaleFormula: {
                serializedName: "autoScaleFormula",
                type: {
                    name: "String"
                }
            },
            autoScaleEvaluationInterval: {
                serializedName: "autoScaleEvaluationInterval",
                type: {
                    name: "TimeSpan"
                }
            },
            autoScaleRun: {
                serializedName: "autoScaleRun",
                type: {
                    name: "Composite",
                    className: "AutoScaleRun"
                }
            },
            enableInterNodeCommunication: {
                serializedName: "enableInterNodeCommunication",
                type: {
                    name: "Boolean"
                }
            },
            networkConfiguration: {
                serializedName: "networkConfiguration",
                type: {
                    name: "Composite",
                    className: "NetworkConfiguration"
                }
            },
            startTask: {
                serializedName: "startTask",
                type: {
                    name: "Composite",
                    className: "StartTask"
                }
            },
            certificateReferences: {
                serializedName: "certificateReferences",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "CertificateReferenceElementType",
                        type: {
                            name: "Composite",
                            className: "CertificateReference"
                        }
                    }
                }
            },
            applicationPackageReferences: {
                serializedName: "applicationPackageReferences",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ApplicationPackageReferenceElementType",
                        type: {
                            name: "Composite",
                            className: "ApplicationPackageReference"
                        }
                    }
                }
            },
            applicationLicenses: {
                serializedName: "applicationLicenses",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "stringElementType",
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            maxTasksPerNode: {
                serializedName: "maxTasksPerNode",
                type: {
                    name: "Number"
                }
            },
            taskSchedulingPolicy: {
                serializedName: "taskSchedulingPolicy",
                type: {
                    name: "Composite",
                    className: "TaskSchedulingPolicy"
                }
            },
            userAccounts: {
                serializedName: "userAccounts",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "UserAccountElementType",
                        type: {
                            name: "Composite",
                            className: "UserAccount"
                        }
                    }
                }
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "MetadataItemElementType",
                        type: {
                            name: "Composite",
                            className: "MetadataItem"
                        }
                    }
                }
            },
            stats: {
                serializedName: "stats",
                type: {
                    name: "Composite",
                    className: "PoolStatistics"
                }
            }
        }
    }
};
exports.PoolAddParameter = {
    serializedName: "PoolAddParameter",
    type: {
        name: "Composite",
        className: "PoolAddParameter",
        modelProperties: {
            id: {
                required: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            vmSize: {
                required: true,
                serializedName: "vmSize",
                type: {
                    name: "String"
                }
            },
            cloudServiceConfiguration: {
                serializedName: "cloudServiceConfiguration",
                type: {
                    name: "Composite",
                    className: "CloudServiceConfiguration"
                }
            },
            virtualMachineConfiguration: {
                serializedName: "virtualMachineConfiguration",
                type: {
                    name: "Composite",
                    className: "VirtualMachineConfiguration"
                }
            },
            resizeTimeout: {
                serializedName: "resizeTimeout",
                type: {
                    name: "TimeSpan"
                }
            },
            targetDedicatedNodes: {
                serializedName: "targetDedicatedNodes",
                type: {
                    name: "Number"
                }
            },
            targetLowPriorityNodes: {
                serializedName: "targetLowPriorityNodes",
                type: {
                    name: "Number"
                }
            },
            enableAutoScale: {
                serializedName: "enableAutoScale",
                type: {
                    name: "Boolean"
                }
            },
            autoScaleFormula: {
                serializedName: "autoScaleFormula",
                type: {
                    name: "String"
                }
            },
            autoScaleEvaluationInterval: {
                serializedName: "autoScaleEvaluationInterval",
                type: {
                    name: "TimeSpan"
                }
            },
            enableInterNodeCommunication: {
                serializedName: "enableInterNodeCommunication",
                type: {
                    name: "Boolean"
                }
            },
            networkConfiguration: {
                serializedName: "networkConfiguration",
                type: {
                    name: "Composite",
                    className: "NetworkConfiguration"
                }
            },
            startTask: {
                serializedName: "startTask",
                type: {
                    name: "Composite",
                    className: "StartTask"
                }
            },
            certificateReferences: {
                serializedName: "certificateReferences",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "CertificateReferenceElementType",
                        type: {
                            name: "Composite",
                            className: "CertificateReference"
                        }
                    }
                }
            },
            applicationPackageReferences: {
                serializedName: "applicationPackageReferences",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ApplicationPackageReferenceElementType",
                        type: {
                            name: "Composite",
                            className: "ApplicationPackageReference"
                        }
                    }
                }
            },
            applicationLicenses: {
                serializedName: "applicationLicenses",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "stringElementType",
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            maxTasksPerNode: {
                serializedName: "maxTasksPerNode",
                type: {
                    name: "Number"
                }
            },
            taskSchedulingPolicy: {
                serializedName: "taskSchedulingPolicy",
                type: {
                    name: "Composite",
                    className: "TaskSchedulingPolicy"
                }
            },
            userAccounts: {
                serializedName: "userAccounts",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "UserAccountElementType",
                        type: {
                            name: "Composite",
                            className: "UserAccount"
                        }
                    }
                }
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "MetadataItemElementType",
                        type: {
                            name: "Composite",
                            className: "MetadataItem"
                        }
                    }
                }
            }
        }
    }
};
exports.AffinityInformation = {
    serializedName: "AffinityInformation",
    type: {
        name: "Composite",
        className: "AffinityInformation",
        modelProperties: {
            affinityId: {
                required: true,
                serializedName: "affinityId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.TaskExecutionInformation = {
    serializedName: "TaskExecutionInformation",
    type: {
        name: "Composite",
        className: "TaskExecutionInformation",
        modelProperties: {
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            exitCode: {
                serializedName: "exitCode",
                type: {
                    name: "Number"
                }
            },
            containerInfo: {
                serializedName: "containerInfo",
                type: {
                    name: "Composite",
                    className: "TaskContainerExecutionInformation"
                }
            },
            failureInfo: {
                serializedName: "failureInfo",
                type: {
                    name: "Composite",
                    className: "TaskFailureInformation"
                }
            },
            retryCount: {
                required: true,
                serializedName: "retryCount",
                type: {
                    name: "Number"
                }
            },
            lastRetryTime: {
                serializedName: "lastRetryTime",
                type: {
                    name: "DateTime"
                }
            },
            requeueCount: {
                required: true,
                serializedName: "requeueCount",
                type: {
                    name: "Number"
                }
            },
            lastRequeueTime: {
                serializedName: "lastRequeueTime",
                type: {
                    name: "DateTime"
                }
            },
            result: {
                serializedName: "result",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "success",
                        "failure"
                    ]
                }
            }
        }
    }
};
exports.ComputeNodeInformation = {
    serializedName: "ComputeNodeInformation",
    type: {
        name: "Composite",
        className: "ComputeNodeInformation",
        modelProperties: {
            affinityId: {
                serializedName: "affinityId",
                type: {
                    name: "String"
                }
            },
            nodeUrl: {
                serializedName: "nodeUrl",
                type: {
                    name: "String"
                }
            },
            poolId: {
                serializedName: "poolId",
                type: {
                    name: "String"
                }
            },
            nodeId: {
                serializedName: "nodeId",
                type: {
                    name: "String"
                }
            },
            taskRootDirectory: {
                serializedName: "taskRootDirectory",
                type: {
                    name: "String"
                }
            },
            taskRootDirectoryUrl: {
                serializedName: "taskRootDirectoryUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.MultiInstanceSettings = {
    serializedName: "MultiInstanceSettings",
    type: {
        name: "Composite",
        className: "MultiInstanceSettings",
        modelProperties: {
            numberOfInstances: {
                serializedName: "numberOfInstances",
                type: {
                    name: "Number"
                }
            },
            coordinationCommandLine: {
                required: true,
                serializedName: "coordinationCommandLine",
                type: {
                    name: "String"
                }
            },
            commonResourceFiles: {
                serializedName: "commonResourceFiles",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ResourceFileElementType",
                        type: {
                            name: "Composite",
                            className: "ResourceFile"
                        }
                    }
                }
            }
        }
    }
};
exports.TaskStatistics = {
    serializedName: "TaskStatistics",
    type: {
        name: "Composite",
        className: "TaskStatistics",
        modelProperties: {
            url: {
                required: true,
                serializedName: "url",
                type: {
                    name: "String"
                }
            },
            startTime: {
                required: true,
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            lastUpdateTime: {
                required: true,
                serializedName: "lastUpdateTime",
                type: {
                    name: "DateTime"
                }
            },
            userCPUTime: {
                required: true,
                serializedName: "userCPUTime",
                type: {
                    name: "TimeSpan"
                }
            },
            kernelCPUTime: {
                required: true,
                serializedName: "kernelCPUTime",
                type: {
                    name: "TimeSpan"
                }
            },
            wallClockTime: {
                required: true,
                serializedName: "wallClockTime",
                type: {
                    name: "TimeSpan"
                }
            },
            readIOps: {
                required: true,
                serializedName: "readIOps",
                type: {
                    name: "Number"
                }
            },
            writeIOps: {
                required: true,
                serializedName: "writeIOps",
                type: {
                    name: "Number"
                }
            },
            readIOGiB: {
                required: true,
                serializedName: "readIOGiB",
                type: {
                    name: "Number"
                }
            },
            writeIOGiB: {
                required: true,
                serializedName: "writeIOGiB",
                type: {
                    name: "Number"
                }
            },
            waitTime: {
                required: true,
                serializedName: "waitTime",
                type: {
                    name: "TimeSpan"
                }
            }
        }
    }
};
exports.TaskIdRange = {
    serializedName: "TaskIdRange",
    type: {
        name: "Composite",
        className: "TaskIdRange",
        modelProperties: {
            start: {
                required: true,
                serializedName: "start",
                type: {
                    name: "Number"
                }
            },
            end: {
                required: true,
                serializedName: "end",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
exports.TaskDependencies = {
    serializedName: "TaskDependencies",
    type: {
        name: "Composite",
        className: "TaskDependencies",
        modelProperties: {
            taskIds: {
                serializedName: "taskIds",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "stringElementType",
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            taskIdRanges: {
                serializedName: "taskIdRanges",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "TaskIdRangeElementType",
                        type: {
                            name: "Composite",
                            className: "TaskIdRange"
                        }
                    }
                }
            }
        }
    }
};
exports.CloudTask = {
    serializedName: "CloudTask",
    type: {
        name: "Composite",
        className: "CloudTask",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                type: {
                    name: "String"
                }
            },
            eTag: {
                serializedName: "eTag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "lastModified",
                type: {
                    name: "DateTime"
                }
            },
            creationTime: {
                serializedName: "creationTime",
                type: {
                    name: "DateTime"
                }
            },
            exitConditions: {
                serializedName: "exitConditions",
                type: {
                    name: "Composite",
                    className: "ExitConditions"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "active",
                        "preparing",
                        "running",
                        "completed"
                    ]
                }
            },
            stateTransitionTime: {
                serializedName: "stateTransitionTime",
                type: {
                    name: "DateTime"
                }
            },
            previousState: {
                serializedName: "previousState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "active",
                        "preparing",
                        "running",
                        "completed"
                    ]
                }
            },
            previousStateTransitionTime: {
                serializedName: "previousStateTransitionTime",
                type: {
                    name: "DateTime"
                }
            },
            commandLine: {
                serializedName: "commandLine",
                type: {
                    name: "String"
                }
            },
            containerSettings: {
                serializedName: "containerSettings",
                type: {
                    name: "Composite",
                    className: "TaskContainerSettings"
                }
            },
            resourceFiles: {
                serializedName: "resourceFiles",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ResourceFileElementType",
                        type: {
                            name: "Composite",
                            className: "ResourceFile"
                        }
                    }
                }
            },
            outputFiles: {
                serializedName: "outputFiles",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "OutputFileElementType",
                        type: {
                            name: "Composite",
                            className: "OutputFile"
                        }
                    }
                }
            },
            environmentSettings: {
                serializedName: "environmentSettings",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "EnvironmentSettingElementType",
                        type: {
                            name: "Composite",
                            className: "EnvironmentSetting"
                        }
                    }
                }
            },
            affinityInfo: {
                serializedName: "affinityInfo",
                type: {
                    name: "Composite",
                    className: "AffinityInformation"
                }
            },
            constraints: {
                serializedName: "constraints",
                type: {
                    name: "Composite",
                    className: "TaskConstraints"
                }
            },
            userIdentity: {
                serializedName: "userIdentity",
                type: {
                    name: "Composite",
                    className: "UserIdentity"
                }
            },
            executionInfo: {
                serializedName: "executionInfo",
                type: {
                    name: "Composite",
                    className: "TaskExecutionInformation"
                }
            },
            nodeInfo: {
                serializedName: "nodeInfo",
                type: {
                    name: "Composite",
                    className: "ComputeNodeInformation"
                }
            },
            multiInstanceSettings: {
                serializedName: "multiInstanceSettings",
                type: {
                    name: "Composite",
                    className: "MultiInstanceSettings"
                }
            },
            stats: {
                serializedName: "stats",
                type: {
                    name: "Composite",
                    className: "TaskStatistics"
                }
            },
            dependsOn: {
                serializedName: "dependsOn",
                type: {
                    name: "Composite",
                    className: "TaskDependencies"
                }
            },
            applicationPackageReferences: {
                serializedName: "applicationPackageReferences",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ApplicationPackageReferenceElementType",
                        type: {
                            name: "Composite",
                            className: "ApplicationPackageReference"
                        }
                    }
                }
            },
            authenticationTokenSettings: {
                serializedName: "authenticationTokenSettings",
                type: {
                    name: "Composite",
                    className: "AuthenticationTokenSettings"
                }
            }
        }
    }
};
exports.TaskAddParameter = {
    serializedName: "TaskAddParameter",
    type: {
        name: "Composite",
        className: "TaskAddParameter",
        modelProperties: {
            id: {
                required: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            commandLine: {
                required: true,
                serializedName: "commandLine",
                type: {
                    name: "String"
                }
            },
            containerSettings: {
                serializedName: "containerSettings",
                type: {
                    name: "Composite",
                    className: "TaskContainerSettings"
                }
            },
            exitConditions: {
                serializedName: "exitConditions",
                type: {
                    name: "Composite",
                    className: "ExitConditions"
                }
            },
            resourceFiles: {
                serializedName: "resourceFiles",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ResourceFileElementType",
                        type: {
                            name: "Composite",
                            className: "ResourceFile"
                        }
                    }
                }
            },
            outputFiles: {
                serializedName: "outputFiles",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "OutputFileElementType",
                        type: {
                            name: "Composite",
                            className: "OutputFile"
                        }
                    }
                }
            },
            environmentSettings: {
                serializedName: "environmentSettings",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "EnvironmentSettingElementType",
                        type: {
                            name: "Composite",
                            className: "EnvironmentSetting"
                        }
                    }
                }
            },
            affinityInfo: {
                serializedName: "affinityInfo",
                type: {
                    name: "Composite",
                    className: "AffinityInformation"
                }
            },
            constraints: {
                serializedName: "constraints",
                type: {
                    name: "Composite",
                    className: "TaskConstraints"
                }
            },
            userIdentity: {
                serializedName: "userIdentity",
                type: {
                    name: "Composite",
                    className: "UserIdentity"
                }
            },
            multiInstanceSettings: {
                serializedName: "multiInstanceSettings",
                type: {
                    name: "Composite",
                    className: "MultiInstanceSettings"
                }
            },
            dependsOn: {
                serializedName: "dependsOn",
                type: {
                    name: "Composite",
                    className: "TaskDependencies"
                }
            },
            applicationPackageReferences: {
                serializedName: "applicationPackageReferences",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ApplicationPackageReferenceElementType",
                        type: {
                            name: "Composite",
                            className: "ApplicationPackageReference"
                        }
                    }
                }
            },
            authenticationTokenSettings: {
                serializedName: "authenticationTokenSettings",
                type: {
                    name: "Composite",
                    className: "AuthenticationTokenSettings"
                }
            }
        }
    }
};
exports.TaskAddCollectionParameter = {
    serializedName: "TaskAddCollectionParameter",
    type: {
        name: "Composite",
        className: "TaskAddCollectionParameter",
        modelProperties: {
            value: {
                required: true,
                serializedName: "value",
                constraints: {
                    MaxItems: 100
                },
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "TaskAddParameterElementType",
                        type: {
                            name: "Composite",
                            className: "TaskAddParameter"
                        }
                    }
                }
            }
        }
    }
};
exports.ErrorMessage = {
    serializedName: "ErrorMessage",
    type: {
        name: "Composite",
        className: "ErrorMessage",
        modelProperties: {
            lang: {
                serializedName: "lang",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.BatchErrorDetail = {
    serializedName: "BatchErrorDetail",
    type: {
        name: "Composite",
        className: "BatchErrorDetail",
        modelProperties: {
            key: {
                serializedName: "key",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.BatchError = {
    serializedName: "BatchError",
    type: {
        name: "Composite",
        className: "BatchError",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "Composite",
                    className: "ErrorMessage"
                }
            },
            values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "BatchErrorDetailElementType",
                        type: {
                            name: "Composite",
                            className: "BatchErrorDetail"
                        }
                    }
                }
            }
        }
    }
};
exports.TaskAddResult = {
    serializedName: "TaskAddResult",
    type: {
        name: "Composite",
        className: "TaskAddResult",
        modelProperties: {
            status: {
                required: true,
                serializedName: "status",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "success",
                        "clienterror",
                        "servererror"
                    ]
                }
            },
            taskId: {
                required: true,
                serializedName: "taskId",
                type: {
                    name: "String"
                }
            },
            eTag: {
                serializedName: "eTag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "lastModified",
                type: {
                    name: "DateTime"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "BatchError"
                }
            }
        }
    }
};
exports.TaskAddCollectionResult = {
    serializedName: "TaskAddCollectionResult",
    type: {
        name: "Composite",
        className: "TaskAddCollectionResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "TaskAddResultElementType",
                        type: {
                            name: "Composite",
                            className: "TaskAddResult"
                        }
                    }
                }
            }
        }
    }
};
exports.SubtaskInformation = {
    serializedName: "SubtaskInformation",
    type: {
        name: "Composite",
        className: "SubtaskInformation",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "Number"
                }
            },
            nodeInfo: {
                serializedName: "nodeInfo",
                type: {
                    name: "Composite",
                    className: "ComputeNodeInformation"
                }
            },
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            exitCode: {
                serializedName: "exitCode",
                type: {
                    name: "Number"
                }
            },
            containerInfo: {
                serializedName: "containerInfo",
                type: {
                    name: "Composite",
                    className: "TaskContainerExecutionInformation"
                }
            },
            failureInfo: {
                serializedName: "failureInfo",
                type: {
                    name: "Composite",
                    className: "TaskFailureInformation"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "preparing",
                        "running",
                        "completed"
                    ]
                }
            },
            stateTransitionTime: {
                serializedName: "stateTransitionTime",
                type: {
                    name: "DateTime"
                }
            },
            previousState: {
                serializedName: "previousState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "preparing",
                        "running",
                        "completed"
                    ]
                }
            },
            previousStateTransitionTime: {
                serializedName: "previousStateTransitionTime",
                type: {
                    name: "DateTime"
                }
            },
            result: {
                serializedName: "result",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "success",
                        "failure"
                    ]
                }
            }
        }
    }
};
exports.CloudTaskListSubtasksResult = {
    serializedName: "CloudTaskListSubtasksResult",
    type: {
        name: "Composite",
        className: "CloudTaskListSubtasksResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "SubtaskInformationElementType",
                        type: {
                            name: "Composite",
                            className: "SubtaskInformation"
                        }
                    }
                }
            }
        }
    }
};
exports.TaskInformation = {
    serializedName: "TaskInformation",
    type: {
        name: "Composite",
        className: "TaskInformation",
        modelProperties: {
            taskUrl: {
                serializedName: "taskUrl",
                type: {
                    name: "String"
                }
            },
            jobId: {
                serializedName: "jobId",
                type: {
                    name: "String"
                }
            },
            taskId: {
                serializedName: "taskId",
                type: {
                    name: "String"
                }
            },
            subtaskId: {
                serializedName: "subtaskId",
                type: {
                    name: "Number"
                }
            },
            taskState: {
                required: true,
                serializedName: "taskState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "active",
                        "preparing",
                        "running",
                        "completed"
                    ]
                }
            },
            executionInfo: {
                serializedName: "executionInfo",
                type: {
                    name: "Composite",
                    className: "TaskExecutionInformation"
                }
            }
        }
    }
};
exports.StartTaskInformation = {
    serializedName: "StartTaskInformation",
    type: {
        name: "Composite",
        className: "StartTaskInformation",
        modelProperties: {
            state: {
                required: true,
                serializedName: "state",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "running",
                        "completed"
                    ]
                }
            },
            startTime: {
                required: true,
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            exitCode: {
                serializedName: "exitCode",
                type: {
                    name: "Number"
                }
            },
            containerInfo: {
                serializedName: "containerInfo",
                type: {
                    name: "Composite",
                    className: "TaskContainerExecutionInformation"
                }
            },
            failureInfo: {
                serializedName: "failureInfo",
                type: {
                    name: "Composite",
                    className: "TaskFailureInformation"
                }
            },
            retryCount: {
                required: true,
                serializedName: "retryCount",
                type: {
                    name: "Number"
                }
            },
            lastRetryTime: {
                serializedName: "lastRetryTime",
                type: {
                    name: "DateTime"
                }
            },
            result: {
                serializedName: "result",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "success",
                        "failure"
                    ]
                }
            }
        }
    }
};
exports.ComputeNodeError = {
    serializedName: "ComputeNodeError",
    type: {
        name: "Composite",
        className: "ComputeNodeError",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            errorDetails: {
                serializedName: "errorDetails",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "NameValuePairElementType",
                        type: {
                            name: "Composite",
                            className: "NameValuePair"
                        }
                    }
                }
            }
        }
    }
};
exports.InboundEndpoint = {
    serializedName: "InboundEndpoint",
    type: {
        name: "Composite",
        className: "InboundEndpoint",
        modelProperties: {
            name: {
                required: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            protocol: {
                required: true,
                serializedName: "protocol",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "tcp",
                        "udp"
                    ]
                }
            },
            publicIPAddress: {
                required: true,
                serializedName: "publicIPAddress",
                type: {
                    name: "String"
                }
            },
            publicFQDN: {
                required: true,
                serializedName: "publicFQDN",
                type: {
                    name: "String"
                }
            },
            frontendPort: {
                required: true,
                serializedName: "frontendPort",
                type: {
                    name: "Number"
                }
            },
            backendPort: {
                required: true,
                serializedName: "backendPort",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
exports.ComputeNodeEndpointConfiguration = {
    serializedName: "ComputeNodeEndpointConfiguration",
    type: {
        name: "Composite",
        className: "ComputeNodeEndpointConfiguration",
        modelProperties: {
            inboundEndpoints: {
                required: true,
                serializedName: "inboundEndpoints",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "InboundEndpointElementType",
                        type: {
                            name: "Composite",
                            className: "InboundEndpoint"
                        }
                    }
                }
            }
        }
    }
};
exports.ComputeNode = {
    serializedName: "ComputeNode",
    type: {
        name: "Composite",
        className: "ComputeNode",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "idle",
                        "rebooting",
                        "reimaging",
                        "running",
                        "unusable",
                        "creating",
                        "starting",
                        "waitingforstarttask",
                        "starttaskfailed",
                        "unknown",
                        "leavingpool",
                        "offline",
                        "preempted"
                    ]
                }
            },
            schedulingState: {
                serializedName: "schedulingState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "enabled",
                        "disabled"
                    ]
                }
            },
            stateTransitionTime: {
                serializedName: "stateTransitionTime",
                type: {
                    name: "DateTime"
                }
            },
            lastBootTime: {
                serializedName: "lastBootTime",
                type: {
                    name: "DateTime"
                }
            },
            allocationTime: {
                serializedName: "allocationTime",
                type: {
                    name: "DateTime"
                }
            },
            ipAddress: {
                serializedName: "ipAddress",
                type: {
                    name: "String"
                }
            },
            affinityId: {
                serializedName: "affinityId",
                type: {
                    name: "String"
                }
            },
            vmSize: {
                serializedName: "vmSize",
                type: {
                    name: "String"
                }
            },
            totalTasksRun: {
                serializedName: "totalTasksRun",
                type: {
                    name: "Number"
                }
            },
            runningTasksCount: {
                serializedName: "runningTasksCount",
                type: {
                    name: "Number"
                }
            },
            totalTasksSucceeded: {
                serializedName: "totalTasksSucceeded",
                type: {
                    name: "Number"
                }
            },
            recentTasks: {
                serializedName: "recentTasks",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "TaskInformationElementType",
                        type: {
                            name: "Composite",
                            className: "TaskInformation"
                        }
                    }
                }
            },
            startTask: {
                serializedName: "startTask",
                type: {
                    name: "Composite",
                    className: "StartTask"
                }
            },
            startTaskInfo: {
                serializedName: "startTaskInfo",
                type: {
                    name: "Composite",
                    className: "StartTaskInformation"
                }
            },
            certificateReferences: {
                serializedName: "certificateReferences",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "CertificateReferenceElementType",
                        type: {
                            name: "Composite",
                            className: "CertificateReference"
                        }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ComputeNodeErrorElementType",
                        type: {
                            name: "Composite",
                            className: "ComputeNodeError"
                        }
                    }
                }
            },
            isDedicated: {
                serializedName: "isDedicated",
                type: {
                    name: "Boolean"
                }
            },
            endpointConfiguration: {
                serializedName: "endpointConfiguration",
                type: {
                    name: "Composite",
                    className: "ComputeNodeEndpointConfiguration"
                }
            }
        }
    }
};
exports.ComputeNodeUser = {
    serializedName: "ComputeNodeUser",
    type: {
        name: "Composite",
        className: "ComputeNodeUser",
        modelProperties: {
            name: {
                required: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            isAdmin: {
                serializedName: "isAdmin",
                type: {
                    name: "Boolean"
                }
            },
            expiryTime: {
                serializedName: "expiryTime",
                type: {
                    name: "DateTime"
                }
            },
            password: {
                serializedName: "password",
                type: {
                    name: "String"
                }
            },
            sshPublicKey: {
                serializedName: "sshPublicKey",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.ComputeNodeGetRemoteLoginSettingsResult = {
    serializedName: "ComputeNodeGetRemoteLoginSettingsResult",
    type: {
        name: "Composite",
        className: "ComputeNodeGetRemoteLoginSettingsResult",
        modelProperties: {
            remoteLoginIPAddress: {
                required: true,
                serializedName: "remoteLoginIPAddress",
                type: {
                    name: "String"
                }
            },
            remoteLoginPort: {
                required: true,
                serializedName: "remoteLoginPort",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
exports.JobSchedulePatchParameter = {
    serializedName: "JobSchedulePatchParameter",
    type: {
        name: "Composite",
        className: "JobSchedulePatchParameter",
        modelProperties: {
            schedule: {
                serializedName: "schedule",
                type: {
                    name: "Composite",
                    className: "Schedule"
                }
            },
            jobSpecification: {
                serializedName: "jobSpecification",
                type: {
                    name: "Composite",
                    className: "JobSpecification"
                }
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "MetadataItemElementType",
                        type: {
                            name: "Composite",
                            className: "MetadataItem"
                        }
                    }
                }
            }
        }
    }
};
exports.JobScheduleUpdateParameter = {
    serializedName: "JobScheduleUpdateParameter",
    type: {
        name: "Composite",
        className: "JobScheduleUpdateParameter",
        modelProperties: {
            schedule: {
                required: true,
                serializedName: "schedule",
                type: {
                    name: "Composite",
                    className: "Schedule"
                }
            },
            jobSpecification: {
                required: true,
                serializedName: "jobSpecification",
                defaultValue: {},
                type: {
                    name: "Composite",
                    className: "JobSpecification"
                }
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "MetadataItemElementType",
                        type: {
                            name: "Composite",
                            className: "MetadataItem"
                        }
                    }
                }
            }
        }
    }
};
exports.JobDisableParameter = {
    serializedName: "JobDisableParameter",
    type: {
        name: "Composite",
        className: "JobDisableParameter",
        modelProperties: {
            disableTasks: {
                required: true,
                serializedName: "disableTasks",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "requeue",
                        "terminate",
                        "wait"
                    ]
                }
            }
        }
    }
};
exports.JobTerminateParameter = {
    serializedName: "JobTerminateParameter",
    type: {
        name: "Composite",
        className: "JobTerminateParameter",
        modelProperties: {
            terminateReason: {
                serializedName: "terminateReason",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.JobPatchParameter = {
    serializedName: "JobPatchParameter",
    type: {
        name: "Composite",
        className: "JobPatchParameter",
        modelProperties: {
            priority: {
                serializedName: "priority",
                type: {
                    name: "Number"
                }
            },
            onAllTasksComplete: {
                serializedName: "onAllTasksComplete",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "noaction",
                        "terminatejob"
                    ]
                }
            },
            constraints: {
                serializedName: "constraints",
                type: {
                    name: "Composite",
                    className: "JobConstraints"
                }
            },
            poolInfo: {
                serializedName: "poolInfo",
                type: {
                    name: "Composite",
                    className: "PoolInformation"
                }
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "MetadataItemElementType",
                        type: {
                            name: "Composite",
                            className: "MetadataItem"
                        }
                    }
                }
            }
        }
    }
};
exports.JobUpdateParameter = {
    serializedName: "JobUpdateParameter",
    type: {
        name: "Composite",
        className: "JobUpdateParameter",
        modelProperties: {
            priority: {
                serializedName: "priority",
                type: {
                    name: "Number"
                }
            },
            constraints: {
                serializedName: "constraints",
                type: {
                    name: "Composite",
                    className: "JobConstraints"
                }
            },
            poolInfo: {
                required: true,
                serializedName: "poolInfo",
                defaultValue: {},
                type: {
                    name: "Composite",
                    className: "PoolInformation"
                }
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "MetadataItemElementType",
                        type: {
                            name: "Composite",
                            className: "MetadataItem"
                        }
                    }
                }
            },
            onAllTasksComplete: {
                serializedName: "onAllTasksComplete",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "noaction",
                        "terminatejob"
                    ]
                }
            }
        }
    }
};
exports.PoolEnableAutoScaleParameter = {
    serializedName: "PoolEnableAutoScaleParameter",
    type: {
        name: "Composite",
        className: "PoolEnableAutoScaleParameter",
        modelProperties: {
            autoScaleFormula: {
                serializedName: "autoScaleFormula",
                type: {
                    name: "String"
                }
            },
            autoScaleEvaluationInterval: {
                serializedName: "autoScaleEvaluationInterval",
                type: {
                    name: "TimeSpan"
                }
            }
        }
    }
};
exports.PoolEvaluateAutoScaleParameter = {
    serializedName: "PoolEvaluateAutoScaleParameter",
    type: {
        name: "Composite",
        className: "PoolEvaluateAutoScaleParameter",
        modelProperties: {
            autoScaleFormula: {
                required: true,
                serializedName: "autoScaleFormula",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.PoolResizeParameter = {
    serializedName: "PoolResizeParameter",
    type: {
        name: "Composite",
        className: "PoolResizeParameter",
        modelProperties: {
            targetDedicatedNodes: {
                serializedName: "targetDedicatedNodes",
                type: {
                    name: "Number"
                }
            },
            targetLowPriorityNodes: {
                serializedName: "targetLowPriorityNodes",
                type: {
                    name: "Number"
                }
            },
            resizeTimeout: {
                serializedName: "resizeTimeout",
                type: {
                    name: "TimeSpan"
                }
            },
            nodeDeallocationOption: {
                serializedName: "nodeDeallocationOption",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "requeue",
                        "terminate",
                        "taskcompletion",
                        "retaineddata"
                    ]
                }
            }
        }
    }
};
exports.PoolUpdatePropertiesParameter = {
    serializedName: "PoolUpdatePropertiesParameter",
    type: {
        name: "Composite",
        className: "PoolUpdatePropertiesParameter",
        modelProperties: {
            startTask: {
                serializedName: "startTask",
                type: {
                    name: "Composite",
                    className: "StartTask"
                }
            },
            certificateReferences: {
                required: true,
                serializedName: "certificateReferences",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "CertificateReferenceElementType",
                        type: {
                            name: "Composite",
                            className: "CertificateReference"
                        }
                    }
                }
            },
            applicationPackageReferences: {
                required: true,
                serializedName: "applicationPackageReferences",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ApplicationPackageReferenceElementType",
                        type: {
                            name: "Composite",
                            className: "ApplicationPackageReference"
                        }
                    }
                }
            },
            metadata: {
                required: true,
                serializedName: "metadata",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "MetadataItemElementType",
                        type: {
                            name: "Composite",
                            className: "MetadataItem"
                        }
                    }
                }
            }
        }
    }
};
exports.PoolUpgradeOSParameter = {
    serializedName: "PoolUpgradeOSParameter",
    type: {
        name: "Composite",
        className: "PoolUpgradeOSParameter",
        modelProperties: {
            targetOSVersion: {
                required: true,
                serializedName: "targetOSVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.PoolPatchParameter = {
    serializedName: "PoolPatchParameter",
    type: {
        name: "Composite",
        className: "PoolPatchParameter",
        modelProperties: {
            startTask: {
                serializedName: "startTask",
                type: {
                    name: "Composite",
                    className: "StartTask"
                }
            },
            certificateReferences: {
                serializedName: "certificateReferences",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "CertificateReferenceElementType",
                        type: {
                            name: "Composite",
                            className: "CertificateReference"
                        }
                    }
                }
            },
            applicationPackageReferences: {
                serializedName: "applicationPackageReferences",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ApplicationPackageReferenceElementType",
                        type: {
                            name: "Composite",
                            className: "ApplicationPackageReference"
                        }
                    }
                }
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "MetadataItemElementType",
                        type: {
                            name: "Composite",
                            className: "MetadataItem"
                        }
                    }
                }
            }
        }
    }
};
exports.TaskUpdateParameter = {
    serializedName: "TaskUpdateParameter",
    type: {
        name: "Composite",
        className: "TaskUpdateParameter",
        modelProperties: {
            constraints: {
                serializedName: "constraints",
                type: {
                    name: "Composite",
                    className: "TaskConstraints"
                }
            }
        }
    }
};
exports.NodeUpdateUserParameter = {
    serializedName: "NodeUpdateUserParameter",
    type: {
        name: "Composite",
        className: "NodeUpdateUserParameter",
        modelProperties: {
            password: {
                serializedName: "password",
                type: {
                    name: "String"
                }
            },
            expiryTime: {
                serializedName: "expiryTime",
                type: {
                    name: "DateTime"
                }
            },
            sshPublicKey: {
                serializedName: "sshPublicKey",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.NodeRebootParameter = {
    serializedName: "NodeRebootParameter",
    type: {
        name: "Composite",
        className: "NodeRebootParameter",
        modelProperties: {
            nodeRebootOption: {
                serializedName: "nodeRebootOption",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "requeue",
                        "terminate",
                        "taskcompletion",
                        "retaineddata"
                    ]
                }
            }
        }
    }
};
exports.NodeReimageParameter = {
    serializedName: "NodeReimageParameter",
    type: {
        name: "Composite",
        className: "NodeReimageParameter",
        modelProperties: {
            nodeReimageOption: {
                serializedName: "nodeReimageOption",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "requeue",
                        "terminate",
                        "taskcompletion",
                        "retaineddata"
                    ]
                }
            }
        }
    }
};
exports.NodeDisableSchedulingParameter = {
    serializedName: "NodeDisableSchedulingParameter",
    type: {
        name: "Composite",
        className: "NodeDisableSchedulingParameter",
        modelProperties: {
            nodeDisableSchedulingOption: {
                serializedName: "nodeDisableSchedulingOption",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "requeue",
                        "terminate",
                        "taskcompletion"
                    ]
                }
            }
        }
    }
};
exports.NodeRemoveParameter = {
    serializedName: "NodeRemoveParameter",
    type: {
        name: "Composite",
        className: "NodeRemoveParameter",
        modelProperties: {
            nodeList: {
                required: true,
                serializedName: "nodeList",
                constraints: {
                    MaxItems: 100
                },
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "stringElementType",
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            resizeTimeout: {
                serializedName: "resizeTimeout",
                type: {
                    name: "TimeSpan"
                }
            },
            nodeDeallocationOption: {
                serializedName: "nodeDeallocationOption",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "requeue",
                        "terminate",
                        "taskcompletion",
                        "retaineddata"
                    ]
                }
            }
        }
    }
};
exports.UploadBatchServiceLogsConfiguration = {
    serializedName: "UploadBatchServiceLogsConfiguration",
    type: {
        name: "Composite",
        className: "UploadBatchServiceLogsConfiguration",
        modelProperties: {
            containerUrl: {
                required: true,
                serializedName: "containerUrl",
                type: {
                    name: "String"
                }
            },
            startTime: {
                required: true,
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
exports.UploadBatchServiceLogsResult = {
    serializedName: "UploadBatchServiceLogsResult",
    type: {
        name: "Composite",
        className: "UploadBatchServiceLogsResult",
        modelProperties: {
            virtualDirectoryName: {
                required: true,
                serializedName: "virtualDirectoryName",
                type: {
                    name: "String"
                }
            },
            numberOfFilesUploaded: {
                required: true,
                serializedName: "numberOfFilesUploaded",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
exports.NodeCounts = {
    serializedName: "NodeCounts",
    type: {
        name: "Composite",
        className: "NodeCounts",
        modelProperties: {
            creating: {
                required: true,
                serializedName: "creating",
                type: {
                    name: "Number"
                }
            },
            idle: {
                required: true,
                serializedName: "idle",
                type: {
                    name: "Number"
                }
            },
            offline: {
                required: true,
                serializedName: "offline",
                type: {
                    name: "Number"
                }
            },
            preempted: {
                required: true,
                serializedName: "preempted",
                type: {
                    name: "Number"
                }
            },
            rebooting: {
                required: true,
                serializedName: "rebooting",
                type: {
                    name: "Number"
                }
            },
            reimaging: {
                required: true,
                serializedName: "reimaging",
                type: {
                    name: "Number"
                }
            },
            running: {
                required: true,
                serializedName: "running",
                type: {
                    name: "Number"
                }
            },
            starting: {
                required: true,
                serializedName: "starting",
                type: {
                    name: "Number"
                }
            },
            startTaskFailed: {
                required: true,
                serializedName: "startTaskFailed",
                type: {
                    name: "Number"
                }
            },
            leavingPool: {
                required: true,
                serializedName: "leavingPool",
                type: {
                    name: "Number"
                }
            },
            unknown: {
                required: true,
                serializedName: "unknown",
                type: {
                    name: "Number"
                }
            },
            unusable: {
                required: true,
                serializedName: "unusable",
                type: {
                    name: "Number"
                }
            },
            waitingForStartTask: {
                required: true,
                serializedName: "waitingForStartTask",
                type: {
                    name: "Number"
                }
            },
            total: {
                required: true,
                serializedName: "total",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
exports.PoolNodeCounts = {
    serializedName: "PoolNodeCounts",
    type: {
        name: "Composite",
        className: "PoolNodeCounts",
        modelProperties: {
            poolId: {
                required: true,
                serializedName: "poolId",
                type: {
                    name: "String"
                }
            },
            dedicated: {
                serializedName: "dedicated",
                type: {
                    name: "Composite",
                    className: "NodeCounts"
                }
            },
            lowPriority: {
                serializedName: "lowPriority",
                type: {
                    name: "Composite",
                    className: "NodeCounts"
                }
            }
        }
    }
};
exports.ApplicationListOptions = {
    type: {
        name: "Composite",
        className: "ApplicationListOptions",
        modelProperties: {
            maxResults: {
                defaultValue: 1000,
                type: {
                    name: "Number"
                }
            },
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.ApplicationGetOptions = {
    type: {
        name: "Composite",
        className: "ApplicationGetOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.PoolListUsageMetricsOptions = {
    type: {
        name: "Composite",
        className: "PoolListUsageMetricsOptions",
        modelProperties: {
            startTime: {
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                type: {
                    name: "DateTime"
                }
            },
            filter: {
                type: {
                    name: "String"
                }
            },
            maxResults: {
                defaultValue: 1000,
                type: {
                    name: "Number"
                }
            },
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.PoolGetAllLifetimeStatisticsOptions = {
    type: {
        name: "Composite",
        className: "PoolGetAllLifetimeStatisticsOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.PoolAddOptions = {
    type: {
        name: "Composite",
        className: "PoolAddOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.PoolListOptions = {
    type: {
        name: "Composite",
        className: "PoolListOptions",
        modelProperties: {
            filter: {
                type: {
                    name: "String"
                }
            },
            select: {
                type: {
                    name: "String"
                }
            },
            expand: {
                type: {
                    name: "String"
                }
            },
            maxResults: {
                defaultValue: 1000,
                type: {
                    name: "Number"
                }
            },
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.PoolDeleteMethodOptions = {
    type: {
        name: "Composite",
        className: "PoolDeleteMethodOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.PoolExistsOptions = {
    type: {
        name: "Composite",
        className: "PoolExistsOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.PoolGetOptions = {
    type: {
        name: "Composite",
        className: "PoolGetOptions",
        modelProperties: {
            select: {
                type: {
                    name: "String"
                }
            },
            expand: {
                type: {
                    name: "String"
                }
            },
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.PoolPatchOptions = {
    type: {
        name: "Composite",
        className: "PoolPatchOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.PoolDisableAutoScaleOptions = {
    type: {
        name: "Composite",
        className: "PoolDisableAutoScaleOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.PoolEnableAutoScaleOptions = {
    type: {
        name: "Composite",
        className: "PoolEnableAutoScaleOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.PoolEvaluateAutoScaleOptions = {
    type: {
        name: "Composite",
        className: "PoolEvaluateAutoScaleOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.PoolResizeOptions = {
    type: {
        name: "Composite",
        className: "PoolResizeOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.PoolStopResizeOptions = {
    type: {
        name: "Composite",
        className: "PoolStopResizeOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.PoolUpdatePropertiesOptions = {
    type: {
        name: "Composite",
        className: "PoolUpdatePropertiesOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.PoolUpgradeOSOptions = {
    type: {
        name: "Composite",
        className: "PoolUpgradeOSOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.PoolRemoveNodesOptions = {
    type: {
        name: "Composite",
        className: "PoolRemoveNodesOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.AccountListNodeAgentSkusOptions = {
    type: {
        name: "Composite",
        className: "AccountListNodeAgentSkusOptions",
        modelProperties: {
            filter: {
                type: {
                    name: "String"
                }
            },
            maxResults: {
                defaultValue: 1000,
                type: {
                    name: "Number"
                }
            },
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.AccountListPoolNodeCountsOptions = {
    type: {
        name: "Composite",
        className: "AccountListPoolNodeCountsOptions",
        modelProperties: {
            filter: {
                type: {
                    name: "String"
                }
            },
            maxResults: {
                defaultValue: 10,
                type: {
                    name: "Number"
                }
            },
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobGetAllLifetimeStatisticsOptions = {
    type: {
        name: "Composite",
        className: "JobGetAllLifetimeStatisticsOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobDeleteMethodOptions = {
    type: {
        name: "Composite",
        className: "JobDeleteMethodOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobGetOptions = {
    type: {
        name: "Composite",
        className: "JobGetOptions",
        modelProperties: {
            select: {
                type: {
                    name: "String"
                }
            },
            expand: {
                type: {
                    name: "String"
                }
            },
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobPatchOptions = {
    type: {
        name: "Composite",
        className: "JobPatchOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobUpdateOptions = {
    type: {
        name: "Composite",
        className: "JobUpdateOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobDisableOptions = {
    type: {
        name: "Composite",
        className: "JobDisableOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobEnableOptions = {
    type: {
        name: "Composite",
        className: "JobEnableOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobTerminateOptions = {
    type: {
        name: "Composite",
        className: "JobTerminateOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobAddOptions = {
    type: {
        name: "Composite",
        className: "JobAddOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobListOptions = {
    type: {
        name: "Composite",
        className: "JobListOptions",
        modelProperties: {
            filter: {
                type: {
                    name: "String"
                }
            },
            select: {
                type: {
                    name: "String"
                }
            },
            expand: {
                type: {
                    name: "String"
                }
            },
            maxResults: {
                defaultValue: 1000,
                type: {
                    name: "Number"
                }
            },
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobListFromJobScheduleOptions = {
    type: {
        name: "Composite",
        className: "JobListFromJobScheduleOptions",
        modelProperties: {
            filter: {
                type: {
                    name: "String"
                }
            },
            select: {
                type: {
                    name: "String"
                }
            },
            expand: {
                type: {
                    name: "String"
                }
            },
            maxResults: {
                defaultValue: 1000,
                type: {
                    name: "Number"
                }
            },
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobListPreparationAndReleaseTaskStatusOptions = {
    type: {
        name: "Composite",
        className: "JobListPreparationAndReleaseTaskStatusOptions",
        modelProperties: {
            filter: {
                type: {
                    name: "String"
                }
            },
            select: {
                type: {
                    name: "String"
                }
            },
            maxResults: {
                defaultValue: 1000,
                type: {
                    name: "Number"
                }
            },
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobGetTaskCountsOptions = {
    type: {
        name: "Composite",
        className: "JobGetTaskCountsOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.CertificateAddOptions = {
    type: {
        name: "Composite",
        className: "CertificateAddOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.CertificateListOptions = {
    type: {
        name: "Composite",
        className: "CertificateListOptions",
        modelProperties: {
            filter: {
                type: {
                    name: "String"
                }
            },
            select: {
                type: {
                    name: "String"
                }
            },
            maxResults: {
                defaultValue: 1000,
                type: {
                    name: "Number"
                }
            },
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.CertificateCancelDeletionOptions = {
    type: {
        name: "Composite",
        className: "CertificateCancelDeletionOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.CertificateDeleteMethodOptions = {
    type: {
        name: "Composite",
        className: "CertificateDeleteMethodOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.CertificateGetOptions = {
    type: {
        name: "Composite",
        className: "CertificateGetOptions",
        modelProperties: {
            select: {
                type: {
                    name: "String"
                }
            },
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.FileDeleteFromTaskOptions = {
    type: {
        name: "Composite",
        className: "FileDeleteFromTaskOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.FileGetFromTaskOptions = {
    type: {
        name: "Composite",
        className: "FileGetFromTaskOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ocpRange: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.FileGetPropertiesFromTaskOptions = {
    type: {
        name: "Composite",
        className: "FileGetPropertiesFromTaskOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.FileDeleteFromComputeNodeOptions = {
    type: {
        name: "Composite",
        className: "FileDeleteFromComputeNodeOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.FileGetFromComputeNodeOptions = {
    type: {
        name: "Composite",
        className: "FileGetFromComputeNodeOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ocpRange: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.FileGetPropertiesFromComputeNodeOptions = {
    type: {
        name: "Composite",
        className: "FileGetPropertiesFromComputeNodeOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.FileListFromTaskOptions = {
    type: {
        name: "Composite",
        className: "FileListFromTaskOptions",
        modelProperties: {
            filter: {
                type: {
                    name: "String"
                }
            },
            maxResults: {
                defaultValue: 1000,
                type: {
                    name: "Number"
                }
            },
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.FileListFromComputeNodeOptions = {
    type: {
        name: "Composite",
        className: "FileListFromComputeNodeOptions",
        modelProperties: {
            filter: {
                type: {
                    name: "String"
                }
            },
            maxResults: {
                defaultValue: 1000,
                type: {
                    name: "Number"
                }
            },
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobScheduleExistsOptions = {
    type: {
        name: "Composite",
        className: "JobScheduleExistsOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobScheduleDeleteMethodOptions = {
    type: {
        name: "Composite",
        className: "JobScheduleDeleteMethodOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobScheduleGetOptions = {
    type: {
        name: "Composite",
        className: "JobScheduleGetOptions",
        modelProperties: {
            select: {
                type: {
                    name: "String"
                }
            },
            expand: {
                type: {
                    name: "String"
                }
            },
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobSchedulePatchOptions = {
    type: {
        name: "Composite",
        className: "JobSchedulePatchOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobScheduleUpdateOptions = {
    type: {
        name: "Composite",
        className: "JobScheduleUpdateOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobScheduleDisableOptions = {
    type: {
        name: "Composite",
        className: "JobScheduleDisableOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobScheduleEnableOptions = {
    type: {
        name: "Composite",
        className: "JobScheduleEnableOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobScheduleTerminateOptions = {
    type: {
        name: "Composite",
        className: "JobScheduleTerminateOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobScheduleAddOptions = {
    type: {
        name: "Composite",
        className: "JobScheduleAddOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobScheduleListOptions = {
    type: {
        name: "Composite",
        className: "JobScheduleListOptions",
        modelProperties: {
            filter: {
                type: {
                    name: "String"
                }
            },
            select: {
                type: {
                    name: "String"
                }
            },
            expand: {
                type: {
                    name: "String"
                }
            },
            maxResults: {
                defaultValue: 1000,
                type: {
                    name: "Number"
                }
            },
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.TaskAddOptions = {
    type: {
        name: "Composite",
        className: "TaskAddOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.TaskListOptions = {
    type: {
        name: "Composite",
        className: "TaskListOptions",
        modelProperties: {
            filter: {
                type: {
                    name: "String"
                }
            },
            select: {
                type: {
                    name: "String"
                }
            },
            expand: {
                type: {
                    name: "String"
                }
            },
            maxResults: {
                defaultValue: 1000,
                type: {
                    name: "Number"
                }
            },
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.TaskAddCollectionOptions = {
    type: {
        name: "Composite",
        className: "TaskAddCollectionOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.TaskDeleteMethodOptions = {
    type: {
        name: "Composite",
        className: "TaskDeleteMethodOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.TaskGetOptions = {
    type: {
        name: "Composite",
        className: "TaskGetOptions",
        modelProperties: {
            select: {
                type: {
                    name: "String"
                }
            },
            expand: {
                type: {
                    name: "String"
                }
            },
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.TaskUpdateOptions = {
    type: {
        name: "Composite",
        className: "TaskUpdateOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.TaskListSubtasksOptions = {
    type: {
        name: "Composite",
        className: "TaskListSubtasksOptions",
        modelProperties: {
            select: {
                type: {
                    name: "String"
                }
            },
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.TaskTerminateOptions = {
    type: {
        name: "Composite",
        className: "TaskTerminateOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.TaskReactivateOptions = {
    type: {
        name: "Composite",
        className: "TaskReactivateOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifMatch: {
                type: {
                    name: "String"
                }
            },
            ifNoneMatch: {
                type: {
                    name: "String"
                }
            },
            ifModifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ifUnmodifiedSince: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.ComputeNodeAddUserOptions = {
    type: {
        name: "Composite",
        className: "ComputeNodeAddUserOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.ComputeNodeDeleteUserOptions = {
    type: {
        name: "Composite",
        className: "ComputeNodeDeleteUserOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.ComputeNodeUpdateUserOptions = {
    type: {
        name: "Composite",
        className: "ComputeNodeUpdateUserOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.ComputeNodeGetOptions = {
    type: {
        name: "Composite",
        className: "ComputeNodeGetOptions",
        modelProperties: {
            select: {
                type: {
                    name: "String"
                }
            },
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.ComputeNodeRebootOptions = {
    type: {
        name: "Composite",
        className: "ComputeNodeRebootOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.ComputeNodeReimageOptions = {
    type: {
        name: "Composite",
        className: "ComputeNodeReimageOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.ComputeNodeDisableSchedulingOptions = {
    type: {
        name: "Composite",
        className: "ComputeNodeDisableSchedulingOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.ComputeNodeEnableSchedulingOptions = {
    type: {
        name: "Composite",
        className: "ComputeNodeEnableSchedulingOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.ComputeNodeGetRemoteLoginSettingsOptions = {
    type: {
        name: "Composite",
        className: "ComputeNodeGetRemoteLoginSettingsOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.ComputeNodeGetRemoteDesktopOptions = {
    type: {
        name: "Composite",
        className: "ComputeNodeGetRemoteDesktopOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.ComputeNodeUploadBatchServiceLogsOptions = {
    type: {
        name: "Composite",
        className: "ComputeNodeUploadBatchServiceLogsOptions",
        modelProperties: {
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.ComputeNodeListOptions = {
    type: {
        name: "Composite",
        className: "ComputeNodeListOptions",
        modelProperties: {
            filter: {
                type: {
                    name: "String"
                }
            },
            select: {
                type: {
                    name: "String"
                }
            },
            maxResults: {
                defaultValue: 1000,
                type: {
                    name: "Number"
                }
            },
            timeout: {
                defaultValue: 30,
                type: {
                    name: "Number"
                }
            },
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.ApplicationListNextOptions = {
    type: {
        name: "Composite",
        className: "ApplicationListNextOptions",
        modelProperties: {
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.PoolListUsageMetricsNextOptions = {
    type: {
        name: "Composite",
        className: "PoolListUsageMetricsNextOptions",
        modelProperties: {
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.PoolListNextOptions = {
    type: {
        name: "Composite",
        className: "PoolListNextOptions",
        modelProperties: {
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.AccountListNodeAgentSkusNextOptions = {
    type: {
        name: "Composite",
        className: "AccountListNodeAgentSkusNextOptions",
        modelProperties: {
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.AccountListPoolNodeCountsNextOptions = {
    type: {
        name: "Composite",
        className: "AccountListPoolNodeCountsNextOptions",
        modelProperties: {
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobListNextOptions = {
    type: {
        name: "Composite",
        className: "JobListNextOptions",
        modelProperties: {
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobListFromJobScheduleNextOptions = {
    type: {
        name: "Composite",
        className: "JobListFromJobScheduleNextOptions",
        modelProperties: {
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobListPreparationAndReleaseTaskStatusNextOptions = {
    type: {
        name: "Composite",
        className: "JobListPreparationAndReleaseTaskStatusNextOptions",
        modelProperties: {
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.CertificateListNextOptions = {
    type: {
        name: "Composite",
        className: "CertificateListNextOptions",
        modelProperties: {
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.FileListFromTaskNextOptions = {
    type: {
        name: "Composite",
        className: "FileListFromTaskNextOptions",
        modelProperties: {
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.FileListFromComputeNodeNextOptions = {
    type: {
        name: "Composite",
        className: "FileListFromComputeNodeNextOptions",
        modelProperties: {
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobScheduleListNextOptions = {
    type: {
        name: "Composite",
        className: "JobScheduleListNextOptions",
        modelProperties: {
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.TaskListNextOptions = {
    type: {
        name: "Composite",
        className: "TaskListNextOptions",
        modelProperties: {
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.ComputeNodeListNextOptions = {
    type: {
        name: "Composite",
        className: "ComputeNodeListNextOptions",
        modelProperties: {
            clientRequestId: {
                type: {
                    name: "Uuid"
                }
            },
            returnClientRequestId: {
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            ocpDate: {
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.ApplicationListOptionalParams = {
    serializedName: "ListOptions",
    type: {
        name: "Composite",
        className: "ApplicationListOptionalParams",
        modelProperties: {
            applicationListOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "ApplicationListOptions"
                }
            }
        }
    }
};
exports.ApplicationGetOptionalParams = {
    serializedName: "GetOptions",
    type: {
        name: "Composite",
        className: "ApplicationGetOptionalParams",
        modelProperties: {
            applicationGetOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "ApplicationGetOptions"
                }
            }
        }
    }
};
exports.ApplicationListNextOptionalParams = {
    serializedName: "ListNextOptions",
    type: {
        name: "Composite",
        className: "ApplicationListNextOptionalParams",
        modelProperties: {
            applicationListNextOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "ApplicationListNextOptions"
                }
            }
        }
    }
};
exports.PoolListUsageMetricsOptionalParams = {
    serializedName: "ListUsageMetricsOptions",
    type: {
        name: "Composite",
        className: "PoolListUsageMetricsOptionalParams",
        modelProperties: {
            poolListUsageMetricsOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "PoolListUsageMetricsOptions"
                }
            }
        }
    }
};
exports.PoolGetAllLifetimeStatisticsOptionalParams = {
    serializedName: "GetAllLifetimeStatisticsOptions",
    type: {
        name: "Composite",
        className: "PoolGetAllLifetimeStatisticsOptionalParams",
        modelProperties: {
            poolGetAllLifetimeStatisticsOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "PoolGetAllLifetimeStatisticsOptions"
                }
            }
        }
    }
};
exports.PoolAddOptionalParams = {
    serializedName: "AddOptions",
    type: {
        name: "Composite",
        className: "PoolAddOptionalParams",
        modelProperties: {
            poolAddOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "PoolAddOptions"
                }
            }
        }
    }
};
exports.PoolListOptionalParams = {
    serializedName: "ListOptions",
    type: {
        name: "Composite",
        className: "PoolListOptionalParams",
        modelProperties: {
            poolListOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "PoolListOptions"
                }
            }
        }
    }
};
exports.PoolDeleteMethodOptionalParams = {
    serializedName: "DeleteMethodOptions",
    type: {
        name: "Composite",
        className: "PoolDeleteMethodOptionalParams",
        modelProperties: {
            poolDeleteMethodOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "PoolDeleteMethodOptions"
                }
            }
        }
    }
};
exports.PoolExistsOptionalParams = {
    serializedName: "ExistsOptions",
    type: {
        name: "Composite",
        className: "PoolExistsOptionalParams",
        modelProperties: {
            poolExistsOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "PoolExistsOptions"
                }
            }
        }
    }
};
exports.PoolGetOptionalParams = {
    serializedName: "GetOptions",
    type: {
        name: "Composite",
        className: "PoolGetOptionalParams",
        modelProperties: {
            poolGetOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "PoolGetOptions"
                }
            }
        }
    }
};
exports.PoolPatchOptionalParams = {
    serializedName: "PatchOptions",
    type: {
        name: "Composite",
        className: "PoolPatchOptionalParams",
        modelProperties: {
            poolPatchOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "PoolPatchOptions"
                }
            }
        }
    }
};
exports.PoolDisableAutoScaleOptionalParams = {
    serializedName: "DisableAutoScaleOptions",
    type: {
        name: "Composite",
        className: "PoolDisableAutoScaleOptionalParams",
        modelProperties: {
            poolDisableAutoScaleOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "PoolDisableAutoScaleOptions"
                }
            }
        }
    }
};
exports.PoolEnableAutoScaleOptionalParams = {
    serializedName: "EnableAutoScaleOptions",
    type: {
        name: "Composite",
        className: "PoolEnableAutoScaleOptionalParams",
        modelProperties: {
            poolEnableAutoScaleOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "PoolEnableAutoScaleOptions"
                }
            }
        }
    }
};
exports.PoolEvaluateAutoScaleOptionalParams = {
    serializedName: "EvaluateAutoScaleOptions",
    type: {
        name: "Composite",
        className: "PoolEvaluateAutoScaleOptionalParams",
        modelProperties: {
            poolEvaluateAutoScaleOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "PoolEvaluateAutoScaleOptions"
                }
            }
        }
    }
};
exports.PoolResizeOptionalParams = {
    serializedName: "ResizeOptions",
    type: {
        name: "Composite",
        className: "PoolResizeOptionalParams",
        modelProperties: {
            poolResizeOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "PoolResizeOptions"
                }
            }
        }
    }
};
exports.PoolStopResizeOptionalParams = {
    serializedName: "StopResizeOptions",
    type: {
        name: "Composite",
        className: "PoolStopResizeOptionalParams",
        modelProperties: {
            poolStopResizeOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "PoolStopResizeOptions"
                }
            }
        }
    }
};
exports.PoolUpdatePropertiesOptionalParams = {
    serializedName: "UpdatePropertiesOptions",
    type: {
        name: "Composite",
        className: "PoolUpdatePropertiesOptionalParams",
        modelProperties: {
            poolUpdatePropertiesOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "PoolUpdatePropertiesOptions"
                }
            }
        }
    }
};
exports.PoolUpgradeOSOptionalParams = {
    serializedName: "UpgradeOSOptions",
    type: {
        name: "Composite",
        className: "PoolUpgradeOSOptionalParams",
        modelProperties: {
            poolUpgradeOSOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "PoolUpgradeOSOptions"
                }
            }
        }
    }
};
exports.PoolRemoveNodesOptionalParams = {
    serializedName: "RemoveNodesOptions",
    type: {
        name: "Composite",
        className: "PoolRemoveNodesOptionalParams",
        modelProperties: {
            poolRemoveNodesOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "PoolRemoveNodesOptions"
                }
            }
        }
    }
};
exports.PoolListUsageMetricsNextOptionalParams = {
    serializedName: "ListUsageMetricsNextOptions",
    type: {
        name: "Composite",
        className: "PoolListUsageMetricsNextOptionalParams",
        modelProperties: {
            poolListUsageMetricsNextOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "PoolListUsageMetricsNextOptions"
                }
            }
        }
    }
};
exports.PoolListNextOptionalParams = {
    serializedName: "ListNextOptions",
    type: {
        name: "Composite",
        className: "PoolListNextOptionalParams",
        modelProperties: {
            poolListNextOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "PoolListNextOptions"
                }
            }
        }
    }
};
exports.AccountListNodeAgentSkusOptionalParams = {
    serializedName: "ListNodeAgentSkusOptions",
    type: {
        name: "Composite",
        className: "AccountListNodeAgentSkusOptionalParams",
        modelProperties: {
            accountListNodeAgentSkusOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "AccountListNodeAgentSkusOptions"
                }
            }
        }
    }
};
exports.AccountListPoolNodeCountsOptionalParams = {
    serializedName: "ListPoolNodeCountsOptions",
    type: {
        name: "Composite",
        className: "AccountListPoolNodeCountsOptionalParams",
        modelProperties: {
            accountListPoolNodeCountsOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "AccountListPoolNodeCountsOptions"
                }
            }
        }
    }
};
exports.AccountListNodeAgentSkusNextOptionalParams = {
    serializedName: "ListNodeAgentSkusNextOptions",
    type: {
        name: "Composite",
        className: "AccountListNodeAgentSkusNextOptionalParams",
        modelProperties: {
            accountListNodeAgentSkusNextOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "AccountListNodeAgentSkusNextOptions"
                }
            }
        }
    }
};
exports.AccountListPoolNodeCountsNextOptionalParams = {
    serializedName: "ListPoolNodeCountsNextOptions",
    type: {
        name: "Composite",
        className: "AccountListPoolNodeCountsNextOptionalParams",
        modelProperties: {
            accountListPoolNodeCountsNextOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "AccountListPoolNodeCountsNextOptions"
                }
            }
        }
    }
};
exports.JobGetAllLifetimeStatisticsOptionalParams = {
    serializedName: "GetAllLifetimeStatisticsOptions",
    type: {
        name: "Composite",
        className: "JobGetAllLifetimeStatisticsOptionalParams",
        modelProperties: {
            jobGetAllLifetimeStatisticsOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "JobGetAllLifetimeStatisticsOptions"
                }
            }
        }
    }
};
exports.JobDeleteMethodOptionalParams = {
    serializedName: "DeleteMethodOptions",
    type: {
        name: "Composite",
        className: "JobDeleteMethodOptionalParams",
        modelProperties: {
            jobDeleteMethodOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "JobDeleteMethodOptions"
                }
            }
        }
    }
};
exports.JobGetOptionalParams = {
    serializedName: "GetOptions",
    type: {
        name: "Composite",
        className: "JobGetOptionalParams",
        modelProperties: {
            jobGetOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "JobGetOptions"
                }
            }
        }
    }
};
exports.JobPatchOptionalParams = {
    serializedName: "PatchOptions",
    type: {
        name: "Composite",
        className: "JobPatchOptionalParams",
        modelProperties: {
            jobPatchOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "JobPatchOptions"
                }
            }
        }
    }
};
exports.JobUpdateOptionalParams = {
    serializedName: "UpdateOptions",
    type: {
        name: "Composite",
        className: "JobUpdateOptionalParams",
        modelProperties: {
            jobUpdateOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "JobUpdateOptions"
                }
            }
        }
    }
};
exports.JobDisableOptionalParams = {
    serializedName: "DisableOptions",
    type: {
        name: "Composite",
        className: "JobDisableOptionalParams",
        modelProperties: {
            jobDisableOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "JobDisableOptions"
                }
            }
        }
    }
};
exports.JobEnableOptionalParams = {
    serializedName: "EnableOptions",
    type: {
        name: "Composite",
        className: "JobEnableOptionalParams",
        modelProperties: {
            jobEnableOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "JobEnableOptions"
                }
            }
        }
    }
};
exports.JobTerminateOptionalParams = {
    serializedName: "TerminateOptions",
    type: {
        name: "Composite",
        className: "JobTerminateOptionalParams",
        modelProperties: {
            jobTerminateParameter: {
                serializedName: "jobTerminateParameter",
                type: {
                    name: "Composite",
                    className: "JobTerminateParameter"
                }
            },
            jobTerminateOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "JobTerminateOptions"
                }
            }
        }
    }
};
exports.JobAddOptionalParams = {
    serializedName: "AddOptions",
    type: {
        name: "Composite",
        className: "JobAddOptionalParams",
        modelProperties: {
            jobAddOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "JobAddOptions"
                }
            }
        }
    }
};
exports.JobListOptionalParams = {
    serializedName: "ListOptions",
    type: {
        name: "Composite",
        className: "JobListOptionalParams",
        modelProperties: {
            jobListOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "JobListOptions"
                }
            }
        }
    }
};
exports.JobListFromJobScheduleOptionalParams = {
    serializedName: "ListFromJobScheduleOptions",
    type: {
        name: "Composite",
        className: "JobListFromJobScheduleOptionalParams",
        modelProperties: {
            jobListFromJobScheduleOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "JobListFromJobScheduleOptions"
                }
            }
        }
    }
};
exports.JobListPreparationAndReleaseTaskStatusOptionalParams = {
    serializedName: "ListPreparationAndReleaseTaskStatusOptions",
    type: {
        name: "Composite",
        className: "JobListPreparationAndReleaseTaskStatusOptionalParams",
        modelProperties: {
            jobListPreparationAndReleaseTaskStatusOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "JobListPreparationAndReleaseTaskStatusOptions"
                }
            }
        }
    }
};
exports.JobGetTaskCountsOptionalParams = {
    serializedName: "GetTaskCountsOptions",
    type: {
        name: "Composite",
        className: "JobGetTaskCountsOptionalParams",
        modelProperties: {
            jobGetTaskCountsOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "JobGetTaskCountsOptions"
                }
            }
        }
    }
};
exports.JobListNextOptionalParams = {
    serializedName: "ListNextOptions",
    type: {
        name: "Composite",
        className: "JobListNextOptionalParams",
        modelProperties: {
            jobListNextOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "JobListNextOptions"
                }
            }
        }
    }
};
exports.JobListFromJobScheduleNextOptionalParams = {
    serializedName: "ListFromJobScheduleNextOptions",
    type: {
        name: "Composite",
        className: "JobListFromJobScheduleNextOptionalParams",
        modelProperties: {
            jobListFromJobScheduleNextOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "JobListFromJobScheduleNextOptions"
                }
            }
        }
    }
};
exports.JobListPreparationAndReleaseTaskStatusNextOptionalParams = {
    serializedName: "ListPreparationAndReleaseTaskStatusNextOptions",
    type: {
        name: "Composite",
        className: "JobListPreparationAndReleaseTaskStatusNextOptionalParams",
        modelProperties: {
            jobListPreparationAndReleaseTaskStatusNextOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "JobListPreparationAndReleaseTaskStatusNextOptions"
                }
            }
        }
    }
};
exports.CertificateAddOptionalParams = {
    serializedName: "AddOptions",
    type: {
        name: "Composite",
        className: "CertificateAddOptionalParams",
        modelProperties: {
            certificateAddOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "CertificateAddOptions"
                }
            }
        }
    }
};
exports.CertificateListOptionalParams = {
    serializedName: "ListOptions",
    type: {
        name: "Composite",
        className: "CertificateListOptionalParams",
        modelProperties: {
            certificateListOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "CertificateListOptions"
                }
            }
        }
    }
};
exports.CertificateCancelDeletionOptionalParams = {
    serializedName: "CancelDeletionOptions",
    type: {
        name: "Composite",
        className: "CertificateCancelDeletionOptionalParams",
        modelProperties: {
            certificateCancelDeletionOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "CertificateCancelDeletionOptions"
                }
            }
        }
    }
};
exports.CertificateDeleteMethodOptionalParams = {
    serializedName: "DeleteMethodOptions",
    type: {
        name: "Composite",
        className: "CertificateDeleteMethodOptionalParams",
        modelProperties: {
            certificateDeleteMethodOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "CertificateDeleteMethodOptions"
                }
            }
        }
    }
};
exports.CertificateGetOptionalParams = {
    serializedName: "GetOptions",
    type: {
        name: "Composite",
        className: "CertificateGetOptionalParams",
        modelProperties: {
            certificateGetOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "CertificateGetOptions"
                }
            }
        }
    }
};
exports.CertificateListNextOptionalParams = {
    serializedName: "ListNextOptions",
    type: {
        name: "Composite",
        className: "CertificateListNextOptionalParams",
        modelProperties: {
            certificateListNextOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "CertificateListNextOptions"
                }
            }
        }
    }
};
exports.FileDeleteFromTaskOptionalParams = {
    serializedName: "DeleteFromTaskOptions",
    type: {
        name: "Composite",
        className: "FileDeleteFromTaskOptionalParams",
        modelProperties: {
            recursive: {
                serializedName: "recursive",
                type: {
                    name: "Boolean"
                }
            },
            fileDeleteFromTaskOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "FileDeleteFromTaskOptions"
                }
            }
        }
    }
};
exports.FileGetFromTaskOptionalParams = {
    serializedName: "GetFromTaskOptions",
    type: {
        name: "Composite",
        className: "FileGetFromTaskOptionalParams",
        modelProperties: {
            fileGetFromTaskOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "FileGetFromTaskOptions"
                }
            }
        }
    }
};
exports.FileGetPropertiesFromTaskOptionalParams = {
    serializedName: "GetPropertiesFromTaskOptions",
    type: {
        name: "Composite",
        className: "FileGetPropertiesFromTaskOptionalParams",
        modelProperties: {
            fileGetPropertiesFromTaskOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "FileGetPropertiesFromTaskOptions"
                }
            }
        }
    }
};
exports.FileDeleteFromComputeNodeOptionalParams = {
    serializedName: "DeleteFromComputeNodeOptions",
    type: {
        name: "Composite",
        className: "FileDeleteFromComputeNodeOptionalParams",
        modelProperties: {
            recursive: {
                serializedName: "recursive",
                type: {
                    name: "Boolean"
                }
            },
            fileDeleteFromComputeNodeOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "FileDeleteFromComputeNodeOptions"
                }
            }
        }
    }
};
exports.FileGetFromComputeNodeOptionalParams = {
    serializedName: "GetFromComputeNodeOptions",
    type: {
        name: "Composite",
        className: "FileGetFromComputeNodeOptionalParams",
        modelProperties: {
            fileGetFromComputeNodeOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "FileGetFromComputeNodeOptions"
                }
            }
        }
    }
};
exports.FileGetPropertiesFromComputeNodeOptionalParams = {
    serializedName: "GetPropertiesFromComputeNodeOptions",
    type: {
        name: "Composite",
        className: "FileGetPropertiesFromComputeNodeOptionalParams",
        modelProperties: {
            fileGetPropertiesFromComputeNodeOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "FileGetPropertiesFromComputeNodeOptions"
                }
            }
        }
    }
};
exports.FileListFromTaskOptionalParams = {
    serializedName: "ListFromTaskOptions",
    type: {
        name: "Composite",
        className: "FileListFromTaskOptionalParams",
        modelProperties: {
            recursive: {
                serializedName: "recursive",
                type: {
                    name: "Boolean"
                }
            },
            fileListFromTaskOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "FileListFromTaskOptions"
                }
            }
        }
    }
};
exports.FileListFromComputeNodeOptionalParams = {
    serializedName: "ListFromComputeNodeOptions",
    type: {
        name: "Composite",
        className: "FileListFromComputeNodeOptionalParams",
        modelProperties: {
            recursive: {
                serializedName: "recursive",
                type: {
                    name: "Boolean"
                }
            },
            fileListFromComputeNodeOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "FileListFromComputeNodeOptions"
                }
            }
        }
    }
};
exports.FileListFromTaskNextOptionalParams = {
    serializedName: "ListFromTaskNextOptions",
    type: {
        name: "Composite",
        className: "FileListFromTaskNextOptionalParams",
        modelProperties: {
            fileListFromTaskNextOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "FileListFromTaskNextOptions"
                }
            }
        }
    }
};
exports.FileListFromComputeNodeNextOptionalParams = {
    serializedName: "ListFromComputeNodeNextOptions",
    type: {
        name: "Composite",
        className: "FileListFromComputeNodeNextOptionalParams",
        modelProperties: {
            fileListFromComputeNodeNextOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "FileListFromComputeNodeNextOptions"
                }
            }
        }
    }
};
exports.JobScheduleExistsOptionalParams = {
    serializedName: "ExistsOptions",
    type: {
        name: "Composite",
        className: "JobScheduleExistsOptionalParams",
        modelProperties: {
            jobScheduleExistsOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "JobScheduleExistsOptions"
                }
            }
        }
    }
};
exports.JobScheduleDeleteMethodOptionalParams = {
    serializedName: "DeleteMethodOptions",
    type: {
        name: "Composite",
        className: "JobScheduleDeleteMethodOptionalParams",
        modelProperties: {
            jobScheduleDeleteMethodOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "JobScheduleDeleteMethodOptions"
                }
            }
        }
    }
};
exports.JobScheduleGetOptionalParams = {
    serializedName: "GetOptions",
    type: {
        name: "Composite",
        className: "JobScheduleGetOptionalParams",
        modelProperties: {
            jobScheduleGetOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "JobScheduleGetOptions"
                }
            }
        }
    }
};
exports.JobSchedulePatchOptionalParams = {
    serializedName: "PatchOptions",
    type: {
        name: "Composite",
        className: "JobSchedulePatchOptionalParams",
        modelProperties: {
            jobSchedulePatchOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "JobSchedulePatchOptions"
                }
            }
        }
    }
};
exports.JobScheduleUpdateOptionalParams = {
    serializedName: "UpdateOptions",
    type: {
        name: "Composite",
        className: "JobScheduleUpdateOptionalParams",
        modelProperties: {
            jobScheduleUpdateOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "JobScheduleUpdateOptions"
                }
            }
        }
    }
};
exports.JobScheduleDisableOptionalParams = {
    serializedName: "DisableOptions",
    type: {
        name: "Composite",
        className: "JobScheduleDisableOptionalParams",
        modelProperties: {
            jobScheduleDisableOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "JobScheduleDisableOptions"
                }
            }
        }
    }
};
exports.JobScheduleEnableOptionalParams = {
    serializedName: "EnableOptions",
    type: {
        name: "Composite",
        className: "JobScheduleEnableOptionalParams",
        modelProperties: {
            jobScheduleEnableOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "JobScheduleEnableOptions"
                }
            }
        }
    }
};
exports.JobScheduleTerminateOptionalParams = {
    serializedName: "TerminateOptions",
    type: {
        name: "Composite",
        className: "JobScheduleTerminateOptionalParams",
        modelProperties: {
            jobScheduleTerminateOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "JobScheduleTerminateOptions"
                }
            }
        }
    }
};
exports.JobScheduleAddOptionalParams = {
    serializedName: "AddOptions",
    type: {
        name: "Composite",
        className: "JobScheduleAddOptionalParams",
        modelProperties: {
            jobScheduleAddOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "JobScheduleAddOptions"
                }
            }
        }
    }
};
exports.JobScheduleListOptionalParams = {
    serializedName: "ListOptions",
    type: {
        name: "Composite",
        className: "JobScheduleListOptionalParams",
        modelProperties: {
            jobScheduleListOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "JobScheduleListOptions"
                }
            }
        }
    }
};
exports.JobScheduleListNextOptionalParams = {
    serializedName: "ListNextOptions",
    type: {
        name: "Composite",
        className: "JobScheduleListNextOptionalParams",
        modelProperties: {
            jobScheduleListNextOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "JobScheduleListNextOptions"
                }
            }
        }
    }
};
exports.TaskAddOptionalParams = {
    serializedName: "AddOptions",
    type: {
        name: "Composite",
        className: "TaskAddOptionalParams",
        modelProperties: {
            taskAddOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "TaskAddOptions"
                }
            }
        }
    }
};
exports.TaskListOptionalParams = {
    serializedName: "ListOptions",
    type: {
        name: "Composite",
        className: "TaskListOptionalParams",
        modelProperties: {
            taskListOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "TaskListOptions"
                }
            }
        }
    }
};
exports.TaskAddCollectionOptionalParams = {
    serializedName: "AddCollectionOptions",
    type: {
        name: "Composite",
        className: "TaskAddCollectionOptionalParams",
        modelProperties: {
            taskAddCollectionOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "TaskAddCollectionOptions"
                }
            }
        }
    }
};
exports.TaskDeleteMethodOptionalParams = {
    serializedName: "DeleteMethodOptions",
    type: {
        name: "Composite",
        className: "TaskDeleteMethodOptionalParams",
        modelProperties: {
            taskDeleteMethodOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "TaskDeleteMethodOptions"
                }
            }
        }
    }
};
exports.TaskGetOptionalParams = {
    serializedName: "GetOptions",
    type: {
        name: "Composite",
        className: "TaskGetOptionalParams",
        modelProperties: {
            taskGetOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "TaskGetOptions"
                }
            }
        }
    }
};
exports.TaskUpdateOptionalParams = {
    serializedName: "UpdateOptions",
    type: {
        name: "Composite",
        className: "TaskUpdateOptionalParams",
        modelProperties: {
            taskUpdateOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "TaskUpdateOptions"
                }
            }
        }
    }
};
exports.TaskListSubtasksOptionalParams = {
    serializedName: "ListSubtasksOptions",
    type: {
        name: "Composite",
        className: "TaskListSubtasksOptionalParams",
        modelProperties: {
            taskListSubtasksOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "TaskListSubtasksOptions"
                }
            }
        }
    }
};
exports.TaskTerminateOptionalParams = {
    serializedName: "TerminateOptions",
    type: {
        name: "Composite",
        className: "TaskTerminateOptionalParams",
        modelProperties: {
            taskTerminateOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "TaskTerminateOptions"
                }
            }
        }
    }
};
exports.TaskReactivateOptionalParams = {
    serializedName: "ReactivateOptions",
    type: {
        name: "Composite",
        className: "TaskReactivateOptionalParams",
        modelProperties: {
            taskReactivateOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "TaskReactivateOptions"
                }
            }
        }
    }
};
exports.TaskListNextOptionalParams = {
    serializedName: "ListNextOptions",
    type: {
        name: "Composite",
        className: "TaskListNextOptionalParams",
        modelProperties: {
            taskListNextOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "TaskListNextOptions"
                }
            }
        }
    }
};
exports.ComputeNodeAddUserOptionalParams = {
    serializedName: "AddUserOptions",
    type: {
        name: "Composite",
        className: "ComputeNodeAddUserOptionalParams",
        modelProperties: {
            computeNodeAddUserOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "ComputeNodeAddUserOptions"
                }
            }
        }
    }
};
exports.ComputeNodeDeleteUserOptionalParams = {
    serializedName: "DeleteUserOptions",
    type: {
        name: "Composite",
        className: "ComputeNodeDeleteUserOptionalParams",
        modelProperties: {
            computeNodeDeleteUserOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "ComputeNodeDeleteUserOptions"
                }
            }
        }
    }
};
exports.ComputeNodeUpdateUserOptionalParams = {
    serializedName: "UpdateUserOptions",
    type: {
        name: "Composite",
        className: "ComputeNodeUpdateUserOptionalParams",
        modelProperties: {
            computeNodeUpdateUserOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "ComputeNodeUpdateUserOptions"
                }
            }
        }
    }
};
exports.ComputeNodeGetOptionalParams = {
    serializedName: "GetOptions",
    type: {
        name: "Composite",
        className: "ComputeNodeGetOptionalParams",
        modelProperties: {
            computeNodeGetOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "ComputeNodeGetOptions"
                }
            }
        }
    }
};
exports.ComputeNodeRebootOptionalParams = {
    serializedName: "RebootOptions",
    type: {
        name: "Composite",
        className: "ComputeNodeRebootOptionalParams",
        modelProperties: {
            nodeRebootParameter: {
                serializedName: "nodeRebootParameter",
                type: {
                    name: "Composite",
                    className: "NodeRebootParameter"
                }
            },
            computeNodeRebootOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "ComputeNodeRebootOptions"
                }
            }
        }
    }
};
exports.ComputeNodeReimageOptionalParams = {
    serializedName: "ReimageOptions",
    type: {
        name: "Composite",
        className: "ComputeNodeReimageOptionalParams",
        modelProperties: {
            nodeReimageParameter: {
                serializedName: "nodeReimageParameter",
                type: {
                    name: "Composite",
                    className: "NodeReimageParameter"
                }
            },
            computeNodeReimageOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "ComputeNodeReimageOptions"
                }
            }
        }
    }
};
exports.ComputeNodeDisableSchedulingOptionalParams = {
    serializedName: "DisableSchedulingOptions",
    type: {
        name: "Composite",
        className: "ComputeNodeDisableSchedulingOptionalParams",
        modelProperties: {
            nodeDisableSchedulingParameter: {
                serializedName: "nodeDisableSchedulingParameter",
                type: {
                    name: "Composite",
                    className: "NodeDisableSchedulingParameter"
                }
            },
            computeNodeDisableSchedulingOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "ComputeNodeDisableSchedulingOptions"
                }
            }
        }
    }
};
exports.ComputeNodeEnableSchedulingOptionalParams = {
    serializedName: "EnableSchedulingOptions",
    type: {
        name: "Composite",
        className: "ComputeNodeEnableSchedulingOptionalParams",
        modelProperties: {
            computeNodeEnableSchedulingOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "ComputeNodeEnableSchedulingOptions"
                }
            }
        }
    }
};
exports.ComputeNodeGetRemoteLoginSettingsOptionalParams = {
    serializedName: "GetRemoteLoginSettingsOptions",
    type: {
        name: "Composite",
        className: "ComputeNodeGetRemoteLoginSettingsOptionalParams",
        modelProperties: {
            computeNodeGetRemoteLoginSettingsOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "ComputeNodeGetRemoteLoginSettingsOptions"
                }
            }
        }
    }
};
exports.ComputeNodeGetRemoteDesktopOptionalParams = {
    serializedName: "GetRemoteDesktopOptions",
    type: {
        name: "Composite",
        className: "ComputeNodeGetRemoteDesktopOptionalParams",
        modelProperties: {
            computeNodeGetRemoteDesktopOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "ComputeNodeGetRemoteDesktopOptions"
                }
            }
        }
    }
};
exports.ComputeNodeUploadBatchServiceLogsOptionalParams = {
    serializedName: "UploadBatchServiceLogsOptions",
    type: {
        name: "Composite",
        className: "ComputeNodeUploadBatchServiceLogsOptionalParams",
        modelProperties: {
            computeNodeUploadBatchServiceLogsOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "ComputeNodeUploadBatchServiceLogsOptions"
                }
            }
        }
    }
};
exports.ComputeNodeListOptionalParams = {
    serializedName: "ListOptions",
    type: {
        name: "Composite",
        className: "ComputeNodeListOptionalParams",
        modelProperties: {
            computeNodeListOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "ComputeNodeListOptions"
                }
            }
        }
    }
};
exports.ComputeNodeListNextOptionalParams = {
    serializedName: "ListNextOptions",
    type: {
        name: "Composite",
        className: "ComputeNodeListNextOptionalParams",
        modelProperties: {
            computeNodeListNextOptions: {
                serializedName: "",
                type: {
                    name: "Composite",
                    className: "ComputeNodeListNextOptions"
                }
            }
        }
    }
};
exports.ApplicationListHeaders = {
    serializedName: "application-list-headers",
    type: {
        name: "Composite",
        className: "ApplicationListHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.ApplicationGetHeaders = {
    serializedName: "application-get-headers",
    type: {
        name: "Composite",
        className: "ApplicationGetHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.PoolListUsageMetricsHeaders = {
    serializedName: "pool-listusagemetrics-headers",
    type: {
        name: "Composite",
        className: "PoolListUsageMetricsHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.AccountListNodeAgentSkusHeaders = {
    serializedName: "account-listnodeagentskus-headers",
    type: {
        name: "Composite",
        className: "AccountListNodeAgentSkusHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.AccountListPoolNodeCountsHeaders = {
    serializedName: "account-listpoolnodecounts-headers",
    type: {
        name: "Composite",
        className: "AccountListPoolNodeCountsHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            }
        }
    }
};
exports.PoolGetAllLifetimeStatisticsHeaders = {
    serializedName: "pool-getalllifetimestatistics-headers",
    type: {
        name: "Composite",
        className: "PoolGetAllLifetimeStatisticsHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobGetAllLifetimeStatisticsHeaders = {
    serializedName: "job-getalllifetimestatistics-headers",
    type: {
        name: "Composite",
        className: "JobGetAllLifetimeStatisticsHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.CertificateAddHeaders = {
    serializedName: "certificate-add-headers",
    type: {
        name: "Composite",
        className: "CertificateAddHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CertificateListHeaders = {
    serializedName: "certificate-list-headers",
    type: {
        name: "Composite",
        className: "CertificateListHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.CertificateCancelDeletionHeaders = {
    serializedName: "certificate-canceldeletion-headers",
    type: {
        name: "Composite",
        className: "CertificateCancelDeletionHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CertificateDeleteHeaders = {
    serializedName: "certificate-delete-headers",
    type: {
        name: "Composite",
        className: "CertificateDeleteHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.CertificateGetHeaders = {
    serializedName: "certificate-get-headers",
    type: {
        name: "Composite",
        className: "CertificateGetHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.FileDeleteFromTaskHeaders = {
    serializedName: "file-deletefromtask-headers",
    type: {
        name: "Composite",
        className: "FileDeleteFromTaskHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.FileGetFromTaskHeaders = {
    serializedName: "file-getfromtask-headers",
    type: {
        name: "Composite",
        className: "FileGetFromTaskHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ocpCreationTime: {
                serializedName: "ocp-creation-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ocpBatchFileIsdirectory: {
                serializedName: "ocp-batch-file-isdirectory",
                type: {
                    name: "Boolean"
                }
            },
            ocpBatchFileUrl: {
                serializedName: "ocp-batch-file-url",
                type: {
                    name: "String"
                }
            },
            ocpBatchFileMode: {
                serializedName: "ocp-batch-file-mode",
                type: {
                    name: "String"
                }
            },
            contentType: {
                serializedName: "content-type",
                type: {
                    name: "String"
                }
            },
            contentLength: {
                serializedName: "content-length",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
exports.FileGetPropertiesFromTaskHeaders = {
    serializedName: "file-getpropertiesfromtask-headers",
    type: {
        name: "Composite",
        className: "FileGetPropertiesFromTaskHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ocpCreationTime: {
                serializedName: "ocp-creation-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ocpBatchFileIsdirectory: {
                serializedName: "ocp-batch-file-isdirectory",
                type: {
                    name: "Boolean"
                }
            },
            ocpBatchFileUrl: {
                serializedName: "ocp-batch-file-url",
                type: {
                    name: "String"
                }
            },
            ocpBatchFileMode: {
                serializedName: "ocp-batch-file-mode",
                type: {
                    name: "String"
                }
            },
            contentType: {
                serializedName: "content-type",
                type: {
                    name: "String"
                }
            },
            contentLength: {
                serializedName: "content-length",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
exports.FileDeleteFromComputeNodeHeaders = {
    serializedName: "file-deletefromcomputenode-headers",
    type: {
        name: "Composite",
        className: "FileDeleteFromComputeNodeHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.FileGetFromComputeNodeHeaders = {
    serializedName: "file-getfromcomputenode-headers",
    type: {
        name: "Composite",
        className: "FileGetFromComputeNodeHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ocpCreationTime: {
                serializedName: "ocp-creation-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ocpBatchFileIsdirectory: {
                serializedName: "ocp-batch-file-isdirectory",
                type: {
                    name: "Boolean"
                }
            },
            ocpBatchFileUrl: {
                serializedName: "ocp-batch-file-url",
                type: {
                    name: "String"
                }
            },
            ocpBatchFileMode: {
                serializedName: "ocp-batch-file-mode",
                type: {
                    name: "String"
                }
            },
            contentType: {
                serializedName: "content-type",
                type: {
                    name: "String"
                }
            },
            contentLength: {
                serializedName: "content-length",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
exports.FileGetPropertiesFromComputeNodeHeaders = {
    serializedName: "file-getpropertiesfromcomputenode-headers",
    type: {
        name: "Composite",
        className: "FileGetPropertiesFromComputeNodeHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ocpCreationTime: {
                serializedName: "ocp-creation-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            ocpBatchFileIsdirectory: {
                serializedName: "ocp-batch-file-isdirectory",
                type: {
                    name: "Boolean"
                }
            },
            ocpBatchFileUrl: {
                serializedName: "ocp-batch-file-url",
                type: {
                    name: "String"
                }
            },
            ocpBatchFileMode: {
                serializedName: "ocp-batch-file-mode",
                type: {
                    name: "String"
                }
            },
            contentType: {
                serializedName: "content-type",
                type: {
                    name: "String"
                }
            },
            contentLength: {
                serializedName: "content-length",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
exports.FileListFromTaskHeaders = {
    serializedName: "file-listfromtask-headers",
    type: {
        name: "Composite",
        className: "FileListFromTaskHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.FileListFromComputeNodeHeaders = {
    serializedName: "file-listfromcomputenode-headers",
    type: {
        name: "Composite",
        className: "FileListFromComputeNodeHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobScheduleExistsHeaders = {
    serializedName: "jobschedule-exists-headers",
    type: {
        name: "Composite",
        className: "JobScheduleExistsHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobScheduleDeleteHeaders = {
    serializedName: "jobschedule-delete-headers",
    type: {
        name: "Composite",
        className: "JobScheduleDeleteHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.JobScheduleGetHeaders = {
    serializedName: "jobschedule-get-headers",
    type: {
        name: "Composite",
        className: "JobScheduleGetHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobSchedulePatchHeaders = {
    serializedName: "jobschedule-patch-headers",
    type: {
        name: "Composite",
        className: "JobSchedulePatchHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.JobScheduleUpdateHeaders = {
    serializedName: "jobschedule-update-headers",
    type: {
        name: "Composite",
        className: "JobScheduleUpdateHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.JobScheduleDisableHeaders = {
    serializedName: "jobschedule-disable-headers",
    type: {
        name: "Composite",
        className: "JobScheduleDisableHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.JobScheduleEnableHeaders = {
    serializedName: "jobschedule-enable-headers",
    type: {
        name: "Composite",
        className: "JobScheduleEnableHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.JobScheduleTerminateHeaders = {
    serializedName: "jobschedule-terminate-headers",
    type: {
        name: "Composite",
        className: "JobScheduleTerminateHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.JobScheduleAddHeaders = {
    serializedName: "jobschedule-add-headers",
    type: {
        name: "Composite",
        className: "JobScheduleAddHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.JobScheduleListHeaders = {
    serializedName: "jobschedule-list-headers",
    type: {
        name: "Composite",
        className: "JobScheduleListHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobDeleteHeaders = {
    serializedName: "job-delete-headers",
    type: {
        name: "Composite",
        className: "JobDeleteHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.JobGetHeaders = {
    serializedName: "job-get-headers",
    type: {
        name: "Composite",
        className: "JobGetHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobPatchHeaders = {
    serializedName: "job-patch-headers",
    type: {
        name: "Composite",
        className: "JobPatchHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.JobUpdateHeaders = {
    serializedName: "job-update-headers",
    type: {
        name: "Composite",
        className: "JobUpdateHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.JobDisableHeaders = {
    serializedName: "job-disable-headers",
    type: {
        name: "Composite",
        className: "JobDisableHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.JobEnableHeaders = {
    serializedName: "job-enable-headers",
    type: {
        name: "Composite",
        className: "JobEnableHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.JobTerminateHeaders = {
    serializedName: "job-terminate-headers",
    type: {
        name: "Composite",
        className: "JobTerminateHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.JobAddHeaders = {
    serializedName: "job-add-headers",
    type: {
        name: "Composite",
        className: "JobAddHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.JobListHeaders = {
    serializedName: "job-list-headers",
    type: {
        name: "Composite",
        className: "JobListHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobListFromJobScheduleHeaders = {
    serializedName: "job-listfromjobschedule-headers",
    type: {
        name: "Composite",
        className: "JobListFromJobScheduleHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobListPreparationAndReleaseTaskStatusHeaders = {
    serializedName: "job-listpreparationandreleasetaskstatus-headers",
    type: {
        name: "Composite",
        className: "JobListPreparationAndReleaseTaskStatusHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.JobGetTaskCountsHeaders = {
    serializedName: "job-gettaskcounts-headers",
    type: {
        name: "Composite",
        className: "JobGetTaskCountsHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            }
        }
    }
};
exports.PoolAddHeaders = {
    serializedName: "pool-add-headers",
    type: {
        name: "Composite",
        className: "PoolAddHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.PoolListHeaders = {
    serializedName: "pool-list-headers",
    type: {
        name: "Composite",
        className: "PoolListHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.PoolDeleteHeaders = {
    serializedName: "pool-delete-headers",
    type: {
        name: "Composite",
        className: "PoolDeleteHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.PoolExistsHeaders = {
    serializedName: "pool-exists-headers",
    type: {
        name: "Composite",
        className: "PoolExistsHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.PoolGetHeaders = {
    serializedName: "pool-get-headers",
    type: {
        name: "Composite",
        className: "PoolGetHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.PoolPatchHeaders = {
    serializedName: "pool-patch-headers",
    type: {
        name: "Composite",
        className: "PoolPatchHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.PoolDisableAutoScaleHeaders = {
    serializedName: "pool-disableautoscale-headers",
    type: {
        name: "Composite",
        className: "PoolDisableAutoScaleHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.PoolEnableAutoScaleHeaders = {
    serializedName: "pool-enableautoscale-headers",
    type: {
        name: "Composite",
        className: "PoolEnableAutoScaleHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.PoolEvaluateAutoScaleHeaders = {
    serializedName: "pool-evaluateautoscale-headers",
    type: {
        name: "Composite",
        className: "PoolEvaluateAutoScaleHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.PoolResizeHeaders = {
    serializedName: "pool-resize-headers",
    type: {
        name: "Composite",
        className: "PoolResizeHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.PoolStopResizeHeaders = {
    serializedName: "pool-stopresize-headers",
    type: {
        name: "Composite",
        className: "PoolStopResizeHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.PoolUpdatePropertiesHeaders = {
    serializedName: "pool-updateproperties-headers",
    type: {
        name: "Composite",
        className: "PoolUpdatePropertiesHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.PoolUpgradeOSHeaders = {
    serializedName: "pool-upgradeos-headers",
    type: {
        name: "Composite",
        className: "PoolUpgradeOSHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.PoolRemoveNodesHeaders = {
    serializedName: "pool-removenodes-headers",
    type: {
        name: "Composite",
        className: "PoolRemoveNodesHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.TaskAddHeaders = {
    serializedName: "task-add-headers",
    type: {
        name: "Composite",
        className: "TaskAddHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.TaskListHeaders = {
    serializedName: "task-list-headers",
    type: {
        name: "Composite",
        className: "TaskListHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.TaskAddCollectionHeaders = {
    serializedName: "task-addcollection-headers",
    type: {
        name: "Composite",
        className: "TaskAddCollectionHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.TaskDeleteHeaders = {
    serializedName: "task-delete-headers",
    type: {
        name: "Composite",
        className: "TaskDeleteHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.TaskGetHeaders = {
    serializedName: "task-get-headers",
    type: {
        name: "Composite",
        className: "TaskGetHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.TaskUpdateHeaders = {
    serializedName: "task-update-headers",
    type: {
        name: "Composite",
        className: "TaskUpdateHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.TaskListSubtasksHeaders = {
    serializedName: "task-listsubtasks-headers",
    type: {
        name: "Composite",
        className: "TaskListSubtasksHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.TaskTerminateHeaders = {
    serializedName: "task-terminate-headers",
    type: {
        name: "Composite",
        className: "TaskTerminateHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.TaskReactivateHeaders = {
    serializedName: "task-reactivate-headers",
    type: {
        name: "Composite",
        className: "TaskReactivateHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.ComputeNodeAddUserHeaders = {
    serializedName: "computenode-adduser-headers",
    type: {
        name: "Composite",
        className: "ComputeNodeAddUserHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.ComputeNodeDeleteUserHeaders = {
    serializedName: "computenode-deleteuser-headers",
    type: {
        name: "Composite",
        className: "ComputeNodeDeleteUserHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.ComputeNodeUpdateUserHeaders = {
    serializedName: "computenode-updateuser-headers",
    type: {
        name: "Composite",
        className: "ComputeNodeUpdateUserHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.ComputeNodeGetHeaders = {
    serializedName: "computenode-get-headers",
    type: {
        name: "Composite",
        className: "ComputeNodeGetHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.ComputeNodeRebootHeaders = {
    serializedName: "computenode-reboot-headers",
    type: {
        name: "Composite",
        className: "ComputeNodeRebootHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.ComputeNodeReimageHeaders = {
    serializedName: "computenode-reimage-headers",
    type: {
        name: "Composite",
        className: "ComputeNodeReimageHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.ComputeNodeDisableSchedulingHeaders = {
    serializedName: "computenode-disablescheduling-headers",
    type: {
        name: "Composite",
        className: "ComputeNodeDisableSchedulingHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.ComputeNodeEnableSchedulingHeaders = {
    serializedName: "computenode-enablescheduling-headers",
    type: {
        name: "Composite",
        className: "ComputeNodeEnableSchedulingHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            dataServiceId: {
                serializedName: "dataserviceid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.ComputeNodeGetRemoteLoginSettingsHeaders = {
    serializedName: "computenode-getremoteloginsettings-headers",
    type: {
        name: "Composite",
        className: "ComputeNodeGetRemoteLoginSettingsHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.ComputeNodeGetRemoteDesktopHeaders = {
    serializedName: "computenode-getremotedesktop-headers",
    type: {
        name: "Composite",
        className: "ComputeNodeGetRemoteDesktopHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.ComputeNodeUploadBatchServiceLogsHeaders = {
    serializedName: "computenode-uploadbatchservicelogs-headers",
    type: {
        name: "Composite",
        className: "ComputeNodeUploadBatchServiceLogsHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            }
        }
    }
};
exports.ComputeNodeListHeaders = {
    serializedName: "computenode-list-headers",
    type: {
        name: "Composite",
        className: "ComputeNodeListHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "client-request-id",
                type: {
                    name: "Uuid"
                }
            },
            requestId: {
                serializedName: "request-id",
                type: {
                    name: "Uuid"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
exports.ApplicationListResult = {
    serializedName: "ApplicationListResult",
    type: {
        name: "Composite",
        className: "ApplicationListResult",
        modelProperties: {
            value: {
                serializedName: "",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ApplicationSummaryElementType",
                        type: {
                            name: "Composite",
                            className: "ApplicationSummary"
                        }
                    }
                }
            },
            odatanextLink: {
                serializedName: "odata\\.nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.PoolListUsageMetricsResult = {
    serializedName: "PoolListUsageMetricsResult",
    type: {
        name: "Composite",
        className: "PoolListUsageMetricsResult",
        modelProperties: {
            value: {
                serializedName: "",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "PoolUsageMetricsElementType",
                        type: {
                            name: "Composite",
                            className: "PoolUsageMetrics"
                        }
                    }
                }
            },
            odatanextLink: {
                serializedName: "odata\\.nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CloudPoolListResult = {
    serializedName: "CloudPoolListResult",
    type: {
        name: "Composite",
        className: "CloudPoolListResult",
        modelProperties: {
            value: {
                serializedName: "",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "CloudPoolElementType",
                        type: {
                            name: "Composite",
                            className: "CloudPool"
                        }
                    }
                }
            },
            odatanextLink: {
                serializedName: "odata\\.nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.AccountListNodeAgentSkusResult = {
    serializedName: "AccountListNodeAgentSkusResult",
    type: {
        name: "Composite",
        className: "AccountListNodeAgentSkusResult",
        modelProperties: {
            value: {
                serializedName: "",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "NodeAgentSkuElementType",
                        type: {
                            name: "Composite",
                            className: "NodeAgentSku"
                        }
                    }
                }
            },
            odatanextLink: {
                serializedName: "odata\\.nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.PoolNodeCountsListResult = {
    serializedName: "PoolNodeCountsListResult",
    type: {
        name: "Composite",
        className: "PoolNodeCountsListResult",
        modelProperties: {
            value: {
                serializedName: "",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "PoolNodeCountsElementType",
                        type: {
                            name: "Composite",
                            className: "PoolNodeCounts"
                        }
                    }
                }
            },
            odatanextLink: {
                serializedName: "odata\\.nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CloudJobListResult = {
    serializedName: "CloudJobListResult",
    type: {
        name: "Composite",
        className: "CloudJobListResult",
        modelProperties: {
            value: {
                serializedName: "",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "CloudJobElementType",
                        type: {
                            name: "Composite",
                            className: "CloudJob"
                        }
                    }
                }
            },
            odatanextLink: {
                serializedName: "odata\\.nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CloudJobListPreparationAndReleaseTaskStatusResult = {
    serializedName: "CloudJobListPreparationAndReleaseTaskStatusResult",
    type: {
        name: "Composite",
        className: "CloudJobListPreparationAndReleaseTaskStatusResult",
        modelProperties: {
            value: {
                serializedName: "",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "JobPreparationAndReleaseTaskExecutionInformationElementType",
                        type: {
                            name: "Composite",
                            className: "JobPreparationAndReleaseTaskExecutionInformation"
                        }
                    }
                }
            },
            odatanextLink: {
                serializedName: "odata\\.nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CertificateListResult = {
    serializedName: "CertificateListResult",
    type: {
        name: "Composite",
        className: "CertificateListResult",
        modelProperties: {
            value: {
                serializedName: "",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "CertificateElementType",
                        type: {
                            name: "Composite",
                            className: "Certificate"
                        }
                    }
                }
            },
            odatanextLink: {
                serializedName: "odata\\.nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.NodeFileListResult = {
    serializedName: "NodeFileListResult",
    type: {
        name: "Composite",
        className: "NodeFileListResult",
        modelProperties: {
            value: {
                serializedName: "",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "NodeFileElementType",
                        type: {
                            name: "Composite",
                            className: "NodeFile"
                        }
                    }
                }
            },
            odatanextLink: {
                serializedName: "odata\\.nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CloudJobScheduleListResult = {
    serializedName: "CloudJobScheduleListResult",
    type: {
        name: "Composite",
        className: "CloudJobScheduleListResult",
        modelProperties: {
            value: {
                serializedName: "",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "CloudJobScheduleElementType",
                        type: {
                            name: "Composite",
                            className: "CloudJobSchedule"
                        }
                    }
                }
            },
            odatanextLink: {
                serializedName: "odata\\.nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CloudTaskListResult = {
    serializedName: "CloudTaskListResult",
    type: {
        name: "Composite",
        className: "CloudTaskListResult",
        modelProperties: {
            value: {
                serializedName: "",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "CloudTaskElementType",
                        type: {
                            name: "Composite",
                            className: "CloudTask"
                        }
                    }
                }
            },
            odatanextLink: {
                serializedName: "odata\\.nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.ComputeNodeListResult = {
    serializedName: "ComputeNodeListResult",
    type: {
        name: "Composite",
        className: "ComputeNodeListResult",
        modelProperties: {
            value: {
                serializedName: "",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ComputeNodeElementType",
                        type: {
                            name: "Composite",
                            className: "ComputeNode"
                        }
                    }
                }
            },
            odatanextLink: {
                serializedName: "odata\\.nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};


/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = msRest;

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["__extends"] = __extends;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (immutable) */ __webpack_exports__["__rest"] = __rest;
/* harmony export (immutable) */ __webpack_exports__["__decorate"] = __decorate;
/* harmony export (immutable) */ __webpack_exports__["__param"] = __param;
/* harmony export (immutable) */ __webpack_exports__["__metadata"] = __metadata;
/* harmony export (immutable) */ __webpack_exports__["__awaiter"] = __awaiter;
/* harmony export (immutable) */ __webpack_exports__["__generator"] = __generator;
/* harmony export (immutable) */ __webpack_exports__["__exportStar"] = __exportStar;
/* harmony export (immutable) */ __webpack_exports__["__values"] = __values;
/* harmony export (immutable) */ __webpack_exports__["__read"] = __read;
/* harmony export (immutable) */ __webpack_exports__["__spread"] = __spread;
/* harmony export (immutable) */ __webpack_exports__["__await"] = __await;
/* harmony export (immutable) */ __webpack_exports__["__asyncGenerator"] = __asyncGenerator;
/* harmony export (immutable) */ __webpack_exports__["__asyncDelegator"] = __asyncDelegator;
/* harmony export (immutable) */ __webpack_exports__["__asyncValues"] = __asyncValues;
/* harmony export (immutable) */ __webpack_exports__["__makeTemplateObject"] = __makeTemplateObject;
/* harmony export (immutable) */ __webpack_exports__["__importStar"] = __importStar;
/* harmony export (immutable) */ __webpack_exports__["__importDefault"] = __importDefault;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __exportStar(m, exports) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; }; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator];
    return m ? m.call(o) : typeof __values === "function" ? __values(o) : o[Symbol.iterator]();
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}


/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = msRestAzure;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Models = __webpack_require__(5);
exports.BatchServiceModels = Models;
const Mappers = __webpack_require__(0);
exports.BatchServiceMappers = Mappers;
const batchServiceClientContext_1 = __webpack_require__(6);
const operations = __webpack_require__(7);
class BatchServiceClient extends batchServiceClientContext_1.BatchServiceClientContext {
    /**
     * @class
     * Initializes a new instance of the BatchServiceClient class.
     * @constructor
     *
     * @param {msRest.ServiceClientCredentials} credentials - Credentials needed for the client to connect to Azure.
     *
     * @param {string} [baseUri] - The base URI of the service.
     *
     * @param {object} [options] - The parameter options
     *
     * @param {Array} [options.filters] - Filters to be added to the request pipeline
     *
     * @param {object} [options.requestOptions] - The request options. Detailed info can be found at
     * {@link https://github.github.io/fetch/#Request Options doc}
     *
     * @param {boolean} [options.noRetryPolicy] - If set to true, turn off default retry policy
     *
     * @param {string} [options.acceptLanguage] - The preferred language for the response.
     *
     * @param {number} [options.longRunningOperationRetryTimeout] - The retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @param {boolean} [options.generateClientRequestId] - Whether a unique x-ms-client-request-id should be generated. When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     */
    constructor(credentials, baseUri, options) {
        super(credentials, baseUri, options);
        this.application = new operations.Application(this);
        this.pool = new operations.Pool(this);
        this.account = new operations.Account(this);
        this.job = new operations.Job(this);
        this.certificate = new operations.CertificateOperations(this);
        this.file = new operations.File(this);
        this.jobSchedule = new operations.JobSchedule(this);
        this.task = new operations.Task(this);
        this.computeNode = new operations.ComputeNodeOperations(this);
    }
}
exports.BatchServiceClient = BatchServiceClient;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Defines values for OSType.
 * Possible values include: 'linux', 'windows'
 * @readonly
 * @enum {string}
 */
var OSType;
(function (OSType) {
    /**
     * The Linux operating system.
     */
    OSType["Linux"] = "linux";
    /**
     * The Windows operating system.
     */
    OSType["Windows"] = "windows";
})(OSType = exports.OSType || (exports.OSType = {}));
/**
 * Defines values for AccessScope.
 * Possible values include: 'job'
 * @readonly
 * @enum {string}
 */
var AccessScope;
(function (AccessScope) {
    /**
     * Grants access to perform all operations on the job containing the task.
     */
    AccessScope["Job"] = "job";
})(AccessScope = exports.AccessScope || (exports.AccessScope = {}));
/**
 * Defines values for CertificateState.
 * Possible values include: 'active', 'deleting', 'deleteFailed'
 * @readonly
 * @enum {string}
 */
var CertificateState;
(function (CertificateState) {
    /**
     * The certificate is available for use in pools.
     */
    CertificateState["Active"] = "active";
    /**
     * The user has requested that the certificate be deleted, but the delete
     * operation has not yet completed. You may not reference the certificate
     * when creating or updating pools.
     */
    CertificateState["Deleting"] = "deleting";
    /**
     * The user requested that the certificate be deleted, but there are pools
     * that still have references to the certificate, or it is still installed on
     * one or more compute nodes. (The latter can occur if the certificate has
     * been removed from the pool, but the node has not yet restarted. Nodes
     * refresh their certificates only when they restart.) You may use the cancel
     * certificate delete operation to cancel the delete, or the delete
     * certificate operation to retry the delete.
     */
    CertificateState["DeleteFailed"] = "deletefailed";
})(CertificateState = exports.CertificateState || (exports.CertificateState = {}));
/**
 * Defines values for CertificateFormat.
 * Possible values include: 'pfx', 'cer'
 * @readonly
 * @enum {string}
 */
var CertificateFormat;
(function (CertificateFormat) {
    /**
     * The certificate is a PFX (PKCS#12) formatted certificate or certificate
     * chain.
     */
    CertificateFormat["Pfx"] = "pfx";
    /**
     * The certificate is a base64-encoded X.509 certificate.
     */
    CertificateFormat["Cer"] = "cer";
})(CertificateFormat = exports.CertificateFormat || (exports.CertificateFormat = {}));
/**
 * Defines values for JobAction.
 * Possible values include: 'none', 'disable', 'terminate'
 * @readonly
 * @enum {string}
 */
var JobAction;
(function (JobAction) {
    /**
     * Take no action.
     */
    JobAction["None"] = "none";
    /**
     * Disable the job. This is equivalent to calling the disable job API, with a
     * disableTasks value of requeue.
     */
    JobAction["Disable"] = "disable";
    /**
     * Terminate the job. The terminateReason in the job's executionInfo is set
     * to "TaskFailed".
     */
    JobAction["Terminate"] = "terminate";
})(JobAction = exports.JobAction || (exports.JobAction = {}));
/**
 * Defines values for DependencyAction.
 * Possible values include: 'satisfy', 'block'
 * @readonly
 * @enum {string}
 */
var DependencyAction;
(function (DependencyAction) {
    /**
     * Satisfy the task's dependencies.
     */
    DependencyAction["Satisfy"] = "satisfy";
    /**
     * Block the task's dependencies.
     */
    DependencyAction["Block"] = "block";
})(DependencyAction = exports.DependencyAction || (exports.DependencyAction = {}));
/**
 * Defines values for AutoUserScope.
 * Possible values include: 'task', 'pool'
 * @readonly
 * @enum {string}
 */
var AutoUserScope;
(function (AutoUserScope) {
    /**
     * Specifies that the service should create a new user for the task.
     */
    AutoUserScope["Task"] = "task";
    /**
     * Specifies that the task runs as the common auto user account which is
     * created on every node in a pool.
     */
    AutoUserScope["Pool"] = "pool";
})(AutoUserScope = exports.AutoUserScope || (exports.AutoUserScope = {}));
/**
 * Defines values for ElevationLevel.
 * Possible values include: 'nonAdmin', 'admin'
 * @readonly
 * @enum {string}
 */
var ElevationLevel;
(function (ElevationLevel) {
    /**
     * The user is a standard user without elevated access.
     */
    ElevationLevel["NonAdmin"] = "nonadmin";
    /**
     * The user is a user with elevated access and operates with full
     * Administrator permissions.
     */
    ElevationLevel["Admin"] = "admin";
})(ElevationLevel = exports.ElevationLevel || (exports.ElevationLevel = {}));
/**
 * Defines values for OutputFileUploadCondition.
 * Possible values include: 'taskSuccess', 'taskFailure', 'taskCompletion'
 * @readonly
 * @enum {string}
 */
var OutputFileUploadCondition;
(function (OutputFileUploadCondition) {
    /**
     * Upload the file(s) only after the task process exits with an exit code of
     * 0.
     */
    OutputFileUploadCondition["TaskSuccess"] = "tasksuccess";
    /**
     * Upload the file(s) only after the task process exits with a nonzero exit
     * code.
     */
    OutputFileUploadCondition["TaskFailure"] = "taskfailure";
    /**
     * Upload the file(s) after the task process exits, no matter what the exit
     * code was.
     */
    OutputFileUploadCondition["TaskCompletion"] = "taskcompletion";
})(OutputFileUploadCondition = exports.OutputFileUploadCondition || (exports.OutputFileUploadCondition = {}));
/**
 * Defines values for ComputeNodeFillType.
 * Possible values include: 'spread', 'pack'
 * @readonly
 * @enum {string}
 */
var ComputeNodeFillType;
(function (ComputeNodeFillType) {
    /**
     * Tasks should be assigned evenly across all nodes in the pool.
     */
    ComputeNodeFillType["Spread"] = "spread";
    /**
     * As many tasks as possible (maxTasksPerNode) should be assigned to each
     * node in the pool before any tasks are assigned to the next node in the
     * pool.
     */
    ComputeNodeFillType["Pack"] = "pack";
})(ComputeNodeFillType = exports.ComputeNodeFillType || (exports.ComputeNodeFillType = {}));
/**
 * Defines values for CertificateStoreLocation.
 * Possible values include: 'currentUser', 'localMachine'
 * @readonly
 * @enum {string}
 */
var CertificateStoreLocation;
(function (CertificateStoreLocation) {
    /**
     * Certificates should be installed to the CurrentUser certificate store.
     */
    CertificateStoreLocation["CurrentUser"] = "currentuser";
    /**
     * Certificates should be installed to the LocalMachine certificate store.
     */
    CertificateStoreLocation["LocalMachine"] = "localmachine";
})(CertificateStoreLocation = exports.CertificateStoreLocation || (exports.CertificateStoreLocation = {}));
/**
 * Defines values for CertificateVisibility.
 * Possible values include: 'startTask', 'task', 'remoteUser'
 * @readonly
 * @enum {string}
 */
var CertificateVisibility;
(function (CertificateVisibility) {
    /**
     * The certificate should be visible to the user account under which the
     * start task is run.
     */
    CertificateVisibility["StartTask"] = "starttask";
    /**
     * The certificate should be visibile to the user accounts under which job
     * tasks are run.
     */
    CertificateVisibility["Task"] = "task";
    /**
     * The certificate should be visibile to the user accounts under which users
     * remotely access the node.
     */
    CertificateVisibility["RemoteUser"] = "remoteuser";
})(CertificateVisibility = exports.CertificateVisibility || (exports.CertificateVisibility = {}));
/**
 * Defines values for CachingType.
 * Possible values include: 'none', 'readOnly', 'readWrite'
 * @readonly
 * @enum {string}
 */
var CachingType;
(function (CachingType) {
    /**
     * The caching mode for the disk is not enabled.
     */
    CachingType["None"] = "none";
    /**
     * The caching mode for the disk is read only.
     */
    CachingType["ReadOnly"] = "readonly";
    /**
     * The caching mode for the disk is read and write.
     */
    CachingType["ReadWrite"] = "readwrite";
})(CachingType = exports.CachingType || (exports.CachingType = {}));
/**
 * Defines values for StorageAccountType.
 * Possible values include: 'StandardLRS', 'PremiumLRS'
 * @readonly
 * @enum {string}
 */
var StorageAccountType;
(function (StorageAccountType) {
    /**
     * The data disk should use standard locally redundant storage.
     */
    StorageAccountType["StandardLRS"] = "standard_lrs";
    /**
     * The data disk should use premium locally redundant storage.
     */
    StorageAccountType["PremiumLRS"] = "premium_lrs";
})(StorageAccountType = exports.StorageAccountType || (exports.StorageAccountType = {}));
/**
 * Defines values for InboundEndpointProtocol.
 * Possible values include: 'tcp', 'udp'
 * @readonly
 * @enum {string}
 */
var InboundEndpointProtocol;
(function (InboundEndpointProtocol) {
    /**
     * Use TCP for the endpoint.
     */
    InboundEndpointProtocol["Tcp"] = "tcp";
    /**
     * Use UDP for the endpoint.
     */
    InboundEndpointProtocol["Udp"] = "udp";
})(InboundEndpointProtocol = exports.InboundEndpointProtocol || (exports.InboundEndpointProtocol = {}));
/**
 * Defines values for NetworkSecurityGroupRuleAccess.
 * Possible values include: 'allow', 'deny'
 * @readonly
 * @enum {string}
 */
var NetworkSecurityGroupRuleAccess;
(function (NetworkSecurityGroupRuleAccess) {
    /**
     * Allow access.
     */
    NetworkSecurityGroupRuleAccess["Allow"] = "allow";
    /**
     * Deny access.
     */
    NetworkSecurityGroupRuleAccess["Deny"] = "deny";
})(NetworkSecurityGroupRuleAccess = exports.NetworkSecurityGroupRuleAccess || (exports.NetworkSecurityGroupRuleAccess = {}));
/**
 * Defines values for PoolLifetimeOption.
 * Possible values include: 'jobSchedule', 'job'
 * @readonly
 * @enum {string}
 */
var PoolLifetimeOption;
(function (PoolLifetimeOption) {
    /**
     * The pool exists for the lifetime of the job schedule. The Batch Service
     * creates the pool when it creates the first job on the schedule. You may
     * apply this option only to job schedules, not to jobs.
     */
    PoolLifetimeOption["JobSchedule"] = "jobschedule";
    /**
     * The pool exists for the lifetime of the job to which it is dedicated. The
     * Batch service creates the pool when it creates the job. If the 'job'
     * option is applied to a job schedule, the Batch service creates a new auto
     * pool for every job created on the schedule.
     */
    PoolLifetimeOption["Job"] = "job";
})(PoolLifetimeOption = exports.PoolLifetimeOption || (exports.PoolLifetimeOption = {}));
/**
 * Defines values for OnAllTasksComplete.
 * Possible values include: 'noAction', 'terminateJob'
 * @readonly
 * @enum {string}
 */
var OnAllTasksComplete;
(function (OnAllTasksComplete) {
    /**
     * Do nothing. The job remains active unless terminated or disabled by some
     * other means.
     */
    OnAllTasksComplete["NoAction"] = "noaction";
    /**
     * Terminate the job. The job's terminateReason is set to 'AllTasksComplete'.
     */
    OnAllTasksComplete["TerminateJob"] = "terminatejob";
})(OnAllTasksComplete = exports.OnAllTasksComplete || (exports.OnAllTasksComplete = {}));
/**
 * Defines values for OnTaskFailure.
 * Possible values include: 'noAction', 'performExitOptionsJobAction'
 * @readonly
 * @enum {string}
 */
var OnTaskFailure;
(function (OnTaskFailure) {
    /**
     * Do nothing. The job remains active unless terminated or disabled by some
     * other means.
     */
    OnTaskFailure["NoAction"] = "noaction";
    /**
     * Take the action associated with the task exit condition in the task's
     * exitConditions collection. (This may still result in no action being
     * taken, if that is what the task specifies.)
     */
    OnTaskFailure["PerformExitOptionsJobAction"] = "performexitoptionsjobaction";
})(OnTaskFailure = exports.OnTaskFailure || (exports.OnTaskFailure = {}));
/**
 * Defines values for JobScheduleState.
 * Possible values include: 'active', 'completed', 'disabled', 'terminating',
 * 'deleting'
 * @readonly
 * @enum {string}
 */
var JobScheduleState;
(function (JobScheduleState) {
    /**
     * The job schedule is active and will create jobs as per its schedule.
     */
    JobScheduleState["Active"] = "active";
    /**
     * The schedule has terminated, either by reaching its end time or by the
     * user terminating it explicitly.
     */
    JobScheduleState["Completed"] = "completed";
    /**
     * The user has disabled the schedule. The scheduler will not initiate any
     * new jobs will on this schedule, but any existing active job will continue
     * to run.
     */
    JobScheduleState["Disabled"] = "disabled";
    /**
     * The schedule has no more work to do, or has been explicitly terminated by
     * the user, but the termination operation is still in progress. The
     * scheduler will not initiate any new jobs for this schedule, nor is any
     * existing job active.
     */
    JobScheduleState["Terminating"] = "terminating";
    /**
     * The user has requested that the schedule be deleted, but the delete
     * operation is still in progress. The scheduler will not initiate any new
     * jobs for this schedule, and will delete any existing jobs and tasks under
     * the schedule, including any active job. The schedule will be deleted when
     * all jobs and tasks under the schedule have been deleted.
     */
    JobScheduleState["Deleting"] = "deleting";
})(JobScheduleState = exports.JobScheduleState || (exports.JobScheduleState = {}));
/**
 * Defines values for ErrorCategory.
 * Possible values include: 'userError', 'serverError'
 * @readonly
 * @enum {string}
 */
var ErrorCategory;
(function (ErrorCategory) {
    /**
     * The error is due to a user issue, such as misconfiguration.
     */
    ErrorCategory["UserError"] = "usererror";
    /**
     * The error is due to an internal server issue.
     */
    ErrorCategory["ServerError"] = "servererror";
})(ErrorCategory = exports.ErrorCategory || (exports.ErrorCategory = {}));
/**
 * Defines values for JobState.
 * Possible values include: 'active', 'disabling', 'disabled', 'enabling',
 * 'terminating', 'completed', 'deleting'
 * @readonly
 * @enum {string}
 */
var JobState;
(function (JobState) {
    /**
     * The job is available to have tasks scheduled.
     */
    JobState["Active"] = "active";
    /**
     * A user has requested that the job be disabled, but the disable operation
     * is still in progress (for example, waiting for tasks to terminate).
     */
    JobState["Disabling"] = "disabling";
    /**
     * A user has disabled the job. No tasks are running, and no new tasks will
     * be scheduled.
     */
    JobState["Disabled"] = "disabled";
    /**
     * A user has requested that the job be enabled, but the enable operation is
     * still in progress.
     */
    JobState["Enabling"] = "enabling";
    /**
     * The job is about to complete, either because a Job Manager task has
     * completed or because the user has terminated the job, but the terminate
     * operation is still in progress (for example, because Job Release tasks are
     * running).
     */
    JobState["Terminating"] = "terminating";
    /**
     * All tasks have terminated, and the system will not accept any more tasks
     * or any further changes to the job.
     */
    JobState["Completed"] = "completed";
    /**
     * A user has requested that the job be deleted, but the delete operation is
     * still in progress (for example, because the system is still terminating
     * running tasks).
     */
    JobState["Deleting"] = "deleting";
})(JobState = exports.JobState || (exports.JobState = {}));
/**
 * Defines values for JobPreparationTaskState.
 * Possible values include: 'running', 'completed'
 * @readonly
 * @enum {string}
 */
var JobPreparationTaskState;
(function (JobPreparationTaskState) {
    /**
     * The task is currently running (including retrying).
     */
    JobPreparationTaskState["Running"] = "running";
    /**
     * The task has exited with exit code 0, or the task has exhausted its retry
     * limit, or the Batch service was unable to start the task due to task
     * preparation errors (such as resource file download failures).
     */
    JobPreparationTaskState["Completed"] = "completed";
})(JobPreparationTaskState = exports.JobPreparationTaskState || (exports.JobPreparationTaskState = {}));
/**
 * Defines values for TaskExecutionResult.
 * Possible values include: 'success', 'failure'
 * @readonly
 * @enum {string}
 */
var TaskExecutionResult;
(function (TaskExecutionResult) {
    /**
     * The task ran successfully.
     */
    TaskExecutionResult["Success"] = "success";
    /**
     * There was an error during processing of the task. The failure may have
     * occurred before the task process was launched, while the task process was
     * executing, or after the task process exited.
     */
    TaskExecutionResult["Failure"] = "failure";
})(TaskExecutionResult = exports.TaskExecutionResult || (exports.TaskExecutionResult = {}));
/**
 * Defines values for JobReleaseTaskState.
 * Possible values include: 'running', 'completed'
 * @readonly
 * @enum {string}
 */
var JobReleaseTaskState;
(function (JobReleaseTaskState) {
    /**
     * The task is currently running (including retrying).
     */
    JobReleaseTaskState["Running"] = "running";
    /**
     * The task has exited with exit code 0, or the task has exhausted its retry
     * limit, or the Batch service was unable to start the task due to task
     * preparation errors (such as resource file download failures).
     */
    JobReleaseTaskState["Completed"] = "completed";
})(JobReleaseTaskState = exports.JobReleaseTaskState || (exports.JobReleaseTaskState = {}));
/**
 * Defines values for TaskCountValidationStatus.
 * Possible values include: 'validated', 'unvalidated'
 * @readonly
 * @enum {string}
 */
var TaskCountValidationStatus;
(function (TaskCountValidationStatus) {
    /**
     * The Batch service has validated the state counts against the task states
     * as reported in the List Tasks API.
     */
    TaskCountValidationStatus["Validated"] = "validated";
    /**
     * The Batch service has not been able to check state counts against the task
     * states as reported in the List Tasks API. The validationStatus may be
     * unvalidated if the job contains more than 200,000 tasks.
     */
    TaskCountValidationStatus["Unvalidated"] = "unvalidated";
})(TaskCountValidationStatus = exports.TaskCountValidationStatus || (exports.TaskCountValidationStatus = {}));
/**
 * Defines values for PoolState.
 * Possible values include: 'active', 'deleting', 'upgrading'
 * @readonly
 * @enum {string}
 */
var PoolState;
(function (PoolState) {
    /**
     * The pool is available to run tasks subject to the availability of compute
     * nodes.
     */
    PoolState["Active"] = "active";
    /**
     * The user has requested that the pool be deleted, but the delete operation
     * has not yet completed.
     */
    PoolState["Deleting"] = "deleting";
    /**
     * The user has requested that the operating system of the pool's nodes be
     * upgraded, but the upgrade operation has not yet completed (that is, some
     * nodes in the pool have not yet been upgraded). While upgrading, the pool
     * may be able to run tasks (with reduced capacity) but this is not
     * guaranteed.
     */
    PoolState["Upgrading"] = "upgrading";
})(PoolState = exports.PoolState || (exports.PoolState = {}));
/**
 * Defines values for AllocationState.
 * Possible values include: 'steady', 'resizing', 'stopping'
 * @readonly
 * @enum {string}
 */
var AllocationState;
(function (AllocationState) {
    /**
     * The pool is not resizing. There are no changes to the number of nodes in
     * the pool in progress. A pool enters this state when it is created and when
     * no operations are being performed on the pool to change the number of
     * nodes.
     */
    AllocationState["Steady"] = "steady";
    /**
     * The pool is resizing; that is, compute nodes are being added to or removed
     * from the pool.
     */
    AllocationState["Resizing"] = "resizing";
    /**
     * The pool was resizing, but the user has requested that the resize be
     * stopped, but the stop request has not yet been completed.
     */
    AllocationState["Stopping"] = "stopping";
})(AllocationState = exports.AllocationState || (exports.AllocationState = {}));
/**
 * Defines values for TaskState.
 * Possible values include: 'active', 'preparing', 'running', 'completed'
 * @readonly
 * @enum {string}
 */
var TaskState;
(function (TaskState) {
    /**
     * The task is queued and able to run, but is not currently assigned to a
     * compute node. A task enters this state when it is created, when it is
     * enabled after being disabled, or when it is awaiting a retry after a
     * failed run.
     */
    TaskState["Active"] = "active";
    /**
     * The task has been assigned to a compute node, but is waiting for a
     * required Job Preparation task to complete on the node. If the Job
     * Preparation task succeeds, the task will move to running. If the Job
     * Preparation task fails, the task will return to active and will be
     * eligible to be assigned to a different node.
     */
    TaskState["Preparing"] = "preparing";
    /**
     * The task is running on a compute node. This includes task-level
     * preparation such as downloading resource files or deploying application
     * packages specified on the task - it does not necessarily mean that the
     * task command line has started executing.
     */
    TaskState["Running"] = "running";
    /**
     * The task is no longer eligible to run, usually because the task has
     * finished successfully, or the task has finished unsuccessfully and has
     * exhausted its retry limit. A task is also marked as completed if an error
     * occurred launching the task, or when the task has been terminated.
     */
    TaskState["Completed"] = "completed";
})(TaskState = exports.TaskState || (exports.TaskState = {}));
/**
 * Defines values for TaskAddStatus.
 * Possible values include: 'success', 'clientError', 'serverError'
 * @readonly
 * @enum {string}
 */
var TaskAddStatus;
(function (TaskAddStatus) {
    /**
     * The task was added successfully.
     */
    TaskAddStatus["Success"] = "success";
    /**
     * The task failed to add due to a client error and should not be retried
     * without modifying the request as appropriate.
     */
    TaskAddStatus["ClientError"] = "clienterror";
    /**
     * Task failed to add due to a server error and can be retried without
     * modification.
     */
    TaskAddStatus["ServerError"] = "servererror";
})(TaskAddStatus = exports.TaskAddStatus || (exports.TaskAddStatus = {}));
/**
 * Defines values for SubtaskState.
 * Possible values include: 'preparing', 'running', 'completed'
 * @readonly
 * @enum {string}
 */
var SubtaskState;
(function (SubtaskState) {
    /**
     * The task has been assigned to a compute node, but is waiting for a
     * required Job Preparation task to complete on the node. If the Job
     * Preparation task succeeds, the task will move to running. If the Job
     * Preparation task fails, the task will return to active and will be
     * eligible to be assigned to a different node.
     */
    SubtaskState["Preparing"] = "preparing";
    /**
     * The task is running on a compute node. This includes task-level
     * preparation such as downloading resource files or deploying application
     * packages specified on the task - it does not necessarily mean that the
     * task command line has started executing.
     */
    SubtaskState["Running"] = "running";
    /**
     * The task is no longer eligible to run, usually because the task has
     * finished successfully, or the task has finished unsuccessfully and has
     * exhausted its retry limit. A task is also marked as completed if an error
     * occurred launching the task, or when the task has been terminated.
     */
    SubtaskState["Completed"] = "completed";
})(SubtaskState = exports.SubtaskState || (exports.SubtaskState = {}));
/**
 * Defines values for StartTaskState.
 * Possible values include: 'running', 'completed'
 * @readonly
 * @enum {string}
 */
var StartTaskState;
(function (StartTaskState) {
    /**
     * The start task is currently running.
     */
    StartTaskState["Running"] = "running";
    /**
     * The start task has exited with exit code 0, or the start task has failed
     * and the retry limit has reached, or the start task process did not run due
     * to task preparation errors (such as resource file download failures).
     */
    StartTaskState["Completed"] = "completed";
})(StartTaskState = exports.StartTaskState || (exports.StartTaskState = {}));
/**
 * Defines values for ComputeNodeState.
 * Possible values include: 'idle', 'rebooting', 'reimaging', 'running',
 * 'unusable', 'creating', 'starting', 'waitingForStartTask',
 * 'startTaskFailed', 'unknown', 'leavingPool', 'offline', 'preempted'
 * @readonly
 * @enum {string}
 */
var ComputeNodeState;
(function (ComputeNodeState) {
    /**
     * The node is not currently running a task.
     */
    ComputeNodeState["Idle"] = "idle";
    /**
     * The node is rebooting.
     */
    ComputeNodeState["Rebooting"] = "rebooting";
    /**
     * The node is reimaging.
     */
    ComputeNodeState["Reimaging"] = "reimaging";
    /**
     * The node is running one or more tasks (other than a start task).
     */
    ComputeNodeState["Running"] = "running";
    /**
     * The node cannot be used for task execution due to errors.
     */
    ComputeNodeState["Unusable"] = "unusable";
    /**
     * The Batch service has obtained the underlying virtual machine from Azure
     * Compute, but it has not yet started to join the pool.
     */
    ComputeNodeState["Creating"] = "creating";
    /**
     * The Batch service is starting on the underlying virtual machine.
     */
    ComputeNodeState["Starting"] = "starting";
    /**
     * The start task has started running on the compute node, but waitForSuccess
     * is set and the start task has not yet completed.
     */
    ComputeNodeState["WaitingForStartTask"] = "waitingforstarttask";
    /**
     * The start task has failed on the compute node (and exhausted all retries),
     * and waitForSuccess is set. The node is not usable for running tasks.
     */
    ComputeNodeState["StartTaskFailed"] = "starttaskfailed";
    /**
     * The Batch service has lost contact with the node, and does not know its
     * true state.
     */
    ComputeNodeState["Unknown"] = "unknown";
    /**
     * The node is leaving the pool, either because the user explicitly removed
     * it or because the pool is resizing or autoscaling down.
     */
    ComputeNodeState["LeavingPool"] = "leavingpool";
    /**
     * The node is not currently running a task, and scheduling of new tasks to
     * the node is disabled.
     */
    ComputeNodeState["Offline"] = "offline";
    /**
     * The low-priority node has been preempted. Tasks which were running on the
     * node when it was pre-empted will be rescheduled when another node becomes
     * available.
     */
    ComputeNodeState["Preempted"] = "preempted";
})(ComputeNodeState = exports.ComputeNodeState || (exports.ComputeNodeState = {}));
/**
 * Defines values for SchedulingState.
 * Possible values include: 'enabled', 'disabled'
 * @readonly
 * @enum {string}
 */
var SchedulingState;
(function (SchedulingState) {
    /**
     * Tasks can be scheduled on the node.
     */
    SchedulingState["Enabled"] = "enabled";
    /**
     * No new tasks will be scheduled on the node. Tasks already running on the
     * node may still run to completion. All nodes start with scheduling enabled.
     */
    SchedulingState["Disabled"] = "disabled";
})(SchedulingState = exports.SchedulingState || (exports.SchedulingState = {}));
/**
 * Defines values for DisableJobOption.
 * Possible values include: 'requeue', 'terminate', 'wait'
 * @readonly
 * @enum {string}
 */
var DisableJobOption;
(function (DisableJobOption) {
    /**
     * Terminate running tasks and requeue them. The tasks will run again when
     * the job is enabled.
     */
    DisableJobOption["Requeue"] = "requeue";
    /**
     * Terminate running tasks. The tasks will be completed with failureInfo
     * indicating that they were terminated, and will not run again.
     */
    DisableJobOption["Terminate"] = "terminate";
    /**
     * Allow currently running tasks to complete.
     */
    DisableJobOption["Wait"] = "wait";
})(DisableJobOption = exports.DisableJobOption || (exports.DisableJobOption = {}));
/**
 * Defines values for ComputeNodeDeallocationOption.
 * Possible values include: 'requeue', 'terminate', 'taskCompletion',
 * 'retainedData'
 * @readonly
 * @enum {string}
 */
var ComputeNodeDeallocationOption;
(function (ComputeNodeDeallocationOption) {
    /**
     * Terminate running task processes and requeue the tasks. The tasks will run
     * again when a node is available. Remove nodes as soon as tasks have been
     * terminated.
     */
    ComputeNodeDeallocationOption["Requeue"] = "requeue";
    /**
     * Terminate running tasks. The tasks will be completed with failureInfo
     * indicating that they were terminated, and will not run again. Remove nodes
     * as soon as tasks have been terminated.
     */
    ComputeNodeDeallocationOption["Terminate"] = "terminate";
    /**
     * Allow currently running tasks to complete. Schedule no new tasks while
     * waiting. Remove nodes when all tasks have completed.
     */
    ComputeNodeDeallocationOption["TaskCompletion"] = "taskcompletion";
    /**
     * Allow currently running tasks to complete, then wait for all task data
     * retention periods to expire. Schedule no new tasks while waiting. Remove
     * nodes when all task retention periods have expired.
     */
    ComputeNodeDeallocationOption["RetainedData"] = "retaineddata";
})(ComputeNodeDeallocationOption = exports.ComputeNodeDeallocationOption || (exports.ComputeNodeDeallocationOption = {}));
/**
 * Defines values for ComputeNodeRebootOption.
 * Possible values include: 'requeue', 'terminate', 'taskCompletion',
 * 'retainedData'
 * @readonly
 * @enum {string}
 */
var ComputeNodeRebootOption;
(function (ComputeNodeRebootOption) {
    /**
     * Terminate running task processes and requeue the tasks. The tasks will run
     * again when a node is available. Restart the node as soon as tasks have
     * been terminated.
     */
    ComputeNodeRebootOption["Requeue"] = "requeue";
    /**
     * Terminate running tasks. The tasks will be completed with failureInfo
     * indicating that they were terminated, and will not run again. Restart the
     * node as soon as tasks have been terminated.
     */
    ComputeNodeRebootOption["Terminate"] = "terminate";
    /**
     * Allow currently running tasks to complete. Schedule no new tasks while
     * waiting. Restart the node when all tasks have completed.
     */
    ComputeNodeRebootOption["TaskCompletion"] = "taskcompletion";
    /**
     * Allow currently running tasks to complete, then wait for all task data
     * retention periods to expire. Schedule no new tasks while waiting. Restart
     * the node when all task retention periods have expired.
     */
    ComputeNodeRebootOption["RetainedData"] = "retaineddata";
})(ComputeNodeRebootOption = exports.ComputeNodeRebootOption || (exports.ComputeNodeRebootOption = {}));
/**
 * Defines values for ComputeNodeReimageOption.
 * Possible values include: 'requeue', 'terminate', 'taskCompletion',
 * 'retainedData'
 * @readonly
 * @enum {string}
 */
var ComputeNodeReimageOption;
(function (ComputeNodeReimageOption) {
    /**
     * Terminate running task processes and requeue the tasks. The tasks will run
     * again when a node is available. Reimage the node as soon as tasks have
     * been terminated.
     */
    ComputeNodeReimageOption["Requeue"] = "requeue";
    /**
     * Terminate running tasks. The tasks will be completed with failureInfo
     * indicating that they were terminated, and will not run again. Reimage the
     * node as soon as tasks have been terminated.
     */
    ComputeNodeReimageOption["Terminate"] = "terminate";
    /**
     * Allow currently running tasks to complete. Schedule no new tasks while
     * waiting. Reimage the node when all tasks have completed.
     */
    ComputeNodeReimageOption["TaskCompletion"] = "taskcompletion";
    /**
     * Allow currently running tasks to complete, then wait for all task data
     * retention periods to expire. Schedule no new tasks while waiting. Reimage
     * the node when all task retention periods have expired.
     */
    ComputeNodeReimageOption["RetainedData"] = "retaineddata";
})(ComputeNodeReimageOption = exports.ComputeNodeReimageOption || (exports.ComputeNodeReimageOption = {}));
/**
 * Defines values for DisableComputeNodeSchedulingOption.
 * Possible values include: 'requeue', 'terminate', 'taskCompletion'
 * @readonly
 * @enum {string}
 */
var DisableComputeNodeSchedulingOption;
(function (DisableComputeNodeSchedulingOption) {
    /**
     * Terminate running task processes and requeue the tasks. The tasks may run
     * again on other compute nodes, or when task scheduling is re-enabled on
     * this node. Enter offline state as soon as tasks have been terminated.
     */
    DisableComputeNodeSchedulingOption["Requeue"] = "requeue";
    /**
     * Terminate running tasks. The tasks will be completed with failureInfo
     * indicating that they were terminated, and will not run again. Enter
     * offline state as soon as tasks have been terminated.
     */
    DisableComputeNodeSchedulingOption["Terminate"] = "terminate";
    /**
     * Allow currently running tasks to complete. Schedule no new tasks while
     * waiting. Enter offline state when all tasks have completed.
     */
    DisableComputeNodeSchedulingOption["TaskCompletion"] = "taskcompletion";
})(DisableComputeNodeSchedulingOption = exports.DisableComputeNodeSchedulingOption || (exports.DisableComputeNodeSchedulingOption = {}));
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const msRest = __webpack_require__(1);
const msRestAzure = __webpack_require__(3);
const Mappers = __webpack_require__(0);
const packageName = "azure-batch-js";
const packageVersion = "0.1.0";
class BatchServiceClientContext extends msRestAzure.AzureServiceClient {
    /**
     * @class
     * Initializes a new instance of the BatchServiceClient class.
     * @constructor
     *
     * @param {msRest.ServiceClientCredentials} credentials - Credentials needed for the client to connect to Azure.
     *
     * @param {string} [baseUri] - The base URI of the service.
     *
     * @param {object} [options] - The parameter options
     *
     * @param {Array} [options.filters] - Filters to be added to the request pipeline
     *
     * @param {object} [options.requestOptions] - The request options. Detailed info can be found at
     * {@link https://github.github.io/fetch/#Request Options doc}
     *
     * @param {boolean} [options.noRetryPolicy] - If set to true, turn off default retry policy
     *
     * @param {string} [options.acceptLanguage] - The preferred language for the response.
     *
     * @param {number} [options.longRunningOperationRetryTimeout] - The retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @param {boolean} [options.generateClientRequestId] - Whether a unique x-ms-client-request-id should be generated. When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     */
    constructor(credentials, baseUri, options) {
        if (credentials == undefined) {
            throw new Error('\'credentials\' cannot be null.');
        }
        if (!options) {
            options = {};
        }
        if (!options.serializer) {
            options = Object.assign({}, options, { serializer: new msRest.Serializer(Mappers, false) });
        }
        super(credentials, options);
        this.serializer = new msRest.Serializer(Mappers);
        this.apiVersion = '2018-03-01.6.1';
        this.acceptLanguage = 'en-US';
        this.longRunningOperationRetryTimeout = 30;
        this.baseUri = baseUri;
        if (!this.baseUri) {
            this.baseUri = 'https://batch.core.windows.net';
        }
        this.credentials = credentials;
        this.addUserAgentInfo(`${packageName}/${packageVersion}`);
        if (options.acceptLanguage !== null && options.acceptLanguage !== undefined) {
            this.acceptLanguage = options.acceptLanguage;
        }
        if (options.longRunningOperationRetryTimeout !== null && options.longRunningOperationRetryTimeout !== undefined) {
            this.longRunningOperationRetryTimeout = options.longRunningOperationRetryTimeout;
        }
    }
}
exports.BatchServiceClientContext = BatchServiceClientContext;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const application_1 = __webpack_require__(8);
exports.Application = application_1.Application;
const pool_1 = __webpack_require__(9);
exports.Pool = pool_1.Pool;
const account_1 = __webpack_require__(10);
exports.Account = account_1.Account;
const job_1 = __webpack_require__(11);
exports.Job = job_1.Job;
const certificateOperations_1 = __webpack_require__(12);
exports.CertificateOperations = certificateOperations_1.CertificateOperations;
const file_1 = __webpack_require__(13);
exports.File = file_1.File;
const jobSchedule_1 = __webpack_require__(14);
exports.JobSchedule = jobSchedule_1.JobSchedule;
const task_1 = __webpack_require__(15);
exports.Task = task_1.Task;
const computeNodeOperations_1 = __webpack_require__(16);
exports.ComputeNodeOperations = computeNodeOperations_1.ComputeNodeOperations;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(2);
const msRest = __webpack_require__(1);
const Mappers = __webpack_require__(0);
const WebResource = msRest.WebResource;
/** Class representing a Application. */
class Application {
    /**
     * Create a Application.
     * @param {BatchServiceClientContext} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Lists all of the applications available in the specified account.
     *
     * This operation returns only applications and versions that are available for
     * use on compute nodes; that is, that can be used in an application package
     * reference. For administrator information about applications and versions
     * that are not yet available to compute nodes, use the Azure portal or the
     * Azure Resource Manager API.
     *
     * @param {ApplicationListOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let applicationListOptions = (options && options.applicationListOptions !== undefined) ? options.applicationListOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (applicationListOptions !== null && applicationListOptions !== undefined) {
                    maxResults = applicationListOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (applicationListOptions !== null && applicationListOptions !== undefined) {
                    timeout = applicationListOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (applicationListOptions !== null && applicationListOptions !== undefined) {
                    clientRequestId = applicationListOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (applicationListOptions !== null && applicationListOptions !== undefined) {
                    returnClientRequestId = applicationListOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (applicationListOptions !== null && applicationListOptions !== undefined) {
                    ocpDate = applicationListOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    maxResults,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "applications",
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "maxResults",
                            mapper: {
                                serializedName: "maxresults",
                                defaultValue: 1000,
                                constraints: {
                                    InclusiveMaximum: 1000,
                                    InclusiveMinimum: 1
                                },
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.ApplicationListResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.ApplicationListHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets information about the specified application.
     *
     * This operation returns only applications and versions that are available for
     * use on compute nodes; that is, that can be used in an application package
     * reference. For administrator information about applications and versions
     * that are not yet available to compute nodes, use the Azure portal or the
     * Azure Resource Manager API.
     *
     * @param {string} applicationId The ID of the application.
     *
     * @param {ApplicationGetOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(applicationId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let applicationGetOptions = (options && options.applicationGetOptions !== undefined) ? options.applicationGetOptions : undefined;
            // Validate
            try {
                if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
                    throw new Error('applicationId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (applicationGetOptions !== null && applicationGetOptions !== undefined) {
                    timeout = applicationGetOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (applicationGetOptions !== null && applicationGetOptions !== undefined) {
                    clientRequestId = applicationGetOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (applicationGetOptions !== null && applicationGetOptions !== undefined) {
                    returnClientRequestId = applicationGetOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (applicationGetOptions !== null && applicationGetOptions !== undefined) {
                    ocpDate = applicationGetOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    applicationId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "applications/{applicationId}",
                    urlParameters: [
                        {
                            parameterName: "applicationId",
                            mapper: {
                                required: true,
                                serializedName: "applicationId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.ApplicationSummary;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.ApplicationGetHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the applications available in the specified account.
     *
     * This operation returns only applications and versions that are available for
     * use on compute nodes; that is, that can be used in an application package
     * reference. For administrator information about applications and versions
     * that are not yet available to compute nodes, use the Azure portal or the
     * Azure Resource Manager API.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {ApplicationListNextOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNextWithHttpOperationResponse(nextPageLink, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let applicationListNextOptions = (options && options.applicationListNextOptions !== undefined) ? options.applicationListNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (applicationListNextOptions !== null && applicationListNextOptions !== undefined) {
                    clientRequestId = applicationListNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (applicationListNextOptions !== null && applicationListNextOptions !== undefined) {
                    returnClientRequestId = applicationListNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (applicationListNextOptions !== null && applicationListNextOptions !== undefined) {
                    ocpDate = applicationListNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    nextPageLink,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: "https://batch.core.windows.net",
                    path: "{nextLink}",
                    urlParameters: [
                        {
                            parameterName: "nextPageLink",
                            skipEncoding: true,
                            mapper: {
                                required: true,
                                serializedName: "nextLink",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.ApplicationListResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.ApplicationListHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    list(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    get(applicationId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(applicationId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getWithHttpOperationResponse(applicationId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    listNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
}
exports.Application = Application;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(2);
const msRest = __webpack_require__(1);
const Mappers = __webpack_require__(0);
const WebResource = msRest.WebResource;
/** Class representing a Pool. */
class Pool {
    /**
     * Create a Pool.
     * @param {BatchServiceClientContext} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Lists the usage metrics, aggregated by pool across individual time
     * intervals, for the specified account.
     *
     * If you do not specify a $filter clause including a poolId, the response
     * includes all pools that existed in the account in the time range of the
     * returned aggregation intervals. If you do not specify a $filter clause
     * including a startTime or endTime these filters default to the start and end
     * times of the last aggregation interval currently available; that is, only
     * the last aggregation interval is returned.
     *
     * @param {PoolListUsageMetricsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listUsageMetricsWithHttpOperationResponse(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolListUsageMetricsOptions = (options && options.poolListUsageMetricsOptions !== undefined) ? options.poolListUsageMetricsOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let startTime;
            let endTime;
            let filter;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    startTime = poolListUsageMetricsOptions.startTime;
                    if (startTime && !(startTime instanceof Date ||
                        (typeof startTime.valueOf() === 'string' && !isNaN(Date.parse(startTime))))) {
                        throw new Error('startTime must be of type date.');
                    }
                }
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    endTime = poolListUsageMetricsOptions.endTime;
                    if (endTime && !(endTime instanceof Date ||
                        (typeof endTime.valueOf() === 'string' && !isNaN(Date.parse(endTime))))) {
                        throw new Error('endTime must be of type date.');
                    }
                }
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    filter = poolListUsageMetricsOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    maxResults = poolListUsageMetricsOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    timeout = poolListUsageMetricsOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    clientRequestId = poolListUsageMetricsOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    returnClientRequestId = poolListUsageMetricsOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    ocpDate = poolListUsageMetricsOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    startTime,
                    endTime,
                    filter,
                    maxResults,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "poolusagemetrics",
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "startTime",
                            mapper: {
                                serializedName: "starttime",
                                type: {
                                    name: "DateTime"
                                }
                            }
                        },
                        {
                            parameterName: "endTime",
                            mapper: {
                                serializedName: "endtime",
                                type: {
                                    name: "DateTime"
                                }
                            }
                        },
                        {
                            parameterName: "filter",
                            mapper: {
                                serializedName: "$filter",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "maxResults",
                            mapper: {
                                serializedName: "maxresults",
                                defaultValue: 1000,
                                constraints: {
                                    InclusiveMaximum: 1000,
                                    InclusiveMinimum: 1
                                },
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.PoolListUsageMetricsResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.PoolListUsageMetricsHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets lifetime summary statistics for all of the pools in the
     * specified account.
     *
     * Statistics are aggregated across all pools that have ever existed in the
     * account, from account creation to the last update time of the statistics.
     * The statistics may not be immediately available. The Batch service performs
     * periodic roll-up of statistics. The typical delay is about 30 minutes.
     *
     * @param {PoolGetAllLifetimeStatisticsOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getAllLifetimeStatisticsWithHttpOperationResponse(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolGetAllLifetimeStatisticsOptions = (options && options.poolGetAllLifetimeStatisticsOptions !== undefined) ? options.poolGetAllLifetimeStatisticsOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolGetAllLifetimeStatisticsOptions !== null && poolGetAllLifetimeStatisticsOptions !== undefined) {
                    timeout = poolGetAllLifetimeStatisticsOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolGetAllLifetimeStatisticsOptions !== null && poolGetAllLifetimeStatisticsOptions !== undefined) {
                    clientRequestId = poolGetAllLifetimeStatisticsOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolGetAllLifetimeStatisticsOptions !== null && poolGetAllLifetimeStatisticsOptions !== undefined) {
                    returnClientRequestId = poolGetAllLifetimeStatisticsOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolGetAllLifetimeStatisticsOptions !== null && poolGetAllLifetimeStatisticsOptions !== undefined) {
                    ocpDate = poolGetAllLifetimeStatisticsOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "lifetimepoolstats",
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.PoolStatistics;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.PoolGetAllLifetimeStatisticsHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Adds a pool to the specified account.
     *
     * When naming pools, avoid including sensitive information such as user names
     * or secret project names. This information may appear in telemetry logs
     * accessible to Microsoft Support engineers.
     *
     * @param {PoolAddParameter} pool The pool to be added.
     *
     * @param {PoolAddOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addWithHttpOperationResponse(pool, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolAddOptions = (options && options.poolAddOptions !== undefined) ? options.poolAddOptions : undefined;
            if (pool === null || pool === undefined) {
                pool = {};
            }
            // Validate
            try {
                if (pool === null || pool === undefined) {
                    throw new Error('pool cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolAddOptions !== null && poolAddOptions !== undefined) {
                    timeout = poolAddOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolAddOptions !== null && poolAddOptions !== undefined) {
                    clientRequestId = poolAddOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolAddOptions !== null && poolAddOptions !== undefined) {
                    returnClientRequestId = poolAddOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolAddOptions !== null && poolAddOptions !== undefined) {
                    ocpDate = poolAddOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    pool,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "pools",
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.PoolAddParameter,
                    requestBodyName: "pool",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 201) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 201) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.PoolAddHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the pools in the specified account.
     *
     * @param {PoolListOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolListOptions = (options && options.poolListOptions !== undefined) ? options.poolListOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let select;
            let expand;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    filter = poolListOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    select = poolListOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    expand = poolListOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    maxResults = poolListOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    timeout = poolListOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    clientRequestId = poolListOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    returnClientRequestId = poolListOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    ocpDate = poolListOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    filter,
                    select,
                    expand,
                    maxResults,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "pools",
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "filter",
                            mapper: {
                                serializedName: "$filter",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "select",
                            mapper: {
                                serializedName: "$select",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "expand",
                            mapper: {
                                serializedName: "$expand",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "maxResults",
                            mapper: {
                                serializedName: "maxresults",
                                defaultValue: 1000,
                                constraints: {
                                    InclusiveMaximum: 1000,
                                    InclusiveMinimum: 1
                                },
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.CloudPoolListResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.PoolListHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Deletes a pool from the specified account.
     *
     * When you request that a pool be deleted, the following actions occur: the
     * pool state is set to deleting; any ongoing resize operation on the pool are
     * stopped; the Batch service starts resizing the pool to zero nodes; any tasks
     * running on existing nodes are terminated and requeued (as if a resize pool
     * operation had been requested with the default requeue option); finally, the
     * pool is removed from the system. Because running tasks are requeued, the
     * user can rerun these tasks by updating their job to target a different pool.
     * The tasks can then run on the new pool. If you want to override the requeue
     * behavior, then you should call resize pool explicitly to shrink the pool to
     * zero size before deleting the pool. If you call an Update, Patch or Delete
     * API on a pool in the deleting state, it will fail with HTTP status code 409
     * with error code PoolBeingDeleted.
     *
     * @param {string} poolId The ID of the pool to delete.
     *
     * @param {PoolDeleteMethodOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(poolId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolDeleteMethodOptions = (options && options.poolDeleteMethodOptions !== undefined) ? options.poolDeleteMethodOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    timeout = poolDeleteMethodOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    clientRequestId = poolDeleteMethodOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    returnClientRequestId = poolDeleteMethodOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    ocpDate = poolDeleteMethodOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    ifMatch = poolDeleteMethodOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    ifNoneMatch = poolDeleteMethodOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    ifModifiedSince = poolDeleteMethodOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    ifUnmodifiedSince = poolDeleteMethodOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    poolId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.client.baseUri,
                    path: "pools/{poolId}",
                    urlParameters: [
                        {
                            parameterName: "poolId",
                            mapper: {
                                required: true,
                                serializedName: "poolId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 202) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.PoolDeleteHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets basic properties of a pool.
     *
     * @param {string} poolId The ID of the pool to get.
     *
     * @param {PoolExistsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    existsWithHttpOperationResponse(poolId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolExistsOptions = (options && options.poolExistsOptions !== undefined) ? options.poolExistsOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    timeout = poolExistsOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    clientRequestId = poolExistsOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    returnClientRequestId = poolExistsOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    ocpDate = poolExistsOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    ifMatch = poolExistsOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    ifNoneMatch = poolExistsOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    ifModifiedSince = poolExistsOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    ifUnmodifiedSince = poolExistsOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    poolId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "HEAD",
                    baseUrl: this.client.baseUri,
                    path: "pools/{poolId}",
                    urlParameters: [
                        {
                            parameterName: "poolId",
                            mapper: {
                                required: true,
                                serializedName: "poolId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200 && statusCode !== 404) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                operationRes.parsedBody = (statusCode === 200);
                // Deserialize Response
                if (statusCode === 200) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.PoolExistsHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
                // Deserialize Response
                if (statusCode === 404) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.PoolExistsHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets information about the specified pool.
     *
     * @param {string} poolId The ID of the pool to get.
     *
     * @param {PoolGetOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(poolId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolGetOptions = (options && options.poolGetOptions !== undefined) ? options.poolGetOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let select;
            let expand;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    select = poolGetOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    expand = poolGetOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    timeout = poolGetOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    clientRequestId = poolGetOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    returnClientRequestId = poolGetOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    ocpDate = poolGetOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    ifMatch = poolGetOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    ifNoneMatch = poolGetOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    ifModifiedSince = poolGetOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    ifUnmodifiedSince = poolGetOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    poolId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    select,
                    expand,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "pools/{poolId}",
                    urlParameters: [
                        {
                            parameterName: "poolId",
                            mapper: {
                                required: true,
                                serializedName: "poolId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "select",
                            mapper: {
                                serializedName: "$select",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "expand",
                            mapper: {
                                serializedName: "$expand",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.CloudPool;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.PoolGetHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Updates the properties of the specified pool.
     *
     * This only replaces the pool properties specified in the request. For
     * example, if the pool has a start task associated with it, and a request does
     * not specify a start task element, then the pool keeps the existing start
     * task.
     *
     * @param {string} poolId The ID of the pool to update.
     *
     * @param {PoolPatchParameter} poolPatchParameter The parameters for the
     * request.
     *
     * @param {PoolPatchOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    patchWithHttpOperationResponse(poolId, poolPatchParameter, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolPatchOptions = (options && options.poolPatchOptions !== undefined) ? options.poolPatchOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (poolPatchParameter === null || poolPatchParameter === undefined) {
                    throw new Error('poolPatchParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    timeout = poolPatchOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    clientRequestId = poolPatchOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    returnClientRequestId = poolPatchOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    ocpDate = poolPatchOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    ifMatch = poolPatchOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    ifNoneMatch = poolPatchOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    ifModifiedSince = poolPatchOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    ifUnmodifiedSince = poolPatchOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    poolId,
                    poolPatchParameter,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PATCH",
                    baseUrl: this.client.baseUri,
                    path: "pools/{poolId}",
                    urlParameters: [
                        {
                            parameterName: "poolId",
                            mapper: {
                                required: true,
                                serializedName: "poolId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.PoolPatchParameter,
                    requestBodyName: "poolPatchParameter",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.PoolPatchHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Disables automatic scaling for a pool.
     *
     * @param {string} poolId The ID of the pool on which to disable automatic
     * scaling.
     *
     * @param {PoolDisableAutoScaleOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    disableAutoScaleWithHttpOperationResponse(poolId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolDisableAutoScaleOptions = (options && options.poolDisableAutoScaleOptions !== undefined) ? options.poolDisableAutoScaleOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolDisableAutoScaleOptions !== null && poolDisableAutoScaleOptions !== undefined) {
                    timeout = poolDisableAutoScaleOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolDisableAutoScaleOptions !== null && poolDisableAutoScaleOptions !== undefined) {
                    clientRequestId = poolDisableAutoScaleOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolDisableAutoScaleOptions !== null && poolDisableAutoScaleOptions !== undefined) {
                    returnClientRequestId = poolDisableAutoScaleOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolDisableAutoScaleOptions !== null && poolDisableAutoScaleOptions !== undefined) {
                    ocpDate = poolDisableAutoScaleOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    poolId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "pools/{poolId}/disableautoscale",
                    urlParameters: [
                        {
                            parameterName: "poolId",
                            mapper: {
                                required: true,
                                serializedName: "poolId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.PoolDisableAutoScaleHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Enables automatic scaling for a pool.
     *
     * You cannot enable automatic scaling on a pool if a resize operation is in
     * progress on the pool. If automatic scaling of the pool is currently
     * disabled, you must specify a valid autoscale formula as part of the request.
     * If automatic scaling of the pool is already enabled, you may specify a new
     * autoscale formula and/or a new evaluation interval. You cannot call this API
     * for the same pool more than once every 30 seconds.
     *
     * @param {string} poolId The ID of the pool on which to enable automatic
     * scaling.
     *
     * @param {PoolEnableAutoScaleParameter} poolEnableAutoScaleParameter The
     * parameters for the request.
     *
     * @param {PoolEnableAutoScaleOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    enableAutoScaleWithHttpOperationResponse(poolId, poolEnableAutoScaleParameter, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolEnableAutoScaleOptions = (options && options.poolEnableAutoScaleOptions !== undefined) ? options.poolEnableAutoScaleOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (poolEnableAutoScaleParameter === null || poolEnableAutoScaleParameter === undefined) {
                    throw new Error('poolEnableAutoScaleParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    timeout = poolEnableAutoScaleOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    clientRequestId = poolEnableAutoScaleOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    returnClientRequestId = poolEnableAutoScaleOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    ocpDate = poolEnableAutoScaleOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    ifMatch = poolEnableAutoScaleOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    ifNoneMatch = poolEnableAutoScaleOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    ifModifiedSince = poolEnableAutoScaleOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    ifUnmodifiedSince = poolEnableAutoScaleOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    poolId,
                    poolEnableAutoScaleParameter,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "pools/{poolId}/enableautoscale",
                    urlParameters: [
                        {
                            parameterName: "poolId",
                            mapper: {
                                required: true,
                                serializedName: "poolId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.PoolEnableAutoScaleParameter,
                    requestBodyName: "poolEnableAutoScaleParameter",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.PoolEnableAutoScaleHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets the result of evaluating an automatic scaling formula on the
     * pool.
     *
     * This API is primarily for validating an autoscale formula, as it simply
     * returns the result without applying the formula to the pool. The pool must
     * have auto scaling enabled in order to evaluate a formula.
     *
     * @param {string} poolId The ID of the pool on which to evaluate the automatic
     * scaling formula.
     *
     * @param {PoolEvaluateAutoScaleParameter} poolEvaluateAutoScaleParameter The
     * parameters for the request.
     *
     * @param {PoolEvaluateAutoScaleOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    evaluateAutoScaleWithHttpOperationResponse(poolId, poolEvaluateAutoScaleParameter, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolEvaluateAutoScaleOptions = (options && options.poolEvaluateAutoScaleOptions !== undefined) ? options.poolEvaluateAutoScaleOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (poolEvaluateAutoScaleParameter === null || poolEvaluateAutoScaleParameter === undefined) {
                    throw new Error('poolEvaluateAutoScaleParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolEvaluateAutoScaleOptions !== null && poolEvaluateAutoScaleOptions !== undefined) {
                    timeout = poolEvaluateAutoScaleOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolEvaluateAutoScaleOptions !== null && poolEvaluateAutoScaleOptions !== undefined) {
                    clientRequestId = poolEvaluateAutoScaleOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolEvaluateAutoScaleOptions !== null && poolEvaluateAutoScaleOptions !== undefined) {
                    returnClientRequestId = poolEvaluateAutoScaleOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolEvaluateAutoScaleOptions !== null && poolEvaluateAutoScaleOptions !== undefined) {
                    ocpDate = poolEvaluateAutoScaleOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    poolId,
                    poolEvaluateAutoScaleParameter,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "pools/{poolId}/evaluateautoscale",
                    urlParameters: [
                        {
                            parameterName: "poolId",
                            mapper: {
                                required: true,
                                serializedName: "poolId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.PoolEvaluateAutoScaleParameter,
                    requestBodyName: "poolEvaluateAutoScaleParameter",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.AutoScaleRun;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.PoolEvaluateAutoScaleHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Changes the number of compute nodes that are assigned to a pool.
     *
     * You can only resize a pool when its allocation state is steady. If the pool
     * is already resizing, the request fails with status code 409. When you resize
     * a pool, the pool's allocation state changes from steady to resizing. You
     * cannot resize pools which are configured for automatic scaling. If you try
     * to do this, the Batch service returns an error 409. If you resize a pool
     * downwards, the Batch service chooses which nodes to remove. To remove
     * specific nodes, use the pool remove nodes API instead.
     *
     * @param {string} poolId The ID of the pool to resize.
     *
     * @param {PoolResizeParameter} poolResizeParameter The parameters for the
     * request.
     *
     * @param {PoolResizeOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    resizeWithHttpOperationResponse(poolId, poolResizeParameter, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolResizeOptions = (options && options.poolResizeOptions !== undefined) ? options.poolResizeOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (poolResizeParameter === null || poolResizeParameter === undefined) {
                    throw new Error('poolResizeParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    timeout = poolResizeOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    clientRequestId = poolResizeOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    returnClientRequestId = poolResizeOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    ocpDate = poolResizeOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    ifMatch = poolResizeOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    ifNoneMatch = poolResizeOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    ifModifiedSince = poolResizeOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    ifUnmodifiedSince = poolResizeOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    poolId,
                    poolResizeParameter,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "pools/{poolId}/resize",
                    urlParameters: [
                        {
                            parameterName: "poolId",
                            mapper: {
                                required: true,
                                serializedName: "poolId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.PoolResizeParameter,
                    requestBodyName: "poolResizeParameter",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 202) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.PoolResizeHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Stops an ongoing resize operation on the pool.
     *
     * This does not restore the pool to its previous state before the resize
     * operation: it only stops any further changes being made, and the pool
     * maintains its current state. After stopping, the pool stabilizes at the
     * number of nodes it was at when the stop operation was done. During the stop
     * operation, the pool allocation state changes first to stopping and then to
     * steady. A resize operation need not be an explicit resize pool request; this
     * API can also be used to halt the initial sizing of the pool when it is
     * created.
     *
     * @param {string} poolId The ID of the pool whose resizing you want to stop.
     *
     * @param {PoolStopResizeOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    stopResizeWithHttpOperationResponse(poolId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolStopResizeOptions = (options && options.poolStopResizeOptions !== undefined) ? options.poolStopResizeOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    timeout = poolStopResizeOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    clientRequestId = poolStopResizeOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    returnClientRequestId = poolStopResizeOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    ocpDate = poolStopResizeOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    ifMatch = poolStopResizeOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    ifNoneMatch = poolStopResizeOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    ifModifiedSince = poolStopResizeOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    ifUnmodifiedSince = poolStopResizeOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    poolId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "pools/{poolId}/stopresize",
                    urlParameters: [
                        {
                            parameterName: "poolId",
                            mapper: {
                                required: true,
                                serializedName: "poolId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 202) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.PoolStopResizeHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Updates the properties of the specified pool.
     *
     * This fully replaces all the updateable properties of the pool. For example,
     * if the pool has a start task associated with it and if start task is not
     * specified with this request, then the Batch service will remove the existing
     * start task.
     *
     * @param {string} poolId The ID of the pool to update.
     *
     * @param {PoolUpdatePropertiesParameter} poolUpdatePropertiesParameter The
     * parameters for the request.
     *
     * @param {PoolUpdatePropertiesOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updatePropertiesWithHttpOperationResponse(poolId, poolUpdatePropertiesParameter, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolUpdatePropertiesOptions = (options && options.poolUpdatePropertiesOptions !== undefined) ? options.poolUpdatePropertiesOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (poolUpdatePropertiesParameter === null || poolUpdatePropertiesParameter === undefined) {
                    throw new Error('poolUpdatePropertiesParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolUpdatePropertiesOptions !== null && poolUpdatePropertiesOptions !== undefined) {
                    timeout = poolUpdatePropertiesOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolUpdatePropertiesOptions !== null && poolUpdatePropertiesOptions !== undefined) {
                    clientRequestId = poolUpdatePropertiesOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolUpdatePropertiesOptions !== null && poolUpdatePropertiesOptions !== undefined) {
                    returnClientRequestId = poolUpdatePropertiesOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolUpdatePropertiesOptions !== null && poolUpdatePropertiesOptions !== undefined) {
                    ocpDate = poolUpdatePropertiesOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    poolId,
                    poolUpdatePropertiesParameter,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "pools/{poolId}/updateproperties",
                    urlParameters: [
                        {
                            parameterName: "poolId",
                            mapper: {
                                required: true,
                                serializedName: "poolId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.PoolUpdatePropertiesParameter,
                    requestBodyName: "poolUpdatePropertiesParameter",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 204) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 204) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.PoolUpdatePropertiesHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Upgrades the operating system of the specified pool.
     *
     * During an upgrade, the Batch service upgrades each compute node in the pool.
     * When a compute node is chosen for upgrade, any tasks running on that node
     * are removed from the node and returned to the queue to be rerun later (or on
     * a different compute node). The node will be unavailable until the upgrade is
     * complete. This operation results in temporarily reduced pool capacity as
     * nodes are taken out of service to be upgraded. Although the Batch service
     * tries to avoid upgrading all compute nodes at the same time, it does not
     * guarantee to do this (particularly on small pools); therefore, the pool may
     * be temporarily unavailable to run tasks. When this operation runs, the pool
     * state changes to upgrading. When all compute nodes have finished upgrading,
     * the pool state returns to active. While the upgrade is in progress, the
     * pool's currentOSVersion reflects the OS version that nodes are upgrading
     * from, and targetOSVersion reflects the OS version that nodes are upgrading
     * to. Once the upgrade is complete, currentOSVersion is updated to reflect the
     * OS version now running on all nodes. This operation can only be invoked on
     * pools created with the cloudServiceConfiguration property.
     *
     * @param {string} poolId The ID of the pool to upgrade.
     *
     * @param {PoolUpgradeOSParameter} poolUpgradeOSParameter The parameters for
     * the request.
     *
     * @param {PoolUpgradeOSOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    upgradeOSWithHttpOperationResponse(poolId, poolUpgradeOSParameter, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolUpgradeOSOptions = (options && options.poolUpgradeOSOptions !== undefined) ? options.poolUpgradeOSOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (poolUpgradeOSParameter === null || poolUpgradeOSParameter === undefined) {
                    throw new Error('poolUpgradeOSParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    timeout = poolUpgradeOSOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    clientRequestId = poolUpgradeOSOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    returnClientRequestId = poolUpgradeOSOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    ocpDate = poolUpgradeOSOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    ifMatch = poolUpgradeOSOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    ifNoneMatch = poolUpgradeOSOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    ifModifiedSince = poolUpgradeOSOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    ifUnmodifiedSince = poolUpgradeOSOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    poolId,
                    poolUpgradeOSParameter,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "pools/{poolId}/upgradeos",
                    urlParameters: [
                        {
                            parameterName: "poolId",
                            mapper: {
                                required: true,
                                serializedName: "poolId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.PoolUpgradeOSParameter,
                    requestBodyName: "poolUpgradeOSParameter",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 202) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.PoolUpgradeOSHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Removes compute nodes from the specified pool.
     *
     * This operation can only run when the allocation state of the pool is steady.
     * When this operation runs, the allocation state changes from steady to
     * resizing.
     *
     * @param {string} poolId The ID of the pool from which you want to remove
     * nodes.
     *
     * @param {NodeRemoveParameter} nodeRemoveParameter The parameters for the
     * request.
     *
     * @param {PoolRemoveNodesOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    removeNodesWithHttpOperationResponse(poolId, nodeRemoveParameter, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolRemoveNodesOptions = (options && options.poolRemoveNodesOptions !== undefined) ? options.poolRemoveNodesOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeRemoveParameter === null || nodeRemoveParameter === undefined) {
                    throw new Error('nodeRemoveParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    timeout = poolRemoveNodesOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    clientRequestId = poolRemoveNodesOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    returnClientRequestId = poolRemoveNodesOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    ocpDate = poolRemoveNodesOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    ifMatch = poolRemoveNodesOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    ifNoneMatch = poolRemoveNodesOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    ifModifiedSince = poolRemoveNodesOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    ifUnmodifiedSince = poolRemoveNodesOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    poolId,
                    nodeRemoveParameter,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "pools/{poolId}/removenodes",
                    urlParameters: [
                        {
                            parameterName: "poolId",
                            mapper: {
                                required: true,
                                serializedName: "poolId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.NodeRemoveParameter,
                    requestBodyName: "nodeRemoveParameter",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 202) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.PoolRemoveNodesHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the usage metrics, aggregated by pool across individual time
     * intervals, for the specified account.
     *
     * If you do not specify a $filter clause including a poolId, the response
     * includes all pools that existed in the account in the time range of the
     * returned aggregation intervals. If you do not specify a $filter clause
     * including a startTime or endTime these filters default to the start and end
     * times of the last aggregation interval currently available; that is, only
     * the last aggregation interval is returned.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {PoolListUsageMetricsNextOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listUsageMetricsNextWithHttpOperationResponse(nextPageLink, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolListUsageMetricsNextOptions = (options && options.poolListUsageMetricsNextOptions !== undefined) ? options.poolListUsageMetricsNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolListUsageMetricsNextOptions !== null && poolListUsageMetricsNextOptions !== undefined) {
                    clientRequestId = poolListUsageMetricsNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolListUsageMetricsNextOptions !== null && poolListUsageMetricsNextOptions !== undefined) {
                    returnClientRequestId = poolListUsageMetricsNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolListUsageMetricsNextOptions !== null && poolListUsageMetricsNextOptions !== undefined) {
                    ocpDate = poolListUsageMetricsNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    nextPageLink,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: "https://batch.core.windows.net",
                    path: "{nextLink}",
                    urlParameters: [
                        {
                            parameterName: "nextPageLink",
                            skipEncoding: true,
                            mapper: {
                                required: true,
                                serializedName: "nextLink",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.PoolListUsageMetricsResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.PoolListUsageMetricsHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the pools in the specified account.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {PoolListNextOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNextWithHttpOperationResponse(nextPageLink, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolListNextOptions = (options && options.poolListNextOptions !== undefined) ? options.poolListNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolListNextOptions !== null && poolListNextOptions !== undefined) {
                    clientRequestId = poolListNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolListNextOptions !== null && poolListNextOptions !== undefined) {
                    returnClientRequestId = poolListNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolListNextOptions !== null && poolListNextOptions !== undefined) {
                    ocpDate = poolListNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    nextPageLink,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: "https://batch.core.windows.net",
                    path: "{nextLink}",
                    urlParameters: [
                        {
                            parameterName: "nextPageLink",
                            skipEncoding: true,
                            mapper: {
                                required: true,
                                serializedName: "nextLink",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.CloudPoolListResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.PoolListHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    listUsageMetrics(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listUsageMetricsWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listUsageMetricsWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getAllLifetimeStatistics(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getAllLifetimeStatisticsWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getAllLifetimeStatisticsWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    add(pool, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.addWithHttpOperationResponse(pool, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.addWithHttpOperationResponse(pool, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    list(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    deleteMethod(poolId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteMethodWithHttpOperationResponse(poolId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deleteMethodWithHttpOperationResponse(poolId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    exists(poolId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.existsWithHttpOperationResponse(poolId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.existsWithHttpOperationResponse(poolId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    get(poolId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(poolId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getWithHttpOperationResponse(poolId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    patch(poolId, poolPatchParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.patchWithHttpOperationResponse(poolId, poolPatchParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.patchWithHttpOperationResponse(poolId, poolPatchParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    disableAutoScale(poolId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.disableAutoScaleWithHttpOperationResponse(poolId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.disableAutoScaleWithHttpOperationResponse(poolId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    enableAutoScale(poolId, poolEnableAutoScaleParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.enableAutoScaleWithHttpOperationResponse(poolId, poolEnableAutoScaleParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.enableAutoScaleWithHttpOperationResponse(poolId, poolEnableAutoScaleParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    evaluateAutoScale(poolId, poolEvaluateAutoScaleParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.evaluateAutoScaleWithHttpOperationResponse(poolId, poolEvaluateAutoScaleParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.evaluateAutoScaleWithHttpOperationResponse(poolId, poolEvaluateAutoScaleParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    resize(poolId, poolResizeParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.resizeWithHttpOperationResponse(poolId, poolResizeParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.resizeWithHttpOperationResponse(poolId, poolResizeParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    stopResize(poolId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.stopResizeWithHttpOperationResponse(poolId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.stopResizeWithHttpOperationResponse(poolId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    updateProperties(poolId, poolUpdatePropertiesParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.updatePropertiesWithHttpOperationResponse(poolId, poolUpdatePropertiesParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.updatePropertiesWithHttpOperationResponse(poolId, poolUpdatePropertiesParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    upgradeOS(poolId, poolUpgradeOSParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.upgradeOSWithHttpOperationResponse(poolId, poolUpgradeOSParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.upgradeOSWithHttpOperationResponse(poolId, poolUpgradeOSParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    removeNodes(poolId, nodeRemoveParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.removeNodesWithHttpOperationResponse(poolId, nodeRemoveParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.removeNodesWithHttpOperationResponse(poolId, nodeRemoveParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    listUsageMetricsNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listUsageMetricsNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listUsageMetricsNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    listNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
}
exports.Pool = Pool;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(2);
const msRest = __webpack_require__(1);
const Mappers = __webpack_require__(0);
const WebResource = msRest.WebResource;
/** Class representing a Account. */
class Account {
    /**
     * Create a Account.
     * @param {BatchServiceClientContext} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Lists all node agent SKUs supported by the Azure Batch service.
     *
     * @param {AccountListNodeAgentSkusOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNodeAgentSkusWithHttpOperationResponse(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let accountListNodeAgentSkusOptions = (options && options.accountListNodeAgentSkusOptions !== undefined) ? options.accountListNodeAgentSkusOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (accountListNodeAgentSkusOptions !== null && accountListNodeAgentSkusOptions !== undefined) {
                    filter = accountListNodeAgentSkusOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (accountListNodeAgentSkusOptions !== null && accountListNodeAgentSkusOptions !== undefined) {
                    maxResults = accountListNodeAgentSkusOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (accountListNodeAgentSkusOptions !== null && accountListNodeAgentSkusOptions !== undefined) {
                    timeout = accountListNodeAgentSkusOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (accountListNodeAgentSkusOptions !== null && accountListNodeAgentSkusOptions !== undefined) {
                    clientRequestId = accountListNodeAgentSkusOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (accountListNodeAgentSkusOptions !== null && accountListNodeAgentSkusOptions !== undefined) {
                    returnClientRequestId = accountListNodeAgentSkusOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (accountListNodeAgentSkusOptions !== null && accountListNodeAgentSkusOptions !== undefined) {
                    ocpDate = accountListNodeAgentSkusOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    filter,
                    maxResults,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "nodeagentskus",
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "filter",
                            mapper: {
                                serializedName: "$filter",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "maxResults",
                            mapper: {
                                serializedName: "maxresults",
                                defaultValue: 1000,
                                constraints: {
                                    InclusiveMaximum: 1000,
                                    InclusiveMinimum: 1
                                },
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.AccountListNodeAgentSkusResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.AccountListNodeAgentSkusHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets the number of nodes in each state, grouped by pool.
     *
     * @param {AccountListPoolNodeCountsOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listPoolNodeCountsWithHttpOperationResponse(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let accountListPoolNodeCountsOptions = (options && options.accountListPoolNodeCountsOptions !== undefined) ? options.accountListPoolNodeCountsOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (accountListPoolNodeCountsOptions !== null && accountListPoolNodeCountsOptions !== undefined) {
                    filter = accountListPoolNodeCountsOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (accountListPoolNodeCountsOptions !== null && accountListPoolNodeCountsOptions !== undefined) {
                    maxResults = accountListPoolNodeCountsOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (accountListPoolNodeCountsOptions !== null && accountListPoolNodeCountsOptions !== undefined) {
                    timeout = accountListPoolNodeCountsOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (accountListPoolNodeCountsOptions !== null && accountListPoolNodeCountsOptions !== undefined) {
                    clientRequestId = accountListPoolNodeCountsOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (accountListPoolNodeCountsOptions !== null && accountListPoolNodeCountsOptions !== undefined) {
                    returnClientRequestId = accountListPoolNodeCountsOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (accountListPoolNodeCountsOptions !== null && accountListPoolNodeCountsOptions !== undefined) {
                    ocpDate = accountListPoolNodeCountsOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    filter,
                    maxResults,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "nodecounts",
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "filter",
                            mapper: {
                                serializedName: "$filter",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "maxResults",
                            mapper: {
                                serializedName: "maxresults",
                                defaultValue: 10,
                                constraints: {
                                    InclusiveMaximum: 10,
                                    InclusiveMinimum: 1
                                },
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.PoolNodeCountsListResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.AccountListPoolNodeCountsHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all node agent SKUs supported by the Azure Batch service.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {AccountListNodeAgentSkusNextOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNodeAgentSkusNextWithHttpOperationResponse(nextPageLink, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let accountListNodeAgentSkusNextOptions = (options && options.accountListNodeAgentSkusNextOptions !== undefined) ? options.accountListNodeAgentSkusNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (accountListNodeAgentSkusNextOptions !== null && accountListNodeAgentSkusNextOptions !== undefined) {
                    clientRequestId = accountListNodeAgentSkusNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (accountListNodeAgentSkusNextOptions !== null && accountListNodeAgentSkusNextOptions !== undefined) {
                    returnClientRequestId = accountListNodeAgentSkusNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (accountListNodeAgentSkusNextOptions !== null && accountListNodeAgentSkusNextOptions !== undefined) {
                    ocpDate = accountListNodeAgentSkusNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    nextPageLink,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: "https://batch.core.windows.net",
                    path: "{nextLink}",
                    urlParameters: [
                        {
                            parameterName: "nextPageLink",
                            skipEncoding: true,
                            mapper: {
                                required: true,
                                serializedName: "nextLink",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.AccountListNodeAgentSkusResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.AccountListNodeAgentSkusHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets the number of nodes in each state, grouped by pool.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {AccountListPoolNodeCountsNextOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listPoolNodeCountsNextWithHttpOperationResponse(nextPageLink, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let accountListPoolNodeCountsNextOptions = (options && options.accountListPoolNodeCountsNextOptions !== undefined) ? options.accountListPoolNodeCountsNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (accountListPoolNodeCountsNextOptions !== null && accountListPoolNodeCountsNextOptions !== undefined) {
                    clientRequestId = accountListPoolNodeCountsNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (accountListPoolNodeCountsNextOptions !== null && accountListPoolNodeCountsNextOptions !== undefined) {
                    returnClientRequestId = accountListPoolNodeCountsNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (accountListPoolNodeCountsNextOptions !== null && accountListPoolNodeCountsNextOptions !== undefined) {
                    ocpDate = accountListPoolNodeCountsNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    nextPageLink,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: "https://batch.core.windows.net",
                    path: "{nextLink}",
                    urlParameters: [
                        {
                            parameterName: "nextPageLink",
                            skipEncoding: true,
                            mapper: {
                                required: true,
                                serializedName: "nextLink",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.PoolNodeCountsListResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.AccountListPoolNodeCountsHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    listNodeAgentSkus(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNodeAgentSkusWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listNodeAgentSkusWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    listPoolNodeCounts(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listPoolNodeCountsWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listPoolNodeCountsWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    listNodeAgentSkusNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNodeAgentSkusNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listNodeAgentSkusNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    listPoolNodeCountsNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listPoolNodeCountsNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listPoolNodeCountsNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
}
exports.Account = Account;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(2);
const msRest = __webpack_require__(1);
const Mappers = __webpack_require__(0);
const WebResource = msRest.WebResource;
/** Class representing a Job. */
class Job {
    /**
     * Create a Job.
     * @param {BatchServiceClientContext} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Gets lifetime summary statistics for all of the jobs in the
     * specified account.
     *
     * Statistics are aggregated across all jobs that have ever existed in the
     * account, from account creation to the last update time of the statistics.
     * The statistics may not be immediately available. The Batch service performs
     * periodic roll-up of statistics. The typical delay is about 30 minutes.
     *
     * @param {JobGetAllLifetimeStatisticsOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getAllLifetimeStatisticsWithHttpOperationResponse(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobGetAllLifetimeStatisticsOptions = (options && options.jobGetAllLifetimeStatisticsOptions !== undefined) ? options.jobGetAllLifetimeStatisticsOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobGetAllLifetimeStatisticsOptions !== null && jobGetAllLifetimeStatisticsOptions !== undefined) {
                    timeout = jobGetAllLifetimeStatisticsOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobGetAllLifetimeStatisticsOptions !== null && jobGetAllLifetimeStatisticsOptions !== undefined) {
                    clientRequestId = jobGetAllLifetimeStatisticsOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobGetAllLifetimeStatisticsOptions !== null && jobGetAllLifetimeStatisticsOptions !== undefined) {
                    returnClientRequestId = jobGetAllLifetimeStatisticsOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobGetAllLifetimeStatisticsOptions !== null && jobGetAllLifetimeStatisticsOptions !== undefined) {
                    ocpDate = jobGetAllLifetimeStatisticsOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "lifetimejobstats",
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.JobStatistics;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobGetAllLifetimeStatisticsHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Deletes a job.
     *
     * Deleting a job also deletes all tasks that are part of that job, and all job
     * statistics. This also overrides the retention period for task data; that is,
     * if the job contains tasks which are still retained on compute nodes, the
     * Batch services deletes those tasks' working directories and all their
     * contents.  When a Delete Job request is received, the Batch service sets the
     * job to the deleting state. All update operations on a job that is in
     * deleting state will fail with status code 409 (Conflict), with additional
     * information indicating that the job is being deleted.
     *
     * @param {string} jobId The ID of the job to delete.
     *
     * @param {JobDeleteMethodOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(jobId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobDeleteMethodOptions = (options && options.jobDeleteMethodOptions !== undefined) ? options.jobDeleteMethodOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    timeout = jobDeleteMethodOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    clientRequestId = jobDeleteMethodOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    returnClientRequestId = jobDeleteMethodOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    ocpDate = jobDeleteMethodOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    ifMatch = jobDeleteMethodOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    ifNoneMatch = jobDeleteMethodOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    ifModifiedSince = jobDeleteMethodOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    ifUnmodifiedSince = jobDeleteMethodOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 202) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobDeleteHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets information about the specified job.
     *
     * @param {string} jobId The ID of the job.
     *
     * @param {JobGetOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(jobId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobGetOptions = (options && options.jobGetOptions !== undefined) ? options.jobGetOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let select;
            let expand;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    select = jobGetOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    expand = jobGetOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    timeout = jobGetOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    clientRequestId = jobGetOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    returnClientRequestId = jobGetOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    ocpDate = jobGetOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    ifMatch = jobGetOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    ifNoneMatch = jobGetOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    ifModifiedSince = jobGetOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    ifUnmodifiedSince = jobGetOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    select,
                    expand,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "select",
                            mapper: {
                                serializedName: "$select",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "expand",
                            mapper: {
                                serializedName: "$expand",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.CloudJob;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobGetHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Updates the properties of the specified job.
     *
     * This replaces only the job properties specified in the request. For example,
     * if the job has constraints, and a request does not specify the constraints
     * element, then the job keeps the existing constraints.
     *
     * @param {string} jobId The ID of the job whose properties you want to update.
     *
     * @param {JobPatchParameter} jobPatchParameter The parameters for the request.
     *
     * @param {JobPatchOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    patchWithHttpOperationResponse(jobId, jobPatchParameter, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobPatchOptions = (options && options.jobPatchOptions !== undefined) ? options.jobPatchOptions : undefined;
            if (jobPatchParameter === null || jobPatchParameter === undefined) {
                jobPatchParameter = {};
            }
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (jobPatchParameter === null || jobPatchParameter === undefined) {
                    throw new Error('jobPatchParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    timeout = jobPatchOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    clientRequestId = jobPatchOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    returnClientRequestId = jobPatchOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    ocpDate = jobPatchOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    ifMatch = jobPatchOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    ifNoneMatch = jobPatchOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    ifModifiedSince = jobPatchOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    ifUnmodifiedSince = jobPatchOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    jobPatchParameter,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PATCH",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.JobPatchParameter,
                    requestBodyName: "jobPatchParameter",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobPatchHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Updates the properties of the specified job.
     *
     * This fully replaces all the updateable properties of the job. For example,
     * if the job has constraints associated with it and if constraints is not
     * specified with this request, then the Batch service will remove the existing
     * constraints.
     *
     * @param {string} jobId The ID of the job whose properties you want to update.
     *
     * @param {JobUpdateParameter} jobUpdateParameter The parameters for the
     * request.
     *
     * @param {JobUpdateOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updateWithHttpOperationResponse(jobId, jobUpdateParameter, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobUpdateOptions = (options && options.jobUpdateOptions !== undefined) ? options.jobUpdateOptions : undefined;
            if (jobUpdateParameter === null || jobUpdateParameter === undefined) {
                jobUpdateParameter = {};
            }
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (jobUpdateParameter === null || jobUpdateParameter === undefined) {
                    throw new Error('jobUpdateParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    timeout = jobUpdateOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    clientRequestId = jobUpdateOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    returnClientRequestId = jobUpdateOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    ocpDate = jobUpdateOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    ifMatch = jobUpdateOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    ifNoneMatch = jobUpdateOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    ifModifiedSince = jobUpdateOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    ifUnmodifiedSince = jobUpdateOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    jobUpdateParameter,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PUT",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.JobUpdateParameter,
                    requestBodyName: "jobUpdateParameter",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobUpdateHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Disables the specified job, preventing new tasks from running.
     *
     * The Batch Service immediately moves the job to the disabling state. Batch
     * then uses the disableTasks parameter to determine what to do with the
     * currently running tasks of the job. The job remains in the disabling state
     * until the disable operation is completed and all tasks have been dealt with
     * according to the disableTasks option; the job then moves to the disabled
     * state. No new tasks are started under the job until it moves back to active
     * state. If you try to disable a job that is in any state other than active,
     * disabling, or disabled, the request fails with status code 409.
     *
     * @param {string} jobId The ID of the job to disable.
     *
     * @param {JobDisableParameter} jobDisableParameter The parameters for the
     * request.
     *
     * @param {JobDisableOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    disableWithHttpOperationResponse(jobId, jobDisableParameter, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobDisableOptions = (options && options.jobDisableOptions !== undefined) ? options.jobDisableOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (jobDisableParameter === null || jobDisableParameter === undefined) {
                    throw new Error('jobDisableParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    timeout = jobDisableOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    clientRequestId = jobDisableOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    returnClientRequestId = jobDisableOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    ocpDate = jobDisableOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    ifMatch = jobDisableOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    ifNoneMatch = jobDisableOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    ifModifiedSince = jobDisableOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    ifUnmodifiedSince = jobDisableOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    jobDisableParameter,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}/disable",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.JobDisableParameter,
                    requestBodyName: "jobDisableParameter",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 202) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobDisableHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Enables the specified job, allowing new tasks to run.
     *
     * When you call this API, the Batch service sets a disabled job to the
     * enabling state. After the this operation is completed, the job moves to the
     * active state, and scheduling of new tasks under the job resumes. The Batch
     * service does not allow a task to remain in the active state for more than 7
     * days. Therefore, if you enable a job containing active tasks which were
     * added more than 7 days ago, those tasks will not run.
     *
     * @param {string} jobId The ID of the job to enable.
     *
     * @param {JobEnableOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    enableWithHttpOperationResponse(jobId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobEnableOptions = (options && options.jobEnableOptions !== undefined) ? options.jobEnableOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    timeout = jobEnableOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    clientRequestId = jobEnableOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    returnClientRequestId = jobEnableOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    ocpDate = jobEnableOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    ifMatch = jobEnableOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    ifNoneMatch = jobEnableOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    ifModifiedSince = jobEnableOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    ifUnmodifiedSince = jobEnableOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}/enable",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 202) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobEnableHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Terminates the specified job, marking it as completed.
     *
     * When a Terminate Job request is received, the Batch service sets the job to
     * the terminating state. The Batch service then terminates any running tasks
     * associated with the job and runs any required job release tasks. Then the
     * job moves into the completed state. If there are any tasks in the job in the
     * active state, they will remain in the active state. Once a job is
     * terminated, new tasks cannot be added and any remaining active tasks will
     * not be scheduled.
     *
     * @param {string} jobId The ID of the job to terminate.
     *
     * @param {JobTerminateOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    terminateWithHttpOperationResponse(jobId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobTerminateParameter = (options && options.jobTerminateParameter !== undefined) ? options.jobTerminateParameter : undefined;
            let jobTerminateOptions = (options && options.jobTerminateOptions !== undefined) ? options.jobTerminateOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    timeout = jobTerminateOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    clientRequestId = jobTerminateOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    returnClientRequestId = jobTerminateOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    ocpDate = jobTerminateOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    ifMatch = jobTerminateOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    ifNoneMatch = jobTerminateOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    ifModifiedSince = jobTerminateOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    ifUnmodifiedSince = jobTerminateOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    jobTerminateParameter,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}/terminate",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.JobTerminateParameter,
                    requestBodyName: "jobTerminateParameter",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 202) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobTerminateHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Adds a job to the specified account.
     *
     * The Batch service supports two ways to control the work done as part of a
     * job. In the first approach, the user specifies a Job Manager task. The Batch
     * service launches this task when it is ready to start the job. The Job
     * Manager task controls all other tasks that run under this job, by using the
     * Task APIs. In the second approach, the user directly controls the execution
     * of tasks under an active job, by using the Task APIs. Also note: when naming
     * jobs, avoid including sensitive information such as user names or secret
     * project names. This information may appear in telemetry logs accessible to
     * Microsoft Support engineers.
     *
     * @param {JobAddParameter} job The job to be added.
     *
     * @param {JobAddOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addWithHttpOperationResponse(job, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobAddOptions = (options && options.jobAddOptions !== undefined) ? options.jobAddOptions : undefined;
            if (job === null || job === undefined) {
                job = {};
            }
            // Validate
            try {
                if (job === null || job === undefined) {
                    throw new Error('job cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobAddOptions !== null && jobAddOptions !== undefined) {
                    timeout = jobAddOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobAddOptions !== null && jobAddOptions !== undefined) {
                    clientRequestId = jobAddOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobAddOptions !== null && jobAddOptions !== undefined) {
                    returnClientRequestId = jobAddOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobAddOptions !== null && jobAddOptions !== undefined) {
                    ocpDate = jobAddOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    job,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "jobs",
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.JobAddParameter,
                    requestBodyName: "job",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 201) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 201) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobAddHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the jobs in the specified account.
     *
     * @param {JobListOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobListOptions = (options && options.jobListOptions !== undefined) ? options.jobListOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let select;
            let expand;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    filter = jobListOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    select = jobListOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    expand = jobListOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    maxResults = jobListOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    timeout = jobListOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    clientRequestId = jobListOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    returnClientRequestId = jobListOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    ocpDate = jobListOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    filter,
                    select,
                    expand,
                    maxResults,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "jobs",
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "filter",
                            mapper: {
                                serializedName: "$filter",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "select",
                            mapper: {
                                serializedName: "$select",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "expand",
                            mapper: {
                                serializedName: "$expand",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "maxResults",
                            mapper: {
                                serializedName: "maxresults",
                                defaultValue: 1000,
                                constraints: {
                                    InclusiveMaximum: 1000,
                                    InclusiveMinimum: 1
                                },
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.CloudJobListResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobListHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the jobs that have been created under the specified job
     * schedule.
     *
     * @param {string} jobScheduleId The ID of the job schedule from which you want
     * to get a list of jobs.
     *
     * @param {JobListFromJobScheduleOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listFromJobScheduleWithHttpOperationResponse(jobScheduleId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobListFromJobScheduleOptions = (options && options.jobListFromJobScheduleOptions !== undefined) ? options.jobListFromJobScheduleOptions : undefined;
            // Validate
            try {
                if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
                    throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let select;
            let expand;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    filter = jobListFromJobScheduleOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    select = jobListFromJobScheduleOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    expand = jobListFromJobScheduleOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    maxResults = jobListFromJobScheduleOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    timeout = jobListFromJobScheduleOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    clientRequestId = jobListFromJobScheduleOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    returnClientRequestId = jobListFromJobScheduleOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    ocpDate = jobListFromJobScheduleOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobScheduleId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    filter,
                    select,
                    expand,
                    maxResults,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "jobschedules/{jobScheduleId}/jobs",
                    urlParameters: [
                        {
                            parameterName: "jobScheduleId",
                            mapper: {
                                required: true,
                                serializedName: "jobScheduleId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "filter",
                            mapper: {
                                serializedName: "$filter",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "select",
                            mapper: {
                                serializedName: "$select",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "expand",
                            mapper: {
                                serializedName: "$expand",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "maxResults",
                            mapper: {
                                serializedName: "maxresults",
                                defaultValue: 1000,
                                constraints: {
                                    InclusiveMaximum: 1000,
                                    InclusiveMinimum: 1
                                },
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.CloudJobListResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobListFromJobScheduleHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the execution status of the Job Preparation and Job Release
     * task for the specified job across the compute nodes where the job has run.
     *
     * This API returns the Job Preparation and Job Release task status on all
     * compute nodes that have run the Job Preparation or Job Release task. This
     * includes nodes which have since been removed from the pool. If this API is
     * invoked on a job which has no Job Preparation or Job Release task, the Batch
     * service returns HTTP status code 409 (Conflict) with an error code of
     * JobPreparationTaskNotSpecified.
     *
     * @param {string} jobId The ID of the job.
     *
     * @param {JobListPreparationAndReleaseTaskStatusOptionalParams} [options]
     * Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listPreparationAndReleaseTaskStatusWithHttpOperationResponse(jobId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobListPreparationAndReleaseTaskStatusOptions = (options && options.jobListPreparationAndReleaseTaskStatusOptions !== undefined) ? options.jobListPreparationAndReleaseTaskStatusOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let select;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
                    filter = jobListPreparationAndReleaseTaskStatusOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
                    select = jobListPreparationAndReleaseTaskStatusOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
                    maxResults = jobListPreparationAndReleaseTaskStatusOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
                    timeout = jobListPreparationAndReleaseTaskStatusOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
                    clientRequestId = jobListPreparationAndReleaseTaskStatusOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
                    returnClientRequestId = jobListPreparationAndReleaseTaskStatusOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
                    ocpDate = jobListPreparationAndReleaseTaskStatusOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    filter,
                    select,
                    maxResults,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}/jobpreparationandreleasetaskstatus",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "filter",
                            mapper: {
                                serializedName: "$filter",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "select",
                            mapper: {
                                serializedName: "$select",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "maxResults",
                            mapper: {
                                serializedName: "maxresults",
                                defaultValue: 1000,
                                constraints: {
                                    InclusiveMaximum: 1000,
                                    InclusiveMinimum: 1
                                },
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.CloudJobListPreparationAndReleaseTaskStatusResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobListPreparationAndReleaseTaskStatusHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets the task counts for the specified job.
     *
     * Task counts provide a count of the tasks by active, running or completed
     * task state, and a count of tasks which succeeded or failed. Tasks in the
     * preparing state are counted as running. If the validationStatus is
     * unvalidated, then the Batch service has not been able to check state counts
     * against the task states as reported in the List Tasks API. The
     * validationStatus may be unvalidated if the job contains more than 200,000
     * tasks.
     *
     * @param {string} jobId The ID of the job.
     *
     * @param {JobGetTaskCountsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getTaskCountsWithHttpOperationResponse(jobId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobGetTaskCountsOptions = (options && options.jobGetTaskCountsOptions !== undefined) ? options.jobGetTaskCountsOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobGetTaskCountsOptions !== null && jobGetTaskCountsOptions !== undefined) {
                    timeout = jobGetTaskCountsOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobGetTaskCountsOptions !== null && jobGetTaskCountsOptions !== undefined) {
                    clientRequestId = jobGetTaskCountsOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobGetTaskCountsOptions !== null && jobGetTaskCountsOptions !== undefined) {
                    returnClientRequestId = jobGetTaskCountsOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobGetTaskCountsOptions !== null && jobGetTaskCountsOptions !== undefined) {
                    ocpDate = jobGetTaskCountsOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}/taskcounts",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.TaskCounts;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobGetTaskCountsHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the jobs in the specified account.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {JobListNextOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNextWithHttpOperationResponse(nextPageLink, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobListNextOptions = (options && options.jobListNextOptions !== undefined) ? options.jobListNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobListNextOptions !== null && jobListNextOptions !== undefined) {
                    clientRequestId = jobListNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobListNextOptions !== null && jobListNextOptions !== undefined) {
                    returnClientRequestId = jobListNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobListNextOptions !== null && jobListNextOptions !== undefined) {
                    ocpDate = jobListNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    nextPageLink,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: "https://batch.core.windows.net",
                    path: "{nextLink}",
                    urlParameters: [
                        {
                            parameterName: "nextPageLink",
                            skipEncoding: true,
                            mapper: {
                                required: true,
                                serializedName: "nextLink",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.CloudJobListResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobListHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the jobs that have been created under the specified job
     * schedule.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {JobListFromJobScheduleNextOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listFromJobScheduleNextWithHttpOperationResponse(nextPageLink, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobListFromJobScheduleNextOptions = (options && options.jobListFromJobScheduleNextOptions !== undefined) ? options.jobListFromJobScheduleNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobListFromJobScheduleNextOptions !== null && jobListFromJobScheduleNextOptions !== undefined) {
                    clientRequestId = jobListFromJobScheduleNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobListFromJobScheduleNextOptions !== null && jobListFromJobScheduleNextOptions !== undefined) {
                    returnClientRequestId = jobListFromJobScheduleNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobListFromJobScheduleNextOptions !== null && jobListFromJobScheduleNextOptions !== undefined) {
                    ocpDate = jobListFromJobScheduleNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    nextPageLink,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: "https://batch.core.windows.net",
                    path: "{nextLink}",
                    urlParameters: [
                        {
                            parameterName: "nextPageLink",
                            skipEncoding: true,
                            mapper: {
                                required: true,
                                serializedName: "nextLink",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.CloudJobListResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobListFromJobScheduleHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the execution status of the Job Preparation and Job Release
     * task for the specified job across the compute nodes where the job has run.
     *
     * This API returns the Job Preparation and Job Release task status on all
     * compute nodes that have run the Job Preparation or Job Release task. This
     * includes nodes which have since been removed from the pool. If this API is
     * invoked on a job which has no Job Preparation or Job Release task, the Batch
     * service returns HTTP status code 409 (Conflict) with an error code of
     * JobPreparationTaskNotSpecified.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {JobListPreparationAndReleaseTaskStatusNextOptionalParams} [options]
     * Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listPreparationAndReleaseTaskStatusNextWithHttpOperationResponse(nextPageLink, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobListPreparationAndReleaseTaskStatusNextOptions = (options && options.jobListPreparationAndReleaseTaskStatusNextOptions !== undefined) ? options.jobListPreparationAndReleaseTaskStatusNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobListPreparationAndReleaseTaskStatusNextOptions !== null && jobListPreparationAndReleaseTaskStatusNextOptions !== undefined) {
                    clientRequestId = jobListPreparationAndReleaseTaskStatusNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusNextOptions !== null && jobListPreparationAndReleaseTaskStatusNextOptions !== undefined) {
                    returnClientRequestId = jobListPreparationAndReleaseTaskStatusNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusNextOptions !== null && jobListPreparationAndReleaseTaskStatusNextOptions !== undefined) {
                    ocpDate = jobListPreparationAndReleaseTaskStatusNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    nextPageLink,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: "https://batch.core.windows.net",
                    path: "{nextLink}",
                    urlParameters: [
                        {
                            parameterName: "nextPageLink",
                            skipEncoding: true,
                            mapper: {
                                required: true,
                                serializedName: "nextLink",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.CloudJobListPreparationAndReleaseTaskStatusResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobListPreparationAndReleaseTaskStatusHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    getAllLifetimeStatistics(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getAllLifetimeStatisticsWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getAllLifetimeStatisticsWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    deleteMethod(jobId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteMethodWithHttpOperationResponse(jobId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deleteMethodWithHttpOperationResponse(jobId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    get(jobId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(jobId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getWithHttpOperationResponse(jobId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    patch(jobId, jobPatchParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.patchWithHttpOperationResponse(jobId, jobPatchParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.patchWithHttpOperationResponse(jobId, jobPatchParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    update(jobId, jobUpdateParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.updateWithHttpOperationResponse(jobId, jobUpdateParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.updateWithHttpOperationResponse(jobId, jobUpdateParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    disable(jobId, jobDisableParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.disableWithHttpOperationResponse(jobId, jobDisableParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.disableWithHttpOperationResponse(jobId, jobDisableParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    enable(jobId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.enableWithHttpOperationResponse(jobId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.enableWithHttpOperationResponse(jobId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    terminate(jobId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.terminateWithHttpOperationResponse(jobId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.terminateWithHttpOperationResponse(jobId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    add(job, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.addWithHttpOperationResponse(job, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.addWithHttpOperationResponse(job, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    list(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    listFromJobSchedule(jobScheduleId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listFromJobScheduleWithHttpOperationResponse(jobScheduleId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listFromJobScheduleWithHttpOperationResponse(jobScheduleId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    listPreparationAndReleaseTaskStatus(jobId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listPreparationAndReleaseTaskStatusWithHttpOperationResponse(jobId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listPreparationAndReleaseTaskStatusWithHttpOperationResponse(jobId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getTaskCounts(jobId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getTaskCountsWithHttpOperationResponse(jobId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getTaskCountsWithHttpOperationResponse(jobId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    listNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    listFromJobScheduleNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listFromJobScheduleNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listFromJobScheduleNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    listPreparationAndReleaseTaskStatusNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listPreparationAndReleaseTaskStatusNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listPreparationAndReleaseTaskStatusNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
}
exports.Job = Job;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(2);
const msRest = __webpack_require__(1);
const Mappers = __webpack_require__(0);
const WebResource = msRest.WebResource;
/** Class representing a CertificateOperations. */
class CertificateOperations {
    /**
     * Create a CertificateOperations.
     * @param {BatchServiceClientContext} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Adds a certificate to the specified account.
     *
     * @param {CertificateAddParameter} certificate The certificate to be added.
     *
     * @param {CertificateAddOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addWithHttpOperationResponse(certificate, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let certificateAddOptions = (options && options.certificateAddOptions !== undefined) ? options.certificateAddOptions : undefined;
            // Validate
            try {
                if (certificate === null || certificate === undefined) {
                    throw new Error('certificate cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (certificateAddOptions !== null && certificateAddOptions !== undefined) {
                    timeout = certificateAddOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (certificateAddOptions !== null && certificateAddOptions !== undefined) {
                    clientRequestId = certificateAddOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (certificateAddOptions !== null && certificateAddOptions !== undefined) {
                    returnClientRequestId = certificateAddOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (certificateAddOptions !== null && certificateAddOptions !== undefined) {
                    ocpDate = certificateAddOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    certificate,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "certificates",
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.CertificateAddParameter,
                    requestBodyName: "certificate",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 201) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 201) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.CertificateAddHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the certificates that have been added to the specified
     * account.
     *
     * @param {CertificateListOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let certificateListOptions = (options && options.certificateListOptions !== undefined) ? options.certificateListOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let select;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (certificateListOptions !== null && certificateListOptions !== undefined) {
                    filter = certificateListOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (certificateListOptions !== null && certificateListOptions !== undefined) {
                    select = certificateListOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (certificateListOptions !== null && certificateListOptions !== undefined) {
                    maxResults = certificateListOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (certificateListOptions !== null && certificateListOptions !== undefined) {
                    timeout = certificateListOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (certificateListOptions !== null && certificateListOptions !== undefined) {
                    clientRequestId = certificateListOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (certificateListOptions !== null && certificateListOptions !== undefined) {
                    returnClientRequestId = certificateListOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (certificateListOptions !== null && certificateListOptions !== undefined) {
                    ocpDate = certificateListOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    filter,
                    select,
                    maxResults,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "certificates",
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "filter",
                            mapper: {
                                serializedName: "$filter",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "select",
                            mapper: {
                                serializedName: "$select",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "maxResults",
                            mapper: {
                                serializedName: "maxresults",
                                defaultValue: 1000,
                                constraints: {
                                    InclusiveMaximum: 1000,
                                    InclusiveMinimum: 1
                                },
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.CertificateListResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.CertificateListHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Cancels a failed deletion of a certificate from the specified
     * account.
     *
     * If you try to delete a certificate that is being used by a pool or compute
     * node, the status of the certificate changes to deleteFailed. If you decide
     * that you want to continue using the certificate, you can use this operation
     * to set the status of the certificate back to active. If you intend to delete
     * the certificate, you do not need to run this operation after the deletion
     * failed. You must make sure that the certificate is not being used by any
     * resources, and then you can try again to delete the certificate.
     *
     * @param {string} thumbprintAlgorithm The algorithm used to derive the
     * thumbprint parameter. This must be sha1.
     *
     * @param {string} thumbprint The thumbprint of the certificate being deleted.
     *
     * @param {CertificateCancelDeletionOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    cancelDeletionWithHttpOperationResponse(thumbprintAlgorithm, thumbprint, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let certificateCancelDeletionOptions = (options && options.certificateCancelDeletionOptions !== undefined) ? options.certificateCancelDeletionOptions : undefined;
            // Validate
            try {
                if (thumbprintAlgorithm === null || thumbprintAlgorithm === undefined || typeof thumbprintAlgorithm.valueOf() !== 'string') {
                    throw new Error('thumbprintAlgorithm cannot be null or undefined and it must be of type string.');
                }
                if (thumbprint === null || thumbprint === undefined || typeof thumbprint.valueOf() !== 'string') {
                    throw new Error('thumbprint cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (certificateCancelDeletionOptions !== null && certificateCancelDeletionOptions !== undefined) {
                    timeout = certificateCancelDeletionOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (certificateCancelDeletionOptions !== null && certificateCancelDeletionOptions !== undefined) {
                    clientRequestId = certificateCancelDeletionOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (certificateCancelDeletionOptions !== null && certificateCancelDeletionOptions !== undefined) {
                    returnClientRequestId = certificateCancelDeletionOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (certificateCancelDeletionOptions !== null && certificateCancelDeletionOptions !== undefined) {
                    ocpDate = certificateCancelDeletionOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    thumbprintAlgorithm,
                    thumbprint,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "certificates(thumbprintAlgorithm={thumbprintAlgorithm},thumbprint={thumbprint})/canceldelete",
                    urlParameters: [
                        {
                            parameterName: "thumbprintAlgorithm",
                            mapper: {
                                required: true,
                                serializedName: "thumbprintAlgorithm",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "thumbprint",
                            mapper: {
                                required: true,
                                serializedName: "thumbprint",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 204) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 204) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.CertificateCancelDeletionHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Deletes a certificate from the specified account.
     *
     * You cannot delete a certificate if a resource (pool or compute node) is
     * using it. Before you can delete a certificate, you must therefore make sure
     * that the certificate is not associated with any existing pools, the
     * certificate is not installed on any compute nodes (even if you remove a
     * certificate from a pool, it is not removed from existing compute nodes in
     * that pool until they restart), and no running tasks depend on the
     * certificate. If you try to delete a certificate that is in use, the deletion
     * fails. The certificate status changes to deleteFailed. You can use Cancel
     * Delete Certificate to set the status back to active if you decide that you
     * want to continue using the certificate.
     *
     * @param {string} thumbprintAlgorithm The algorithm used to derive the
     * thumbprint parameter. This must be sha1.
     *
     * @param {string} thumbprint The thumbprint of the certificate to be deleted.
     *
     * @param {CertificateDeleteMethodOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(thumbprintAlgorithm, thumbprint, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let certificateDeleteMethodOptions = (options && options.certificateDeleteMethodOptions !== undefined) ? options.certificateDeleteMethodOptions : undefined;
            // Validate
            try {
                if (thumbprintAlgorithm === null || thumbprintAlgorithm === undefined || typeof thumbprintAlgorithm.valueOf() !== 'string') {
                    throw new Error('thumbprintAlgorithm cannot be null or undefined and it must be of type string.');
                }
                if (thumbprint === null || thumbprint === undefined || typeof thumbprint.valueOf() !== 'string') {
                    throw new Error('thumbprint cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (certificateDeleteMethodOptions !== null && certificateDeleteMethodOptions !== undefined) {
                    timeout = certificateDeleteMethodOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (certificateDeleteMethodOptions !== null && certificateDeleteMethodOptions !== undefined) {
                    clientRequestId = certificateDeleteMethodOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (certificateDeleteMethodOptions !== null && certificateDeleteMethodOptions !== undefined) {
                    returnClientRequestId = certificateDeleteMethodOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (certificateDeleteMethodOptions !== null && certificateDeleteMethodOptions !== undefined) {
                    ocpDate = certificateDeleteMethodOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    thumbprintAlgorithm,
                    thumbprint,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.client.baseUri,
                    path: "certificates(thumbprintAlgorithm={thumbprintAlgorithm},thumbprint={thumbprint})",
                    urlParameters: [
                        {
                            parameterName: "thumbprintAlgorithm",
                            mapper: {
                                required: true,
                                serializedName: "thumbprintAlgorithm",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "thumbprint",
                            mapper: {
                                required: true,
                                serializedName: "thumbprint",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 202) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.CertificateDeleteHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets information about the specified certificate.
     *
     * @param {string} thumbprintAlgorithm The algorithm used to derive the
     * thumbprint parameter. This must be sha1.
     *
     * @param {string} thumbprint The thumbprint of the certificate to get.
     *
     * @param {CertificateGetOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(thumbprintAlgorithm, thumbprint, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let certificateGetOptions = (options && options.certificateGetOptions !== undefined) ? options.certificateGetOptions : undefined;
            // Validate
            try {
                if (thumbprintAlgorithm === null || thumbprintAlgorithm === undefined || typeof thumbprintAlgorithm.valueOf() !== 'string') {
                    throw new Error('thumbprintAlgorithm cannot be null or undefined and it must be of type string.');
                }
                if (thumbprint === null || thumbprint === undefined || typeof thumbprint.valueOf() !== 'string') {
                    throw new Error('thumbprint cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let select;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (certificateGetOptions !== null && certificateGetOptions !== undefined) {
                    select = certificateGetOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (certificateGetOptions !== null && certificateGetOptions !== undefined) {
                    timeout = certificateGetOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (certificateGetOptions !== null && certificateGetOptions !== undefined) {
                    clientRequestId = certificateGetOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (certificateGetOptions !== null && certificateGetOptions !== undefined) {
                    returnClientRequestId = certificateGetOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (certificateGetOptions !== null && certificateGetOptions !== undefined) {
                    ocpDate = certificateGetOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    thumbprintAlgorithm,
                    thumbprint,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    select,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "certificates(thumbprintAlgorithm={thumbprintAlgorithm},thumbprint={thumbprint})",
                    urlParameters: [
                        {
                            parameterName: "thumbprintAlgorithm",
                            mapper: {
                                required: true,
                                serializedName: "thumbprintAlgorithm",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "thumbprint",
                            mapper: {
                                required: true,
                                serializedName: "thumbprint",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "select",
                            mapper: {
                                serializedName: "$select",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.Certificate;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.CertificateGetHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the certificates that have been added to the specified
     * account.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {CertificateListNextOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNextWithHttpOperationResponse(nextPageLink, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let certificateListNextOptions = (options && options.certificateListNextOptions !== undefined) ? options.certificateListNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (certificateListNextOptions !== null && certificateListNextOptions !== undefined) {
                    clientRequestId = certificateListNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (certificateListNextOptions !== null && certificateListNextOptions !== undefined) {
                    returnClientRequestId = certificateListNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (certificateListNextOptions !== null && certificateListNextOptions !== undefined) {
                    ocpDate = certificateListNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    nextPageLink,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: "https://batch.core.windows.net",
                    path: "{nextLink}",
                    urlParameters: [
                        {
                            parameterName: "nextPageLink",
                            skipEncoding: true,
                            mapper: {
                                required: true,
                                serializedName: "nextLink",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.CertificateListResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.CertificateListHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    add(certificate, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.addWithHttpOperationResponse(certificate, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.addWithHttpOperationResponse(certificate, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    list(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    cancelDeletion(thumbprintAlgorithm, thumbprint, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.cancelDeletionWithHttpOperationResponse(thumbprintAlgorithm, thumbprint, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.cancelDeletionWithHttpOperationResponse(thumbprintAlgorithm, thumbprint, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    deleteMethod(thumbprintAlgorithm, thumbprint, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteMethodWithHttpOperationResponse(thumbprintAlgorithm, thumbprint, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deleteMethodWithHttpOperationResponse(thumbprintAlgorithm, thumbprint, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    get(thumbprintAlgorithm, thumbprint, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(thumbprintAlgorithm, thumbprint, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getWithHttpOperationResponse(thumbprintAlgorithm, thumbprint, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    listNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
}
exports.CertificateOperations = CertificateOperations;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(2);
const msRest = __webpack_require__(1);
const Mappers = __webpack_require__(0);
const WebResource = msRest.WebResource;
/** Class representing a File. */
class File {
    /**
     * Create a File.
     * @param {BatchServiceClientContext} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Deletes the specified task file from the compute node where the
     * task ran.
     *
     * @param {string} jobId The ID of the job that contains the task.
     *
     * @param {string} taskId The ID of the task whose file you want to delete.
     *
     * @param {string} filePath The path to the task file or directory that you
     * want to delete.
     *
     * @param {FileDeleteFromTaskOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteFromTaskWithHttpOperationResponse(jobId, taskId, filePath, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let recursive = (options && options.recursive !== undefined) ? options.recursive : undefined;
            let fileDeleteFromTaskOptions = (options && options.fileDeleteFromTaskOptions !== undefined) ? options.fileDeleteFromTaskOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (filePath === null || filePath === undefined || typeof filePath.valueOf() !== 'string') {
                    throw new Error('filePath cannot be null or undefined and it must be of type string.');
                }
                if (recursive !== null && recursive !== undefined && typeof recursive !== 'boolean') {
                    throw new Error('recursive must be of type boolean.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (fileDeleteFromTaskOptions !== null && fileDeleteFromTaskOptions !== undefined) {
                    timeout = fileDeleteFromTaskOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (fileDeleteFromTaskOptions !== null && fileDeleteFromTaskOptions !== undefined) {
                    clientRequestId = fileDeleteFromTaskOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileDeleteFromTaskOptions !== null && fileDeleteFromTaskOptions !== undefined) {
                    returnClientRequestId = fileDeleteFromTaskOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileDeleteFromTaskOptions !== null && fileDeleteFromTaskOptions !== undefined) {
                    ocpDate = fileDeleteFromTaskOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    taskId,
                    filePath,
                    recursive,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}/tasks/{taskId}/files/{filePath}",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "taskId",
                            mapper: {
                                required: true,
                                serializedName: "taskId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "filePath",
                            mapper: {
                                required: true,
                                serializedName: "filePath",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "recursive",
                            mapper: {
                                serializedName: "recursive",
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.FileDeleteFromTaskHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Returns the content of the specified task file.
     *
     * @param {string} jobId The ID of the job that contains the task.
     *
     * @param {string} taskId The ID of the task whose file you want to retrieve.
     *
     * @param {string} filePath The path to the task file that you want to get the
     * content of.
     *
     * @param {FileGetFromTaskOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getFromTaskWithHttpOperationResponse(jobId, taskId, filePath, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let fileGetFromTaskOptions = (options && options.fileGetFromTaskOptions !== undefined) ? options.fileGetFromTaskOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (filePath === null || filePath === undefined || typeof filePath.valueOf() !== 'string') {
                    throw new Error('filePath cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ocpRange;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (fileGetFromTaskOptions !== null && fileGetFromTaskOptions !== undefined) {
                    timeout = fileGetFromTaskOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (fileGetFromTaskOptions !== null && fileGetFromTaskOptions !== undefined) {
                    clientRequestId = fileGetFromTaskOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileGetFromTaskOptions !== null && fileGetFromTaskOptions !== undefined) {
                    returnClientRequestId = fileGetFromTaskOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileGetFromTaskOptions !== null && fileGetFromTaskOptions !== undefined) {
                    ocpDate = fileGetFromTaskOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (fileGetFromTaskOptions !== null && fileGetFromTaskOptions !== undefined) {
                    ocpRange = fileGetFromTaskOptions.ocpRange;
                    if (ocpRange !== null && ocpRange !== undefined && typeof ocpRange.valueOf() !== 'string') {
                        throw new Error('ocpRange must be of type string.');
                    }
                }
                if (fileGetFromTaskOptions !== null && fileGetFromTaskOptions !== undefined) {
                    ifModifiedSince = fileGetFromTaskOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (fileGetFromTaskOptions !== null && fileGetFromTaskOptions !== undefined) {
                    ifUnmodifiedSince = fileGetFromTaskOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            httpRequest.rawResponse = true;
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    taskId,
                    filePath,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ocpRange,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}/tasks/{taskId}/files/{filePath}",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "taskId",
                            mapper: {
                                required: true,
                                serializedName: "taskId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "filePath",
                            mapper: {
                                required: true,
                                serializedName: "filePath",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ocpRange",
                            mapper: {
                                serializedName: "ocp-range",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(`Unexpected status code: ${statusCode}`);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets the properties of the specified task file.
     *
     * @param {string} jobId The ID of the job that contains the task.
     *
     * @param {string} taskId The ID of the task whose file you want to get the
     * properties of.
     *
     * @param {string} filePath The path to the task file that you want to get the
     * properties of.
     *
     * @param {FileGetPropertiesFromTaskOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getPropertiesFromTaskWithHttpOperationResponse(jobId, taskId, filePath, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let fileGetPropertiesFromTaskOptions = (options && options.fileGetPropertiesFromTaskOptions !== undefined) ? options.fileGetPropertiesFromTaskOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (filePath === null || filePath === undefined || typeof filePath.valueOf() !== 'string') {
                    throw new Error('filePath cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (fileGetPropertiesFromTaskOptions !== null && fileGetPropertiesFromTaskOptions !== undefined) {
                    timeout = fileGetPropertiesFromTaskOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (fileGetPropertiesFromTaskOptions !== null && fileGetPropertiesFromTaskOptions !== undefined) {
                    clientRequestId = fileGetPropertiesFromTaskOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileGetPropertiesFromTaskOptions !== null && fileGetPropertiesFromTaskOptions !== undefined) {
                    returnClientRequestId = fileGetPropertiesFromTaskOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileGetPropertiesFromTaskOptions !== null && fileGetPropertiesFromTaskOptions !== undefined) {
                    ocpDate = fileGetPropertiesFromTaskOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (fileGetPropertiesFromTaskOptions !== null && fileGetPropertiesFromTaskOptions !== undefined) {
                    ifModifiedSince = fileGetPropertiesFromTaskOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (fileGetPropertiesFromTaskOptions !== null && fileGetPropertiesFromTaskOptions !== undefined) {
                    ifUnmodifiedSince = fileGetPropertiesFromTaskOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    taskId,
                    filePath,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "HEAD",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}/tasks/{taskId}/files/{filePath}",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "taskId",
                            mapper: {
                                required: true,
                                serializedName: "taskId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "filePath",
                            mapper: {
                                required: true,
                                serializedName: "filePath",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.FileGetPropertiesFromTaskHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Deletes the specified file from the compute node.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node from which you want to
     * delete the file.
     *
     * @param {string} filePath The path to the file or directory that you want to
     * delete.
     *
     * @param {FileDeleteFromComputeNodeOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteFromComputeNodeWithHttpOperationResponse(poolId, nodeId, filePath, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let recursive = (options && options.recursive !== undefined) ? options.recursive : undefined;
            let fileDeleteFromComputeNodeOptions = (options && options.fileDeleteFromComputeNodeOptions !== undefined) ? options.fileDeleteFromComputeNodeOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (filePath === null || filePath === undefined || typeof filePath.valueOf() !== 'string') {
                    throw new Error('filePath cannot be null or undefined and it must be of type string.');
                }
                if (recursive !== null && recursive !== undefined && typeof recursive !== 'boolean') {
                    throw new Error('recursive must be of type boolean.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (fileDeleteFromComputeNodeOptions !== null && fileDeleteFromComputeNodeOptions !== undefined) {
                    timeout = fileDeleteFromComputeNodeOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (fileDeleteFromComputeNodeOptions !== null && fileDeleteFromComputeNodeOptions !== undefined) {
                    clientRequestId = fileDeleteFromComputeNodeOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileDeleteFromComputeNodeOptions !== null && fileDeleteFromComputeNodeOptions !== undefined) {
                    returnClientRequestId = fileDeleteFromComputeNodeOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileDeleteFromComputeNodeOptions !== null && fileDeleteFromComputeNodeOptions !== undefined) {
                    ocpDate = fileDeleteFromComputeNodeOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    poolId,
                    nodeId,
                    filePath,
                    recursive,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.client.baseUri,
                    path: "pools/{poolId}/nodes/{nodeId}/files/{filePath}",
                    urlParameters: [
                        {
                            parameterName: "poolId",
                            mapper: {
                                required: true,
                                serializedName: "poolId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "nodeId",
                            mapper: {
                                required: true,
                                serializedName: "nodeId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "filePath",
                            mapper: {
                                required: true,
                                serializedName: "filePath",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "recursive",
                            mapper: {
                                serializedName: "recursive",
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.FileDeleteFromComputeNodeHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Returns the content of the specified compute node file.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node that contains the file.
     *
     * @param {string} filePath The path to the compute node file that you want to
     * get the content of.
     *
     * @param {FileGetFromComputeNodeOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getFromComputeNodeWithHttpOperationResponse(poolId, nodeId, filePath, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let fileGetFromComputeNodeOptions = (options && options.fileGetFromComputeNodeOptions !== undefined) ? options.fileGetFromComputeNodeOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (filePath === null || filePath === undefined || typeof filePath.valueOf() !== 'string') {
                    throw new Error('filePath cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ocpRange;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (fileGetFromComputeNodeOptions !== null && fileGetFromComputeNodeOptions !== undefined) {
                    timeout = fileGetFromComputeNodeOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (fileGetFromComputeNodeOptions !== null && fileGetFromComputeNodeOptions !== undefined) {
                    clientRequestId = fileGetFromComputeNodeOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileGetFromComputeNodeOptions !== null && fileGetFromComputeNodeOptions !== undefined) {
                    returnClientRequestId = fileGetFromComputeNodeOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileGetFromComputeNodeOptions !== null && fileGetFromComputeNodeOptions !== undefined) {
                    ocpDate = fileGetFromComputeNodeOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (fileGetFromComputeNodeOptions !== null && fileGetFromComputeNodeOptions !== undefined) {
                    ocpRange = fileGetFromComputeNodeOptions.ocpRange;
                    if (ocpRange !== null && ocpRange !== undefined && typeof ocpRange.valueOf() !== 'string') {
                        throw new Error('ocpRange must be of type string.');
                    }
                }
                if (fileGetFromComputeNodeOptions !== null && fileGetFromComputeNodeOptions !== undefined) {
                    ifModifiedSince = fileGetFromComputeNodeOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (fileGetFromComputeNodeOptions !== null && fileGetFromComputeNodeOptions !== undefined) {
                    ifUnmodifiedSince = fileGetFromComputeNodeOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            httpRequest.rawResponse = true;
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    poolId,
                    nodeId,
                    filePath,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ocpRange,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "pools/{poolId}/nodes/{nodeId}/files/{filePath}",
                    urlParameters: [
                        {
                            parameterName: "poolId",
                            mapper: {
                                required: true,
                                serializedName: "poolId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "nodeId",
                            mapper: {
                                required: true,
                                serializedName: "nodeId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "filePath",
                            mapper: {
                                required: true,
                                serializedName: "filePath",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ocpRange",
                            mapper: {
                                serializedName: "ocp-range",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(`Unexpected status code: ${statusCode}`);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets the properties of the specified compute node file.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node that contains the file.
     *
     * @param {string} filePath The path to the compute node file that you want to
     * get the properties of.
     *
     * @param {FileGetPropertiesFromComputeNodeOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getPropertiesFromComputeNodeWithHttpOperationResponse(poolId, nodeId, filePath, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let fileGetPropertiesFromComputeNodeOptions = (options && options.fileGetPropertiesFromComputeNodeOptions !== undefined) ? options.fileGetPropertiesFromComputeNodeOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (filePath === null || filePath === undefined || typeof filePath.valueOf() !== 'string') {
                    throw new Error('filePath cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (fileGetPropertiesFromComputeNodeOptions !== null && fileGetPropertiesFromComputeNodeOptions !== undefined) {
                    timeout = fileGetPropertiesFromComputeNodeOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (fileGetPropertiesFromComputeNodeOptions !== null && fileGetPropertiesFromComputeNodeOptions !== undefined) {
                    clientRequestId = fileGetPropertiesFromComputeNodeOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileGetPropertiesFromComputeNodeOptions !== null && fileGetPropertiesFromComputeNodeOptions !== undefined) {
                    returnClientRequestId = fileGetPropertiesFromComputeNodeOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileGetPropertiesFromComputeNodeOptions !== null && fileGetPropertiesFromComputeNodeOptions !== undefined) {
                    ocpDate = fileGetPropertiesFromComputeNodeOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (fileGetPropertiesFromComputeNodeOptions !== null && fileGetPropertiesFromComputeNodeOptions !== undefined) {
                    ifModifiedSince = fileGetPropertiesFromComputeNodeOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (fileGetPropertiesFromComputeNodeOptions !== null && fileGetPropertiesFromComputeNodeOptions !== undefined) {
                    ifUnmodifiedSince = fileGetPropertiesFromComputeNodeOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    poolId,
                    nodeId,
                    filePath,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "HEAD",
                    baseUrl: this.client.baseUri,
                    path: "pools/{poolId}/nodes/{nodeId}/files/{filePath}",
                    urlParameters: [
                        {
                            parameterName: "poolId",
                            mapper: {
                                required: true,
                                serializedName: "poolId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "nodeId",
                            mapper: {
                                required: true,
                                serializedName: "nodeId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "filePath",
                            mapper: {
                                required: true,
                                serializedName: "filePath",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.FileGetPropertiesFromComputeNodeHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the files in a task's directory on its compute node.
     *
     * @param {string} jobId The ID of the job that contains the task.
     *
     * @param {string} taskId The ID of the task whose files you want to list.
     *
     * @param {FileListFromTaskOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listFromTaskWithHttpOperationResponse(jobId, taskId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let recursive = (options && options.recursive !== undefined) ? options.recursive : undefined;
            let fileListFromTaskOptions = (options && options.fileListFromTaskOptions !== undefined) ? options.fileListFromTaskOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (recursive !== null && recursive !== undefined && typeof recursive !== 'boolean') {
                    throw new Error('recursive must be of type boolean.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (fileListFromTaskOptions !== null && fileListFromTaskOptions !== undefined) {
                    filter = fileListFromTaskOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (fileListFromTaskOptions !== null && fileListFromTaskOptions !== undefined) {
                    maxResults = fileListFromTaskOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (fileListFromTaskOptions !== null && fileListFromTaskOptions !== undefined) {
                    timeout = fileListFromTaskOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (fileListFromTaskOptions !== null && fileListFromTaskOptions !== undefined) {
                    clientRequestId = fileListFromTaskOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileListFromTaskOptions !== null && fileListFromTaskOptions !== undefined) {
                    returnClientRequestId = fileListFromTaskOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileListFromTaskOptions !== null && fileListFromTaskOptions !== undefined) {
                    ocpDate = fileListFromTaskOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    taskId,
                    recursive,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    filter,
                    maxResults,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}/tasks/{taskId}/files",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "taskId",
                            mapper: {
                                required: true,
                                serializedName: "taskId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "recursive",
                            mapper: {
                                serializedName: "recursive",
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "filter",
                            mapper: {
                                serializedName: "$filter",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "maxResults",
                            mapper: {
                                serializedName: "maxresults",
                                defaultValue: 1000,
                                constraints: {
                                    InclusiveMaximum: 1000,
                                    InclusiveMinimum: 1
                                },
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.NodeFileListResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.FileListFromTaskHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the files in task directories on the specified compute
     * node.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node whose files you want to
     * list.
     *
     * @param {FileListFromComputeNodeOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listFromComputeNodeWithHttpOperationResponse(poolId, nodeId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let recursive = (options && options.recursive !== undefined) ? options.recursive : undefined;
            let fileListFromComputeNodeOptions = (options && options.fileListFromComputeNodeOptions !== undefined) ? options.fileListFromComputeNodeOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (recursive !== null && recursive !== undefined && typeof recursive !== 'boolean') {
                    throw new Error('recursive must be of type boolean.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (fileListFromComputeNodeOptions !== null && fileListFromComputeNodeOptions !== undefined) {
                    filter = fileListFromComputeNodeOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (fileListFromComputeNodeOptions !== null && fileListFromComputeNodeOptions !== undefined) {
                    maxResults = fileListFromComputeNodeOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (fileListFromComputeNodeOptions !== null && fileListFromComputeNodeOptions !== undefined) {
                    timeout = fileListFromComputeNodeOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (fileListFromComputeNodeOptions !== null && fileListFromComputeNodeOptions !== undefined) {
                    clientRequestId = fileListFromComputeNodeOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileListFromComputeNodeOptions !== null && fileListFromComputeNodeOptions !== undefined) {
                    returnClientRequestId = fileListFromComputeNodeOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileListFromComputeNodeOptions !== null && fileListFromComputeNodeOptions !== undefined) {
                    ocpDate = fileListFromComputeNodeOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    poolId,
                    nodeId,
                    recursive,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    filter,
                    maxResults,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "pools/{poolId}/nodes/{nodeId}/files",
                    urlParameters: [
                        {
                            parameterName: "poolId",
                            mapper: {
                                required: true,
                                serializedName: "poolId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "nodeId",
                            mapper: {
                                required: true,
                                serializedName: "nodeId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "recursive",
                            mapper: {
                                serializedName: "recursive",
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "filter",
                            mapper: {
                                serializedName: "$filter",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "maxResults",
                            mapper: {
                                serializedName: "maxresults",
                                defaultValue: 1000,
                                constraints: {
                                    InclusiveMaximum: 1000,
                                    InclusiveMinimum: 1
                                },
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.NodeFileListResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.FileListFromComputeNodeHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the files in a task's directory on its compute node.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {FileListFromTaskNextOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listFromTaskNextWithHttpOperationResponse(nextPageLink, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let fileListFromTaskNextOptions = (options && options.fileListFromTaskNextOptions !== undefined) ? options.fileListFromTaskNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (fileListFromTaskNextOptions !== null && fileListFromTaskNextOptions !== undefined) {
                    clientRequestId = fileListFromTaskNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileListFromTaskNextOptions !== null && fileListFromTaskNextOptions !== undefined) {
                    returnClientRequestId = fileListFromTaskNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileListFromTaskNextOptions !== null && fileListFromTaskNextOptions !== undefined) {
                    ocpDate = fileListFromTaskNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    nextPageLink,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: "https://batch.core.windows.net",
                    path: "{nextLink}",
                    urlParameters: [
                        {
                            parameterName: "nextPageLink",
                            skipEncoding: true,
                            mapper: {
                                required: true,
                                serializedName: "nextLink",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.NodeFileListResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.FileListFromTaskHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the files in task directories on the specified compute
     * node.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {FileListFromComputeNodeNextOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listFromComputeNodeNextWithHttpOperationResponse(nextPageLink, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let fileListFromComputeNodeNextOptions = (options && options.fileListFromComputeNodeNextOptions !== undefined) ? options.fileListFromComputeNodeNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (fileListFromComputeNodeNextOptions !== null && fileListFromComputeNodeNextOptions !== undefined) {
                    clientRequestId = fileListFromComputeNodeNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileListFromComputeNodeNextOptions !== null && fileListFromComputeNodeNextOptions !== undefined) {
                    returnClientRequestId = fileListFromComputeNodeNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileListFromComputeNodeNextOptions !== null && fileListFromComputeNodeNextOptions !== undefined) {
                    ocpDate = fileListFromComputeNodeNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    nextPageLink,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: "https://batch.core.windows.net",
                    path: "{nextLink}",
                    urlParameters: [
                        {
                            parameterName: "nextPageLink",
                            skipEncoding: true,
                            mapper: {
                                required: true,
                                serializedName: "nextLink",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.NodeFileListResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.FileListFromComputeNodeHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    deleteFromTask(jobId, taskId, filePath, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteFromTaskWithHttpOperationResponse(jobId, taskId, filePath, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deleteFromTaskWithHttpOperationResponse(jobId, taskId, filePath, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getPropertiesFromTask(jobId, taskId, filePath, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getPropertiesFromTaskWithHttpOperationResponse(jobId, taskId, filePath, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getPropertiesFromTaskWithHttpOperationResponse(jobId, taskId, filePath, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    deleteFromComputeNode(poolId, nodeId, filePath, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteFromComputeNodeWithHttpOperationResponse(poolId, nodeId, filePath, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deleteFromComputeNodeWithHttpOperationResponse(poolId, nodeId, filePath, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getPropertiesFromComputeNode(poolId, nodeId, filePath, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getPropertiesFromComputeNodeWithHttpOperationResponse(poolId, nodeId, filePath, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getPropertiesFromComputeNodeWithHttpOperationResponse(poolId, nodeId, filePath, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    listFromTask(jobId, taskId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listFromTaskWithHttpOperationResponse(jobId, taskId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listFromTaskWithHttpOperationResponse(jobId, taskId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    listFromComputeNode(poolId, nodeId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listFromComputeNodeWithHttpOperationResponse(poolId, nodeId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listFromComputeNodeWithHttpOperationResponse(poolId, nodeId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    listFromTaskNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listFromTaskNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listFromTaskNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    listFromComputeNodeNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listFromComputeNodeNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listFromComputeNodeNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
}
exports.File = File;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(2);
const msRest = __webpack_require__(1);
const Mappers = __webpack_require__(0);
const WebResource = msRest.WebResource;
/** Class representing a JobSchedule. */
class JobSchedule {
    /**
     * Create a JobSchedule.
     * @param {BatchServiceClientContext} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Checks the specified job schedule exists.
     *
     * @param {string} jobScheduleId The ID of the job schedule which you want to
     * check.
     *
     * @param {JobScheduleExistsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    existsWithHttpOperationResponse(jobScheduleId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleExistsOptions = (options && options.jobScheduleExistsOptions !== undefined) ? options.jobScheduleExistsOptions : undefined;
            // Validate
            try {
                if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
                    throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined) {
                    timeout = jobScheduleExistsOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined) {
                    clientRequestId = jobScheduleExistsOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined) {
                    returnClientRequestId = jobScheduleExistsOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined) {
                    ocpDate = jobScheduleExistsOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined) {
                    ifMatch = jobScheduleExistsOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined) {
                    ifNoneMatch = jobScheduleExistsOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined) {
                    ifModifiedSince = jobScheduleExistsOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined) {
                    ifUnmodifiedSince = jobScheduleExistsOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobScheduleId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "HEAD",
                    baseUrl: this.client.baseUri,
                    path: "jobschedules/{jobScheduleId}",
                    urlParameters: [
                        {
                            parameterName: "jobScheduleId",
                            mapper: {
                                required: true,
                                serializedName: "jobScheduleId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200 && statusCode !== 404) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                operationRes.parsedBody = (statusCode === 200);
                // Deserialize Response
                if (statusCode === 200) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobScheduleExistsHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
                // Deserialize Response
                if (statusCode === 404) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobScheduleExistsHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Deletes a job schedule from the specified account.
     *
     * When you delete a job schedule, this also deletes all jobs and tasks under
     * that schedule. When tasks are deleted, all the files in their working
     * directories on the compute nodes are also deleted (the retention period is
     * ignored). The job schedule statistics are no longer accessible once the job
     * schedule is deleted, though they are still counted towards account lifetime
     * statistics.
     *
     * @param {string} jobScheduleId The ID of the job schedule to delete.
     *
     * @param {JobScheduleDeleteMethodOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(jobScheduleId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleDeleteMethodOptions = (options && options.jobScheduleDeleteMethodOptions !== undefined) ? options.jobScheduleDeleteMethodOptions : undefined;
            // Validate
            try {
                if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
                    throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined) {
                    timeout = jobScheduleDeleteMethodOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined) {
                    clientRequestId = jobScheduleDeleteMethodOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined) {
                    returnClientRequestId = jobScheduleDeleteMethodOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined) {
                    ocpDate = jobScheduleDeleteMethodOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined) {
                    ifMatch = jobScheduleDeleteMethodOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined) {
                    ifNoneMatch = jobScheduleDeleteMethodOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined) {
                    ifModifiedSince = jobScheduleDeleteMethodOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined) {
                    ifUnmodifiedSince = jobScheduleDeleteMethodOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobScheduleId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.client.baseUri,
                    path: "jobschedules/{jobScheduleId}",
                    urlParameters: [
                        {
                            parameterName: "jobScheduleId",
                            mapper: {
                                required: true,
                                serializedName: "jobScheduleId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 202) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobScheduleDeleteHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets information about the specified job schedule.
     *
     * @param {string} jobScheduleId The ID of the job schedule to get.
     *
     * @param {JobScheduleGetOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(jobScheduleId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleGetOptions = (options && options.jobScheduleGetOptions !== undefined) ? options.jobScheduleGetOptions : undefined;
            // Validate
            try {
                if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
                    throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let select;
            let expand;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    select = jobScheduleGetOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    expand = jobScheduleGetOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    timeout = jobScheduleGetOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    clientRequestId = jobScheduleGetOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    returnClientRequestId = jobScheduleGetOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    ocpDate = jobScheduleGetOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    ifMatch = jobScheduleGetOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    ifNoneMatch = jobScheduleGetOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    ifModifiedSince = jobScheduleGetOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    ifUnmodifiedSince = jobScheduleGetOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobScheduleId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    select,
                    expand,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "jobschedules/{jobScheduleId}",
                    urlParameters: [
                        {
                            parameterName: "jobScheduleId",
                            mapper: {
                                required: true,
                                serializedName: "jobScheduleId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "select",
                            mapper: {
                                serializedName: "$select",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "expand",
                            mapper: {
                                serializedName: "$expand",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.CloudJobSchedule;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobScheduleGetHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Updates the properties of the specified job schedule.
     *
     * This replaces only the job schedule properties specified in the request. For
     * example, if the schedule property is not specified with this request, then
     * the Batch service will keep the existing schedule. Changes to a job schedule
     * only impact jobs created by the schedule after the update has taken place;
     * currently running jobs are unaffected.
     *
     * @param {string} jobScheduleId The ID of the job schedule to update.
     *
     * @param {JobSchedulePatchParameter} jobSchedulePatchParameter The parameters
     * for the request.
     *
     * @param {JobSchedulePatchOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    patchWithHttpOperationResponse(jobScheduleId, jobSchedulePatchParameter, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobSchedulePatchOptions = (options && options.jobSchedulePatchOptions !== undefined) ? options.jobSchedulePatchOptions : undefined;
            if (jobSchedulePatchParameter === null || jobSchedulePatchParameter === undefined) {
                jobSchedulePatchParameter = {};
            }
            // Validate
            try {
                if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
                    throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
                }
                if (jobSchedulePatchParameter === null || jobSchedulePatchParameter === undefined) {
                    throw new Error('jobSchedulePatchParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined) {
                    timeout = jobSchedulePatchOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined) {
                    clientRequestId = jobSchedulePatchOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined) {
                    returnClientRequestId = jobSchedulePatchOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined) {
                    ocpDate = jobSchedulePatchOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined) {
                    ifMatch = jobSchedulePatchOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined) {
                    ifNoneMatch = jobSchedulePatchOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined) {
                    ifModifiedSince = jobSchedulePatchOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined) {
                    ifUnmodifiedSince = jobSchedulePatchOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobScheduleId,
                    jobSchedulePatchParameter,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PATCH",
                    baseUrl: this.client.baseUri,
                    path: "jobschedules/{jobScheduleId}",
                    urlParameters: [
                        {
                            parameterName: "jobScheduleId",
                            mapper: {
                                required: true,
                                serializedName: "jobScheduleId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.JobSchedulePatchParameter,
                    requestBodyName: "jobSchedulePatchParameter",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobSchedulePatchHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Updates the properties of the specified job schedule.
     *
     * This fully replaces all the updateable properties of the job schedule. For
     * example, if the schedule property is not specified with this request, then
     * the Batch service will remove the existing schedule. Changes to a job
     * schedule only impact jobs created by the schedule after the update has taken
     * place; currently running jobs are unaffected.
     *
     * @param {string} jobScheduleId The ID of the job schedule to update.
     *
     * @param {JobScheduleUpdateParameter} jobScheduleUpdateParameter The
     * parameters for the request.
     *
     * @param {JobScheduleUpdateOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updateWithHttpOperationResponse(jobScheduleId, jobScheduleUpdateParameter, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleUpdateOptions = (options && options.jobScheduleUpdateOptions !== undefined) ? options.jobScheduleUpdateOptions : undefined;
            if (jobScheduleUpdateParameter === null || jobScheduleUpdateParameter === undefined) {
                jobScheduleUpdateParameter = {};
            }
            // Validate
            try {
                if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
                    throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
                }
                if (jobScheduleUpdateParameter === null || jobScheduleUpdateParameter === undefined) {
                    throw new Error('jobScheduleUpdateParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined) {
                    timeout = jobScheduleUpdateOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined) {
                    clientRequestId = jobScheduleUpdateOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined) {
                    returnClientRequestId = jobScheduleUpdateOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined) {
                    ocpDate = jobScheduleUpdateOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined) {
                    ifMatch = jobScheduleUpdateOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined) {
                    ifNoneMatch = jobScheduleUpdateOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined) {
                    ifModifiedSince = jobScheduleUpdateOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined) {
                    ifUnmodifiedSince = jobScheduleUpdateOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobScheduleId,
                    jobScheduleUpdateParameter,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PUT",
                    baseUrl: this.client.baseUri,
                    path: "jobschedules/{jobScheduleId}",
                    urlParameters: [
                        {
                            parameterName: "jobScheduleId",
                            mapper: {
                                required: true,
                                serializedName: "jobScheduleId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.JobScheduleUpdateParameter,
                    requestBodyName: "jobScheduleUpdateParameter",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobScheduleUpdateHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Disables a job schedule.
     *
     * No new jobs will be created until the job schedule is enabled again.
     *
     * @param {string} jobScheduleId The ID of the job schedule to disable.
     *
     * @param {JobScheduleDisableOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    disableWithHttpOperationResponse(jobScheduleId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleDisableOptions = (options && options.jobScheduleDisableOptions !== undefined) ? options.jobScheduleDisableOptions : undefined;
            // Validate
            try {
                if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
                    throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined) {
                    timeout = jobScheduleDisableOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined) {
                    clientRequestId = jobScheduleDisableOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined) {
                    returnClientRequestId = jobScheduleDisableOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined) {
                    ocpDate = jobScheduleDisableOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined) {
                    ifMatch = jobScheduleDisableOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined) {
                    ifNoneMatch = jobScheduleDisableOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined) {
                    ifModifiedSince = jobScheduleDisableOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined) {
                    ifUnmodifiedSince = jobScheduleDisableOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobScheduleId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "jobschedules/{jobScheduleId}/disable",
                    urlParameters: [
                        {
                            parameterName: "jobScheduleId",
                            mapper: {
                                required: true,
                                serializedName: "jobScheduleId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 204) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 204) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobScheduleDisableHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Enables a job schedule.
     *
     * @param {string} jobScheduleId The ID of the job schedule to enable.
     *
     * @param {JobScheduleEnableOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    enableWithHttpOperationResponse(jobScheduleId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleEnableOptions = (options && options.jobScheduleEnableOptions !== undefined) ? options.jobScheduleEnableOptions : undefined;
            // Validate
            try {
                if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
                    throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined) {
                    timeout = jobScheduleEnableOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined) {
                    clientRequestId = jobScheduleEnableOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined) {
                    returnClientRequestId = jobScheduleEnableOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined) {
                    ocpDate = jobScheduleEnableOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined) {
                    ifMatch = jobScheduleEnableOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined) {
                    ifNoneMatch = jobScheduleEnableOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined) {
                    ifModifiedSince = jobScheduleEnableOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined) {
                    ifUnmodifiedSince = jobScheduleEnableOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobScheduleId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "jobschedules/{jobScheduleId}/enable",
                    urlParameters: [
                        {
                            parameterName: "jobScheduleId",
                            mapper: {
                                required: true,
                                serializedName: "jobScheduleId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 204) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 204) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobScheduleEnableHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Terminates a job schedule.
     *
     * @param {string} jobScheduleId The ID of the job schedule to terminates.
     *
     * @param {JobScheduleTerminateOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    terminateWithHttpOperationResponse(jobScheduleId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleTerminateOptions = (options && options.jobScheduleTerminateOptions !== undefined) ? options.jobScheduleTerminateOptions : undefined;
            // Validate
            try {
                if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
                    throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined) {
                    timeout = jobScheduleTerminateOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined) {
                    clientRequestId = jobScheduleTerminateOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined) {
                    returnClientRequestId = jobScheduleTerminateOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined) {
                    ocpDate = jobScheduleTerminateOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined) {
                    ifMatch = jobScheduleTerminateOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined) {
                    ifNoneMatch = jobScheduleTerminateOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined) {
                    ifModifiedSince = jobScheduleTerminateOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined) {
                    ifUnmodifiedSince = jobScheduleTerminateOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobScheduleId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "jobschedules/{jobScheduleId}/terminate",
                    urlParameters: [
                        {
                            parameterName: "jobScheduleId",
                            mapper: {
                                required: true,
                                serializedName: "jobScheduleId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 202) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobScheduleTerminateHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Adds a job schedule to the specified account.
     *
     * @param {JobScheduleAddParameter} cloudJobSchedule The job schedule to be
     * added.
     *
     * @param {JobScheduleAddOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addWithHttpOperationResponse(cloudJobSchedule, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleAddOptions = (options && options.jobScheduleAddOptions !== undefined) ? options.jobScheduleAddOptions : undefined;
            if (cloudJobSchedule === null || cloudJobSchedule === undefined) {
                cloudJobSchedule = {};
            }
            // Validate
            try {
                if (cloudJobSchedule === null || cloudJobSchedule === undefined) {
                    throw new Error('cloudJobSchedule cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobScheduleAddOptions !== null && jobScheduleAddOptions !== undefined) {
                    timeout = jobScheduleAddOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobScheduleAddOptions !== null && jobScheduleAddOptions !== undefined) {
                    clientRequestId = jobScheduleAddOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleAddOptions !== null && jobScheduleAddOptions !== undefined) {
                    returnClientRequestId = jobScheduleAddOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleAddOptions !== null && jobScheduleAddOptions !== undefined) {
                    ocpDate = jobScheduleAddOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    cloudJobSchedule,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "jobschedules",
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.JobScheduleAddParameter,
                    requestBodyName: "cloudJobSchedule",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 201) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 201) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobScheduleAddHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the job schedules in the specified account.
     *
     * @param {JobScheduleListOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleListOptions = (options && options.jobScheduleListOptions !== undefined) ? options.jobScheduleListOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let select;
            let expand;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined) {
                    filter = jobScheduleListOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined) {
                    select = jobScheduleListOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined) {
                    expand = jobScheduleListOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined) {
                    maxResults = jobScheduleListOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined) {
                    timeout = jobScheduleListOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined) {
                    clientRequestId = jobScheduleListOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined) {
                    returnClientRequestId = jobScheduleListOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined) {
                    ocpDate = jobScheduleListOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    filter,
                    select,
                    expand,
                    maxResults,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "jobschedules",
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "filter",
                            mapper: {
                                serializedName: "$filter",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "select",
                            mapper: {
                                serializedName: "$select",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "expand",
                            mapper: {
                                serializedName: "$expand",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "maxResults",
                            mapper: {
                                serializedName: "maxresults",
                                defaultValue: 1000,
                                constraints: {
                                    InclusiveMaximum: 1000,
                                    InclusiveMinimum: 1
                                },
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.CloudJobScheduleListResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobScheduleListHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the job schedules in the specified account.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {JobScheduleListNextOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNextWithHttpOperationResponse(nextPageLink, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleListNextOptions = (options && options.jobScheduleListNextOptions !== undefined) ? options.jobScheduleListNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobScheduleListNextOptions !== null && jobScheduleListNextOptions !== undefined) {
                    clientRequestId = jobScheduleListNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleListNextOptions !== null && jobScheduleListNextOptions !== undefined) {
                    returnClientRequestId = jobScheduleListNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleListNextOptions !== null && jobScheduleListNextOptions !== undefined) {
                    ocpDate = jobScheduleListNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    nextPageLink,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: "https://batch.core.windows.net",
                    path: "{nextLink}",
                    urlParameters: [
                        {
                            parameterName: "nextPageLink",
                            skipEncoding: true,
                            mapper: {
                                required: true,
                                serializedName: "nextLink",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.CloudJobScheduleListResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobScheduleListHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    exists(jobScheduleId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.existsWithHttpOperationResponse(jobScheduleId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.existsWithHttpOperationResponse(jobScheduleId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    deleteMethod(jobScheduleId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteMethodWithHttpOperationResponse(jobScheduleId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deleteMethodWithHttpOperationResponse(jobScheduleId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    get(jobScheduleId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(jobScheduleId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getWithHttpOperationResponse(jobScheduleId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    patch(jobScheduleId, jobSchedulePatchParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.patchWithHttpOperationResponse(jobScheduleId, jobSchedulePatchParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.patchWithHttpOperationResponse(jobScheduleId, jobSchedulePatchParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    update(jobScheduleId, jobScheduleUpdateParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.updateWithHttpOperationResponse(jobScheduleId, jobScheduleUpdateParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.updateWithHttpOperationResponse(jobScheduleId, jobScheduleUpdateParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    disable(jobScheduleId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.disableWithHttpOperationResponse(jobScheduleId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.disableWithHttpOperationResponse(jobScheduleId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    enable(jobScheduleId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.enableWithHttpOperationResponse(jobScheduleId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.enableWithHttpOperationResponse(jobScheduleId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    terminate(jobScheduleId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.terminateWithHttpOperationResponse(jobScheduleId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.terminateWithHttpOperationResponse(jobScheduleId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    add(cloudJobSchedule, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.addWithHttpOperationResponse(cloudJobSchedule, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.addWithHttpOperationResponse(cloudJobSchedule, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    list(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    listNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
}
exports.JobSchedule = JobSchedule;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(2);
const msRest = __webpack_require__(1);
const Mappers = __webpack_require__(0);
const WebResource = msRest.WebResource;
/** Class representing a Task. */
class Task {
    /**
     * Create a Task.
     * @param {BatchServiceClientContext} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Adds a task to the specified job.
     *
     * The maximum lifetime of a task from addition to completion is 7 days. If a
     * task has not completed within 7 days of being added it will be terminated by
     * the Batch service and left in whatever state it was in at that time.
     *
     * @param {string} jobId The ID of the job to which the task is to be added.
     *
     * @param {TaskAddParameter} task The task to be added.
     *
     * @param {TaskAddOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addWithHttpOperationResponse(jobId, task, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let taskAddOptions = (options && options.taskAddOptions !== undefined) ? options.taskAddOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (task === null || task === undefined) {
                    throw new Error('task cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (taskAddOptions !== null && taskAddOptions !== undefined) {
                    timeout = taskAddOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (taskAddOptions !== null && taskAddOptions !== undefined) {
                    clientRequestId = taskAddOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskAddOptions !== null && taskAddOptions !== undefined) {
                    returnClientRequestId = taskAddOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskAddOptions !== null && taskAddOptions !== undefined) {
                    ocpDate = taskAddOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    task,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}/tasks",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.TaskAddParameter,
                    requestBodyName: "task",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 201) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 201) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.TaskAddHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the tasks that are associated with the specified job.
     *
     * For multi-instance tasks, information such as affinityId, executionInfo and
     * nodeInfo refer to the primary task. Use the list subtasks API to retrieve
     * information about subtasks.
     *
     * @param {string} jobId The ID of the job.
     *
     * @param {TaskListOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(jobId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let taskListOptions = (options && options.taskListOptions !== undefined) ? options.taskListOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let select;
            let expand;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (taskListOptions !== null && taskListOptions !== undefined) {
                    filter = taskListOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (taskListOptions !== null && taskListOptions !== undefined) {
                    select = taskListOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (taskListOptions !== null && taskListOptions !== undefined) {
                    expand = taskListOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (taskListOptions !== null && taskListOptions !== undefined) {
                    maxResults = taskListOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (taskListOptions !== null && taskListOptions !== undefined) {
                    timeout = taskListOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (taskListOptions !== null && taskListOptions !== undefined) {
                    clientRequestId = taskListOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskListOptions !== null && taskListOptions !== undefined) {
                    returnClientRequestId = taskListOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskListOptions !== null && taskListOptions !== undefined) {
                    ocpDate = taskListOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    filter,
                    select,
                    expand,
                    maxResults,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}/tasks",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "filter",
                            mapper: {
                                serializedName: "$filter",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "select",
                            mapper: {
                                serializedName: "$select",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "expand",
                            mapper: {
                                serializedName: "$expand",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "maxResults",
                            mapper: {
                                serializedName: "maxresults",
                                defaultValue: 1000,
                                constraints: {
                                    InclusiveMaximum: 1000,
                                    InclusiveMinimum: 1
                                },
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.CloudTaskListResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.TaskListHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Adds a collection of tasks to the specified job.
     *
     * Note that each task must have a unique ID. The Batch service may not return
     * the results for each task in the same order the tasks were submitted in this
     * request. If the server times out or the connection is closed during the
     * request, the request may have been partially or fully processed, or not at
     * all. In such cases, the user should re-issue the request. Note that it is up
     * to the user to correctly handle failures when re-issuing a request. For
     * example, you should use the same task IDs during a retry so that if the
     * prior operation succeeded, the retry will not create extra tasks
     * unexpectedly. If the response contains any tasks which failed to add, a
     * client can retry the request. In a retry, it is most efficient to resubmit
     * only tasks that failed to add, and to omit tasks that were successfully
     * added on the first attempt. The maximum lifetime of a task from addition to
     * completion is 7 days. If a task has not completed within 7 days of being
     * added it will be terminated by the Batch service and left in whatever state
     * it was in at that time.
     *
     * @param {string} jobId The ID of the job to which the task collection is to
     * be added.
     *
     * @param {TaskAddCollectionParameter} taskCollection The tasks to be added.
     *
     * @param {TaskAddCollectionOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addCollectionWithHttpOperationResponse(jobId, taskCollection, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let taskAddCollectionOptions = (options && options.taskAddCollectionOptions !== undefined) ? options.taskAddCollectionOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskCollection === null || taskCollection === undefined) {
                    throw new Error('taskCollection cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (taskAddCollectionOptions !== null && taskAddCollectionOptions !== undefined) {
                    timeout = taskAddCollectionOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (taskAddCollectionOptions !== null && taskAddCollectionOptions !== undefined) {
                    clientRequestId = taskAddCollectionOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskAddCollectionOptions !== null && taskAddCollectionOptions !== undefined) {
                    returnClientRequestId = taskAddCollectionOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskAddCollectionOptions !== null && taskAddCollectionOptions !== undefined) {
                    ocpDate = taskAddCollectionOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    taskCollection,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}/addtaskcollection",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.TaskAddCollectionParameter,
                    requestBodyName: "taskCollection",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.TaskAddCollectionResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.TaskAddCollectionHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Deletes a task from the specified job.
     *
     * When a task is deleted, all of the files in its directory on the compute
     * node where it ran are also deleted (regardless of the retention time). For
     * multi-instance tasks, the delete task operation applies synchronously to the
     * primary task; subtasks and their files are then deleted asynchronously in
     * the background.
     *
     * @param {string} jobId The ID of the job from which to delete the task.
     *
     * @param {string} taskId The ID of the task to delete.
     *
     * @param {TaskDeleteMethodOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(jobId, taskId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let taskDeleteMethodOptions = (options && options.taskDeleteMethodOptions !== undefined) ? options.taskDeleteMethodOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (taskDeleteMethodOptions !== null && taskDeleteMethodOptions !== undefined) {
                    timeout = taskDeleteMethodOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (taskDeleteMethodOptions !== null && taskDeleteMethodOptions !== undefined) {
                    clientRequestId = taskDeleteMethodOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskDeleteMethodOptions !== null && taskDeleteMethodOptions !== undefined) {
                    returnClientRequestId = taskDeleteMethodOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskDeleteMethodOptions !== null && taskDeleteMethodOptions !== undefined) {
                    ocpDate = taskDeleteMethodOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (taskDeleteMethodOptions !== null && taskDeleteMethodOptions !== undefined) {
                    ifMatch = taskDeleteMethodOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (taskDeleteMethodOptions !== null && taskDeleteMethodOptions !== undefined) {
                    ifNoneMatch = taskDeleteMethodOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (taskDeleteMethodOptions !== null && taskDeleteMethodOptions !== undefined) {
                    ifModifiedSince = taskDeleteMethodOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (taskDeleteMethodOptions !== null && taskDeleteMethodOptions !== undefined) {
                    ifUnmodifiedSince = taskDeleteMethodOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    taskId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}/tasks/{taskId}",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "taskId",
                            mapper: {
                                required: true,
                                serializedName: "taskId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.TaskDeleteHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets information about the specified task.
     *
     * For multi-instance tasks, information such as affinityId, executionInfo and
     * nodeInfo refer to the primary task. Use the list subtasks API to retrieve
     * information about subtasks.
     *
     * @param {string} jobId The ID of the job that contains the task.
     *
     * @param {string} taskId The ID of the task to get information about.
     *
     * @param {TaskGetOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(jobId, taskId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let taskGetOptions = (options && options.taskGetOptions !== undefined) ? options.taskGetOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let select;
            let expand;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    select = taskGetOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    expand = taskGetOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    timeout = taskGetOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    clientRequestId = taskGetOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    returnClientRequestId = taskGetOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    ocpDate = taskGetOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    ifMatch = taskGetOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    ifNoneMatch = taskGetOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    ifModifiedSince = taskGetOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    ifUnmodifiedSince = taskGetOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    taskId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    select,
                    expand,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}/tasks/{taskId}",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "taskId",
                            mapper: {
                                required: true,
                                serializedName: "taskId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "select",
                            mapper: {
                                serializedName: "$select",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "expand",
                            mapper: {
                                serializedName: "$expand",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.CloudTask;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.TaskGetHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Updates the properties of the specified task.
     *
     * @param {string} jobId The ID of the job containing the task.
     *
     * @param {string} taskId The ID of the task to update.
     *
     * @param {TaskUpdateParameter} taskUpdateParameter The parameters for the
     * request.
     *
     * @param {TaskUpdateOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updateWithHttpOperationResponse(jobId, taskId, taskUpdateParameter, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let taskUpdateOptions = (options && options.taskUpdateOptions !== undefined) ? options.taskUpdateOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (taskUpdateParameter === null || taskUpdateParameter === undefined) {
                    throw new Error('taskUpdateParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (taskUpdateOptions !== null && taskUpdateOptions !== undefined) {
                    timeout = taskUpdateOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (taskUpdateOptions !== null && taskUpdateOptions !== undefined) {
                    clientRequestId = taskUpdateOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskUpdateOptions !== null && taskUpdateOptions !== undefined) {
                    returnClientRequestId = taskUpdateOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskUpdateOptions !== null && taskUpdateOptions !== undefined) {
                    ocpDate = taskUpdateOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (taskUpdateOptions !== null && taskUpdateOptions !== undefined) {
                    ifMatch = taskUpdateOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (taskUpdateOptions !== null && taskUpdateOptions !== undefined) {
                    ifNoneMatch = taskUpdateOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (taskUpdateOptions !== null && taskUpdateOptions !== undefined) {
                    ifModifiedSince = taskUpdateOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (taskUpdateOptions !== null && taskUpdateOptions !== undefined) {
                    ifUnmodifiedSince = taskUpdateOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    taskId,
                    taskUpdateParameter,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PUT",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}/tasks/{taskId}",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "taskId",
                            mapper: {
                                required: true,
                                serializedName: "taskId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.TaskUpdateParameter,
                    requestBodyName: "taskUpdateParameter",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.TaskUpdateHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the subtasks that are associated with the specified
     * multi-instance task.
     *
     * If the task is not a multi-instance task then this returns an empty
     * collection.
     *
     * @param {string} jobId The ID of the job.
     *
     * @param {string} taskId The ID of the task.
     *
     * @param {TaskListSubtasksOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listSubtasksWithHttpOperationResponse(jobId, taskId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let taskListSubtasksOptions = (options && options.taskListSubtasksOptions !== undefined) ? options.taskListSubtasksOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let select;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (taskListSubtasksOptions !== null && taskListSubtasksOptions !== undefined) {
                    select = taskListSubtasksOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (taskListSubtasksOptions !== null && taskListSubtasksOptions !== undefined) {
                    timeout = taskListSubtasksOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (taskListSubtasksOptions !== null && taskListSubtasksOptions !== undefined) {
                    clientRequestId = taskListSubtasksOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskListSubtasksOptions !== null && taskListSubtasksOptions !== undefined) {
                    returnClientRequestId = taskListSubtasksOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskListSubtasksOptions !== null && taskListSubtasksOptions !== undefined) {
                    ocpDate = taskListSubtasksOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    taskId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    select,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}/tasks/{taskId}/subtasksinfo",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "taskId",
                            mapper: {
                                required: true,
                                serializedName: "taskId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "select",
                            mapper: {
                                serializedName: "$select",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.CloudTaskListSubtasksResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.TaskListSubtasksHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Terminates the specified task.
     *
     * When the task has been terminated, it moves to the completed state. For
     * multi-instance tasks, the terminate task operation applies synchronously to
     * the primary task; subtasks are then terminated asynchronously in the
     * background.
     *
     * @param {string} jobId The ID of the job containing the task.
     *
     * @param {string} taskId The ID of the task to terminate.
     *
     * @param {TaskTerminateOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    terminateWithHttpOperationResponse(jobId, taskId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let taskTerminateOptions = (options && options.taskTerminateOptions !== undefined) ? options.taskTerminateOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (taskTerminateOptions !== null && taskTerminateOptions !== undefined) {
                    timeout = taskTerminateOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (taskTerminateOptions !== null && taskTerminateOptions !== undefined) {
                    clientRequestId = taskTerminateOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskTerminateOptions !== null && taskTerminateOptions !== undefined) {
                    returnClientRequestId = taskTerminateOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskTerminateOptions !== null && taskTerminateOptions !== undefined) {
                    ocpDate = taskTerminateOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (taskTerminateOptions !== null && taskTerminateOptions !== undefined) {
                    ifMatch = taskTerminateOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (taskTerminateOptions !== null && taskTerminateOptions !== undefined) {
                    ifNoneMatch = taskTerminateOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (taskTerminateOptions !== null && taskTerminateOptions !== undefined) {
                    ifModifiedSince = taskTerminateOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (taskTerminateOptions !== null && taskTerminateOptions !== undefined) {
                    ifUnmodifiedSince = taskTerminateOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    taskId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}/tasks/{taskId}/terminate",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "taskId",
                            mapper: {
                                required: true,
                                serializedName: "taskId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 204) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 204) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.TaskTerminateHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Reactivates a task, allowing it to run again even if its retry
     * count has been exhausted.
     *
     * Reactivation makes a task eligible to be retried again up to its maximum
     * retry count. The task's state is changed to active. As the task is no longer
     * in the completed state, any previous exit code or failure information is no
     * longer available after reactivation. Each time a task is reactivated, its
     * retry count is reset to 0. Reactivation will fail for tasks that are not
     * completed or that previously completed successfully (with an exit code of
     * 0). Additionally, it will fail if the job has completed (or is terminating
     * or deleting).
     *
     * @param {string} jobId The ID of the job containing the task.
     *
     * @param {string} taskId The ID of the task to reactivate.
     *
     * @param {TaskReactivateOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    reactivateWithHttpOperationResponse(jobId, taskId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let taskReactivateOptions = (options && options.taskReactivateOptions !== undefined) ? options.taskReactivateOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (taskReactivateOptions !== null && taskReactivateOptions !== undefined) {
                    timeout = taskReactivateOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (taskReactivateOptions !== null && taskReactivateOptions !== undefined) {
                    clientRequestId = taskReactivateOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskReactivateOptions !== null && taskReactivateOptions !== undefined) {
                    returnClientRequestId = taskReactivateOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskReactivateOptions !== null && taskReactivateOptions !== undefined) {
                    ocpDate = taskReactivateOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (taskReactivateOptions !== null && taskReactivateOptions !== undefined) {
                    ifMatch = taskReactivateOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (taskReactivateOptions !== null && taskReactivateOptions !== undefined) {
                    ifNoneMatch = taskReactivateOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (taskReactivateOptions !== null && taskReactivateOptions !== undefined) {
                    ifModifiedSince = taskReactivateOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (taskReactivateOptions !== null && taskReactivateOptions !== undefined) {
                    ifUnmodifiedSince = taskReactivateOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    taskId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}/tasks/{taskId}/reactivate",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "taskId",
                            mapper: {
                                required: true,
                                serializedName: "taskId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 204) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 204) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.TaskReactivateHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the tasks that are associated with the specified job.
     *
     * For multi-instance tasks, information such as affinityId, executionInfo and
     * nodeInfo refer to the primary task. Use the list subtasks API to retrieve
     * information about subtasks.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {TaskListNextOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNextWithHttpOperationResponse(nextPageLink, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let taskListNextOptions = (options && options.taskListNextOptions !== undefined) ? options.taskListNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (taskListNextOptions !== null && taskListNextOptions !== undefined) {
                    clientRequestId = taskListNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskListNextOptions !== null && taskListNextOptions !== undefined) {
                    returnClientRequestId = taskListNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskListNextOptions !== null && taskListNextOptions !== undefined) {
                    ocpDate = taskListNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    nextPageLink,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: "https://batch.core.windows.net",
                    path: "{nextLink}",
                    urlParameters: [
                        {
                            parameterName: "nextPageLink",
                            skipEncoding: true,
                            mapper: {
                                required: true,
                                serializedName: "nextLink",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.CloudTaskListResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.TaskListHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    add(jobId, task, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.addWithHttpOperationResponse(jobId, task, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.addWithHttpOperationResponse(jobId, task, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    list(jobId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listWithHttpOperationResponse(jobId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listWithHttpOperationResponse(jobId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    addCollection(jobId, taskCollection, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.addCollectionWithHttpOperationResponse(jobId, taskCollection, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.addCollectionWithHttpOperationResponse(jobId, taskCollection, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    deleteMethod(jobId, taskId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteMethodWithHttpOperationResponse(jobId, taskId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deleteMethodWithHttpOperationResponse(jobId, taskId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    get(jobId, taskId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(jobId, taskId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getWithHttpOperationResponse(jobId, taskId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    update(jobId, taskId, taskUpdateParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.updateWithHttpOperationResponse(jobId, taskId, taskUpdateParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.updateWithHttpOperationResponse(jobId, taskId, taskUpdateParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    listSubtasks(jobId, taskId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listSubtasksWithHttpOperationResponse(jobId, taskId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listSubtasksWithHttpOperationResponse(jobId, taskId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    terminate(jobId, taskId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.terminateWithHttpOperationResponse(jobId, taskId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.terminateWithHttpOperationResponse(jobId, taskId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    reactivate(jobId, taskId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.reactivateWithHttpOperationResponse(jobId, taskId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.reactivateWithHttpOperationResponse(jobId, taskId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    listNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
}
exports.Task = Task;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(2);
const msRest = __webpack_require__(1);
const Mappers = __webpack_require__(0);
const WebResource = msRest.WebResource;
/** Class representing a ComputeNodeOperations. */
class ComputeNodeOperations {
    /**
     * Create a ComputeNodeOperations.
     * @param {BatchServiceClientContext} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Adds a user account to the specified compute node.
     *
     * You can add a user account to a node only when it is in the idle or running
     * state.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the machine on which you want to create a
     * user account.
     *
     * @param {ComputeNodeUser} user The user account to be created.
     *
     * @param {ComputeNodeAddUserOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addUserWithHttpOperationResponse(poolId, nodeId, user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let computeNodeAddUserOptions = (options && options.computeNodeAddUserOptions !== undefined) ? options.computeNodeAddUserOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (user === null || user === undefined) {
                    throw new Error('user cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeAddUserOptions !== null && computeNodeAddUserOptions !== undefined) {
                    timeout = computeNodeAddUserOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeAddUserOptions !== null && computeNodeAddUserOptions !== undefined) {
                    clientRequestId = computeNodeAddUserOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeAddUserOptions !== null && computeNodeAddUserOptions !== undefined) {
                    returnClientRequestId = computeNodeAddUserOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeAddUserOptions !== null && computeNodeAddUserOptions !== undefined) {
                    ocpDate = computeNodeAddUserOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    poolId,
                    nodeId,
                    user,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "pools/{poolId}/nodes/{nodeId}/users",
                    urlParameters: [
                        {
                            parameterName: "poolId",
                            mapper: {
                                required: true,
                                serializedName: "poolId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "nodeId",
                            mapper: {
                                required: true,
                                serializedName: "nodeId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.ComputeNodeUser,
                    requestBodyName: "user",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 201) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 201) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.ComputeNodeAddUserHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Deletes a user account from the specified compute node.
     *
     * You can delete a user account to a node only when it is in the idle or
     * running state.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the machine on which you want to delete a
     * user account.
     *
     * @param {string} userName The name of the user account to delete.
     *
     * @param {ComputeNodeDeleteUserOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteUserWithHttpOperationResponse(poolId, nodeId, userName, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let computeNodeDeleteUserOptions = (options && options.computeNodeDeleteUserOptions !== undefined) ? options.computeNodeDeleteUserOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (userName === null || userName === undefined || typeof userName.valueOf() !== 'string') {
                    throw new Error('userName cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeDeleteUserOptions !== null && computeNodeDeleteUserOptions !== undefined) {
                    timeout = computeNodeDeleteUserOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeDeleteUserOptions !== null && computeNodeDeleteUserOptions !== undefined) {
                    clientRequestId = computeNodeDeleteUserOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeDeleteUserOptions !== null && computeNodeDeleteUserOptions !== undefined) {
                    returnClientRequestId = computeNodeDeleteUserOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeDeleteUserOptions !== null && computeNodeDeleteUserOptions !== undefined) {
                    ocpDate = computeNodeDeleteUserOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    poolId,
                    nodeId,
                    userName,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.client.baseUri,
                    path: "pools/{poolId}/nodes/{nodeId}/users/{userName}",
                    urlParameters: [
                        {
                            parameterName: "poolId",
                            mapper: {
                                required: true,
                                serializedName: "poolId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "nodeId",
                            mapper: {
                                required: true,
                                serializedName: "nodeId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "userName",
                            mapper: {
                                required: true,
                                serializedName: "userName",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.ComputeNodeDeleteUserHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Updates the password and expiration time of a user account on the
     * specified compute node.
     *
     * This operation replaces of all the updateable properties of the account. For
     * example, if the expiryTime element is not specified, the current value is
     * replaced with the default value, not left unmodified. You can update a user
     * account on a node only when it is in the idle or running state.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the machine on which you want to update a
     * user account.
     *
     * @param {string} userName The name of the user account to update.
     *
     * @param {NodeUpdateUserParameter} nodeUpdateUserParameter The parameters for
     * the request.
     *
     * @param {ComputeNodeUpdateUserOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updateUserWithHttpOperationResponse(poolId, nodeId, userName, nodeUpdateUserParameter, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let computeNodeUpdateUserOptions = (options && options.computeNodeUpdateUserOptions !== undefined) ? options.computeNodeUpdateUserOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (userName === null || userName === undefined || typeof userName.valueOf() !== 'string') {
                    throw new Error('userName cannot be null or undefined and it must be of type string.');
                }
                if (nodeUpdateUserParameter === null || nodeUpdateUserParameter === undefined) {
                    throw new Error('nodeUpdateUserParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeUpdateUserOptions !== null && computeNodeUpdateUserOptions !== undefined) {
                    timeout = computeNodeUpdateUserOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeUpdateUserOptions !== null && computeNodeUpdateUserOptions !== undefined) {
                    clientRequestId = computeNodeUpdateUserOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeUpdateUserOptions !== null && computeNodeUpdateUserOptions !== undefined) {
                    returnClientRequestId = computeNodeUpdateUserOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeUpdateUserOptions !== null && computeNodeUpdateUserOptions !== undefined) {
                    ocpDate = computeNodeUpdateUserOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    poolId,
                    nodeId,
                    userName,
                    nodeUpdateUserParameter,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PUT",
                    baseUrl: this.client.baseUri,
                    path: "pools/{poolId}/nodes/{nodeId}/users/{userName}",
                    urlParameters: [
                        {
                            parameterName: "poolId",
                            mapper: {
                                required: true,
                                serializedName: "poolId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "nodeId",
                            mapper: {
                                required: true,
                                serializedName: "nodeId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "userName",
                            mapper: {
                                required: true,
                                serializedName: "userName",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.NodeUpdateUserParameter,
                    requestBodyName: "nodeUpdateUserParameter",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.ComputeNodeUpdateUserHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets information about the specified compute node.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node that you want to get
     * information about.
     *
     * @param {ComputeNodeGetOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(poolId, nodeId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let computeNodeGetOptions = (options && options.computeNodeGetOptions !== undefined) ? options.computeNodeGetOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let select;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeGetOptions !== null && computeNodeGetOptions !== undefined) {
                    select = computeNodeGetOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (computeNodeGetOptions !== null && computeNodeGetOptions !== undefined) {
                    timeout = computeNodeGetOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeGetOptions !== null && computeNodeGetOptions !== undefined) {
                    clientRequestId = computeNodeGetOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeGetOptions !== null && computeNodeGetOptions !== undefined) {
                    returnClientRequestId = computeNodeGetOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeGetOptions !== null && computeNodeGetOptions !== undefined) {
                    ocpDate = computeNodeGetOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    poolId,
                    nodeId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    select,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "pools/{poolId}/nodes/{nodeId}",
                    urlParameters: [
                        {
                            parameterName: "poolId",
                            mapper: {
                                required: true,
                                serializedName: "poolId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "nodeId",
                            mapper: {
                                required: true,
                                serializedName: "nodeId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "select",
                            mapper: {
                                serializedName: "$select",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.ComputeNode;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.ComputeNodeGetHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Restarts the specified compute node.
     *
     * You can restart a node only if it is in an idle or running state.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node that you want to restart.
     *
     * @param {ComputeNodeRebootOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    rebootWithHttpOperationResponse(poolId, nodeId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let nodeRebootParameter = (options && options.nodeRebootParameter !== undefined) ? options.nodeRebootParameter : undefined;
            let computeNodeRebootOptions = (options && options.computeNodeRebootOptions !== undefined) ? options.computeNodeRebootOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeRebootOptions !== null && computeNodeRebootOptions !== undefined) {
                    timeout = computeNodeRebootOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeRebootOptions !== null && computeNodeRebootOptions !== undefined) {
                    clientRequestId = computeNodeRebootOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeRebootOptions !== null && computeNodeRebootOptions !== undefined) {
                    returnClientRequestId = computeNodeRebootOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeRebootOptions !== null && computeNodeRebootOptions !== undefined) {
                    ocpDate = computeNodeRebootOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    poolId,
                    nodeId,
                    nodeRebootParameter,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "pools/{poolId}/nodes/{nodeId}/reboot",
                    urlParameters: [
                        {
                            parameterName: "poolId",
                            mapper: {
                                required: true,
                                serializedName: "poolId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "nodeId",
                            mapper: {
                                required: true,
                                serializedName: "nodeId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.NodeRebootParameter,
                    requestBodyName: "nodeRebootParameter",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 202) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.ComputeNodeRebootHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Reinstalls the operating system on the specified compute node.
     *
     * You can reinstall the operating system on a node only if it is in an idle or
     * running state. This API can be invoked only on pools created with the cloud
     * service configuration property.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node that you want to restart.
     *
     * @param {ComputeNodeReimageOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    reimageWithHttpOperationResponse(poolId, nodeId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let nodeReimageParameter = (options && options.nodeReimageParameter !== undefined) ? options.nodeReimageParameter : undefined;
            let computeNodeReimageOptions = (options && options.computeNodeReimageOptions !== undefined) ? options.computeNodeReimageOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeReimageOptions !== null && computeNodeReimageOptions !== undefined) {
                    timeout = computeNodeReimageOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeReimageOptions !== null && computeNodeReimageOptions !== undefined) {
                    clientRequestId = computeNodeReimageOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeReimageOptions !== null && computeNodeReimageOptions !== undefined) {
                    returnClientRequestId = computeNodeReimageOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeReimageOptions !== null && computeNodeReimageOptions !== undefined) {
                    ocpDate = computeNodeReimageOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    poolId,
                    nodeId,
                    nodeReimageParameter,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "pools/{poolId}/nodes/{nodeId}/reimage",
                    urlParameters: [
                        {
                            parameterName: "poolId",
                            mapper: {
                                required: true,
                                serializedName: "poolId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "nodeId",
                            mapper: {
                                required: true,
                                serializedName: "nodeId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.NodeReimageParameter,
                    requestBodyName: "nodeReimageParameter",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 202) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.ComputeNodeReimageHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Disables task scheduling on the specified compute node.
     *
     * You can disable task scheduling on a node only if its current scheduling
     * state is enabled.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node on which you want to
     * disable task scheduling.
     *
     * @param {ComputeNodeDisableSchedulingOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    disableSchedulingWithHttpOperationResponse(poolId, nodeId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let nodeDisableSchedulingParameter = (options && options.nodeDisableSchedulingParameter !== undefined) ? options.nodeDisableSchedulingParameter : undefined;
            let computeNodeDisableSchedulingOptions = (options && options.computeNodeDisableSchedulingOptions !== undefined) ? options.computeNodeDisableSchedulingOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeDisableSchedulingOptions !== null && computeNodeDisableSchedulingOptions !== undefined) {
                    timeout = computeNodeDisableSchedulingOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeDisableSchedulingOptions !== null && computeNodeDisableSchedulingOptions !== undefined) {
                    clientRequestId = computeNodeDisableSchedulingOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeDisableSchedulingOptions !== null && computeNodeDisableSchedulingOptions !== undefined) {
                    returnClientRequestId = computeNodeDisableSchedulingOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeDisableSchedulingOptions !== null && computeNodeDisableSchedulingOptions !== undefined) {
                    ocpDate = computeNodeDisableSchedulingOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    poolId,
                    nodeId,
                    nodeDisableSchedulingParameter,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "pools/{poolId}/nodes/{nodeId}/disablescheduling",
                    urlParameters: [
                        {
                            parameterName: "poolId",
                            mapper: {
                                required: true,
                                serializedName: "poolId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "nodeId",
                            mapper: {
                                required: true,
                                serializedName: "nodeId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.NodeDisableSchedulingParameter,
                    requestBodyName: "nodeDisableSchedulingParameter",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.ComputeNodeDisableSchedulingHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Enables task scheduling on the specified compute node.
     *
     * You can enable task scheduling on a node only if its current scheduling
     * state is disabled
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node on which you want to
     * enable task scheduling.
     *
     * @param {ComputeNodeEnableSchedulingOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    enableSchedulingWithHttpOperationResponse(poolId, nodeId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let computeNodeEnableSchedulingOptions = (options && options.computeNodeEnableSchedulingOptions !== undefined) ? options.computeNodeEnableSchedulingOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeEnableSchedulingOptions !== null && computeNodeEnableSchedulingOptions !== undefined) {
                    timeout = computeNodeEnableSchedulingOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeEnableSchedulingOptions !== null && computeNodeEnableSchedulingOptions !== undefined) {
                    clientRequestId = computeNodeEnableSchedulingOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeEnableSchedulingOptions !== null && computeNodeEnableSchedulingOptions !== undefined) {
                    returnClientRequestId = computeNodeEnableSchedulingOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeEnableSchedulingOptions !== null && computeNodeEnableSchedulingOptions !== undefined) {
                    ocpDate = computeNodeEnableSchedulingOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    poolId,
                    nodeId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "pools/{poolId}/nodes/{nodeId}/enablescheduling",
                    urlParameters: [
                        {
                            parameterName: "poolId",
                            mapper: {
                                required: true,
                                serializedName: "poolId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "nodeId",
                            mapper: {
                                required: true,
                                serializedName: "nodeId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.ComputeNodeEnableSchedulingHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets the settings required for remote login to a compute node.
     *
     * Before you can remotely login to a node using the remote login settings, you
     * must create a user account on the node. This API can be invoked only on
     * pools created with the virtual machine configuration property. For pools
     * created with a cloud service configuration, see the GetRemoteDesktop API.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node for which to obtain the
     * remote login settings.
     *
     * @param {ComputeNodeGetRemoteLoginSettingsOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getRemoteLoginSettingsWithHttpOperationResponse(poolId, nodeId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let computeNodeGetRemoteLoginSettingsOptions = (options && options.computeNodeGetRemoteLoginSettingsOptions !== undefined) ? options.computeNodeGetRemoteLoginSettingsOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeGetRemoteLoginSettingsOptions !== null && computeNodeGetRemoteLoginSettingsOptions !== undefined) {
                    timeout = computeNodeGetRemoteLoginSettingsOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeGetRemoteLoginSettingsOptions !== null && computeNodeGetRemoteLoginSettingsOptions !== undefined) {
                    clientRequestId = computeNodeGetRemoteLoginSettingsOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeGetRemoteLoginSettingsOptions !== null && computeNodeGetRemoteLoginSettingsOptions !== undefined) {
                    returnClientRequestId = computeNodeGetRemoteLoginSettingsOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeGetRemoteLoginSettingsOptions !== null && computeNodeGetRemoteLoginSettingsOptions !== undefined) {
                    ocpDate = computeNodeGetRemoteLoginSettingsOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    poolId,
                    nodeId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "pools/{poolId}/nodes/{nodeId}/remoteloginsettings",
                    urlParameters: [
                        {
                            parameterName: "poolId",
                            mapper: {
                                required: true,
                                serializedName: "poolId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "nodeId",
                            mapper: {
                                required: true,
                                serializedName: "nodeId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.ComputeNodeGetRemoteLoginSettingsResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.ComputeNodeGetRemoteLoginSettingsHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets the Remote Desktop Protocol file for the specified compute
     * node.
     *
     * Before you can access a node by using the RDP file, you must create a user
     * account on the node. This API can only be invoked on pools created with a
     * cloud service configuration. For pools created with a virtual machine
     * configuration, see the GetRemoteLoginSettings API.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node for which you want to get
     * the Remote Desktop Protocol file.
     *
     * @param {ComputeNodeGetRemoteDesktopOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getRemoteDesktopWithHttpOperationResponse(poolId, nodeId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let computeNodeGetRemoteDesktopOptions = (options && options.computeNodeGetRemoteDesktopOptions !== undefined) ? options.computeNodeGetRemoteDesktopOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeGetRemoteDesktopOptions !== null && computeNodeGetRemoteDesktopOptions !== undefined) {
                    timeout = computeNodeGetRemoteDesktopOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeGetRemoteDesktopOptions !== null && computeNodeGetRemoteDesktopOptions !== undefined) {
                    clientRequestId = computeNodeGetRemoteDesktopOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeGetRemoteDesktopOptions !== null && computeNodeGetRemoteDesktopOptions !== undefined) {
                    returnClientRequestId = computeNodeGetRemoteDesktopOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeGetRemoteDesktopOptions !== null && computeNodeGetRemoteDesktopOptions !== undefined) {
                    ocpDate = computeNodeGetRemoteDesktopOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            httpRequest.rawResponse = true;
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    poolId,
                    nodeId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "pools/{poolId}/nodes/{nodeId}/rdp",
                    urlParameters: [
                        {
                            parameterName: "poolId",
                            mapper: {
                                required: true,
                                serializedName: "poolId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "nodeId",
                            mapper: {
                                required: true,
                                serializedName: "nodeId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(`Unexpected status code: ${statusCode}`);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Upload Azure Batch service log files from the specified compute
     * node to Azure Blob Storage.
     *
     * This is for gathering Azure Batch service log files in an automated fashion
     * from nodes if you are experiencing an error and wish to escalate to Azure
     * support. The Azure Batch service log files should be shared with Azure
     * support to aid in debugging issues with the Batch service.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node from which you want to
     * upload the Azure Batch service log files.
     *
     * @param {UploadBatchServiceLogsConfiguration}
     * uploadBatchServiceLogsConfiguration The Azure Batch service log files upload
     * configuration.
     *
     * @param {ComputeNodeUploadBatchServiceLogsOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    uploadBatchServiceLogsWithHttpOperationResponse(poolId, nodeId, uploadBatchServiceLogsConfiguration, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let computeNodeUploadBatchServiceLogsOptions = (options && options.computeNodeUploadBatchServiceLogsOptions !== undefined) ? options.computeNodeUploadBatchServiceLogsOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (uploadBatchServiceLogsConfiguration === null || uploadBatchServiceLogsConfiguration === undefined) {
                    throw new Error('uploadBatchServiceLogsConfiguration cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeUploadBatchServiceLogsOptions !== null && computeNodeUploadBatchServiceLogsOptions !== undefined) {
                    timeout = computeNodeUploadBatchServiceLogsOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeUploadBatchServiceLogsOptions !== null && computeNodeUploadBatchServiceLogsOptions !== undefined) {
                    clientRequestId = computeNodeUploadBatchServiceLogsOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeUploadBatchServiceLogsOptions !== null && computeNodeUploadBatchServiceLogsOptions !== undefined) {
                    returnClientRequestId = computeNodeUploadBatchServiceLogsOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeUploadBatchServiceLogsOptions !== null && computeNodeUploadBatchServiceLogsOptions !== undefined) {
                    ocpDate = computeNodeUploadBatchServiceLogsOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    poolId,
                    nodeId,
                    uploadBatchServiceLogsConfiguration,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "pools/{poolId}/nodes/{nodeId}/uploadbatchservicelogs",
                    urlParameters: [
                        {
                            parameterName: "poolId",
                            mapper: {
                                required: true,
                                serializedName: "poolId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "nodeId",
                            mapper: {
                                required: true,
                                serializedName: "nodeId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.UploadBatchServiceLogsConfiguration,
                    requestBodyName: "uploadBatchServiceLogsConfiguration",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.UploadBatchServiceLogsResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.ComputeNodeUploadBatchServiceLogsHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the compute nodes in the specified pool.
     *
     * @param {string} poolId The ID of the pool from which you want to list nodes.
     *
     * @param {ComputeNodeListOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(poolId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let computeNodeListOptions = (options && options.computeNodeListOptions !== undefined) ? options.computeNodeListOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let select;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeListOptions !== null && computeNodeListOptions !== undefined) {
                    filter = computeNodeListOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (computeNodeListOptions !== null && computeNodeListOptions !== undefined) {
                    select = computeNodeListOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (computeNodeListOptions !== null && computeNodeListOptions !== undefined) {
                    maxResults = computeNodeListOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (computeNodeListOptions !== null && computeNodeListOptions !== undefined) {
                    timeout = computeNodeListOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeListOptions !== null && computeNodeListOptions !== undefined) {
                    clientRequestId = computeNodeListOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeListOptions !== null && computeNodeListOptions !== undefined) {
                    returnClientRequestId = computeNodeListOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeListOptions !== null && computeNodeListOptions !== undefined) {
                    ocpDate = computeNodeListOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    poolId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    filter,
                    select,
                    maxResults,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "pools/{poolId}/nodes",
                    urlParameters: [
                        {
                            parameterName: "poolId",
                            mapper: {
                                required: true,
                                serializedName: "poolId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "filter",
                            mapper: {
                                serializedName: "$filter",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "select",
                            mapper: {
                                serializedName: "$select",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "maxResults",
                            mapper: {
                                serializedName: "maxresults",
                                defaultValue: 1000,
                                constraints: {
                                    InclusiveMaximum: 1000,
                                    InclusiveMinimum: 1
                                },
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.ComputeNodeListResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.ComputeNodeListHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the compute nodes in the specified pool.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {ComputeNodeListNextOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNextWithHttpOperationResponse(nextPageLink, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let computeNodeListNextOptions = (options && options.computeNodeListNextOptions !== undefined) ? options.computeNodeListNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeListNextOptions !== null && computeNodeListNextOptions !== undefined) {
                    clientRequestId = computeNodeListNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeListNextOptions !== null && computeNodeListNextOptions !== undefined) {
                    returnClientRequestId = computeNodeListNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeListNextOptions !== null && computeNodeListNextOptions !== undefined) {
                    ocpDate = computeNodeListNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    nextPageLink,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: "https://batch.core.windows.net",
                    path: "{nextLink}",
                    urlParameters: [
                        {
                            parameterName: "nextPageLink",
                            skipEncoding: true,
                            mapper: {
                                required: true,
                                serializedName: "nextLink",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.ComputeNodeListResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.ComputeNodeListHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    addUser(poolId, nodeId, user, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.addUserWithHttpOperationResponse(poolId, nodeId, user, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.addUserWithHttpOperationResponse(poolId, nodeId, user, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    deleteUser(poolId, nodeId, userName, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteUserWithHttpOperationResponse(poolId, nodeId, userName, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deleteUserWithHttpOperationResponse(poolId, nodeId, userName, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    updateUser(poolId, nodeId, userName, nodeUpdateUserParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.updateUserWithHttpOperationResponse(poolId, nodeId, userName, nodeUpdateUserParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.updateUserWithHttpOperationResponse(poolId, nodeId, userName, nodeUpdateUserParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    get(poolId, nodeId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(poolId, nodeId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getWithHttpOperationResponse(poolId, nodeId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    reboot(poolId, nodeId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.rebootWithHttpOperationResponse(poolId, nodeId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.rebootWithHttpOperationResponse(poolId, nodeId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    reimage(poolId, nodeId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.reimageWithHttpOperationResponse(poolId, nodeId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.reimageWithHttpOperationResponse(poolId, nodeId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    disableScheduling(poolId, nodeId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.disableSchedulingWithHttpOperationResponse(poolId, nodeId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.disableSchedulingWithHttpOperationResponse(poolId, nodeId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    enableScheduling(poolId, nodeId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.enableSchedulingWithHttpOperationResponse(poolId, nodeId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.enableSchedulingWithHttpOperationResponse(poolId, nodeId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getRemoteLoginSettings(poolId, nodeId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getRemoteLoginSettingsWithHttpOperationResponse(poolId, nodeId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getRemoteLoginSettingsWithHttpOperationResponse(poolId, nodeId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    uploadBatchServiceLogs(poolId, nodeId, uploadBatchServiceLogsConfiguration, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.uploadBatchServiceLogsWithHttpOperationResponse(poolId, nodeId, uploadBatchServiceLogsConfiguration, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.uploadBatchServiceLogsWithHttpOperationResponse(poolId, nodeId, uploadBatchServiceLogsConfiguration, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    list(poolId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listWithHttpOperationResponse(poolId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listWithHttpOperationResponse(poolId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    listNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
}
exports.ComputeNodeOperations = ComputeNodeOperations;


/***/ })
/******/ ]);
//# sourceMappingURL=batchServiceClientBundle.js.map