var batchServiceClient =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ms_rest_azure_js_1 = __webpack_require__(2);
exports.CloudError = ms_rest_azure_js_1.CloudErrorMapper;
exports.BaseResource = ms_rest_azure_js_1.BaseResourceMapper;
exports.PoolUsageMetrics = {
    required: false,
    serializedName: 'PoolUsageMetrics',
    type: {
        name: 'Composite',
        className: 'PoolUsageMetrics',
        modelProperties: {
            poolId: {
                required: true,
                serializedName: 'poolId',
                type: {
                    name: 'String'
                }
            },
            startTime: {
                required: true,
                serializedName: 'startTime',
                type: {
                    name: 'DateTime'
                }
            },
            endTime: {
                required: true,
                serializedName: 'endTime',
                type: {
                    name: 'DateTime'
                }
            },
            vmSize: {
                required: true,
                serializedName: 'vmSize',
                type: {
                    name: 'String'
                }
            },
            totalCoreHours: {
                required: true,
                serializedName: 'totalCoreHours',
                type: {
                    name: 'Number'
                }
            },
            dataIngressGiB: {
                required: true,
                serializedName: 'dataIngressGiB',
                type: {
                    name: 'Number'
                }
            },
            dataEgressGiB: {
                required: true,
                serializedName: 'dataEgressGiB',
                type: {
                    name: 'Number'
                }
            }
        }
    }
};
exports.ImageReference = {
    required: false,
    serializedName: 'ImageReference',
    type: {
        name: 'Composite',
        className: 'ImageReference',
        modelProperties: {
            publisher: {
                required: false,
                serializedName: 'publisher',
                type: {
                    name: 'String'
                }
            },
            offer: {
                required: false,
                serializedName: 'offer',
                type: {
                    name: 'String'
                }
            },
            sku: {
                required: false,
                serializedName: 'sku',
                type: {
                    name: 'String'
                }
            },
            version: {
                required: false,
                serializedName: 'version',
                type: {
                    name: 'String'
                }
            },
            virtualMachineImageId: {
                required: false,
                serializedName: 'virtualMachineImageId',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.NodeAgentSku = {
    required: false,
    serializedName: 'NodeAgentSku',
    type: {
        name: 'Composite',
        className: 'NodeAgentSku',
        modelProperties: {
            id: {
                required: false,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            verifiedImageReferences: {
                required: false,
                serializedName: 'verifiedImageReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ImageReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'ImageReference'
                        }
                    }
                }
            },
            osType: {
                required: false,
                serializedName: 'osType',
                type: {
                    name: 'Enum',
                    allowedValues: ['linux', 'windows']
                }
            }
        }
    }
};
exports.AuthenticationTokenSettings = {
    required: false,
    serializedName: 'AuthenticationTokenSettings',
    type: {
        name: 'Composite',
        className: 'AuthenticationTokenSettings',
        modelProperties: {
            access: {
                required: false,
                serializedName: 'access',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'AccessScopeElementType',
                        type: {
                            name: 'Enum',
                            allowedValues: ['job']
                        }
                    }
                }
            }
        }
    }
};
exports.UsageStatistics = {
    required: false,
    serializedName: 'UsageStatistics',
    type: {
        name: 'Composite',
        className: 'UsageStatistics',
        modelProperties: {
            startTime: {
                required: true,
                serializedName: 'startTime',
                type: {
                    name: 'DateTime'
                }
            },
            lastUpdateTime: {
                required: true,
                serializedName: 'lastUpdateTime',
                type: {
                    name: 'DateTime'
                }
            },
            dedicatedCoreTime: {
                required: true,
                serializedName: 'dedicatedCoreTime',
                type: {
                    name: 'TimeSpan'
                }
            }
        }
    }
};
exports.ResourceStatistics = {
    required: false,
    serializedName: 'ResourceStatistics',
    type: {
        name: 'Composite',
        className: 'ResourceStatistics',
        modelProperties: {
            startTime: {
                required: true,
                serializedName: 'startTime',
                type: {
                    name: 'DateTime'
                }
            },
            lastUpdateTime: {
                required: true,
                serializedName: 'lastUpdateTime',
                type: {
                    name: 'DateTime'
                }
            },
            avgCPUPercentage: {
                required: true,
                serializedName: 'avgCPUPercentage',
                type: {
                    name: 'Number'
                }
            },
            avgMemoryGiB: {
                required: true,
                serializedName: 'avgMemoryGiB',
                type: {
                    name: 'Number'
                }
            },
            peakMemoryGiB: {
                required: true,
                serializedName: 'peakMemoryGiB',
                type: {
                    name: 'Number'
                }
            },
            avgDiskGiB: {
                required: true,
                serializedName: 'avgDiskGiB',
                type: {
                    name: 'Number'
                }
            },
            peakDiskGiB: {
                required: true,
                serializedName: 'peakDiskGiB',
                type: {
                    name: 'Number'
                }
            },
            diskReadIOps: {
                required: true,
                serializedName: 'diskReadIOps',
                type: {
                    name: 'Number'
                }
            },
            diskWriteIOps: {
                required: true,
                serializedName: 'diskWriteIOps',
                type: {
                    name: 'Number'
                }
            },
            diskReadGiB: {
                required: true,
                serializedName: 'diskReadGiB',
                type: {
                    name: 'Number'
                }
            },
            diskWriteGiB: {
                required: true,
                serializedName: 'diskWriteGiB',
                type: {
                    name: 'Number'
                }
            },
            networkReadGiB: {
                required: true,
                serializedName: 'networkReadGiB',
                type: {
                    name: 'Number'
                }
            },
            networkWriteGiB: {
                required: true,
                serializedName: 'networkWriteGiB',
                type: {
                    name: 'Number'
                }
            }
        }
    }
};
exports.PoolStatistics = {
    required: false,
    serializedName: 'PoolStatistics',
    type: {
        name: 'Composite',
        className: 'PoolStatistics',
        modelProperties: {
            url: {
                required: true,
                serializedName: 'url',
                type: {
                    name: 'String'
                }
            },
            startTime: {
                required: true,
                serializedName: 'startTime',
                type: {
                    name: 'DateTime'
                }
            },
            lastUpdateTime: {
                required: true,
                serializedName: 'lastUpdateTime',
                type: {
                    name: 'DateTime'
                }
            },
            usageStats: {
                required: false,
                serializedName: 'usageStats',
                type: {
                    name: 'Composite',
                    className: 'UsageStatistics'
                }
            },
            resourceStats: {
                required: false,
                serializedName: 'resourceStats',
                type: {
                    name: 'Composite',
                    className: 'ResourceStatistics'
                }
            }
        }
    }
};
exports.JobStatistics = {
    required: false,
    serializedName: 'JobStatistics',
    type: {
        name: 'Composite',
        className: 'JobStatistics',
        modelProperties: {
            url: {
                required: true,
                serializedName: 'url',
                type: {
                    name: 'String'
                }
            },
            startTime: {
                required: true,
                serializedName: 'startTime',
                type: {
                    name: 'DateTime'
                }
            },
            lastUpdateTime: {
                required: true,
                serializedName: 'lastUpdateTime',
                type: {
                    name: 'DateTime'
                }
            },
            userCPUTime: {
                required: true,
                serializedName: 'userCPUTime',
                type: {
                    name: 'TimeSpan'
                }
            },
            kernelCPUTime: {
                required: true,
                serializedName: 'kernelCPUTime',
                type: {
                    name: 'TimeSpan'
                }
            },
            wallClockTime: {
                required: true,
                serializedName: 'wallClockTime',
                type: {
                    name: 'TimeSpan'
                }
            },
            readIOps: {
                required: true,
                serializedName: 'readIOps',
                type: {
                    name: 'Number'
                }
            },
            writeIOps: {
                required: true,
                serializedName: 'writeIOps',
                type: {
                    name: 'Number'
                }
            },
            readIOGiB: {
                required: true,
                serializedName: 'readIOGiB',
                type: {
                    name: 'Number'
                }
            },
            writeIOGiB: {
                required: true,
                serializedName: 'writeIOGiB',
                type: {
                    name: 'Number'
                }
            },
            numSucceededTasks: {
                required: true,
                serializedName: 'numSucceededTasks',
                type: {
                    name: 'Number'
                }
            },
            numFailedTasks: {
                required: true,
                serializedName: 'numFailedTasks',
                type: {
                    name: 'Number'
                }
            },
            numTaskRetries: {
                required: true,
                serializedName: 'numTaskRetries',
                type: {
                    name: 'Number'
                }
            },
            waitTime: {
                required: true,
                serializedName: 'waitTime',
                type: {
                    name: 'TimeSpan'
                }
            }
        }
    }
};
exports.NameValuePair = {
    required: false,
    serializedName: 'NameValuePair',
    type: {
        name: 'Composite',
        className: 'NameValuePair',
        modelProperties: {
            name: {
                required: false,
                serializedName: 'name',
                type: {
                    name: 'String'
                }
            },
            value: {
                required: false,
                serializedName: 'value',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.DeleteCertificateError = {
    required: false,
    serializedName: 'DeleteCertificateError',
    type: {
        name: 'Composite',
        className: 'DeleteCertificateError',
        modelProperties: {
            code: {
                required: false,
                serializedName: 'code',
                type: {
                    name: 'String'
                }
            },
            message: {
                required: false,
                serializedName: 'message',
                type: {
                    name: 'String'
                }
            },
            values: {
                required: false,
                serializedName: 'values',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'NameValuePairElementType',
                        type: {
                            name: 'Composite',
                            className: 'NameValuePair'
                        }
                    }
                }
            }
        }
    }
};
exports.Certificate = {
    required: false,
    serializedName: 'Certificate',
    type: {
        name: 'Composite',
        className: 'Certificate',
        modelProperties: {
            thumbprint: {
                required: false,
                serializedName: 'thumbprint',
                type: {
                    name: 'String'
                }
            },
            thumbprintAlgorithm: {
                required: false,
                serializedName: 'thumbprintAlgorithm',
                type: {
                    name: 'String'
                }
            },
            url: {
                required: false,
                serializedName: 'url',
                type: {
                    name: 'String'
                }
            },
            state: {
                required: false,
                serializedName: 'state',
                type: {
                    name: 'Enum',
                    allowedValues: ['active', 'deleting', 'deleteFailed']
                }
            },
            stateTransitionTime: {
                required: false,
                serializedName: 'stateTransitionTime',
                type: {
                    name: 'DateTime'
                }
            },
            previousState: {
                required: false,
                serializedName: 'previousState',
                type: {
                    name: 'Enum',
                    allowedValues: ['active', 'deleting', 'deleteFailed']
                }
            },
            previousStateTransitionTime: {
                required: false,
                serializedName: 'previousStateTransitionTime',
                type: {
                    name: 'DateTime'
                }
            },
            publicData: {
                required: false,
                serializedName: 'publicData',
                type: {
                    name: 'String'
                }
            },
            deleteCertificateError: {
                required: false,
                serializedName: 'deleteCertificateError',
                type: {
                    name: 'Composite',
                    className: 'DeleteCertificateError'
                }
            }
        }
    }
};
exports.ApplicationPackageReference = {
    required: false,
    serializedName: 'ApplicationPackageReference',
    type: {
        name: 'Composite',
        className: 'ApplicationPackageReference',
        modelProperties: {
            applicationId: {
                required: true,
                serializedName: 'applicationId',
                type: {
                    name: 'String'
                }
            },
            version: {
                required: false,
                serializedName: 'version',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.ApplicationSummary = {
    required: false,
    serializedName: 'ApplicationSummary',
    type: {
        name: 'Composite',
        className: 'ApplicationSummary',
        modelProperties: {
            id: {
                required: true,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            displayName: {
                required: true,
                serializedName: 'displayName',
                type: {
                    name: 'String'
                }
            },
            versions: {
                required: true,
                serializedName: 'versions',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'stringElementType',
                        type: {
                            name: 'String'
                        }
                    }
                }
            }
        }
    }
};
exports.CertificateAddParameter = {
    required: false,
    serializedName: 'CertificateAddParameter',
    type: {
        name: 'Composite',
        className: 'CertificateAddParameter',
        modelProperties: {
            thumbprint: {
                required: true,
                serializedName: 'thumbprint',
                type: {
                    name: 'String'
                }
            },
            thumbprintAlgorithm: {
                required: true,
                serializedName: 'thumbprintAlgorithm',
                type: {
                    name: 'String'
                }
            },
            data: {
                required: true,
                serializedName: 'data',
                type: {
                    name: 'String'
                }
            },
            certificateFormat: {
                required: false,
                serializedName: 'certificateFormat',
                type: {
                    name: 'Enum',
                    allowedValues: ['pfx', 'cer']
                }
            },
            password: {
                required: false,
                serializedName: 'password',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.FileProperties = {
    required: false,
    serializedName: 'FileProperties',
    type: {
        name: 'Composite',
        className: 'FileProperties',
        modelProperties: {
            creationTime: {
                required: false,
                serializedName: 'creationTime',
                type: {
                    name: 'DateTime'
                }
            },
            lastModified: {
                required: true,
                serializedName: 'lastModified',
                type: {
                    name: 'DateTime'
                }
            },
            contentLength: {
                required: true,
                serializedName: 'contentLength',
                type: {
                    name: 'Number'
                }
            },
            contentType: {
                required: false,
                serializedName: 'contentType',
                type: {
                    name: 'String'
                }
            },
            fileMode: {
                required: false,
                serializedName: 'fileMode',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.NodeFile = {
    required: false,
    serializedName: 'NodeFile',
    type: {
        name: 'Composite',
        className: 'NodeFile',
        modelProperties: {
            name: {
                required: false,
                serializedName: 'name',
                type: {
                    name: 'String'
                }
            },
            url: {
                required: false,
                serializedName: 'url',
                type: {
                    name: 'String'
                }
            },
            isDirectory: {
                required: false,
                serializedName: 'isDirectory',
                type: {
                    name: 'Boolean'
                }
            },
            properties: {
                required: false,
                serializedName: 'properties',
                type: {
                    name: 'Composite',
                    className: 'FileProperties'
                }
            }
        }
    }
};
exports.Schedule = {
    required: false,
    serializedName: 'Schedule',
    type: {
        name: 'Composite',
        className: 'Schedule',
        modelProperties: {
            doNotRunUntil: {
                required: false,
                serializedName: 'doNotRunUntil',
                type: {
                    name: 'DateTime'
                }
            },
            doNotRunAfter: {
                required: false,
                serializedName: 'doNotRunAfter',
                type: {
                    name: 'DateTime'
                }
            },
            startWindow: {
                required: false,
                serializedName: 'startWindow',
                type: {
                    name: 'TimeSpan'
                }
            },
            recurrenceInterval: {
                required: false,
                serializedName: 'recurrenceInterval',
                type: {
                    name: 'TimeSpan'
                }
            }
        }
    }
};
exports.JobConstraints = {
    required: false,
    serializedName: 'JobConstraints',
    type: {
        name: 'Composite',
        className: 'JobConstraints',
        modelProperties: {
            maxWallClockTime: {
                required: false,
                serializedName: 'maxWallClockTime',
                type: {
                    name: 'TimeSpan'
                }
            },
            maxTaskRetryCount: {
                required: false,
                serializedName: 'maxTaskRetryCount',
                type: {
                    name: 'Number'
                }
            }
        }
    }
};
exports.ContainerRegistry = {
    required: false,
    serializedName: 'ContainerRegistry',
    type: {
        name: 'Composite',
        className: 'ContainerRegistry',
        modelProperties: {
            registryServer: {
                required: false,
                serializedName: 'registryServer',
                type: {
                    name: 'String'
                }
            },
            userName: {
                required: true,
                serializedName: 'username',
                type: {
                    name: 'String'
                }
            },
            password: {
                required: true,
                serializedName: 'password',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.TaskContainerSettings = {
    required: false,
    serializedName: 'TaskContainerSettings',
    type: {
        name: 'Composite',
        className: 'TaskContainerSettings',
        modelProperties: {
            containerRunOptions: {
                required: false,
                serializedName: 'containerRunOptions',
                type: {
                    name: 'String'
                }
            },
            imageName: {
                required: true,
                serializedName: 'imageName',
                type: {
                    name: 'String'
                }
            },
            registry: {
                required: false,
                serializedName: 'registry',
                type: {
                    name: 'Composite',
                    className: 'ContainerRegistry'
                }
            }
        }
    }
};
exports.ResourceFile = {
    required: false,
    serializedName: 'ResourceFile',
    type: {
        name: 'Composite',
        className: 'ResourceFile',
        modelProperties: {
            blobSource: {
                required: true,
                serializedName: 'blobSource',
                type: {
                    name: 'String'
                }
            },
            filePath: {
                required: true,
                serializedName: 'filePath',
                type: {
                    name: 'String'
                }
            },
            fileMode: {
                required: false,
                serializedName: 'fileMode',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.EnvironmentSetting = {
    required: false,
    serializedName: 'EnvironmentSetting',
    type: {
        name: 'Composite',
        className: 'EnvironmentSetting',
        modelProperties: {
            name: {
                required: true,
                serializedName: 'name',
                type: {
                    name: 'String'
                }
            },
            value: {
                required: false,
                serializedName: 'value',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.ExitOptions = {
    required: false,
    serializedName: 'ExitOptions',
    type: {
        name: 'Composite',
        className: 'ExitOptions',
        modelProperties: {
            jobAction: {
                required: false,
                serializedName: 'jobAction',
                type: {
                    name: 'Enum',
                    allowedValues: ['none', 'disable', 'terminate']
                }
            },
            dependencyAction: {
                required: false,
                serializedName: 'dependencyAction',
                type: {
                    name: 'Enum',
                    allowedValues: ['satisfy', 'block']
                }
            }
        }
    }
};
exports.ExitCodeMapping = {
    required: false,
    serializedName: 'ExitCodeMapping',
    type: {
        name: 'Composite',
        className: 'ExitCodeMapping',
        modelProperties: {
            code: {
                required: true,
                serializedName: 'code',
                type: {
                    name: 'Number'
                }
            },
            exitOptions: {
                required: true,
                serializedName: 'exitOptions',
                type: {
                    name: 'Composite',
                    className: 'ExitOptions'
                }
            }
        }
    }
};
exports.ExitCodeRangeMapping = {
    required: false,
    serializedName: 'ExitCodeRangeMapping',
    type: {
        name: 'Composite',
        className: 'ExitCodeRangeMapping',
        modelProperties: {
            start: {
                required: true,
                serializedName: 'start',
                type: {
                    name: 'Number'
                }
            },
            end: {
                required: true,
                serializedName: 'end',
                type: {
                    name: 'Number'
                }
            },
            exitOptions: {
                required: true,
                serializedName: 'exitOptions',
                type: {
                    name: 'Composite',
                    className: 'ExitOptions'
                }
            }
        }
    }
};
exports.ExitConditions = {
    required: false,
    serializedName: 'ExitConditions',
    type: {
        name: 'Composite',
        className: 'ExitConditions',
        modelProperties: {
            exitCodes: {
                required: false,
                serializedName: 'exitCodes',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ExitCodeMappingElementType',
                        type: {
                            name: 'Composite',
                            className: 'ExitCodeMapping'
                        }
                    }
                }
            },
            exitCodeRanges: {
                required: false,
                serializedName: 'exitCodeRanges',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ExitCodeRangeMappingElementType',
                        type: {
                            name: 'Composite',
                            className: 'ExitCodeRangeMapping'
                        }
                    }
                }
            },
            preProcessingError: {
                required: false,
                serializedName: 'preProcessingError',
                type: {
                    name: 'Composite',
                    className: 'ExitOptions'
                }
            },
            fileUploadError: {
                required: false,
                serializedName: 'fileUploadError',
                type: {
                    name: 'Composite',
                    className: 'ExitOptions'
                }
            },
            default: {
                required: false,
                serializedName: 'default',
                type: {
                    name: 'Composite',
                    className: 'ExitOptions'
                }
            }
        }
    }
};
exports.AutoUserSpecification = {
    required: false,
    serializedName: 'AutoUserSpecification',
    type: {
        name: 'Composite',
        className: 'AutoUserSpecification',
        modelProperties: {
            scope: {
                required: false,
                serializedName: 'scope',
                type: {
                    name: 'Enum',
                    allowedValues: ['task', 'pool']
                }
            },
            elevationLevel: {
                required: false,
                serializedName: 'elevationLevel',
                type: {
                    name: 'Enum',
                    allowedValues: ['nonAdmin', 'admin']
                }
            }
        }
    }
};
exports.UserIdentity = {
    required: false,
    serializedName: 'UserIdentity',
    type: {
        name: 'Composite',
        className: 'UserIdentity',
        modelProperties: {
            userName: {
                required: false,
                serializedName: 'username',
                type: {
                    name: 'String'
                }
            },
            autoUser: {
                required: false,
                serializedName: 'autoUser',
                type: {
                    name: 'Composite',
                    className: 'AutoUserSpecification'
                }
            }
        }
    }
};
exports.LinuxUserConfiguration = {
    required: false,
    serializedName: 'LinuxUserConfiguration',
    type: {
        name: 'Composite',
        className: 'LinuxUserConfiguration',
        modelProperties: {
            uid: {
                required: false,
                serializedName: 'uid',
                type: {
                    name: 'Number'
                }
            },
            gid: {
                required: false,
                serializedName: 'gid',
                type: {
                    name: 'Number'
                }
            },
            sshPrivateKey: {
                required: false,
                serializedName: 'sshPrivateKey',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.UserAccount = {
    required: false,
    serializedName: 'UserAccount',
    type: {
        name: 'Composite',
        className: 'UserAccount',
        modelProperties: {
            name: {
                required: true,
                serializedName: 'name',
                type: {
                    name: 'String'
                }
            },
            password: {
                required: true,
                serializedName: 'password',
                type: {
                    name: 'String'
                }
            },
            elevationLevel: {
                required: false,
                serializedName: 'elevationLevel',
                type: {
                    name: 'Enum',
                    allowedValues: ['nonAdmin', 'admin']
                }
            },
            linuxUserConfiguration: {
                required: false,
                serializedName: 'linuxUserConfiguration',
                type: {
                    name: 'Composite',
                    className: 'LinuxUserConfiguration'
                }
            }
        }
    }
};
exports.TaskConstraints = {
    required: false,
    serializedName: 'TaskConstraints',
    type: {
        name: 'Composite',
        className: 'TaskConstraints',
        modelProperties: {
            maxWallClockTime: {
                required: false,
                serializedName: 'maxWallClockTime',
                type: {
                    name: 'TimeSpan'
                }
            },
            retentionTime: {
                required: false,
                serializedName: 'retentionTime',
                type: {
                    name: 'TimeSpan'
                }
            },
            maxTaskRetryCount: {
                required: false,
                serializedName: 'maxTaskRetryCount',
                type: {
                    name: 'Number'
                }
            }
        }
    }
};
exports.OutputFileBlobContainerDestination = {
    required: false,
    serializedName: 'OutputFileBlobContainerDestination',
    type: {
        name: 'Composite',
        className: 'OutputFileBlobContainerDestination',
        modelProperties: {
            path: {
                required: false,
                serializedName: 'path',
                type: {
                    name: 'String'
                }
            },
            containerUrl: {
                required: true,
                serializedName: 'containerUrl',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.OutputFileDestination = {
    required: false,
    serializedName: 'OutputFileDestination',
    type: {
        name: 'Composite',
        className: 'OutputFileDestination',
        modelProperties: {
            container: {
                required: false,
                serializedName: 'container',
                type: {
                    name: 'Composite',
                    className: 'OutputFileBlobContainerDestination'
                }
            }
        }
    }
};
exports.OutputFileUploadOptions = {
    required: false,
    serializedName: 'OutputFileUploadOptions',
    type: {
        name: 'Composite',
        className: 'OutputFileUploadOptions',
        modelProperties: {
            uploadCondition: {
                required: true,
                serializedName: 'uploadCondition',
                type: {
                    name: 'Enum',
                    allowedValues: ['taskSuccess', 'taskFailure', 'taskCompletion']
                }
            }
        }
    }
};
exports.OutputFile = {
    required: false,
    serializedName: 'OutputFile',
    type: {
        name: 'Composite',
        className: 'OutputFile',
        modelProperties: {
            filePattern: {
                required: true,
                serializedName: 'filePattern',
                type: {
                    name: 'String'
                }
            },
            destination: {
                required: true,
                serializedName: 'destination',
                type: {
                    name: 'Composite',
                    className: 'OutputFileDestination'
                }
            },
            uploadOptions: {
                required: true,
                serializedName: 'uploadOptions',
                type: {
                    name: 'Composite',
                    className: 'OutputFileUploadOptions'
                }
            }
        }
    }
};
exports.JobManagerTask = {
    required: false,
    serializedName: 'JobManagerTask',
    type: {
        name: 'Composite',
        className: 'JobManagerTask',
        modelProperties: {
            id: {
                required: true,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            displayName: {
                required: false,
                serializedName: 'displayName',
                type: {
                    name: 'String'
                }
            },
            commandLine: {
                required: true,
                serializedName: 'commandLine',
                type: {
                    name: 'String'
                }
            },
            containerSettings: {
                required: false,
                serializedName: 'containerSettings',
                type: {
                    name: 'Composite',
                    className: 'TaskContainerSettings'
                }
            },
            resourceFiles: {
                required: false,
                serializedName: 'resourceFiles',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ResourceFileElementType',
                        type: {
                            name: 'Composite',
                            className: 'ResourceFile'
                        }
                    }
                }
            },
            outputFiles: {
                required: false,
                serializedName: 'outputFiles',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'OutputFileElementType',
                        type: {
                            name: 'Composite',
                            className: 'OutputFile'
                        }
                    }
                }
            },
            environmentSettings: {
                required: false,
                serializedName: 'environmentSettings',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'EnvironmentSettingElementType',
                        type: {
                            name: 'Composite',
                            className: 'EnvironmentSetting'
                        }
                    }
                }
            },
            constraints: {
                required: false,
                serializedName: 'constraints',
                type: {
                    name: 'Composite',
                    className: 'TaskConstraints'
                }
            },
            killJobOnCompletion: {
                required: false,
                serializedName: 'killJobOnCompletion',
                type: {
                    name: 'Boolean'
                }
            },
            userIdentity: {
                required: false,
                serializedName: 'userIdentity',
                type: {
                    name: 'Composite',
                    className: 'UserIdentity'
                }
            },
            runExclusive: {
                required: false,
                serializedName: 'runExclusive',
                type: {
                    name: 'Boolean'
                }
            },
            applicationPackageReferences: {
                required: false,
                serializedName: 'applicationPackageReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ApplicationPackageReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'ApplicationPackageReference'
                        }
                    }
                }
            },
            authenticationTokenSettings: {
                required: false,
                serializedName: 'authenticationTokenSettings',
                type: {
                    name: 'Composite',
                    className: 'AuthenticationTokenSettings'
                }
            },
            allowLowPriorityNode: {
                required: false,
                serializedName: 'allowLowPriorityNode',
                type: {
                    name: 'Boolean'
                }
            }
        }
    }
};
exports.JobPreparationTask = {
    required: false,
    serializedName: 'JobPreparationTask',
    type: {
        name: 'Composite',
        className: 'JobPreparationTask',
        modelProperties: {
            id: {
                required: false,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            commandLine: {
                required: true,
                serializedName: 'commandLine',
                type: {
                    name: 'String'
                }
            },
            containerSettings: {
                required: false,
                serializedName: 'containerSettings',
                type: {
                    name: 'Composite',
                    className: 'TaskContainerSettings'
                }
            },
            resourceFiles: {
                required: false,
                serializedName: 'resourceFiles',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ResourceFileElementType',
                        type: {
                            name: 'Composite',
                            className: 'ResourceFile'
                        }
                    }
                }
            },
            environmentSettings: {
                required: false,
                serializedName: 'environmentSettings',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'EnvironmentSettingElementType',
                        type: {
                            name: 'Composite',
                            className: 'EnvironmentSetting'
                        }
                    }
                }
            },
            constraints: {
                required: false,
                serializedName: 'constraints',
                type: {
                    name: 'Composite',
                    className: 'TaskConstraints'
                }
            },
            waitForSuccess: {
                required: false,
                serializedName: 'waitForSuccess',
                type: {
                    name: 'Boolean'
                }
            },
            userIdentity: {
                required: false,
                serializedName: 'userIdentity',
                type: {
                    name: 'Composite',
                    className: 'UserIdentity'
                }
            },
            rerunOnNodeRebootAfterSuccess: {
                required: false,
                serializedName: 'rerunOnNodeRebootAfterSuccess',
                type: {
                    name: 'Boolean'
                }
            }
        }
    }
};
exports.JobReleaseTask = {
    required: false,
    serializedName: 'JobReleaseTask',
    type: {
        name: 'Composite',
        className: 'JobReleaseTask',
        modelProperties: {
            id: {
                required: false,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            commandLine: {
                required: true,
                serializedName: 'commandLine',
                type: {
                    name: 'String'
                }
            },
            containerSettings: {
                required: false,
                serializedName: 'containerSettings',
                type: {
                    name: 'Composite',
                    className: 'TaskContainerSettings'
                }
            },
            resourceFiles: {
                required: false,
                serializedName: 'resourceFiles',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ResourceFileElementType',
                        type: {
                            name: 'Composite',
                            className: 'ResourceFile'
                        }
                    }
                }
            },
            environmentSettings: {
                required: false,
                serializedName: 'environmentSettings',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'EnvironmentSettingElementType',
                        type: {
                            name: 'Composite',
                            className: 'EnvironmentSetting'
                        }
                    }
                }
            },
            maxWallClockTime: {
                required: false,
                serializedName: 'maxWallClockTime',
                type: {
                    name: 'TimeSpan'
                }
            },
            retentionTime: {
                required: false,
                serializedName: 'retentionTime',
                type: {
                    name: 'TimeSpan'
                }
            },
            userIdentity: {
                required: false,
                serializedName: 'userIdentity',
                type: {
                    name: 'Composite',
                    className: 'UserIdentity'
                }
            }
        }
    }
};
exports.TaskSchedulingPolicy = {
    required: false,
    serializedName: 'TaskSchedulingPolicy',
    type: {
        name: 'Composite',
        className: 'TaskSchedulingPolicy',
        modelProperties: {
            nodeFillType: {
                required: true,
                serializedName: 'nodeFillType',
                type: {
                    name: 'Enum',
                    allowedValues: ['spread', 'pack']
                }
            }
        }
    }
};
exports.StartTask = {
    required: false,
    serializedName: 'StartTask',
    type: {
        name: 'Composite',
        className: 'StartTask',
        modelProperties: {
            commandLine: {
                required: true,
                serializedName: 'commandLine',
                type: {
                    name: 'String'
                }
            },
            containerSettings: {
                required: false,
                serializedName: 'containerSettings',
                type: {
                    name: 'Composite',
                    className: 'TaskContainerSettings'
                }
            },
            resourceFiles: {
                required: false,
                serializedName: 'resourceFiles',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ResourceFileElementType',
                        type: {
                            name: 'Composite',
                            className: 'ResourceFile'
                        }
                    }
                }
            },
            environmentSettings: {
                required: false,
                serializedName: 'environmentSettings',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'EnvironmentSettingElementType',
                        type: {
                            name: 'Composite',
                            className: 'EnvironmentSetting'
                        }
                    }
                }
            },
            userIdentity: {
                required: false,
                serializedName: 'userIdentity',
                type: {
                    name: 'Composite',
                    className: 'UserIdentity'
                }
            },
            maxTaskRetryCount: {
                required: false,
                serializedName: 'maxTaskRetryCount',
                type: {
                    name: 'Number'
                }
            },
            waitForSuccess: {
                required: false,
                serializedName: 'waitForSuccess',
                type: {
                    name: 'Boolean'
                }
            }
        }
    }
};
exports.CertificateReference = {
    required: false,
    serializedName: 'CertificateReference',
    type: {
        name: 'Composite',
        className: 'CertificateReference',
        modelProperties: {
            thumbprint: {
                required: true,
                serializedName: 'thumbprint',
                type: {
                    name: 'String'
                }
            },
            thumbprintAlgorithm: {
                required: true,
                serializedName: 'thumbprintAlgorithm',
                type: {
                    name: 'String'
                }
            },
            storeLocation: {
                required: false,
                serializedName: 'storeLocation',
                type: {
                    name: 'Enum',
                    allowedValues: ['currentUser', 'localMachine']
                }
            },
            storeName: {
                required: false,
                serializedName: 'storeName',
                type: {
                    name: 'String'
                }
            },
            visibility: {
                required: false,
                serializedName: 'visibility',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'CertificateVisibilityElementType',
                        type: {
                            name: 'Enum',
                            allowedValues: ['startTask', 'task', 'remoteUser']
                        }
                    }
                }
            }
        }
    }
};
exports.MetadataItem = {
    required: false,
    serializedName: 'MetadataItem',
    type: {
        name: 'Composite',
        className: 'MetadataItem',
        modelProperties: {
            name: {
                required: true,
                serializedName: 'name',
                type: {
                    name: 'String'
                }
            },
            value: {
                required: true,
                serializedName: 'value',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.CloudServiceConfiguration = {
    required: false,
    serializedName: 'CloudServiceConfiguration',
    type: {
        name: 'Composite',
        className: 'CloudServiceConfiguration',
        modelProperties: {
            osFamily: {
                required: true,
                serializedName: 'osFamily',
                type: {
                    name: 'String'
                }
            },
            targetOSVersion: {
                required: false,
                serializedName: 'targetOSVersion',
                type: {
                    name: 'String'
                }
            },
            currentOSVersion: {
                required: false,
                readOnly: true,
                serializedName: 'currentOSVersion',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.OSDisk = {
    required: false,
    serializedName: 'OSDisk',
    type: {
        name: 'Composite',
        className: 'OSDisk',
        modelProperties: {
            caching: {
                required: false,
                serializedName: 'caching',
                type: {
                    name: 'Enum',
                    allowedValues: ['none', 'readOnly', 'readWrite']
                }
            }
        }
    }
};
exports.WindowsConfiguration = {
    required: false,
    serializedName: 'WindowsConfiguration',
    type: {
        name: 'Composite',
        className: 'WindowsConfiguration',
        modelProperties: {
            enableAutomaticUpdates: {
                required: false,
                serializedName: 'enableAutomaticUpdates',
                type: {
                    name: 'Boolean'
                }
            }
        }
    }
};
exports.DataDisk = {
    required: false,
    serializedName: 'DataDisk',
    type: {
        name: 'Composite',
        className: 'DataDisk',
        modelProperties: {
            lun: {
                required: true,
                serializedName: 'lun',
                type: {
                    name: 'Number'
                }
            },
            caching: {
                required: false,
                serializedName: 'caching',
                type: {
                    name: 'Enum',
                    allowedValues: ['none', 'readOnly', 'readWrite']
                }
            },
            diskSizeGB: {
                required: true,
                serializedName: 'diskSizeGB',
                type: {
                    name: 'Number'
                }
            },
            storageAccountType: {
                required: false,
                serializedName: 'storageAccountType',
                type: {
                    name: 'Enum',
                    allowedValues: ['Standard_LRS', 'Premium_LRS']
                }
            }
        }
    }
};
exports.ContainerConfiguration = {
    required: false,
    serializedName: 'ContainerConfiguration',
    type: {
        name: 'Composite',
        className: 'ContainerConfiguration',
        modelProperties: {
            type: {
                required: true,
                isConstant: true,
                serializedName: 'type',
                defaultValue: 'docker',
                type: {
                    name: 'String'
                }
            },
            containerImageNames: {
                required: false,
                serializedName: 'containerImageNames',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'stringElementType',
                        type: {
                            name: 'String'
                        }
                    }
                }
            },
            containerRegistries: {
                required: false,
                serializedName: 'containerRegistries',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ContainerRegistryElementType',
                        type: {
                            name: 'Composite',
                            className: 'ContainerRegistry'
                        }
                    }
                }
            }
        }
    }
};
exports.VirtualMachineConfiguration = {
    required: false,
    serializedName: 'VirtualMachineConfiguration',
    type: {
        name: 'Composite',
        className: 'VirtualMachineConfiguration',
        modelProperties: {
            imageReference: {
                required: true,
                serializedName: 'imageReference',
                type: {
                    name: 'Composite',
                    className: 'ImageReference'
                }
            },
            osDisk: {
                required: false,
                serializedName: 'osDisk',
                type: {
                    name: 'Composite',
                    className: 'OSDisk'
                }
            },
            nodeAgentSKUId: {
                required: true,
                serializedName: 'nodeAgentSKUId',
                type: {
                    name: 'String'
                }
            },
            windowsConfiguration: {
                required: false,
                serializedName: 'windowsConfiguration',
                type: {
                    name: 'Composite',
                    className: 'WindowsConfiguration'
                }
            },
            dataDisks: {
                required: false,
                serializedName: 'dataDisks',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'DataDiskElementType',
                        type: {
                            name: 'Composite',
                            className: 'DataDisk'
                        }
                    }
                }
            },
            licenseType: {
                required: false,
                serializedName: 'licenseType',
                type: {
                    name: 'String'
                }
            },
            containerConfiguration: {
                required: false,
                serializedName: 'containerConfiguration',
                type: {
                    name: 'Composite',
                    className: 'ContainerConfiguration'
                }
            }
        }
    }
};
exports.NetworkSecurityGroupRule = {
    required: false,
    serializedName: 'NetworkSecurityGroupRule',
    type: {
        name: 'Composite',
        className: 'NetworkSecurityGroupRule',
        modelProperties: {
            priority: {
                required: true,
                serializedName: 'priority',
                type: {
                    name: 'Number'
                }
            },
            access: {
                required: true,
                serializedName: 'access',
                type: {
                    name: 'Enum',
                    allowedValues: ['allow', 'deny']
                }
            },
            sourceAddressPrefix: {
                required: true,
                serializedName: 'sourceAddressPrefix',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.InboundNATPool = {
    required: false,
    serializedName: 'InboundNATPool',
    type: {
        name: 'Composite',
        className: 'InboundNATPool',
        modelProperties: {
            name: {
                required: true,
                serializedName: 'name',
                type: {
                    name: 'String'
                }
            },
            protocol: {
                required: true,
                serializedName: 'protocol',
                type: {
                    name: 'Enum',
                    allowedValues: ['tcp', 'udp']
                }
            },
            backendPort: {
                required: true,
                serializedName: 'backendPort',
                type: {
                    name: 'Number'
                }
            },
            frontendPortRangeStart: {
                required: true,
                serializedName: 'frontendPortRangeStart',
                type: {
                    name: 'Number'
                }
            },
            frontendPortRangeEnd: {
                required: true,
                serializedName: 'frontendPortRangeEnd',
                type: {
                    name: 'Number'
                }
            },
            networkSecurityGroupRules: {
                required: false,
                serializedName: 'networkSecurityGroupRules',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'NetworkSecurityGroupRuleElementType',
                        type: {
                            name: 'Composite',
                            className: 'NetworkSecurityGroupRule'
                        }
                    }
                }
            }
        }
    }
};
exports.PoolEndpointConfiguration = {
    required: false,
    serializedName: 'PoolEndpointConfiguration',
    type: {
        name: 'Composite',
        className: 'PoolEndpointConfiguration',
        modelProperties: {
            inboundNATPools: {
                required: true,
                serializedName: 'inboundNATPools',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'InboundNATPoolElementType',
                        type: {
                            name: 'Composite',
                            className: 'InboundNATPool'
                        }
                    }
                }
            }
        }
    }
};
exports.NetworkConfiguration = {
    required: false,
    serializedName: 'NetworkConfiguration',
    type: {
        name: 'Composite',
        className: 'NetworkConfiguration',
        modelProperties: {
            subnetId: {
                required: false,
                serializedName: 'subnetId',
                type: {
                    name: 'String'
                }
            },
            endpointConfiguration: {
                required: false,
                serializedName: 'endpointConfiguration',
                type: {
                    name: 'Composite',
                    className: 'PoolEndpointConfiguration'
                }
            }
        }
    }
};
exports.PoolSpecification = {
    required: false,
    serializedName: 'PoolSpecification',
    type: {
        name: 'Composite',
        className: 'PoolSpecification',
        modelProperties: {
            displayName: {
                required: false,
                serializedName: 'displayName',
                type: {
                    name: 'String'
                }
            },
            vmSize: {
                required: true,
                serializedName: 'vmSize',
                type: {
                    name: 'String'
                }
            },
            cloudServiceConfiguration: {
                required: false,
                serializedName: 'cloudServiceConfiguration',
                type: {
                    name: 'Composite',
                    className: 'CloudServiceConfiguration'
                }
            },
            virtualMachineConfiguration: {
                required: false,
                serializedName: 'virtualMachineConfiguration',
                type: {
                    name: 'Composite',
                    className: 'VirtualMachineConfiguration'
                }
            },
            maxTasksPerNode: {
                required: false,
                serializedName: 'maxTasksPerNode',
                type: {
                    name: 'Number'
                }
            },
            taskSchedulingPolicy: {
                required: false,
                serializedName: 'taskSchedulingPolicy',
                type: {
                    name: 'Composite',
                    className: 'TaskSchedulingPolicy'
                }
            },
            resizeTimeout: {
                required: false,
                serializedName: 'resizeTimeout',
                type: {
                    name: 'TimeSpan'
                }
            },
            targetDedicatedNodes: {
                required: false,
                serializedName: 'targetDedicatedNodes',
                type: {
                    name: 'Number'
                }
            },
            targetLowPriorityNodes: {
                required: false,
                serializedName: 'targetLowPriorityNodes',
                type: {
                    name: 'Number'
                }
            },
            enableAutoScale: {
                required: false,
                serializedName: 'enableAutoScale',
                type: {
                    name: 'Boolean'
                }
            },
            autoScaleFormula: {
                required: false,
                serializedName: 'autoScaleFormula',
                type: {
                    name: 'String'
                }
            },
            autoScaleEvaluationInterval: {
                required: false,
                serializedName: 'autoScaleEvaluationInterval',
                type: {
                    name: 'TimeSpan'
                }
            },
            enableInterNodeCommunication: {
                required: false,
                serializedName: 'enableInterNodeCommunication',
                type: {
                    name: 'Boolean'
                }
            },
            networkConfiguration: {
                required: false,
                serializedName: 'networkConfiguration',
                type: {
                    name: 'Composite',
                    className: 'NetworkConfiguration'
                }
            },
            startTask: {
                required: false,
                serializedName: 'startTask',
                type: {
                    name: 'Composite',
                    className: 'StartTask'
                }
            },
            certificateReferences: {
                required: false,
                serializedName: 'certificateReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'CertificateReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'CertificateReference'
                        }
                    }
                }
            },
            applicationPackageReferences: {
                required: false,
                serializedName: 'applicationPackageReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ApplicationPackageReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'ApplicationPackageReference'
                        }
                    }
                }
            },
            applicationLicenses: {
                required: false,
                serializedName: 'applicationLicenses',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'stringElementType',
                        type: {
                            name: 'String'
                        }
                    }
                }
            },
            userAccounts: {
                required: false,
                serializedName: 'userAccounts',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'UserAccountElementType',
                        type: {
                            name: 'Composite',
                            className: 'UserAccount'
                        }
                    }
                }
            },
            metadata: {
                required: false,
                serializedName: 'metadata',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'MetadataItemElementType',
                        type: {
                            name: 'Composite',
                            className: 'MetadataItem'
                        }
                    }
                }
            }
        }
    }
};
exports.AutoPoolSpecification = {
    required: false,
    serializedName: 'AutoPoolSpecification',
    type: {
        name: 'Composite',
        className: 'AutoPoolSpecification',
        modelProperties: {
            autoPoolIdPrefix: {
                required: false,
                serializedName: 'autoPoolIdPrefix',
                type: {
                    name: 'String'
                }
            },
            poolLifetimeOption: {
                required: true,
                serializedName: 'poolLifetimeOption',
                type: {
                    name: 'Enum',
                    allowedValues: ['jobSchedule', 'job']
                }
            },
            keepAlive: {
                required: false,
                serializedName: 'keepAlive',
                type: {
                    name: 'Boolean'
                }
            },
            pool: {
                required: false,
                serializedName: 'pool',
                type: {
                    name: 'Composite',
                    className: 'PoolSpecification'
                }
            }
        }
    }
};
exports.PoolInformation = {
    required: false,
    serializedName: 'PoolInformation',
    type: {
        name: 'Composite',
        className: 'PoolInformation',
        modelProperties: {
            poolId: {
                required: false,
                serializedName: 'poolId',
                type: {
                    name: 'String'
                }
            },
            autoPoolSpecification: {
                required: false,
                serializedName: 'autoPoolSpecification',
                type: {
                    name: 'Composite',
                    className: 'AutoPoolSpecification'
                }
            }
        }
    }
};
exports.JobSpecification = {
    required: false,
    serializedName: 'JobSpecification',
    type: {
        name: 'Composite',
        className: 'JobSpecification',
        modelProperties: {
            priority: {
                required: false,
                serializedName: 'priority',
                type: {
                    name: 'Number'
                }
            },
            displayName: {
                required: false,
                serializedName: 'displayName',
                type: {
                    name: 'String'
                }
            },
            usesTaskDependencies: {
                required: false,
                serializedName: 'usesTaskDependencies',
                type: {
                    name: 'Boolean'
                }
            },
            onAllTasksComplete: {
                required: false,
                serializedName: 'onAllTasksComplete',
                type: {
                    name: 'Enum',
                    allowedValues: ['noAction', 'terminateJob']
                }
            },
            onTaskFailure: {
                required: false,
                serializedName: 'onTaskFailure',
                type: {
                    name: 'Enum',
                    allowedValues: ['noAction', 'performExitOptionsJobAction']
                }
            },
            constraints: {
                required: false,
                serializedName: 'constraints',
                type: {
                    name: 'Composite',
                    className: 'JobConstraints'
                }
            },
            jobManagerTask: {
                required: false,
                serializedName: 'jobManagerTask',
                type: {
                    name: 'Composite',
                    className: 'JobManagerTask'
                }
            },
            jobPreparationTask: {
                required: false,
                serializedName: 'jobPreparationTask',
                type: {
                    name: 'Composite',
                    className: 'JobPreparationTask'
                }
            },
            jobReleaseTask: {
                required: false,
                serializedName: 'jobReleaseTask',
                type: {
                    name: 'Composite',
                    className: 'JobReleaseTask'
                }
            },
            commonEnvironmentSettings: {
                required: false,
                serializedName: 'commonEnvironmentSettings',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'EnvironmentSettingElementType',
                        type: {
                            name: 'Composite',
                            className: 'EnvironmentSetting'
                        }
                    }
                }
            },
            poolInfo: {
                required: true,
                serializedName: 'poolInfo',
                defaultValue: {},
                type: {
                    name: 'Composite',
                    className: 'PoolInformation'
                }
            },
            metadata: {
                required: false,
                serializedName: 'metadata',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'MetadataItemElementType',
                        type: {
                            name: 'Composite',
                            className: 'MetadataItem'
                        }
                    }
                }
            }
        }
    }
};
exports.RecentJob = {
    required: false,
    serializedName: 'RecentJob',
    type: {
        name: 'Composite',
        className: 'RecentJob',
        modelProperties: {
            id: {
                required: false,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            url: {
                required: false,
                serializedName: 'url',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.JobScheduleExecutionInformation = {
    required: false,
    serializedName: 'JobScheduleExecutionInformation',
    type: {
        name: 'Composite',
        className: 'JobScheduleExecutionInformation',
        modelProperties: {
            nextRunTime: {
                required: false,
                serializedName: 'nextRunTime',
                type: {
                    name: 'DateTime'
                }
            },
            recentJob: {
                required: false,
                serializedName: 'recentJob',
                type: {
                    name: 'Composite',
                    className: 'RecentJob'
                }
            },
            endTime: {
                required: false,
                serializedName: 'endTime',
                type: {
                    name: 'DateTime'
                }
            }
        }
    }
};
exports.JobScheduleStatistics = {
    required: false,
    serializedName: 'JobScheduleStatistics',
    type: {
        name: 'Composite',
        className: 'JobScheduleStatistics',
        modelProperties: {
            url: {
                required: true,
                serializedName: 'url',
                type: {
                    name: 'String'
                }
            },
            startTime: {
                required: true,
                serializedName: 'startTime',
                type: {
                    name: 'DateTime'
                }
            },
            lastUpdateTime: {
                required: true,
                serializedName: 'lastUpdateTime',
                type: {
                    name: 'DateTime'
                }
            },
            userCPUTime: {
                required: true,
                serializedName: 'userCPUTime',
                type: {
                    name: 'TimeSpan'
                }
            },
            kernelCPUTime: {
                required: true,
                serializedName: 'kernelCPUTime',
                type: {
                    name: 'TimeSpan'
                }
            },
            wallClockTime: {
                required: true,
                serializedName: 'wallClockTime',
                type: {
                    name: 'TimeSpan'
                }
            },
            readIOps: {
                required: true,
                serializedName: 'readIOps',
                type: {
                    name: 'Number'
                }
            },
            writeIOps: {
                required: true,
                serializedName: 'writeIOps',
                type: {
                    name: 'Number'
                }
            },
            readIOGiB: {
                required: true,
                serializedName: 'readIOGiB',
                type: {
                    name: 'Number'
                }
            },
            writeIOGiB: {
                required: true,
                serializedName: 'writeIOGiB',
                type: {
                    name: 'Number'
                }
            },
            numSucceededTasks: {
                required: true,
                serializedName: 'numSucceededTasks',
                type: {
                    name: 'Number'
                }
            },
            numFailedTasks: {
                required: true,
                serializedName: 'numFailedTasks',
                type: {
                    name: 'Number'
                }
            },
            numTaskRetries: {
                required: true,
                serializedName: 'numTaskRetries',
                type: {
                    name: 'Number'
                }
            },
            waitTime: {
                required: true,
                serializedName: 'waitTime',
                type: {
                    name: 'TimeSpan'
                }
            }
        }
    }
};
exports.CloudJobSchedule = {
    required: false,
    serializedName: 'CloudJobSchedule',
    type: {
        name: 'Composite',
        className: 'CloudJobSchedule',
        modelProperties: {
            id: {
                required: false,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            displayName: {
                required: false,
                serializedName: 'displayName',
                type: {
                    name: 'String'
                }
            },
            url: {
                required: false,
                serializedName: 'url',
                type: {
                    name: 'String'
                }
            },
            eTag: {
                required: false,
                serializedName: 'eTag',
                type: {
                    name: 'String'
                }
            },
            lastModified: {
                required: false,
                serializedName: 'lastModified',
                type: {
                    name: 'DateTime'
                }
            },
            creationTime: {
                required: false,
                serializedName: 'creationTime',
                type: {
                    name: 'DateTime'
                }
            },
            state: {
                required: false,
                serializedName: 'state',
                type: {
                    name: 'Enum',
                    allowedValues: ['active', 'completed', 'disabled', 'terminating', 'deleting']
                }
            },
            stateTransitionTime: {
                required: false,
                serializedName: 'stateTransitionTime',
                type: {
                    name: 'DateTime'
                }
            },
            previousState: {
                required: false,
                serializedName: 'previousState',
                type: {
                    name: 'Enum',
                    allowedValues: ['active', 'completed', 'disabled', 'terminating', 'deleting']
                }
            },
            previousStateTransitionTime: {
                required: false,
                serializedName: 'previousStateTransitionTime',
                type: {
                    name: 'DateTime'
                }
            },
            schedule: {
                required: false,
                serializedName: 'schedule',
                type: {
                    name: 'Composite',
                    className: 'Schedule'
                }
            },
            jobSpecification: {
                required: false,
                serializedName: 'jobSpecification',
                type: {
                    name: 'Composite',
                    className: 'JobSpecification'
                }
            },
            executionInfo: {
                required: false,
                serializedName: 'executionInfo',
                type: {
                    name: 'Composite',
                    className: 'JobScheduleExecutionInformation'
                }
            },
            metadata: {
                required: false,
                serializedName: 'metadata',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'MetadataItemElementType',
                        type: {
                            name: 'Composite',
                            className: 'MetadataItem'
                        }
                    }
                }
            },
            stats: {
                required: false,
                serializedName: 'stats',
                type: {
                    name: 'Composite',
                    className: 'JobScheduleStatistics'
                }
            }
        }
    }
};
exports.JobScheduleAddParameter = {
    required: false,
    serializedName: 'JobScheduleAddParameter',
    type: {
        name: 'Composite',
        className: 'JobScheduleAddParameter',
        modelProperties: {
            id: {
                required: true,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            displayName: {
                required: false,
                serializedName: 'displayName',
                type: {
                    name: 'String'
                }
            },
            schedule: {
                required: true,
                serializedName: 'schedule',
                type: {
                    name: 'Composite',
                    className: 'Schedule'
                }
            },
            jobSpecification: {
                required: true,
                serializedName: 'jobSpecification',
                defaultValue: {},
                type: {
                    name: 'Composite',
                    className: 'JobSpecification'
                }
            },
            metadata: {
                required: false,
                serializedName: 'metadata',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'MetadataItemElementType',
                        type: {
                            name: 'Composite',
                            className: 'MetadataItem'
                        }
                    }
                }
            }
        }
    }
};
exports.JobSchedulingError = {
    required: false,
    serializedName: 'JobSchedulingError',
    type: {
        name: 'Composite',
        className: 'JobSchedulingError',
        modelProperties: {
            category: {
                required: true,
                serializedName: 'category',
                type: {
                    name: 'Enum',
                    allowedValues: ['userError', 'serverError']
                }
            },
            code: {
                required: false,
                serializedName: 'code',
                type: {
                    name: 'String'
                }
            },
            message: {
                required: false,
                serializedName: 'message',
                type: {
                    name: 'String'
                }
            },
            details: {
                required: false,
                serializedName: 'details',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'NameValuePairElementType',
                        type: {
                            name: 'Composite',
                            className: 'NameValuePair'
                        }
                    }
                }
            }
        }
    }
};
exports.JobExecutionInformation = {
    required: false,
    serializedName: 'JobExecutionInformation',
    type: {
        name: 'Composite',
        className: 'JobExecutionInformation',
        modelProperties: {
            startTime: {
                required: true,
                serializedName: 'startTime',
                type: {
                    name: 'DateTime'
                }
            },
            endTime: {
                required: false,
                serializedName: 'endTime',
                type: {
                    name: 'DateTime'
                }
            },
            poolId: {
                required: false,
                serializedName: 'poolId',
                type: {
                    name: 'String'
                }
            },
            schedulingError: {
                required: false,
                serializedName: 'schedulingError',
                type: {
                    name: 'Composite',
                    className: 'JobSchedulingError'
                }
            },
            terminateReason: {
                required: false,
                serializedName: 'terminateReason',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.CloudJob = {
    required: false,
    serializedName: 'CloudJob',
    type: {
        name: 'Composite',
        className: 'CloudJob',
        modelProperties: {
            id: {
                required: false,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            displayName: {
                required: false,
                serializedName: 'displayName',
                type: {
                    name: 'String'
                }
            },
            usesTaskDependencies: {
                required: false,
                serializedName: 'usesTaskDependencies',
                type: {
                    name: 'Boolean'
                }
            },
            url: {
                required: false,
                serializedName: 'url',
                type: {
                    name: 'String'
                }
            },
            eTag: {
                required: false,
                serializedName: 'eTag',
                type: {
                    name: 'String'
                }
            },
            lastModified: {
                required: false,
                serializedName: 'lastModified',
                type: {
                    name: 'DateTime'
                }
            },
            creationTime: {
                required: false,
                serializedName: 'creationTime',
                type: {
                    name: 'DateTime'
                }
            },
            state: {
                required: false,
                serializedName: 'state',
                type: {
                    name: 'Enum',
                    allowedValues: ['active', 'disabling', 'disabled', 'enabling', 'terminating', 'completed', 'deleting']
                }
            },
            stateTransitionTime: {
                required: false,
                serializedName: 'stateTransitionTime',
                type: {
                    name: 'DateTime'
                }
            },
            previousState: {
                required: false,
                serializedName: 'previousState',
                type: {
                    name: 'Enum',
                    allowedValues: ['active', 'disabling', 'disabled', 'enabling', 'terminating', 'completed', 'deleting']
                }
            },
            previousStateTransitionTime: {
                required: false,
                serializedName: 'previousStateTransitionTime',
                type: {
                    name: 'DateTime'
                }
            },
            priority: {
                required: false,
                serializedName: 'priority',
                type: {
                    name: 'Number'
                }
            },
            constraints: {
                required: false,
                serializedName: 'constraints',
                type: {
                    name: 'Composite',
                    className: 'JobConstraints'
                }
            },
            jobManagerTask: {
                required: false,
                serializedName: 'jobManagerTask',
                type: {
                    name: 'Composite',
                    className: 'JobManagerTask'
                }
            },
            jobPreparationTask: {
                required: false,
                serializedName: 'jobPreparationTask',
                type: {
                    name: 'Composite',
                    className: 'JobPreparationTask'
                }
            },
            jobReleaseTask: {
                required: false,
                serializedName: 'jobReleaseTask',
                type: {
                    name: 'Composite',
                    className: 'JobReleaseTask'
                }
            },
            commonEnvironmentSettings: {
                required: false,
                serializedName: 'commonEnvironmentSettings',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'EnvironmentSettingElementType',
                        type: {
                            name: 'Composite',
                            className: 'EnvironmentSetting'
                        }
                    }
                }
            },
            poolInfo: {
                required: false,
                serializedName: 'poolInfo',
                type: {
                    name: 'Composite',
                    className: 'PoolInformation'
                }
            },
            onAllTasksComplete: {
                required: false,
                serializedName: 'onAllTasksComplete',
                type: {
                    name: 'Enum',
                    allowedValues: ['noAction', 'terminateJob']
                }
            },
            onTaskFailure: {
                required: false,
                serializedName: 'onTaskFailure',
                type: {
                    name: 'Enum',
                    allowedValues: ['noAction', 'performExitOptionsJobAction']
                }
            },
            metadata: {
                required: false,
                serializedName: 'metadata',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'MetadataItemElementType',
                        type: {
                            name: 'Composite',
                            className: 'MetadataItem'
                        }
                    }
                }
            },
            executionInfo: {
                required: false,
                serializedName: 'executionInfo',
                type: {
                    name: 'Composite',
                    className: 'JobExecutionInformation'
                }
            },
            stats: {
                required: false,
                serializedName: 'stats',
                type: {
                    name: 'Composite',
                    className: 'JobStatistics'
                }
            }
        }
    }
};
exports.JobAddParameter = {
    required: false,
    serializedName: 'JobAddParameter',
    type: {
        name: 'Composite',
        className: 'JobAddParameter',
        modelProperties: {
            id: {
                required: true,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            displayName: {
                required: false,
                serializedName: 'displayName',
                type: {
                    name: 'String'
                }
            },
            priority: {
                required: false,
                serializedName: 'priority',
                type: {
                    name: 'Number'
                }
            },
            constraints: {
                required: false,
                serializedName: 'constraints',
                type: {
                    name: 'Composite',
                    className: 'JobConstraints'
                }
            },
            jobManagerTask: {
                required: false,
                serializedName: 'jobManagerTask',
                type: {
                    name: 'Composite',
                    className: 'JobManagerTask'
                }
            },
            jobPreparationTask: {
                required: false,
                serializedName: 'jobPreparationTask',
                type: {
                    name: 'Composite',
                    className: 'JobPreparationTask'
                }
            },
            jobReleaseTask: {
                required: false,
                serializedName: 'jobReleaseTask',
                type: {
                    name: 'Composite',
                    className: 'JobReleaseTask'
                }
            },
            commonEnvironmentSettings: {
                required: false,
                serializedName: 'commonEnvironmentSettings',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'EnvironmentSettingElementType',
                        type: {
                            name: 'Composite',
                            className: 'EnvironmentSetting'
                        }
                    }
                }
            },
            poolInfo: {
                required: true,
                serializedName: 'poolInfo',
                defaultValue: {},
                type: {
                    name: 'Composite',
                    className: 'PoolInformation'
                }
            },
            onAllTasksComplete: {
                required: false,
                serializedName: 'onAllTasksComplete',
                type: {
                    name: 'Enum',
                    allowedValues: ['noAction', 'terminateJob']
                }
            },
            onTaskFailure: {
                required: false,
                serializedName: 'onTaskFailure',
                type: {
                    name: 'Enum',
                    allowedValues: ['noAction', 'performExitOptionsJobAction']
                }
            },
            metadata: {
                required: false,
                serializedName: 'metadata',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'MetadataItemElementType',
                        type: {
                            name: 'Composite',
                            className: 'MetadataItem'
                        }
                    }
                }
            },
            usesTaskDependencies: {
                required: false,
                serializedName: 'usesTaskDependencies',
                type: {
                    name: 'Boolean'
                }
            }
        }
    }
};
exports.TaskContainerExecutionInformation = {
    required: false,
    serializedName: 'TaskContainerExecutionInformation',
    type: {
        name: 'Composite',
        className: 'TaskContainerExecutionInformation',
        modelProperties: {
            containerId: {
                required: false,
                serializedName: 'containerId',
                type: {
                    name: 'String'
                }
            },
            state: {
                required: false,
                serializedName: 'state',
                type: {
                    name: 'String'
                }
            },
            error: {
                required: false,
                serializedName: 'error',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.TaskFailureInformation = {
    required: false,
    serializedName: 'TaskFailureInformation',
    type: {
        name: 'Composite',
        className: 'TaskFailureInformation',
        modelProperties: {
            category: {
                required: true,
                serializedName: 'category',
                type: {
                    name: 'Enum',
                    allowedValues: ['userError', 'serverError']
                }
            },
            code: {
                required: false,
                serializedName: 'code',
                type: {
                    name: 'String'
                }
            },
            message: {
                required: false,
                serializedName: 'message',
                type: {
                    name: 'String'
                }
            },
            details: {
                required: false,
                serializedName: 'details',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'NameValuePairElementType',
                        type: {
                            name: 'Composite',
                            className: 'NameValuePair'
                        }
                    }
                }
            }
        }
    }
};
exports.JobPreparationTaskExecutionInformation = {
    required: false,
    serializedName: 'JobPreparationTaskExecutionInformation',
    type: {
        name: 'Composite',
        className: 'JobPreparationTaskExecutionInformation',
        modelProperties: {
            startTime: {
                required: true,
                serializedName: 'startTime',
                type: {
                    name: 'DateTime'
                }
            },
            endTime: {
                required: false,
                serializedName: 'endTime',
                type: {
                    name: 'DateTime'
                }
            },
            state: {
                required: true,
                serializedName: 'state',
                type: {
                    name: 'Enum',
                    allowedValues: ['running', 'completed']
                }
            },
            taskRootDirectory: {
                required: false,
                serializedName: 'taskRootDirectory',
                type: {
                    name: 'String'
                }
            },
            taskRootDirectoryUrl: {
                required: false,
                serializedName: 'taskRootDirectoryUrl',
                type: {
                    name: 'String'
                }
            },
            exitCode: {
                required: false,
                serializedName: 'exitCode',
                type: {
                    name: 'Number'
                }
            },
            containerInfo: {
                required: false,
                serializedName: 'containerInfo',
                type: {
                    name: 'Composite',
                    className: 'TaskContainerExecutionInformation'
                }
            },
            failureInfo: {
                required: false,
                serializedName: 'failureInfo',
                type: {
                    name: 'Composite',
                    className: 'TaskFailureInformation'
                }
            },
            retryCount: {
                required: true,
                serializedName: 'retryCount',
                type: {
                    name: 'Number'
                }
            },
            lastRetryTime: {
                required: false,
                serializedName: 'lastRetryTime',
                type: {
                    name: 'DateTime'
                }
            },
            result: {
                required: false,
                serializedName: 'result',
                type: {
                    name: 'Enum',
                    allowedValues: ['success', 'failure']
                }
            }
        }
    }
};
exports.JobReleaseTaskExecutionInformation = {
    required: false,
    serializedName: 'JobReleaseTaskExecutionInformation',
    type: {
        name: 'Composite',
        className: 'JobReleaseTaskExecutionInformation',
        modelProperties: {
            startTime: {
                required: true,
                serializedName: 'startTime',
                type: {
                    name: 'DateTime'
                }
            },
            endTime: {
                required: false,
                serializedName: 'endTime',
                type: {
                    name: 'DateTime'
                }
            },
            state: {
                required: true,
                serializedName: 'state',
                type: {
                    name: 'Enum',
                    allowedValues: ['running', 'completed']
                }
            },
            taskRootDirectory: {
                required: false,
                serializedName: 'taskRootDirectory',
                type: {
                    name: 'String'
                }
            },
            taskRootDirectoryUrl: {
                required: false,
                serializedName: 'taskRootDirectoryUrl',
                type: {
                    name: 'String'
                }
            },
            exitCode: {
                required: false,
                serializedName: 'exitCode',
                type: {
                    name: 'Number'
                }
            },
            containerInfo: {
                required: false,
                serializedName: 'containerInfo',
                type: {
                    name: 'Composite',
                    className: 'TaskContainerExecutionInformation'
                }
            },
            failureInfo: {
                required: false,
                serializedName: 'failureInfo',
                type: {
                    name: 'Composite',
                    className: 'TaskFailureInformation'
                }
            },
            result: {
                required: false,
                serializedName: 'result',
                type: {
                    name: 'Enum',
                    allowedValues: ['success', 'failure']
                }
            }
        }
    }
};
exports.JobPreparationAndReleaseTaskExecutionInformation = {
    required: false,
    serializedName: 'JobPreparationAndReleaseTaskExecutionInformation',
    type: {
        name: 'Composite',
        className: 'JobPreparationAndReleaseTaskExecutionInformation',
        modelProperties: {
            poolId: {
                required: false,
                serializedName: 'poolId',
                type: {
                    name: 'String'
                }
            },
            nodeId: {
                required: false,
                serializedName: 'nodeId',
                type: {
                    name: 'String'
                }
            },
            nodeUrl: {
                required: false,
                serializedName: 'nodeUrl',
                type: {
                    name: 'String'
                }
            },
            jobPreparationTaskExecutionInfo: {
                required: false,
                serializedName: 'jobPreparationTaskExecutionInfo',
                type: {
                    name: 'Composite',
                    className: 'JobPreparationTaskExecutionInformation'
                }
            },
            jobReleaseTaskExecutionInfo: {
                required: false,
                serializedName: 'jobReleaseTaskExecutionInfo',
                type: {
                    name: 'Composite',
                    className: 'JobReleaseTaskExecutionInformation'
                }
            }
        }
    }
};
exports.TaskCounts = {
    required: false,
    serializedName: 'TaskCounts',
    type: {
        name: 'Composite',
        className: 'TaskCounts',
        modelProperties: {
            active: {
                required: true,
                serializedName: 'active',
                type: {
                    name: 'Number'
                }
            },
            running: {
                required: true,
                serializedName: 'running',
                type: {
                    name: 'Number'
                }
            },
            completed: {
                required: true,
                serializedName: 'completed',
                type: {
                    name: 'Number'
                }
            },
            succeeded: {
                required: true,
                serializedName: 'succeeded',
                type: {
                    name: 'Number'
                }
            },
            failed: {
                required: true,
                serializedName: 'failed',
                type: {
                    name: 'Number'
                }
            },
            validationStatus: {
                required: true,
                serializedName: 'validationStatus',
                type: {
                    name: 'Enum',
                    allowedValues: ['validated', 'unvalidated']
                }
            }
        }
    }
};
exports.AutoScaleRunError = {
    required: false,
    serializedName: 'AutoScaleRunError',
    type: {
        name: 'Composite',
        className: 'AutoScaleRunError',
        modelProperties: {
            code: {
                required: false,
                serializedName: 'code',
                type: {
                    name: 'String'
                }
            },
            message: {
                required: false,
                serializedName: 'message',
                type: {
                    name: 'String'
                }
            },
            values: {
                required: false,
                serializedName: 'values',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'NameValuePairElementType',
                        type: {
                            name: 'Composite',
                            className: 'NameValuePair'
                        }
                    }
                }
            }
        }
    }
};
exports.AutoScaleRun = {
    required: false,
    serializedName: 'AutoScaleRun',
    type: {
        name: 'Composite',
        className: 'AutoScaleRun',
        modelProperties: {
            timestamp: {
                required: true,
                serializedName: 'timestamp',
                type: {
                    name: 'DateTime'
                }
            },
            results: {
                required: false,
                serializedName: 'results',
                type: {
                    name: 'String'
                }
            },
            error: {
                required: false,
                serializedName: 'error',
                type: {
                    name: 'Composite',
                    className: 'AutoScaleRunError'
                }
            }
        }
    }
};
exports.ResizeError = {
    required: false,
    serializedName: 'ResizeError',
    type: {
        name: 'Composite',
        className: 'ResizeError',
        modelProperties: {
            code: {
                required: false,
                serializedName: 'code',
                type: {
                    name: 'String'
                }
            },
            message: {
                required: false,
                serializedName: 'message',
                type: {
                    name: 'String'
                }
            },
            values: {
                required: false,
                serializedName: 'values',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'NameValuePairElementType',
                        type: {
                            name: 'Composite',
                            className: 'NameValuePair'
                        }
                    }
                }
            }
        }
    }
};
exports.CloudPool = {
    required: false,
    serializedName: 'CloudPool',
    type: {
        name: 'Composite',
        className: 'CloudPool',
        modelProperties: {
            id: {
                required: false,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            displayName: {
                required: false,
                serializedName: 'displayName',
                type: {
                    name: 'String'
                }
            },
            url: {
                required: false,
                serializedName: 'url',
                type: {
                    name: 'String'
                }
            },
            eTag: {
                required: false,
                serializedName: 'eTag',
                type: {
                    name: 'String'
                }
            },
            lastModified: {
                required: false,
                serializedName: 'lastModified',
                type: {
                    name: 'DateTime'
                }
            },
            creationTime: {
                required: false,
                serializedName: 'creationTime',
                type: {
                    name: 'DateTime'
                }
            },
            state: {
                required: false,
                serializedName: 'state',
                type: {
                    name: 'Enum',
                    allowedValues: ['active', 'deleting', 'upgrading']
                }
            },
            stateTransitionTime: {
                required: false,
                serializedName: 'stateTransitionTime',
                type: {
                    name: 'DateTime'
                }
            },
            allocationState: {
                required: false,
                serializedName: 'allocationState',
                type: {
                    name: 'Enum',
                    allowedValues: ['steady', 'resizing', 'stopping']
                }
            },
            allocationStateTransitionTime: {
                required: false,
                serializedName: 'allocationStateTransitionTime',
                type: {
                    name: 'DateTime'
                }
            },
            vmSize: {
                required: false,
                serializedName: 'vmSize',
                type: {
                    name: 'String'
                }
            },
            cloudServiceConfiguration: {
                required: false,
                serializedName: 'cloudServiceConfiguration',
                type: {
                    name: 'Composite',
                    className: 'CloudServiceConfiguration'
                }
            },
            virtualMachineConfiguration: {
                required: false,
                serializedName: 'virtualMachineConfiguration',
                type: {
                    name: 'Composite',
                    className: 'VirtualMachineConfiguration'
                }
            },
            resizeTimeout: {
                required: false,
                serializedName: 'resizeTimeout',
                type: {
                    name: 'TimeSpan'
                }
            },
            resizeErrors: {
                required: false,
                serializedName: 'resizeErrors',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ResizeErrorElementType',
                        type: {
                            name: 'Composite',
                            className: 'ResizeError'
                        }
                    }
                }
            },
            currentDedicatedNodes: {
                required: false,
                serializedName: 'currentDedicatedNodes',
                type: {
                    name: 'Number'
                }
            },
            currentLowPriorityNodes: {
                required: false,
                serializedName: 'currentLowPriorityNodes',
                type: {
                    name: 'Number'
                }
            },
            targetDedicatedNodes: {
                required: false,
                serializedName: 'targetDedicatedNodes',
                type: {
                    name: 'Number'
                }
            },
            targetLowPriorityNodes: {
                required: false,
                serializedName: 'targetLowPriorityNodes',
                type: {
                    name: 'Number'
                }
            },
            enableAutoScale: {
                required: false,
                serializedName: 'enableAutoScale',
                type: {
                    name: 'Boolean'
                }
            },
            autoScaleFormula: {
                required: false,
                serializedName: 'autoScaleFormula',
                type: {
                    name: 'String'
                }
            },
            autoScaleEvaluationInterval: {
                required: false,
                serializedName: 'autoScaleEvaluationInterval',
                type: {
                    name: 'TimeSpan'
                }
            },
            autoScaleRun: {
                required: false,
                serializedName: 'autoScaleRun',
                type: {
                    name: 'Composite',
                    className: 'AutoScaleRun'
                }
            },
            enableInterNodeCommunication: {
                required: false,
                serializedName: 'enableInterNodeCommunication',
                type: {
                    name: 'Boolean'
                }
            },
            networkConfiguration: {
                required: false,
                serializedName: 'networkConfiguration',
                type: {
                    name: 'Composite',
                    className: 'NetworkConfiguration'
                }
            },
            startTask: {
                required: false,
                serializedName: 'startTask',
                type: {
                    name: 'Composite',
                    className: 'StartTask'
                }
            },
            certificateReferences: {
                required: false,
                serializedName: 'certificateReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'CertificateReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'CertificateReference'
                        }
                    }
                }
            },
            applicationPackageReferences: {
                required: false,
                serializedName: 'applicationPackageReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ApplicationPackageReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'ApplicationPackageReference'
                        }
                    }
                }
            },
            applicationLicenses: {
                required: false,
                serializedName: 'applicationLicenses',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'stringElementType',
                        type: {
                            name: 'String'
                        }
                    }
                }
            },
            maxTasksPerNode: {
                required: false,
                serializedName: 'maxTasksPerNode',
                type: {
                    name: 'Number'
                }
            },
            taskSchedulingPolicy: {
                required: false,
                serializedName: 'taskSchedulingPolicy',
                type: {
                    name: 'Composite',
                    className: 'TaskSchedulingPolicy'
                }
            },
            userAccounts: {
                required: false,
                serializedName: 'userAccounts',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'UserAccountElementType',
                        type: {
                            name: 'Composite',
                            className: 'UserAccount'
                        }
                    }
                }
            },
            metadata: {
                required: false,
                serializedName: 'metadata',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'MetadataItemElementType',
                        type: {
                            name: 'Composite',
                            className: 'MetadataItem'
                        }
                    }
                }
            },
            stats: {
                required: false,
                serializedName: 'stats',
                type: {
                    name: 'Composite',
                    className: 'PoolStatistics'
                }
            }
        }
    }
};
exports.PoolAddParameter = {
    required: false,
    serializedName: 'PoolAddParameter',
    type: {
        name: 'Composite',
        className: 'PoolAddParameter',
        modelProperties: {
            id: {
                required: true,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            displayName: {
                required: false,
                serializedName: 'displayName',
                type: {
                    name: 'String'
                }
            },
            vmSize: {
                required: true,
                serializedName: 'vmSize',
                type: {
                    name: 'String'
                }
            },
            cloudServiceConfiguration: {
                required: false,
                serializedName: 'cloudServiceConfiguration',
                type: {
                    name: 'Composite',
                    className: 'CloudServiceConfiguration'
                }
            },
            virtualMachineConfiguration: {
                required: false,
                serializedName: 'virtualMachineConfiguration',
                type: {
                    name: 'Composite',
                    className: 'VirtualMachineConfiguration'
                }
            },
            resizeTimeout: {
                required: false,
                serializedName: 'resizeTimeout',
                type: {
                    name: 'TimeSpan'
                }
            },
            targetDedicatedNodes: {
                required: false,
                serializedName: 'targetDedicatedNodes',
                type: {
                    name: 'Number'
                }
            },
            targetLowPriorityNodes: {
                required: false,
                serializedName: 'targetLowPriorityNodes',
                type: {
                    name: 'Number'
                }
            },
            enableAutoScale: {
                required: false,
                serializedName: 'enableAutoScale',
                type: {
                    name: 'Boolean'
                }
            },
            autoScaleFormula: {
                required: false,
                serializedName: 'autoScaleFormula',
                type: {
                    name: 'String'
                }
            },
            autoScaleEvaluationInterval: {
                required: false,
                serializedName: 'autoScaleEvaluationInterval',
                type: {
                    name: 'TimeSpan'
                }
            },
            enableInterNodeCommunication: {
                required: false,
                serializedName: 'enableInterNodeCommunication',
                type: {
                    name: 'Boolean'
                }
            },
            networkConfiguration: {
                required: false,
                serializedName: 'networkConfiguration',
                type: {
                    name: 'Composite',
                    className: 'NetworkConfiguration'
                }
            },
            startTask: {
                required: false,
                serializedName: 'startTask',
                type: {
                    name: 'Composite',
                    className: 'StartTask'
                }
            },
            certificateReferences: {
                required: false,
                serializedName: 'certificateReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'CertificateReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'CertificateReference'
                        }
                    }
                }
            },
            applicationPackageReferences: {
                required: false,
                serializedName: 'applicationPackageReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ApplicationPackageReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'ApplicationPackageReference'
                        }
                    }
                }
            },
            applicationLicenses: {
                required: false,
                serializedName: 'applicationLicenses',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'stringElementType',
                        type: {
                            name: 'String'
                        }
                    }
                }
            },
            maxTasksPerNode: {
                required: false,
                serializedName: 'maxTasksPerNode',
                type: {
                    name: 'Number'
                }
            },
            taskSchedulingPolicy: {
                required: false,
                serializedName: 'taskSchedulingPolicy',
                type: {
                    name: 'Composite',
                    className: 'TaskSchedulingPolicy'
                }
            },
            userAccounts: {
                required: false,
                serializedName: 'userAccounts',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'UserAccountElementType',
                        type: {
                            name: 'Composite',
                            className: 'UserAccount'
                        }
                    }
                }
            },
            metadata: {
                required: false,
                serializedName: 'metadata',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'MetadataItemElementType',
                        type: {
                            name: 'Composite',
                            className: 'MetadataItem'
                        }
                    }
                }
            }
        }
    }
};
exports.AffinityInformation = {
    required: false,
    serializedName: 'AffinityInformation',
    type: {
        name: 'Composite',
        className: 'AffinityInformation',
        modelProperties: {
            affinityId: {
                required: true,
                serializedName: 'affinityId',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.TaskExecutionInformation = {
    required: false,
    serializedName: 'TaskExecutionInformation',
    type: {
        name: 'Composite',
        className: 'TaskExecutionInformation',
        modelProperties: {
            startTime: {
                required: false,
                serializedName: 'startTime',
                type: {
                    name: 'DateTime'
                }
            },
            endTime: {
                required: false,
                serializedName: 'endTime',
                type: {
                    name: 'DateTime'
                }
            },
            exitCode: {
                required: false,
                serializedName: 'exitCode',
                type: {
                    name: 'Number'
                }
            },
            containerInfo: {
                required: false,
                serializedName: 'containerInfo',
                type: {
                    name: 'Composite',
                    className: 'TaskContainerExecutionInformation'
                }
            },
            failureInfo: {
                required: false,
                serializedName: 'failureInfo',
                type: {
                    name: 'Composite',
                    className: 'TaskFailureInformation'
                }
            },
            retryCount: {
                required: true,
                serializedName: 'retryCount',
                type: {
                    name: 'Number'
                }
            },
            lastRetryTime: {
                required: false,
                serializedName: 'lastRetryTime',
                type: {
                    name: 'DateTime'
                }
            },
            requeueCount: {
                required: true,
                serializedName: 'requeueCount',
                type: {
                    name: 'Number'
                }
            },
            lastRequeueTime: {
                required: false,
                serializedName: 'lastRequeueTime',
                type: {
                    name: 'DateTime'
                }
            },
            result: {
                required: false,
                serializedName: 'result',
                type: {
                    name: 'Enum',
                    allowedValues: ['success', 'failure']
                }
            }
        }
    }
};
exports.ComputeNodeInformation = {
    required: false,
    serializedName: 'ComputeNodeInformation',
    type: {
        name: 'Composite',
        className: 'ComputeNodeInformation',
        modelProperties: {
            affinityId: {
                required: false,
                serializedName: 'affinityId',
                type: {
                    name: 'String'
                }
            },
            nodeUrl: {
                required: false,
                serializedName: 'nodeUrl',
                type: {
                    name: 'String'
                }
            },
            poolId: {
                required: false,
                serializedName: 'poolId',
                type: {
                    name: 'String'
                }
            },
            nodeId: {
                required: false,
                serializedName: 'nodeId',
                type: {
                    name: 'String'
                }
            },
            taskRootDirectory: {
                required: false,
                serializedName: 'taskRootDirectory',
                type: {
                    name: 'String'
                }
            },
            taskRootDirectoryUrl: {
                required: false,
                serializedName: 'taskRootDirectoryUrl',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.MultiInstanceSettings = {
    required: false,
    serializedName: 'MultiInstanceSettings',
    type: {
        name: 'Composite',
        className: 'MultiInstanceSettings',
        modelProperties: {
            numberOfInstances: {
                required: false,
                serializedName: 'numberOfInstances',
                type: {
                    name: 'Number'
                }
            },
            coordinationCommandLine: {
                required: true,
                serializedName: 'coordinationCommandLine',
                type: {
                    name: 'String'
                }
            },
            commonResourceFiles: {
                required: false,
                serializedName: 'commonResourceFiles',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ResourceFileElementType',
                        type: {
                            name: 'Composite',
                            className: 'ResourceFile'
                        }
                    }
                }
            }
        }
    }
};
exports.TaskStatistics = {
    required: false,
    serializedName: 'TaskStatistics',
    type: {
        name: 'Composite',
        className: 'TaskStatistics',
        modelProperties: {
            url: {
                required: true,
                serializedName: 'url',
                type: {
                    name: 'String'
                }
            },
            startTime: {
                required: true,
                serializedName: 'startTime',
                type: {
                    name: 'DateTime'
                }
            },
            lastUpdateTime: {
                required: true,
                serializedName: 'lastUpdateTime',
                type: {
                    name: 'DateTime'
                }
            },
            userCPUTime: {
                required: true,
                serializedName: 'userCPUTime',
                type: {
                    name: 'TimeSpan'
                }
            },
            kernelCPUTime: {
                required: true,
                serializedName: 'kernelCPUTime',
                type: {
                    name: 'TimeSpan'
                }
            },
            wallClockTime: {
                required: true,
                serializedName: 'wallClockTime',
                type: {
                    name: 'TimeSpan'
                }
            },
            readIOps: {
                required: true,
                serializedName: 'readIOps',
                type: {
                    name: 'Number'
                }
            },
            writeIOps: {
                required: true,
                serializedName: 'writeIOps',
                type: {
                    name: 'Number'
                }
            },
            readIOGiB: {
                required: true,
                serializedName: 'readIOGiB',
                type: {
                    name: 'Number'
                }
            },
            writeIOGiB: {
                required: true,
                serializedName: 'writeIOGiB',
                type: {
                    name: 'Number'
                }
            },
            waitTime: {
                required: true,
                serializedName: 'waitTime',
                type: {
                    name: 'TimeSpan'
                }
            }
        }
    }
};
exports.TaskIdRange = {
    required: false,
    serializedName: 'TaskIdRange',
    type: {
        name: 'Composite',
        className: 'TaskIdRange',
        modelProperties: {
            start: {
                required: true,
                serializedName: 'start',
                type: {
                    name: 'Number'
                }
            },
            end: {
                required: true,
                serializedName: 'end',
                type: {
                    name: 'Number'
                }
            }
        }
    }
};
exports.TaskDependencies = {
    required: false,
    serializedName: 'TaskDependencies',
    type: {
        name: 'Composite',
        className: 'TaskDependencies',
        modelProperties: {
            taskIds: {
                required: false,
                serializedName: 'taskIds',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'stringElementType',
                        type: {
                            name: 'String'
                        }
                    }
                }
            },
            taskIdRanges: {
                required: false,
                serializedName: 'taskIdRanges',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'TaskIdRangeElementType',
                        type: {
                            name: 'Composite',
                            className: 'TaskIdRange'
                        }
                    }
                }
            }
        }
    }
};
exports.CloudTask = {
    required: false,
    serializedName: 'CloudTask',
    type: {
        name: 'Composite',
        className: 'CloudTask',
        modelProperties: {
            id: {
                required: false,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            displayName: {
                required: false,
                serializedName: 'displayName',
                type: {
                    name: 'String'
                }
            },
            url: {
                required: false,
                serializedName: 'url',
                type: {
                    name: 'String'
                }
            },
            eTag: {
                required: false,
                serializedName: 'eTag',
                type: {
                    name: 'String'
                }
            },
            lastModified: {
                required: false,
                serializedName: 'lastModified',
                type: {
                    name: 'DateTime'
                }
            },
            creationTime: {
                required: false,
                serializedName: 'creationTime',
                type: {
                    name: 'DateTime'
                }
            },
            exitConditions: {
                required: false,
                serializedName: 'exitConditions',
                type: {
                    name: 'Composite',
                    className: 'ExitConditions'
                }
            },
            state: {
                required: false,
                serializedName: 'state',
                type: {
                    name: 'Enum',
                    allowedValues: ['active', 'preparing', 'running', 'completed']
                }
            },
            stateTransitionTime: {
                required: false,
                serializedName: 'stateTransitionTime',
                type: {
                    name: 'DateTime'
                }
            },
            previousState: {
                required: false,
                serializedName: 'previousState',
                type: {
                    name: 'Enum',
                    allowedValues: ['active', 'preparing', 'running', 'completed']
                }
            },
            previousStateTransitionTime: {
                required: false,
                serializedName: 'previousStateTransitionTime',
                type: {
                    name: 'DateTime'
                }
            },
            commandLine: {
                required: false,
                serializedName: 'commandLine',
                type: {
                    name: 'String'
                }
            },
            containerSettings: {
                required: false,
                serializedName: 'containerSettings',
                type: {
                    name: 'Composite',
                    className: 'TaskContainerSettings'
                }
            },
            resourceFiles: {
                required: false,
                serializedName: 'resourceFiles',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ResourceFileElementType',
                        type: {
                            name: 'Composite',
                            className: 'ResourceFile'
                        }
                    }
                }
            },
            outputFiles: {
                required: false,
                serializedName: 'outputFiles',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'OutputFileElementType',
                        type: {
                            name: 'Composite',
                            className: 'OutputFile'
                        }
                    }
                }
            },
            environmentSettings: {
                required: false,
                serializedName: 'environmentSettings',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'EnvironmentSettingElementType',
                        type: {
                            name: 'Composite',
                            className: 'EnvironmentSetting'
                        }
                    }
                }
            },
            affinityInfo: {
                required: false,
                serializedName: 'affinityInfo',
                type: {
                    name: 'Composite',
                    className: 'AffinityInformation'
                }
            },
            constraints: {
                required: false,
                serializedName: 'constraints',
                type: {
                    name: 'Composite',
                    className: 'TaskConstraints'
                }
            },
            userIdentity: {
                required: false,
                serializedName: 'userIdentity',
                type: {
                    name: 'Composite',
                    className: 'UserIdentity'
                }
            },
            executionInfo: {
                required: false,
                serializedName: 'executionInfo',
                type: {
                    name: 'Composite',
                    className: 'TaskExecutionInformation'
                }
            },
            nodeInfo: {
                required: false,
                serializedName: 'nodeInfo',
                type: {
                    name: 'Composite',
                    className: 'ComputeNodeInformation'
                }
            },
            multiInstanceSettings: {
                required: false,
                serializedName: 'multiInstanceSettings',
                type: {
                    name: 'Composite',
                    className: 'MultiInstanceSettings'
                }
            },
            stats: {
                required: false,
                serializedName: 'stats',
                type: {
                    name: 'Composite',
                    className: 'TaskStatistics'
                }
            },
            dependsOn: {
                required: false,
                serializedName: 'dependsOn',
                type: {
                    name: 'Composite',
                    className: 'TaskDependencies'
                }
            },
            applicationPackageReferences: {
                required: false,
                serializedName: 'applicationPackageReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ApplicationPackageReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'ApplicationPackageReference'
                        }
                    }
                }
            },
            authenticationTokenSettings: {
                required: false,
                serializedName: 'authenticationTokenSettings',
                type: {
                    name: 'Composite',
                    className: 'AuthenticationTokenSettings'
                }
            }
        }
    }
};
exports.TaskAddParameter = {
    required: false,
    serializedName: 'TaskAddParameter',
    type: {
        name: 'Composite',
        className: 'TaskAddParameter',
        modelProperties: {
            id: {
                required: true,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            displayName: {
                required: false,
                serializedName: 'displayName',
                type: {
                    name: 'String'
                }
            },
            commandLine: {
                required: true,
                serializedName: 'commandLine',
                type: {
                    name: 'String'
                }
            },
            containerSettings: {
                required: false,
                serializedName: 'containerSettings',
                type: {
                    name: 'Composite',
                    className: 'TaskContainerSettings'
                }
            },
            exitConditions: {
                required: false,
                serializedName: 'exitConditions',
                type: {
                    name: 'Composite',
                    className: 'ExitConditions'
                }
            },
            resourceFiles: {
                required: false,
                serializedName: 'resourceFiles',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ResourceFileElementType',
                        type: {
                            name: 'Composite',
                            className: 'ResourceFile'
                        }
                    }
                }
            },
            outputFiles: {
                required: false,
                serializedName: 'outputFiles',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'OutputFileElementType',
                        type: {
                            name: 'Composite',
                            className: 'OutputFile'
                        }
                    }
                }
            },
            environmentSettings: {
                required: false,
                serializedName: 'environmentSettings',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'EnvironmentSettingElementType',
                        type: {
                            name: 'Composite',
                            className: 'EnvironmentSetting'
                        }
                    }
                }
            },
            affinityInfo: {
                required: false,
                serializedName: 'affinityInfo',
                type: {
                    name: 'Composite',
                    className: 'AffinityInformation'
                }
            },
            constraints: {
                required: false,
                serializedName: 'constraints',
                type: {
                    name: 'Composite',
                    className: 'TaskConstraints'
                }
            },
            userIdentity: {
                required: false,
                serializedName: 'userIdentity',
                type: {
                    name: 'Composite',
                    className: 'UserIdentity'
                }
            },
            multiInstanceSettings: {
                required: false,
                serializedName: 'multiInstanceSettings',
                type: {
                    name: 'Composite',
                    className: 'MultiInstanceSettings'
                }
            },
            dependsOn: {
                required: false,
                serializedName: 'dependsOn',
                type: {
                    name: 'Composite',
                    className: 'TaskDependencies'
                }
            },
            applicationPackageReferences: {
                required: false,
                serializedName: 'applicationPackageReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ApplicationPackageReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'ApplicationPackageReference'
                        }
                    }
                }
            },
            authenticationTokenSettings: {
                required: false,
                serializedName: 'authenticationTokenSettings',
                type: {
                    name: 'Composite',
                    className: 'AuthenticationTokenSettings'
                }
            }
        }
    }
};
exports.TaskAddCollectionParameter = {
    required: false,
    serializedName: 'TaskAddCollectionParameter',
    type: {
        name: 'Composite',
        className: 'TaskAddCollectionParameter',
        modelProperties: {
            value: {
                required: true,
                serializedName: 'value',
                constraints: {
                    MaxItems: 100
                },
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'TaskAddParameterElementType',
                        type: {
                            name: 'Composite',
                            className: 'TaskAddParameter'
                        }
                    }
                }
            }
        }
    }
};
exports.ErrorMessage = {
    required: false,
    serializedName: 'ErrorMessage',
    type: {
        name: 'Composite',
        className: 'ErrorMessage',
        modelProperties: {
            lang: {
                required: false,
                serializedName: 'lang',
                type: {
                    name: 'String'
                }
            },
            value: {
                required: false,
                serializedName: 'value',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.BatchErrorDetail = {
    required: false,
    serializedName: 'BatchErrorDetail',
    type: {
        name: 'Composite',
        className: 'BatchErrorDetail',
        modelProperties: {
            key: {
                required: false,
                serializedName: 'key',
                type: {
                    name: 'String'
                }
            },
            value: {
                required: false,
                serializedName: 'value',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.BatchError = {
    required: false,
    serializedName: 'BatchError',
    type: {
        name: 'Composite',
        className: 'BatchError',
        modelProperties: {
            code: {
                required: false,
                serializedName: 'code',
                type: {
                    name: 'String'
                }
            },
            message: {
                required: false,
                serializedName: 'message',
                type: {
                    name: 'Composite',
                    className: 'ErrorMessage'
                }
            },
            values: {
                required: false,
                serializedName: 'values',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'BatchErrorDetailElementType',
                        type: {
                            name: 'Composite',
                            className: 'BatchErrorDetail'
                        }
                    }
                }
            }
        }
    }
};
exports.TaskAddResult = {
    required: false,
    serializedName: 'TaskAddResult',
    type: {
        name: 'Composite',
        className: 'TaskAddResult',
        modelProperties: {
            status: {
                required: true,
                serializedName: 'status',
                type: {
                    name: 'Enum',
                    allowedValues: ['success', 'clientError', 'serverError']
                }
            },
            taskId: {
                required: true,
                serializedName: 'taskId',
                type: {
                    name: 'String'
                }
            },
            eTag: {
                required: false,
                serializedName: 'eTag',
                type: {
                    name: 'String'
                }
            },
            lastModified: {
                required: false,
                serializedName: 'lastModified',
                type: {
                    name: 'DateTime'
                }
            },
            location: {
                required: false,
                serializedName: 'location',
                type: {
                    name: 'String'
                }
            },
            error: {
                required: false,
                serializedName: 'error',
                type: {
                    name: 'Composite',
                    className: 'BatchError'
                }
            }
        }
    }
};
exports.TaskAddCollectionResult = {
    required: false,
    serializedName: 'TaskAddCollectionResult',
    type: {
        name: 'Composite',
        className: 'TaskAddCollectionResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: 'value',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'TaskAddResultElementType',
                        type: {
                            name: 'Composite',
                            className: 'TaskAddResult'
                        }
                    }
                }
            }
        }
    }
};
exports.SubtaskInformation = {
    required: false,
    serializedName: 'SubtaskInformation',
    type: {
        name: 'Composite',
        className: 'SubtaskInformation',
        modelProperties: {
            id: {
                required: false,
                serializedName: 'id',
                type: {
                    name: 'Number'
                }
            },
            nodeInfo: {
                required: false,
                serializedName: 'nodeInfo',
                type: {
                    name: 'Composite',
                    className: 'ComputeNodeInformation'
                }
            },
            startTime: {
                required: false,
                serializedName: 'startTime',
                type: {
                    name: 'DateTime'
                }
            },
            endTime: {
                required: false,
                serializedName: 'endTime',
                type: {
                    name: 'DateTime'
                }
            },
            exitCode: {
                required: false,
                serializedName: 'exitCode',
                type: {
                    name: 'Number'
                }
            },
            containerInfo: {
                required: false,
                serializedName: 'containerInfo',
                type: {
                    name: 'Composite',
                    className: 'TaskContainerExecutionInformation'
                }
            },
            failureInfo: {
                required: false,
                serializedName: 'failureInfo',
                type: {
                    name: 'Composite',
                    className: 'TaskFailureInformation'
                }
            },
            state: {
                required: false,
                serializedName: 'state',
                type: {
                    name: 'Enum',
                    allowedValues: ['preparing', 'running', 'completed']
                }
            },
            stateTransitionTime: {
                required: false,
                serializedName: 'stateTransitionTime',
                type: {
                    name: 'DateTime'
                }
            },
            previousState: {
                required: false,
                serializedName: 'previousState',
                type: {
                    name: 'Enum',
                    allowedValues: ['preparing', 'running', 'completed']
                }
            },
            previousStateTransitionTime: {
                required: false,
                serializedName: 'previousStateTransitionTime',
                type: {
                    name: 'DateTime'
                }
            },
            result: {
                required: false,
                serializedName: 'result',
                type: {
                    name: 'Enum',
                    allowedValues: ['success', 'failure']
                }
            }
        }
    }
};
exports.CloudTaskListSubtasksResult = {
    required: false,
    serializedName: 'CloudTaskListSubtasksResult',
    type: {
        name: 'Composite',
        className: 'CloudTaskListSubtasksResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: 'value',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'SubtaskInformationElementType',
                        type: {
                            name: 'Composite',
                            className: 'SubtaskInformation'
                        }
                    }
                }
            }
        }
    }
};
exports.TaskInformation = {
    required: false,
    serializedName: 'TaskInformation',
    type: {
        name: 'Composite',
        className: 'TaskInformation',
        modelProperties: {
            taskUrl: {
                required: false,
                serializedName: 'taskUrl',
                type: {
                    name: 'String'
                }
            },
            jobId: {
                required: false,
                serializedName: 'jobId',
                type: {
                    name: 'String'
                }
            },
            taskId: {
                required: false,
                serializedName: 'taskId',
                type: {
                    name: 'String'
                }
            },
            subtaskId: {
                required: false,
                serializedName: 'subtaskId',
                type: {
                    name: 'Number'
                }
            },
            taskState: {
                required: true,
                serializedName: 'taskState',
                type: {
                    name: 'Enum',
                    allowedValues: ['active', 'preparing', 'running', 'completed']
                }
            },
            executionInfo: {
                required: false,
                serializedName: 'executionInfo',
                type: {
                    name: 'Composite',
                    className: 'TaskExecutionInformation'
                }
            }
        }
    }
};
exports.StartTaskInformation = {
    required: false,
    serializedName: 'StartTaskInformation',
    type: {
        name: 'Composite',
        className: 'StartTaskInformation',
        modelProperties: {
            state: {
                required: true,
                serializedName: 'state',
                type: {
                    name: 'Enum',
                    allowedValues: ['running', 'completed']
                }
            },
            startTime: {
                required: true,
                serializedName: 'startTime',
                type: {
                    name: 'DateTime'
                }
            },
            endTime: {
                required: false,
                serializedName: 'endTime',
                type: {
                    name: 'DateTime'
                }
            },
            exitCode: {
                required: false,
                serializedName: 'exitCode',
                type: {
                    name: 'Number'
                }
            },
            containerInfo: {
                required: false,
                serializedName: 'containerInfo',
                type: {
                    name: 'Composite',
                    className: 'TaskContainerExecutionInformation'
                }
            },
            failureInfo: {
                required: false,
                serializedName: 'failureInfo',
                type: {
                    name: 'Composite',
                    className: 'TaskFailureInformation'
                }
            },
            retryCount: {
                required: true,
                serializedName: 'retryCount',
                type: {
                    name: 'Number'
                }
            },
            lastRetryTime: {
                required: false,
                serializedName: 'lastRetryTime',
                type: {
                    name: 'DateTime'
                }
            },
            result: {
                required: false,
                serializedName: 'result',
                type: {
                    name: 'Enum',
                    allowedValues: ['success', 'failure']
                }
            }
        }
    }
};
exports.ComputeNodeError = {
    required: false,
    serializedName: 'ComputeNodeError',
    type: {
        name: 'Composite',
        className: 'ComputeNodeError',
        modelProperties: {
            code: {
                required: false,
                serializedName: 'code',
                type: {
                    name: 'String'
                }
            },
            message: {
                required: false,
                serializedName: 'message',
                type: {
                    name: 'String'
                }
            },
            errorDetails: {
                required: false,
                serializedName: 'errorDetails',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'NameValuePairElementType',
                        type: {
                            name: 'Composite',
                            className: 'NameValuePair'
                        }
                    }
                }
            }
        }
    }
};
exports.InboundEndpoint = {
    required: false,
    serializedName: 'InboundEndpoint',
    type: {
        name: 'Composite',
        className: 'InboundEndpoint',
        modelProperties: {
            name: {
                required: true,
                serializedName: 'name',
                type: {
                    name: 'String'
                }
            },
            protocol: {
                required: true,
                serializedName: 'protocol',
                type: {
                    name: 'Enum',
                    allowedValues: ['tcp', 'udp']
                }
            },
            publicIPAddress: {
                required: true,
                serializedName: 'publicIPAddress',
                type: {
                    name: 'String'
                }
            },
            publicFQDN: {
                required: true,
                serializedName: 'publicFQDN',
                type: {
                    name: 'String'
                }
            },
            frontendPort: {
                required: true,
                serializedName: 'frontendPort',
                type: {
                    name: 'Number'
                }
            },
            backendPort: {
                required: true,
                serializedName: 'backendPort',
                type: {
                    name: 'Number'
                }
            }
        }
    }
};
exports.ComputeNodeEndpointConfiguration = {
    required: false,
    serializedName: 'ComputeNodeEndpointConfiguration',
    type: {
        name: 'Composite',
        className: 'ComputeNodeEndpointConfiguration',
        modelProperties: {
            inboundEndpoints: {
                required: true,
                serializedName: 'inboundEndpoints',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'InboundEndpointElementType',
                        type: {
                            name: 'Composite',
                            className: 'InboundEndpoint'
                        }
                    }
                }
            }
        }
    }
};
exports.ComputeNode = {
    required: false,
    serializedName: 'ComputeNode',
    type: {
        name: 'Composite',
        className: 'ComputeNode',
        modelProperties: {
            id: {
                required: false,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            url: {
                required: false,
                serializedName: 'url',
                type: {
                    name: 'String'
                }
            },
            state: {
                required: false,
                serializedName: 'state',
                type: {
                    name: 'Enum',
                    allowedValues: ['idle', 'rebooting', 'reimaging', 'running', 'unusable', 'creating', 'starting', 'waitingForStartTask', 'startTaskFailed', 'unknown', 'leavingPool', 'offline', 'preempted']
                }
            },
            schedulingState: {
                required: false,
                serializedName: 'schedulingState',
                type: {
                    name: 'Enum',
                    allowedValues: ['enabled', 'disabled']
                }
            },
            stateTransitionTime: {
                required: false,
                serializedName: 'stateTransitionTime',
                type: {
                    name: 'DateTime'
                }
            },
            lastBootTime: {
                required: false,
                serializedName: 'lastBootTime',
                type: {
                    name: 'DateTime'
                }
            },
            allocationTime: {
                required: false,
                serializedName: 'allocationTime',
                type: {
                    name: 'DateTime'
                }
            },
            ipAddress: {
                required: false,
                serializedName: 'ipAddress',
                type: {
                    name: 'String'
                }
            },
            affinityId: {
                required: false,
                serializedName: 'affinityId',
                type: {
                    name: 'String'
                }
            },
            vmSize: {
                required: false,
                serializedName: 'vmSize',
                type: {
                    name: 'String'
                }
            },
            totalTasksRun: {
                required: false,
                serializedName: 'totalTasksRun',
                type: {
                    name: 'Number'
                }
            },
            runningTasksCount: {
                required: false,
                serializedName: 'runningTasksCount',
                type: {
                    name: 'Number'
                }
            },
            totalTasksSucceeded: {
                required: false,
                serializedName: 'totalTasksSucceeded',
                type: {
                    name: 'Number'
                }
            },
            recentTasks: {
                required: false,
                serializedName: 'recentTasks',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'TaskInformationElementType',
                        type: {
                            name: 'Composite',
                            className: 'TaskInformation'
                        }
                    }
                }
            },
            startTask: {
                required: false,
                serializedName: 'startTask',
                type: {
                    name: 'Composite',
                    className: 'StartTask'
                }
            },
            startTaskInfo: {
                required: false,
                serializedName: 'startTaskInfo',
                type: {
                    name: 'Composite',
                    className: 'StartTaskInformation'
                }
            },
            certificateReferences: {
                required: false,
                serializedName: 'certificateReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'CertificateReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'CertificateReference'
                        }
                    }
                }
            },
            errors: {
                required: false,
                serializedName: 'errors',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ComputeNodeErrorElementType',
                        type: {
                            name: 'Composite',
                            className: 'ComputeNodeError'
                        }
                    }
                }
            },
            isDedicated: {
                required: false,
                serializedName: 'isDedicated',
                type: {
                    name: 'Boolean'
                }
            },
            endpointConfiguration: {
                required: false,
                serializedName: 'endpointConfiguration',
                type: {
                    name: 'Composite',
                    className: 'ComputeNodeEndpointConfiguration'
                }
            }
        }
    }
};
exports.ComputeNodeUser = {
    required: false,
    serializedName: 'ComputeNodeUser',
    type: {
        name: 'Composite',
        className: 'ComputeNodeUser',
        modelProperties: {
            name: {
                required: true,
                serializedName: 'name',
                type: {
                    name: 'String'
                }
            },
            isAdmin: {
                required: false,
                serializedName: 'isAdmin',
                type: {
                    name: 'Boolean'
                }
            },
            expiryTime: {
                required: false,
                serializedName: 'expiryTime',
                type: {
                    name: 'DateTime'
                }
            },
            password: {
                required: false,
                serializedName: 'password',
                type: {
                    name: 'String'
                }
            },
            sshPublicKey: {
                required: false,
                serializedName: 'sshPublicKey',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.ComputeNodeGetRemoteLoginSettingsResult = {
    required: false,
    serializedName: 'ComputeNodeGetRemoteLoginSettingsResult',
    type: {
        name: 'Composite',
        className: 'ComputeNodeGetRemoteLoginSettingsResult',
        modelProperties: {
            remoteLoginIPAddress: {
                required: true,
                serializedName: 'remoteLoginIPAddress',
                type: {
                    name: 'String'
                }
            },
            remoteLoginPort: {
                required: true,
                serializedName: 'remoteLoginPort',
                type: {
                    name: 'Number'
                }
            }
        }
    }
};
exports.JobSchedulePatchParameter = {
    required: false,
    serializedName: 'JobSchedulePatchParameter',
    type: {
        name: 'Composite',
        className: 'JobSchedulePatchParameter',
        modelProperties: {
            schedule: {
                required: false,
                serializedName: 'schedule',
                type: {
                    name: 'Composite',
                    className: 'Schedule'
                }
            },
            jobSpecification: {
                required: false,
                serializedName: 'jobSpecification',
                type: {
                    name: 'Composite',
                    className: 'JobSpecification'
                }
            },
            metadata: {
                required: false,
                serializedName: 'metadata',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'MetadataItemElementType',
                        type: {
                            name: 'Composite',
                            className: 'MetadataItem'
                        }
                    }
                }
            }
        }
    }
};
exports.JobScheduleUpdateParameter = {
    required: false,
    serializedName: 'JobScheduleUpdateParameter',
    type: {
        name: 'Composite',
        className: 'JobScheduleUpdateParameter',
        modelProperties: {
            schedule: {
                required: true,
                serializedName: 'schedule',
                type: {
                    name: 'Composite',
                    className: 'Schedule'
                }
            },
            jobSpecification: {
                required: true,
                serializedName: 'jobSpecification',
                defaultValue: {},
                type: {
                    name: 'Composite',
                    className: 'JobSpecification'
                }
            },
            metadata: {
                required: false,
                serializedName: 'metadata',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'MetadataItemElementType',
                        type: {
                            name: 'Composite',
                            className: 'MetadataItem'
                        }
                    }
                }
            }
        }
    }
};
exports.JobDisableParameter = {
    required: false,
    serializedName: 'JobDisableParameter',
    type: {
        name: 'Composite',
        className: 'JobDisableParameter',
        modelProperties: {
            disableTasks: {
                required: true,
                serializedName: 'disableTasks',
                type: {
                    name: 'Enum',
                    allowedValues: ['requeue', 'terminate', 'wait']
                }
            }
        }
    }
};
exports.JobTerminateParameter = {
    required: false,
    serializedName: 'JobTerminateParameter',
    type: {
        name: 'Composite',
        className: 'JobTerminateParameter',
        modelProperties: {
            terminateReason: {
                required: false,
                serializedName: 'terminateReason',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.JobPatchParameter = {
    required: false,
    serializedName: 'JobPatchParameter',
    type: {
        name: 'Composite',
        className: 'JobPatchParameter',
        modelProperties: {
            priority: {
                required: false,
                serializedName: 'priority',
                type: {
                    name: 'Number'
                }
            },
            onAllTasksComplete: {
                required: false,
                serializedName: 'onAllTasksComplete',
                type: {
                    name: 'Enum',
                    allowedValues: ['noAction', 'terminateJob']
                }
            },
            constraints: {
                required: false,
                serializedName: 'constraints',
                type: {
                    name: 'Composite',
                    className: 'JobConstraints'
                }
            },
            poolInfo: {
                required: false,
                serializedName: 'poolInfo',
                type: {
                    name: 'Composite',
                    className: 'PoolInformation'
                }
            },
            metadata: {
                required: false,
                serializedName: 'metadata',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'MetadataItemElementType',
                        type: {
                            name: 'Composite',
                            className: 'MetadataItem'
                        }
                    }
                }
            }
        }
    }
};
exports.JobUpdateParameter = {
    required: false,
    serializedName: 'JobUpdateParameter',
    type: {
        name: 'Composite',
        className: 'JobUpdateParameter',
        modelProperties: {
            priority: {
                required: false,
                serializedName: 'priority',
                type: {
                    name: 'Number'
                }
            },
            constraints: {
                required: false,
                serializedName: 'constraints',
                type: {
                    name: 'Composite',
                    className: 'JobConstraints'
                }
            },
            poolInfo: {
                required: true,
                serializedName: 'poolInfo',
                defaultValue: {},
                type: {
                    name: 'Composite',
                    className: 'PoolInformation'
                }
            },
            metadata: {
                required: false,
                serializedName: 'metadata',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'MetadataItemElementType',
                        type: {
                            name: 'Composite',
                            className: 'MetadataItem'
                        }
                    }
                }
            },
            onAllTasksComplete: {
                required: false,
                serializedName: 'onAllTasksComplete',
                type: {
                    name: 'Enum',
                    allowedValues: ['noAction', 'terminateJob']
                }
            }
        }
    }
};
exports.PoolEnableAutoScaleParameter = {
    required: false,
    serializedName: 'PoolEnableAutoScaleParameter',
    type: {
        name: 'Composite',
        className: 'PoolEnableAutoScaleParameter',
        modelProperties: {
            autoScaleFormula: {
                required: false,
                serializedName: 'autoScaleFormula',
                type: {
                    name: 'String'
                }
            },
            autoScaleEvaluationInterval: {
                required: false,
                serializedName: 'autoScaleEvaluationInterval',
                type: {
                    name: 'TimeSpan'
                }
            }
        }
    }
};
exports.PoolEvaluateAutoScaleParameter = {
    required: false,
    serializedName: 'PoolEvaluateAutoScaleParameter',
    type: {
        name: 'Composite',
        className: 'PoolEvaluateAutoScaleParameter',
        modelProperties: {
            autoScaleFormula: {
                required: true,
                serializedName: 'autoScaleFormula',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.PoolResizeParameter = {
    required: false,
    serializedName: 'PoolResizeParameter',
    type: {
        name: 'Composite',
        className: 'PoolResizeParameter',
        modelProperties: {
            targetDedicatedNodes: {
                required: false,
                serializedName: 'targetDedicatedNodes',
                type: {
                    name: 'Number'
                }
            },
            targetLowPriorityNodes: {
                required: false,
                serializedName: 'targetLowPriorityNodes',
                type: {
                    name: 'Number'
                }
            },
            resizeTimeout: {
                required: false,
                serializedName: 'resizeTimeout',
                type: {
                    name: 'TimeSpan'
                }
            },
            nodeDeallocationOption: {
                required: false,
                serializedName: 'nodeDeallocationOption',
                type: {
                    name: 'Enum',
                    allowedValues: ['requeue', 'terminate', 'taskCompletion', 'retainedData']
                }
            }
        }
    }
};
exports.PoolUpdatePropertiesParameter = {
    required: false,
    serializedName: 'PoolUpdatePropertiesParameter',
    type: {
        name: 'Composite',
        className: 'PoolUpdatePropertiesParameter',
        modelProperties: {
            startTask: {
                required: false,
                serializedName: 'startTask',
                type: {
                    name: 'Composite',
                    className: 'StartTask'
                }
            },
            certificateReferences: {
                required: true,
                serializedName: 'certificateReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'CertificateReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'CertificateReference'
                        }
                    }
                }
            },
            applicationPackageReferences: {
                required: true,
                serializedName: 'applicationPackageReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ApplicationPackageReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'ApplicationPackageReference'
                        }
                    }
                }
            },
            metadata: {
                required: true,
                serializedName: 'metadata',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'MetadataItemElementType',
                        type: {
                            name: 'Composite',
                            className: 'MetadataItem'
                        }
                    }
                }
            }
        }
    }
};
exports.PoolUpgradeOSParameter = {
    required: false,
    serializedName: 'PoolUpgradeOSParameter',
    type: {
        name: 'Composite',
        className: 'PoolUpgradeOSParameter',
        modelProperties: {
            targetOSVersion: {
                required: true,
                serializedName: 'targetOSVersion',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.PoolPatchParameter = {
    required: false,
    serializedName: 'PoolPatchParameter',
    type: {
        name: 'Composite',
        className: 'PoolPatchParameter',
        modelProperties: {
            startTask: {
                required: false,
                serializedName: 'startTask',
                type: {
                    name: 'Composite',
                    className: 'StartTask'
                }
            },
            certificateReferences: {
                required: false,
                serializedName: 'certificateReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'CertificateReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'CertificateReference'
                        }
                    }
                }
            },
            applicationPackageReferences: {
                required: false,
                serializedName: 'applicationPackageReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ApplicationPackageReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'ApplicationPackageReference'
                        }
                    }
                }
            },
            metadata: {
                required: false,
                serializedName: 'metadata',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'MetadataItemElementType',
                        type: {
                            name: 'Composite',
                            className: 'MetadataItem'
                        }
                    }
                }
            }
        }
    }
};
exports.TaskUpdateParameter = {
    required: false,
    serializedName: 'TaskUpdateParameter',
    type: {
        name: 'Composite',
        className: 'TaskUpdateParameter',
        modelProperties: {
            constraints: {
                required: false,
                serializedName: 'constraints',
                type: {
                    name: 'Composite',
                    className: 'TaskConstraints'
                }
            }
        }
    }
};
exports.NodeUpdateUserParameter = {
    required: false,
    serializedName: 'NodeUpdateUserParameter',
    type: {
        name: 'Composite',
        className: 'NodeUpdateUserParameter',
        modelProperties: {
            password: {
                required: false,
                serializedName: 'password',
                type: {
                    name: 'String'
                }
            },
            expiryTime: {
                required: false,
                serializedName: 'expiryTime',
                type: {
                    name: 'DateTime'
                }
            },
            sshPublicKey: {
                required: false,
                serializedName: 'sshPublicKey',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.NodeRebootParameter = {
    required: false,
    serializedName: 'NodeRebootParameter',
    type: {
        name: 'Composite',
        className: 'NodeRebootParameter',
        modelProperties: {
            nodeRebootOption: {
                required: false,
                serializedName: 'nodeRebootOption',
                type: {
                    name: 'Enum',
                    allowedValues: ['requeue', 'terminate', 'taskCompletion', 'retainedData']
                }
            }
        }
    }
};
exports.NodeReimageParameter = {
    required: false,
    serializedName: 'NodeReimageParameter',
    type: {
        name: 'Composite',
        className: 'NodeReimageParameter',
        modelProperties: {
            nodeReimageOption: {
                required: false,
                serializedName: 'nodeReimageOption',
                type: {
                    name: 'Enum',
                    allowedValues: ['requeue', 'terminate', 'taskCompletion', 'retainedData']
                }
            }
        }
    }
};
exports.NodeDisableSchedulingParameter = {
    required: false,
    serializedName: 'NodeDisableSchedulingParameter',
    type: {
        name: 'Composite',
        className: 'NodeDisableSchedulingParameter',
        modelProperties: {
            nodeDisableSchedulingOption: {
                required: false,
                serializedName: 'nodeDisableSchedulingOption',
                type: {
                    name: 'Enum',
                    allowedValues: ['requeue', 'terminate', 'taskCompletion']
                }
            }
        }
    }
};
exports.NodeRemoveParameter = {
    required: false,
    serializedName: 'NodeRemoveParameter',
    type: {
        name: 'Composite',
        className: 'NodeRemoveParameter',
        modelProperties: {
            nodeList: {
                required: true,
                serializedName: 'nodeList',
                constraints: {
                    MaxItems: 100
                },
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'stringElementType',
                        type: {
                            name: 'String'
                        }
                    }
                }
            },
            resizeTimeout: {
                required: false,
                serializedName: 'resizeTimeout',
                type: {
                    name: 'TimeSpan'
                }
            },
            nodeDeallocationOption: {
                required: false,
                serializedName: 'nodeDeallocationOption',
                type: {
                    name: 'Enum',
                    allowedValues: ['requeue', 'terminate', 'taskCompletion', 'retainedData']
                }
            }
        }
    }
};
exports.ApplicationListOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ApplicationListOptions',
        modelProperties: {
            maxResults: {
                required: false,
                defaultValue: 1000,
                type: {
                    name: 'Number'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.ApplicationGetOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ApplicationGetOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.PoolListUsageMetricsOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolListUsageMetricsOptions',
        modelProperties: {
            startTime: {
                required: false,
                type: {
                    name: 'DateTime'
                }
            },
            endTime: {
                required: false,
                type: {
                    name: 'DateTime'
                }
            },
            filter: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            maxResults: {
                required: false,
                defaultValue: 1000,
                type: {
                    name: 'Number'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.PoolGetAllLifetimeStatisticsOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolGetAllLifetimeStatisticsOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.PoolAddOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolAddOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.PoolListOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolListOptions',
        modelProperties: {
            filter: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            expand: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            maxResults: {
                required: false,
                defaultValue: 1000,
                type: {
                    name: 'Number'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.PoolDeleteMethodOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolDeleteMethodOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.PoolExistsOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolExistsOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.PoolGetOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolGetOptions',
        modelProperties: {
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            expand: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.PoolPatchOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolPatchOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.PoolDisableAutoScaleOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolDisableAutoScaleOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.PoolEnableAutoScaleOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolEnableAutoScaleOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.PoolEvaluateAutoScaleOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolEvaluateAutoScaleOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.PoolResizeOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolResizeOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.PoolStopResizeOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolStopResizeOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.PoolUpdatePropertiesOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolUpdatePropertiesOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.PoolUpgradeOSOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolUpgradeOSOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.PoolRemoveNodesOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolRemoveNodesOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.AccountListNodeAgentSkusOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'AccountListNodeAgentSkusOptions',
        modelProperties: {
            filter: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            maxResults: {
                required: false,
                defaultValue: 1000,
                type: {
                    name: 'Number'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.JobGetAllLifetimeStatisticsOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobGetAllLifetimeStatisticsOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.JobDeleteMethodOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobDeleteMethodOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.JobGetOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobGetOptions',
        modelProperties: {
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            expand: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.JobPatchOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobPatchOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.JobUpdateOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobUpdateOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.JobDisableOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobDisableOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.JobEnableOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobEnableOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.JobTerminateOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobTerminateOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.JobAddOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobAddOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.JobListOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobListOptions',
        modelProperties: {
            filter: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            expand: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            maxResults: {
                required: false,
                defaultValue: 1000,
                type: {
                    name: 'Number'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.JobListFromJobScheduleOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobListFromJobScheduleOptions',
        modelProperties: {
            filter: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            expand: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            maxResults: {
                required: false,
                defaultValue: 1000,
                type: {
                    name: 'Number'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.JobListPreparationAndReleaseTaskStatusOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobListPreparationAndReleaseTaskStatusOptions',
        modelProperties: {
            filter: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            maxResults: {
                required: false,
                defaultValue: 1000,
                type: {
                    name: 'Number'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.JobGetTaskCountsOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobGetTaskCountsOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.CertificateAddOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'CertificateAddOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.CertificateListOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'CertificateListOptions',
        modelProperties: {
            filter: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            maxResults: {
                required: false,
                defaultValue: 1000,
                type: {
                    name: 'Number'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.CertificateCancelDeletionOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'CertificateCancelDeletionOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.CertificateDeleteMethodOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'CertificateDeleteMethodOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.CertificateGetOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'CertificateGetOptions',
        modelProperties: {
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.FileDeleteFromTaskOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'FileDeleteFromTaskOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.FileGetFromTaskOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'FileGetFromTaskOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ocpRange: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.FileGetPropertiesFromTaskOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'FileGetPropertiesFromTaskOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.FileDeleteFromComputeNodeOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'FileDeleteFromComputeNodeOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.FileGetFromComputeNodeOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'FileGetFromComputeNodeOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ocpRange: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.FileGetPropertiesFromComputeNodeOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'FileGetPropertiesFromComputeNodeOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.FileListFromTaskOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'FileListFromTaskOptions',
        modelProperties: {
            filter: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            maxResults: {
                required: false,
                defaultValue: 1000,
                type: {
                    name: 'Number'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.FileListFromComputeNodeOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'FileListFromComputeNodeOptions',
        modelProperties: {
            filter: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            maxResults: {
                required: false,
                defaultValue: 1000,
                type: {
                    name: 'Number'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.JobScheduleExistsOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobScheduleExistsOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.JobScheduleDeleteMethodOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobScheduleDeleteMethodOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.JobScheduleGetOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobScheduleGetOptions',
        modelProperties: {
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            expand: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.JobSchedulePatchOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobSchedulePatchOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.JobScheduleUpdateOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobScheduleUpdateOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.JobScheduleDisableOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobScheduleDisableOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.JobScheduleEnableOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobScheduleEnableOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.JobScheduleTerminateOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobScheduleTerminateOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.JobScheduleAddOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobScheduleAddOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.JobScheduleListOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobScheduleListOptions',
        modelProperties: {
            filter: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            expand: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            maxResults: {
                required: false,
                defaultValue: 1000,
                type: {
                    name: 'Number'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.TaskAddOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'TaskAddOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.TaskListOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'TaskListOptions',
        modelProperties: {
            filter: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            expand: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            maxResults: {
                required: false,
                defaultValue: 1000,
                type: {
                    name: 'Number'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.TaskAddCollectionOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'TaskAddCollectionOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.TaskDeleteMethodOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'TaskDeleteMethodOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.TaskGetOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'TaskGetOptions',
        modelProperties: {
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            expand: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.TaskUpdateOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'TaskUpdateOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.TaskListSubtasksOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'TaskListSubtasksOptions',
        modelProperties: {
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.TaskTerminateOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'TaskTerminateOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.TaskReactivateOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'TaskReactivateOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.ComputeNodeAddUserOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ComputeNodeAddUserOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.ComputeNodeDeleteUserOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ComputeNodeDeleteUserOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.ComputeNodeUpdateUserOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ComputeNodeUpdateUserOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.ComputeNodeGetOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ComputeNodeGetOptions',
        modelProperties: {
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.ComputeNodeRebootOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ComputeNodeRebootOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.ComputeNodeReimageOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ComputeNodeReimageOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.ComputeNodeDisableSchedulingOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ComputeNodeDisableSchedulingOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.ComputeNodeEnableSchedulingOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ComputeNodeEnableSchedulingOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.ComputeNodeGetRemoteLoginSettingsOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ComputeNodeGetRemoteLoginSettingsOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.ComputeNodeGetRemoteDesktopOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ComputeNodeGetRemoteDesktopOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.ComputeNodeListOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ComputeNodeListOptions',
        modelProperties: {
            filter: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            maxResults: {
                required: false,
                defaultValue: 1000,
                type: {
                    name: 'Number'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.ApplicationListNextOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ApplicationListNextOptions',
        modelProperties: {
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.PoolListUsageMetricsNextOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolListUsageMetricsNextOptions',
        modelProperties: {
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.PoolListNextOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolListNextOptions',
        modelProperties: {
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.AccountListNodeAgentSkusNextOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'AccountListNodeAgentSkusNextOptions',
        modelProperties: {
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.JobListNextOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobListNextOptions',
        modelProperties: {
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.JobListFromJobScheduleNextOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobListFromJobScheduleNextOptions',
        modelProperties: {
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.JobListPreparationAndReleaseTaskStatusNextOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobListPreparationAndReleaseTaskStatusNextOptions',
        modelProperties: {
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.CertificateListNextOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'CertificateListNextOptions',
        modelProperties: {
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.FileListFromTaskNextOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'FileListFromTaskNextOptions',
        modelProperties: {
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.FileListFromComputeNodeNextOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'FileListFromComputeNodeNextOptions',
        modelProperties: {
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.JobScheduleListNextOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobScheduleListNextOptions',
        modelProperties: {
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.TaskListNextOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'TaskListNextOptions',
        modelProperties: {
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.ComputeNodeListNextOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ComputeNodeListNextOptions',
        modelProperties: {
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
exports.ApplicationListOptionalParams = {
    required: false,
    serializedName: 'ListOptions',
    type: {
        name: 'Composite',
        className: 'ApplicationListOptionalParams',
        modelProperties: {
            applicationListOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'ApplicationListOptions'
                }
            }
        }
    }
};
exports.ApplicationGetOptionalParams = {
    required: false,
    serializedName: 'GetOptions',
    type: {
        name: 'Composite',
        className: 'ApplicationGetOptionalParams',
        modelProperties: {
            applicationGetOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'ApplicationGetOptions'
                }
            }
        }
    }
};
exports.ApplicationListNextOptionalParams = {
    required: false,
    serializedName: 'ListNextOptions',
    type: {
        name: 'Composite',
        className: 'ApplicationListNextOptionalParams',
        modelProperties: {
            applicationListNextOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'ApplicationListNextOptions'
                }
            }
        }
    }
};
exports.PoolListUsageMetricsOptionalParams = {
    required: false,
    serializedName: 'ListUsageMetricsOptions',
    type: {
        name: 'Composite',
        className: 'PoolListUsageMetricsOptionalParams',
        modelProperties: {
            poolListUsageMetricsOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'PoolListUsageMetricsOptions'
                }
            }
        }
    }
};
exports.PoolGetAllLifetimeStatisticsOptionalParams = {
    required: false,
    serializedName: 'GetAllLifetimeStatisticsOptions',
    type: {
        name: 'Composite',
        className: 'PoolGetAllLifetimeStatisticsOptionalParams',
        modelProperties: {
            poolGetAllLifetimeStatisticsOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'PoolGetAllLifetimeStatisticsOptions'
                }
            }
        }
    }
};
exports.PoolAddOptionalParams = {
    required: false,
    serializedName: 'AddOptions',
    type: {
        name: 'Composite',
        className: 'PoolAddOptionalParams',
        modelProperties: {
            poolAddOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'PoolAddOptions'
                }
            }
        }
    }
};
exports.PoolListOptionalParams = {
    required: false,
    serializedName: 'ListOptions',
    type: {
        name: 'Composite',
        className: 'PoolListOptionalParams',
        modelProperties: {
            poolListOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'PoolListOptions'
                }
            }
        }
    }
};
exports.PoolDeleteMethodOptionalParams = {
    required: false,
    serializedName: 'DeleteMethodOptions',
    type: {
        name: 'Composite',
        className: 'PoolDeleteMethodOptionalParams',
        modelProperties: {
            poolDeleteMethodOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'PoolDeleteMethodOptions'
                }
            }
        }
    }
};
exports.PoolExistsOptionalParams = {
    required: false,
    serializedName: 'ExistsOptions',
    type: {
        name: 'Composite',
        className: 'PoolExistsOptionalParams',
        modelProperties: {
            poolExistsOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'PoolExistsOptions'
                }
            }
        }
    }
};
exports.PoolGetOptionalParams = {
    required: false,
    serializedName: 'GetOptions',
    type: {
        name: 'Composite',
        className: 'PoolGetOptionalParams',
        modelProperties: {
            poolGetOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'PoolGetOptions'
                }
            }
        }
    }
};
exports.PoolPatchOptionalParams = {
    required: false,
    serializedName: 'PatchOptions',
    type: {
        name: 'Composite',
        className: 'PoolPatchOptionalParams',
        modelProperties: {
            poolPatchOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'PoolPatchOptions'
                }
            }
        }
    }
};
exports.PoolDisableAutoScaleOptionalParams = {
    required: false,
    serializedName: 'DisableAutoScaleOptions',
    type: {
        name: 'Composite',
        className: 'PoolDisableAutoScaleOptionalParams',
        modelProperties: {
            poolDisableAutoScaleOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'PoolDisableAutoScaleOptions'
                }
            }
        }
    }
};
exports.PoolEnableAutoScaleOptionalParams = {
    required: false,
    serializedName: 'EnableAutoScaleOptions',
    type: {
        name: 'Composite',
        className: 'PoolEnableAutoScaleOptionalParams',
        modelProperties: {
            poolEnableAutoScaleOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'PoolEnableAutoScaleOptions'
                }
            }
        }
    }
};
exports.PoolEvaluateAutoScaleOptionalParams = {
    required: false,
    serializedName: 'EvaluateAutoScaleOptions',
    type: {
        name: 'Composite',
        className: 'PoolEvaluateAutoScaleOptionalParams',
        modelProperties: {
            poolEvaluateAutoScaleOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'PoolEvaluateAutoScaleOptions'
                }
            }
        }
    }
};
exports.PoolResizeOptionalParams = {
    required: false,
    serializedName: 'ResizeOptions',
    type: {
        name: 'Composite',
        className: 'PoolResizeOptionalParams',
        modelProperties: {
            poolResizeOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'PoolResizeOptions'
                }
            }
        }
    }
};
exports.PoolStopResizeOptionalParams = {
    required: false,
    serializedName: 'StopResizeOptions',
    type: {
        name: 'Composite',
        className: 'PoolStopResizeOptionalParams',
        modelProperties: {
            poolStopResizeOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'PoolStopResizeOptions'
                }
            }
        }
    }
};
exports.PoolUpdatePropertiesOptionalParams = {
    required: false,
    serializedName: 'UpdatePropertiesOptions',
    type: {
        name: 'Composite',
        className: 'PoolUpdatePropertiesOptionalParams',
        modelProperties: {
            poolUpdatePropertiesOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'PoolUpdatePropertiesOptions'
                }
            }
        }
    }
};
exports.PoolUpgradeOSOptionalParams = {
    required: false,
    serializedName: 'UpgradeOSOptions',
    type: {
        name: 'Composite',
        className: 'PoolUpgradeOSOptionalParams',
        modelProperties: {
            poolUpgradeOSOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'PoolUpgradeOSOptions'
                }
            }
        }
    }
};
exports.PoolRemoveNodesOptionalParams = {
    required: false,
    serializedName: 'RemoveNodesOptions',
    type: {
        name: 'Composite',
        className: 'PoolRemoveNodesOptionalParams',
        modelProperties: {
            poolRemoveNodesOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'PoolRemoveNodesOptions'
                }
            }
        }
    }
};
exports.PoolListUsageMetricsNextOptionalParams = {
    required: false,
    serializedName: 'ListUsageMetricsNextOptions',
    type: {
        name: 'Composite',
        className: 'PoolListUsageMetricsNextOptionalParams',
        modelProperties: {
            poolListUsageMetricsNextOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'PoolListUsageMetricsNextOptions'
                }
            }
        }
    }
};
exports.PoolListNextOptionalParams = {
    required: false,
    serializedName: 'ListNextOptions',
    type: {
        name: 'Composite',
        className: 'PoolListNextOptionalParams',
        modelProperties: {
            poolListNextOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'PoolListNextOptions'
                }
            }
        }
    }
};
exports.AccountListNodeAgentSkusOptionalParams = {
    required: false,
    serializedName: 'ListNodeAgentSkusOptions',
    type: {
        name: 'Composite',
        className: 'AccountListNodeAgentSkusOptionalParams',
        modelProperties: {
            accountListNodeAgentSkusOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'AccountListNodeAgentSkusOptions'
                }
            }
        }
    }
};
exports.AccountListNodeAgentSkusNextOptionalParams = {
    required: false,
    serializedName: 'ListNodeAgentSkusNextOptions',
    type: {
        name: 'Composite',
        className: 'AccountListNodeAgentSkusNextOptionalParams',
        modelProperties: {
            accountListNodeAgentSkusNextOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'AccountListNodeAgentSkusNextOptions'
                }
            }
        }
    }
};
exports.JobGetAllLifetimeStatisticsOptionalParams = {
    required: false,
    serializedName: 'GetAllLifetimeStatisticsOptions',
    type: {
        name: 'Composite',
        className: 'JobGetAllLifetimeStatisticsOptionalParams',
        modelProperties: {
            jobGetAllLifetimeStatisticsOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'JobGetAllLifetimeStatisticsOptions'
                }
            }
        }
    }
};
exports.JobDeleteMethodOptionalParams = {
    required: false,
    serializedName: 'DeleteMethodOptions',
    type: {
        name: 'Composite',
        className: 'JobDeleteMethodOptionalParams',
        modelProperties: {
            jobDeleteMethodOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'JobDeleteMethodOptions'
                }
            }
        }
    }
};
exports.JobGetOptionalParams = {
    required: false,
    serializedName: 'GetOptions',
    type: {
        name: 'Composite',
        className: 'JobGetOptionalParams',
        modelProperties: {
            jobGetOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'JobGetOptions'
                }
            }
        }
    }
};
exports.JobPatchOptionalParams = {
    required: false,
    serializedName: 'PatchOptions',
    type: {
        name: 'Composite',
        className: 'JobPatchOptionalParams',
        modelProperties: {
            jobPatchOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'JobPatchOptions'
                }
            }
        }
    }
};
exports.JobUpdateOptionalParams = {
    required: false,
    serializedName: 'UpdateOptions',
    type: {
        name: 'Composite',
        className: 'JobUpdateOptionalParams',
        modelProperties: {
            jobUpdateOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'JobUpdateOptions'
                }
            }
        }
    }
};
exports.JobDisableOptionalParams = {
    required: false,
    serializedName: 'DisableOptions',
    type: {
        name: 'Composite',
        className: 'JobDisableOptionalParams',
        modelProperties: {
            jobDisableOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'JobDisableOptions'
                }
            }
        }
    }
};
exports.JobEnableOptionalParams = {
    required: false,
    serializedName: 'EnableOptions',
    type: {
        name: 'Composite',
        className: 'JobEnableOptionalParams',
        modelProperties: {
            jobEnableOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'JobEnableOptions'
                }
            }
        }
    }
};
exports.JobTerminateOptionalParams = {
    required: false,
    serializedName: 'TerminateOptions',
    type: {
        name: 'Composite',
        className: 'JobTerminateOptionalParams',
        modelProperties: {
            terminateReason: {
                required: false,
                serializedName: 'terminateReason',
                type: {
                    name: 'String'
                }
            },
            jobTerminateOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'JobTerminateOptions'
                }
            }
        }
    }
};
exports.JobAddOptionalParams = {
    required: false,
    serializedName: 'AddOptions',
    type: {
        name: 'Composite',
        className: 'JobAddOptionalParams',
        modelProperties: {
            jobAddOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'JobAddOptions'
                }
            }
        }
    }
};
exports.JobListOptionalParams = {
    required: false,
    serializedName: 'ListOptions',
    type: {
        name: 'Composite',
        className: 'JobListOptionalParams',
        modelProperties: {
            jobListOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'JobListOptions'
                }
            }
        }
    }
};
exports.JobListFromJobScheduleOptionalParams = {
    required: false,
    serializedName: 'ListFromJobScheduleOptions',
    type: {
        name: 'Composite',
        className: 'JobListFromJobScheduleOptionalParams',
        modelProperties: {
            jobListFromJobScheduleOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'JobListFromJobScheduleOptions'
                }
            }
        }
    }
};
exports.JobListPreparationAndReleaseTaskStatusOptionalParams = {
    required: false,
    serializedName: 'ListPreparationAndReleaseTaskStatusOptions',
    type: {
        name: 'Composite',
        className: 'JobListPreparationAndReleaseTaskStatusOptionalParams',
        modelProperties: {
            jobListPreparationAndReleaseTaskStatusOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'JobListPreparationAndReleaseTaskStatusOptions'
                }
            }
        }
    }
};
exports.JobGetTaskCountsOptionalParams = {
    required: false,
    serializedName: 'GetTaskCountsOptions',
    type: {
        name: 'Composite',
        className: 'JobGetTaskCountsOptionalParams',
        modelProperties: {
            jobGetTaskCountsOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'JobGetTaskCountsOptions'
                }
            }
        }
    }
};
exports.JobListNextOptionalParams = {
    required: false,
    serializedName: 'ListNextOptions',
    type: {
        name: 'Composite',
        className: 'JobListNextOptionalParams',
        modelProperties: {
            jobListNextOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'JobListNextOptions'
                }
            }
        }
    }
};
exports.JobListFromJobScheduleNextOptionalParams = {
    required: false,
    serializedName: 'ListFromJobScheduleNextOptions',
    type: {
        name: 'Composite',
        className: 'JobListFromJobScheduleNextOptionalParams',
        modelProperties: {
            jobListFromJobScheduleNextOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'JobListFromJobScheduleNextOptions'
                }
            }
        }
    }
};
exports.JobListPreparationAndReleaseTaskStatusNextOptionalParams = {
    required: false,
    serializedName: 'ListPreparationAndReleaseTaskStatusNextOptions',
    type: {
        name: 'Composite',
        className: 'JobListPreparationAndReleaseTaskStatusNextOptionalParams',
        modelProperties: {
            jobListPreparationAndReleaseTaskStatusNextOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'JobListPreparationAndReleaseTaskStatusNextOptions'
                }
            }
        }
    }
};
exports.CertificateAddOptionalParams = {
    required: false,
    serializedName: 'AddOptions',
    type: {
        name: 'Composite',
        className: 'CertificateAddOptionalParams',
        modelProperties: {
            certificateAddOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'CertificateAddOptions'
                }
            }
        }
    }
};
exports.CertificateListOptionalParams = {
    required: false,
    serializedName: 'ListOptions',
    type: {
        name: 'Composite',
        className: 'CertificateListOptionalParams',
        modelProperties: {
            certificateListOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'CertificateListOptions'
                }
            }
        }
    }
};
exports.CertificateCancelDeletionOptionalParams = {
    required: false,
    serializedName: 'CancelDeletionOptions',
    type: {
        name: 'Composite',
        className: 'CertificateCancelDeletionOptionalParams',
        modelProperties: {
            certificateCancelDeletionOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'CertificateCancelDeletionOptions'
                }
            }
        }
    }
};
exports.CertificateDeleteMethodOptionalParams = {
    required: false,
    serializedName: 'DeleteMethodOptions',
    type: {
        name: 'Composite',
        className: 'CertificateDeleteMethodOptionalParams',
        modelProperties: {
            certificateDeleteMethodOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'CertificateDeleteMethodOptions'
                }
            }
        }
    }
};
exports.CertificateGetOptionalParams = {
    required: false,
    serializedName: 'GetOptions',
    type: {
        name: 'Composite',
        className: 'CertificateGetOptionalParams',
        modelProperties: {
            certificateGetOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'CertificateGetOptions'
                }
            }
        }
    }
};
exports.CertificateListNextOptionalParams = {
    required: false,
    serializedName: 'ListNextOptions',
    type: {
        name: 'Composite',
        className: 'CertificateListNextOptionalParams',
        modelProperties: {
            certificateListNextOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'CertificateListNextOptions'
                }
            }
        }
    }
};
exports.FileDeleteFromTaskOptionalParams = {
    required: false,
    serializedName: 'DeleteFromTaskOptions',
    type: {
        name: 'Composite',
        className: 'FileDeleteFromTaskOptionalParams',
        modelProperties: {
            recursive: {
                required: false,
                serializedName: 'recursive',
                type: {
                    name: 'Boolean'
                }
            },
            fileDeleteFromTaskOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'FileDeleteFromTaskOptions'
                }
            }
        }
    }
};
exports.FileGetFromTaskOptionalParams = {
    required: false,
    serializedName: 'GetFromTaskOptions',
    type: {
        name: 'Composite',
        className: 'FileGetFromTaskOptionalParams',
        modelProperties: {
            fileGetFromTaskOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'FileGetFromTaskOptions'
                }
            }
        }
    }
};
exports.FileGetPropertiesFromTaskOptionalParams = {
    required: false,
    serializedName: 'GetPropertiesFromTaskOptions',
    type: {
        name: 'Composite',
        className: 'FileGetPropertiesFromTaskOptionalParams',
        modelProperties: {
            fileGetPropertiesFromTaskOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'FileGetPropertiesFromTaskOptions'
                }
            }
        }
    }
};
exports.FileDeleteFromComputeNodeOptionalParams = {
    required: false,
    serializedName: 'DeleteFromComputeNodeOptions',
    type: {
        name: 'Composite',
        className: 'FileDeleteFromComputeNodeOptionalParams',
        modelProperties: {
            recursive: {
                required: false,
                serializedName: 'recursive',
                type: {
                    name: 'Boolean'
                }
            },
            fileDeleteFromComputeNodeOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'FileDeleteFromComputeNodeOptions'
                }
            }
        }
    }
};
exports.FileGetFromComputeNodeOptionalParams = {
    required: false,
    serializedName: 'GetFromComputeNodeOptions',
    type: {
        name: 'Composite',
        className: 'FileGetFromComputeNodeOptionalParams',
        modelProperties: {
            fileGetFromComputeNodeOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'FileGetFromComputeNodeOptions'
                }
            }
        }
    }
};
exports.FileGetPropertiesFromComputeNodeOptionalParams = {
    required: false,
    serializedName: 'GetPropertiesFromComputeNodeOptions',
    type: {
        name: 'Composite',
        className: 'FileGetPropertiesFromComputeNodeOptionalParams',
        modelProperties: {
            fileGetPropertiesFromComputeNodeOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'FileGetPropertiesFromComputeNodeOptions'
                }
            }
        }
    }
};
exports.FileListFromTaskOptionalParams = {
    required: false,
    serializedName: 'ListFromTaskOptions',
    type: {
        name: 'Composite',
        className: 'FileListFromTaskOptionalParams',
        modelProperties: {
            recursive: {
                required: false,
                serializedName: 'recursive',
                type: {
                    name: 'Boolean'
                }
            },
            fileListFromTaskOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'FileListFromTaskOptions'
                }
            }
        }
    }
};
exports.FileListFromComputeNodeOptionalParams = {
    required: false,
    serializedName: 'ListFromComputeNodeOptions',
    type: {
        name: 'Composite',
        className: 'FileListFromComputeNodeOptionalParams',
        modelProperties: {
            recursive: {
                required: false,
                serializedName: 'recursive',
                type: {
                    name: 'Boolean'
                }
            },
            fileListFromComputeNodeOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'FileListFromComputeNodeOptions'
                }
            }
        }
    }
};
exports.FileListFromTaskNextOptionalParams = {
    required: false,
    serializedName: 'ListFromTaskNextOptions',
    type: {
        name: 'Composite',
        className: 'FileListFromTaskNextOptionalParams',
        modelProperties: {
            fileListFromTaskNextOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'FileListFromTaskNextOptions'
                }
            }
        }
    }
};
exports.FileListFromComputeNodeNextOptionalParams = {
    required: false,
    serializedName: 'ListFromComputeNodeNextOptions',
    type: {
        name: 'Composite',
        className: 'FileListFromComputeNodeNextOptionalParams',
        modelProperties: {
            fileListFromComputeNodeNextOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'FileListFromComputeNodeNextOptions'
                }
            }
        }
    }
};
exports.JobScheduleExistsOptionalParams = {
    required: false,
    serializedName: 'ExistsOptions',
    type: {
        name: 'Composite',
        className: 'JobScheduleExistsOptionalParams',
        modelProperties: {
            jobScheduleExistsOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'JobScheduleExistsOptions'
                }
            }
        }
    }
};
exports.JobScheduleDeleteMethodOptionalParams = {
    required: false,
    serializedName: 'DeleteMethodOptions',
    type: {
        name: 'Composite',
        className: 'JobScheduleDeleteMethodOptionalParams',
        modelProperties: {
            jobScheduleDeleteMethodOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'JobScheduleDeleteMethodOptions'
                }
            }
        }
    }
};
exports.JobScheduleGetOptionalParams = {
    required: false,
    serializedName: 'GetOptions',
    type: {
        name: 'Composite',
        className: 'JobScheduleGetOptionalParams',
        modelProperties: {
            jobScheduleGetOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'JobScheduleGetOptions'
                }
            }
        }
    }
};
exports.JobSchedulePatchOptionalParams = {
    required: false,
    serializedName: 'PatchOptions',
    type: {
        name: 'Composite',
        className: 'JobSchedulePatchOptionalParams',
        modelProperties: {
            jobSchedulePatchOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'JobSchedulePatchOptions'
                }
            }
        }
    }
};
exports.JobScheduleUpdateOptionalParams = {
    required: false,
    serializedName: 'UpdateOptions',
    type: {
        name: 'Composite',
        className: 'JobScheduleUpdateOptionalParams',
        modelProperties: {
            jobScheduleUpdateOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'JobScheduleUpdateOptions'
                }
            }
        }
    }
};
exports.JobScheduleDisableOptionalParams = {
    required: false,
    serializedName: 'DisableOptions',
    type: {
        name: 'Composite',
        className: 'JobScheduleDisableOptionalParams',
        modelProperties: {
            jobScheduleDisableOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'JobScheduleDisableOptions'
                }
            }
        }
    }
};
exports.JobScheduleEnableOptionalParams = {
    required: false,
    serializedName: 'EnableOptions',
    type: {
        name: 'Composite',
        className: 'JobScheduleEnableOptionalParams',
        modelProperties: {
            jobScheduleEnableOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'JobScheduleEnableOptions'
                }
            }
        }
    }
};
exports.JobScheduleTerminateOptionalParams = {
    required: false,
    serializedName: 'TerminateOptions',
    type: {
        name: 'Composite',
        className: 'JobScheduleTerminateOptionalParams',
        modelProperties: {
            jobScheduleTerminateOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'JobScheduleTerminateOptions'
                }
            }
        }
    }
};
exports.JobScheduleAddOptionalParams = {
    required: false,
    serializedName: 'AddOptions',
    type: {
        name: 'Composite',
        className: 'JobScheduleAddOptionalParams',
        modelProperties: {
            jobScheduleAddOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'JobScheduleAddOptions'
                }
            }
        }
    }
};
exports.JobScheduleListOptionalParams = {
    required: false,
    serializedName: 'ListOptions',
    type: {
        name: 'Composite',
        className: 'JobScheduleListOptionalParams',
        modelProperties: {
            jobScheduleListOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'JobScheduleListOptions'
                }
            }
        }
    }
};
exports.JobScheduleListNextOptionalParams = {
    required: false,
    serializedName: 'ListNextOptions',
    type: {
        name: 'Composite',
        className: 'JobScheduleListNextOptionalParams',
        modelProperties: {
            jobScheduleListNextOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'JobScheduleListNextOptions'
                }
            }
        }
    }
};
exports.TaskAddOptionalParams = {
    required: false,
    serializedName: 'AddOptions',
    type: {
        name: 'Composite',
        className: 'TaskAddOptionalParams',
        modelProperties: {
            taskAddOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'TaskAddOptions'
                }
            }
        }
    }
};
exports.TaskListOptionalParams = {
    required: false,
    serializedName: 'ListOptions',
    type: {
        name: 'Composite',
        className: 'TaskListOptionalParams',
        modelProperties: {
            taskListOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'TaskListOptions'
                }
            }
        }
    }
};
exports.TaskAddCollectionOptionalParams = {
    required: false,
    serializedName: 'AddCollectionOptions',
    type: {
        name: 'Composite',
        className: 'TaskAddCollectionOptionalParams',
        modelProperties: {
            taskAddCollectionOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'TaskAddCollectionOptions'
                }
            }
        }
    }
};
exports.TaskDeleteMethodOptionalParams = {
    required: false,
    serializedName: 'DeleteMethodOptions',
    type: {
        name: 'Composite',
        className: 'TaskDeleteMethodOptionalParams',
        modelProperties: {
            taskDeleteMethodOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'TaskDeleteMethodOptions'
                }
            }
        }
    }
};
exports.TaskGetOptionalParams = {
    required: false,
    serializedName: 'GetOptions',
    type: {
        name: 'Composite',
        className: 'TaskGetOptionalParams',
        modelProperties: {
            taskGetOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'TaskGetOptions'
                }
            }
        }
    }
};
exports.TaskUpdateOptionalParams = {
    required: false,
    serializedName: 'UpdateOptions',
    type: {
        name: 'Composite',
        className: 'TaskUpdateOptionalParams',
        modelProperties: {
            constraints: {
                required: false,
                serializedName: 'constraints',
                type: {
                    name: 'Composite',
                    className: 'TaskConstraints'
                }
            },
            taskUpdateOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'TaskUpdateOptions'
                }
            }
        }
    }
};
exports.TaskListSubtasksOptionalParams = {
    required: false,
    serializedName: 'ListSubtasksOptions',
    type: {
        name: 'Composite',
        className: 'TaskListSubtasksOptionalParams',
        modelProperties: {
            taskListSubtasksOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'TaskListSubtasksOptions'
                }
            }
        }
    }
};
exports.TaskTerminateOptionalParams = {
    required: false,
    serializedName: 'TerminateOptions',
    type: {
        name: 'Composite',
        className: 'TaskTerminateOptionalParams',
        modelProperties: {
            taskTerminateOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'TaskTerminateOptions'
                }
            }
        }
    }
};
exports.TaskReactivateOptionalParams = {
    required: false,
    serializedName: 'ReactivateOptions',
    type: {
        name: 'Composite',
        className: 'TaskReactivateOptionalParams',
        modelProperties: {
            taskReactivateOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'TaskReactivateOptions'
                }
            }
        }
    }
};
exports.TaskListNextOptionalParams = {
    required: false,
    serializedName: 'ListNextOptions',
    type: {
        name: 'Composite',
        className: 'TaskListNextOptionalParams',
        modelProperties: {
            taskListNextOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'TaskListNextOptions'
                }
            }
        }
    }
};
exports.ComputeNodeAddUserOptionalParams = {
    required: false,
    serializedName: 'AddUserOptions',
    type: {
        name: 'Composite',
        className: 'ComputeNodeAddUserOptionalParams',
        modelProperties: {
            computeNodeAddUserOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'ComputeNodeAddUserOptions'
                }
            }
        }
    }
};
exports.ComputeNodeDeleteUserOptionalParams = {
    required: false,
    serializedName: 'DeleteUserOptions',
    type: {
        name: 'Composite',
        className: 'ComputeNodeDeleteUserOptionalParams',
        modelProperties: {
            computeNodeDeleteUserOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'ComputeNodeDeleteUserOptions'
                }
            }
        }
    }
};
exports.ComputeNodeUpdateUserOptionalParams = {
    required: false,
    serializedName: 'UpdateUserOptions',
    type: {
        name: 'Composite',
        className: 'ComputeNodeUpdateUserOptionalParams',
        modelProperties: {
            computeNodeUpdateUserOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'ComputeNodeUpdateUserOptions'
                }
            }
        }
    }
};
exports.ComputeNodeGetOptionalParams = {
    required: false,
    serializedName: 'GetOptions',
    type: {
        name: 'Composite',
        className: 'ComputeNodeGetOptionalParams',
        modelProperties: {
            computeNodeGetOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'ComputeNodeGetOptions'
                }
            }
        }
    }
};
exports.ComputeNodeRebootOptionalParams = {
    required: false,
    serializedName: 'RebootOptions',
    type: {
        name: 'Composite',
        className: 'ComputeNodeRebootOptionalParams',
        modelProperties: {
            nodeRebootOption: {
                required: false,
                serializedName: 'nodeRebootOption',
                type: {
                    name: 'Enum',
                    allowedValues: ['requeue', 'terminate', 'taskCompletion', 'retainedData']
                }
            },
            computeNodeRebootOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'ComputeNodeRebootOptions'
                }
            }
        }
    }
};
exports.ComputeNodeReimageOptionalParams = {
    required: false,
    serializedName: 'ReimageOptions',
    type: {
        name: 'Composite',
        className: 'ComputeNodeReimageOptionalParams',
        modelProperties: {
            nodeReimageOption: {
                required: false,
                serializedName: 'nodeReimageOption',
                type: {
                    name: 'Enum',
                    allowedValues: ['requeue', 'terminate', 'taskCompletion', 'retainedData']
                }
            },
            computeNodeReimageOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'ComputeNodeReimageOptions'
                }
            }
        }
    }
};
exports.ComputeNodeDisableSchedulingOptionalParams = {
    required: false,
    serializedName: 'DisableSchedulingOptions',
    type: {
        name: 'Composite',
        className: 'ComputeNodeDisableSchedulingOptionalParams',
        modelProperties: {
            nodeDisableSchedulingOption: {
                required: false,
                serializedName: 'nodeDisableSchedulingOption',
                type: {
                    name: 'Enum',
                    allowedValues: ['requeue', 'terminate', 'taskCompletion']
                }
            },
            computeNodeDisableSchedulingOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'ComputeNodeDisableSchedulingOptions'
                }
            }
        }
    }
};
exports.ComputeNodeEnableSchedulingOptionalParams = {
    required: false,
    serializedName: 'EnableSchedulingOptions',
    type: {
        name: 'Composite',
        className: 'ComputeNodeEnableSchedulingOptionalParams',
        modelProperties: {
            computeNodeEnableSchedulingOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'ComputeNodeEnableSchedulingOptions'
                }
            }
        }
    }
};
exports.ComputeNodeGetRemoteLoginSettingsOptionalParams = {
    required: false,
    serializedName: 'GetRemoteLoginSettingsOptions',
    type: {
        name: 'Composite',
        className: 'ComputeNodeGetRemoteLoginSettingsOptionalParams',
        modelProperties: {
            computeNodeGetRemoteLoginSettingsOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'ComputeNodeGetRemoteLoginSettingsOptions'
                }
            }
        }
    }
};
exports.ComputeNodeGetRemoteDesktopOptionalParams = {
    required: false,
    serializedName: 'GetRemoteDesktopOptions',
    type: {
        name: 'Composite',
        className: 'ComputeNodeGetRemoteDesktopOptionalParams',
        modelProperties: {
            computeNodeGetRemoteDesktopOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'ComputeNodeGetRemoteDesktopOptions'
                }
            }
        }
    }
};
exports.ComputeNodeListOptionalParams = {
    required: false,
    serializedName: 'ListOptions',
    type: {
        name: 'Composite',
        className: 'ComputeNodeListOptionalParams',
        modelProperties: {
            computeNodeListOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'ComputeNodeListOptions'
                }
            }
        }
    }
};
exports.ComputeNodeListNextOptionalParams = {
    required: false,
    serializedName: 'ListNextOptions',
    type: {
        name: 'Composite',
        className: 'ComputeNodeListNextOptionalParams',
        modelProperties: {
            computeNodeListNextOptions: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Composite',
                    className: 'ComputeNodeListNextOptions'
                }
            }
        }
    }
};
exports.ApplicationListResult = {
    required: false,
    serializedName: 'ApplicationListResult',
    type: {
        name: 'Composite',
        className: 'ApplicationListResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ApplicationSummaryElementType',
                        type: {
                            name: 'Composite',
                            className: 'ApplicationSummary'
                        }
                    }
                }
            },
            odatanextLink: {
                required: false,
                serializedName: 'odata\\.nextLink',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.PoolListUsageMetricsResult = {
    required: false,
    serializedName: 'PoolListUsageMetricsResult',
    type: {
        name: 'Composite',
        className: 'PoolListUsageMetricsResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'PoolUsageMetricsElementType',
                        type: {
                            name: 'Composite',
                            className: 'PoolUsageMetrics'
                        }
                    }
                }
            },
            odatanextLink: {
                required: false,
                serializedName: 'odata\\.nextLink',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.CloudPoolListResult = {
    required: false,
    serializedName: 'CloudPoolListResult',
    type: {
        name: 'Composite',
        className: 'CloudPoolListResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'CloudPoolElementType',
                        type: {
                            name: 'Composite',
                            className: 'CloudPool'
                        }
                    }
                }
            },
            odatanextLink: {
                required: false,
                serializedName: 'odata\\.nextLink',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.AccountListNodeAgentSkusResult = {
    required: false,
    serializedName: 'AccountListNodeAgentSkusResult',
    type: {
        name: 'Composite',
        className: 'AccountListNodeAgentSkusResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'NodeAgentSkuElementType',
                        type: {
                            name: 'Composite',
                            className: 'NodeAgentSku'
                        }
                    }
                }
            },
            odatanextLink: {
                required: false,
                serializedName: 'odata\\.nextLink',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.CloudJobListResult = {
    required: false,
    serializedName: 'CloudJobListResult',
    type: {
        name: 'Composite',
        className: 'CloudJobListResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'CloudJobElementType',
                        type: {
                            name: 'Composite',
                            className: 'CloudJob'
                        }
                    }
                }
            },
            odatanextLink: {
                required: false,
                serializedName: 'odata\\.nextLink',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.CloudJobListPreparationAndReleaseTaskStatusResult = {
    required: false,
    serializedName: 'CloudJobListPreparationAndReleaseTaskStatusResult',
    type: {
        name: 'Composite',
        className: 'CloudJobListPreparationAndReleaseTaskStatusResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'JobPreparationAndReleaseTaskExecutionInformationElementType',
                        type: {
                            name: 'Composite',
                            className: 'JobPreparationAndReleaseTaskExecutionInformation'
                        }
                    }
                }
            },
            odatanextLink: {
                required: false,
                serializedName: 'odata\\.nextLink',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.CertificateListResult = {
    required: false,
    serializedName: 'CertificateListResult',
    type: {
        name: 'Composite',
        className: 'CertificateListResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'CertificateElementType',
                        type: {
                            name: 'Composite',
                            className: 'Certificate'
                        }
                    }
                }
            },
            odatanextLink: {
                required: false,
                serializedName: 'odata\\.nextLink',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.NodeFileListResult = {
    required: false,
    serializedName: 'NodeFileListResult',
    type: {
        name: 'Composite',
        className: 'NodeFileListResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'NodeFileElementType',
                        type: {
                            name: 'Composite',
                            className: 'NodeFile'
                        }
                    }
                }
            },
            odatanextLink: {
                required: false,
                serializedName: 'odata\\.nextLink',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.CloudJobScheduleListResult = {
    required: false,
    serializedName: 'CloudJobScheduleListResult',
    type: {
        name: 'Composite',
        className: 'CloudJobScheduleListResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'CloudJobScheduleElementType',
                        type: {
                            name: 'Composite',
                            className: 'CloudJobSchedule'
                        }
                    }
                }
            },
            odatanextLink: {
                required: false,
                serializedName: 'odata\\.nextLink',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.CloudTaskListResult = {
    required: false,
    serializedName: 'CloudTaskListResult',
    type: {
        name: 'Composite',
        className: 'CloudTaskListResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'CloudTaskElementType',
                        type: {
                            name: 'Composite',
                            className: 'CloudTask'
                        }
                    }
                }
            },
            odatanextLink: {
                required: false,
                serializedName: 'odata\\.nextLink',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.ComputeNodeListResult = {
    required: false,
    serializedName: 'ComputeNodeListResult',
    type: {
        name: 'Composite',
        className: 'ComputeNodeListResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ComputeNodeElementType',
                        type: {
                            name: 'Composite',
                            className: 'ComputeNode'
                        }
                    }
                }
            },
            odatanextLink: {
                required: false,
                serializedName: 'odata\\.nextLink',
                type: {
                    name: 'String'
                }
            }
        }
    }
};


/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = msRest;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = msRestAzure;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Models = __webpack_require__(4);
exports.BatchServiceModels = Models;
const Mappers = __webpack_require__(0);
exports.BatchServiceMappers = Mappers;
const msRest = __webpack_require__(1);
const msRestAzure = __webpack_require__(2);
const operations = __webpack_require__(5);
const packageName = "azure-batch-js";
const packageVersion = "0.1.0";
class BatchServiceClient extends msRestAzure.AzureServiceClient {
    /**
     * @class
     * Initializes a new instance of the BatchServiceClient class.
     * @constructor
     *
     * @param {msRest.ServiceClientCredentials} credentials - Credentials needed for the client to connect to Azure.
     *
     * @param {string} [baseUri] - The base URI of the service.
     *
     * @param {object} [options] - The parameter options
     *
     * @param {Array} [options.filters] - Filters to be added to the request pipeline
     *
     * @param {object} [options.requestOptions] - The request options. Detailed info can be found at
     * {@link https://github.github.io/fetch/#Request Options doc}
     *
     * @param {boolean} [options.noRetryPolicy] - If set to true, turn off default retry policy
     *
     * @param {string} [options.acceptLanguage] - Gets or sets the preferred language for the response.
     *
     * @param {number} [options.longRunningOperationRetryTimeout] - Gets or sets the retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @param {boolean} [options.generateClientRequestId] - When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     */
    constructor(credentials, baseUri, options) {
        if (credentials === null || credentials === undefined) {
            throw new Error('\'credentials\' cannot be null.');
        }
        if (!options)
            options = {};
        super(credentials, options);
        this.apiVersion = '2017-09-01.6.0';
        this.acceptLanguage = 'en-US';
        this.longRunningOperationRetryTimeout = 30;
        this.generateClientRequestId = true;
        this.baseUri = baseUri;
        if (!this.baseUri) {
            this.baseUri = 'https://batch.core.windows.net';
        }
        this.credentials = credentials;
        this.addUserAgentInfo(`${packageName}/${packageVersion}`);
        if (options.acceptLanguage !== null && options.acceptLanguage !== undefined) {
            this.acceptLanguage = options.acceptLanguage;
        }
        if (options.longRunningOperationRetryTimeout !== null && options.longRunningOperationRetryTimeout !== undefined) {
            this.longRunningOperationRetryTimeout = options.longRunningOperationRetryTimeout;
        }
        if (options.generateClientRequestId !== null && options.generateClientRequestId !== undefined) {
            this.generateClientRequestId = options.generateClientRequestId;
        }
        this.application = new operations.Application(this);
        this.pool = new operations.Pool(this);
        this.account = new operations.Account(this);
        this.job = new operations.Job(this);
        this.certificate = new operations.CertificateOperations(this);
        this.file = new operations.File(this);
        this.jobSchedule = new operations.JobSchedule(this);
        this.task = new operations.Task(this);
        this.computeNode = new operations.ComputeNodeOperations(this);
        this.serializer = new msRest.Serializer(Mappers);
    }
}
exports.BatchServiceClient = BatchServiceClient;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Defines values for OSType.
 * Possible values include: 'linux', 'windows'
 * @readonly
 * @enum {string}
 */
var OSType;
(function (OSType) {
    OSType["Linux"] = "linux";
    OSType["Windows"] = "windows";
})(OSType = exports.OSType || (exports.OSType = {}));
/**
 * Defines values for AccessScope.
 * Possible values include: 'job'
 * @readonly
 * @enum {string}
 */
var AccessScope;
(function (AccessScope) {
    AccessScope["Job"] = "job";
})(AccessScope = exports.AccessScope || (exports.AccessScope = {}));
/**
 * Defines values for CertificateState.
 * Possible values include: 'active', 'deleting', 'deleteFailed'
 * @readonly
 * @enum {string}
 */
var CertificateState;
(function (CertificateState) {
    CertificateState["Active"] = "active";
    CertificateState["Deleting"] = "deleting";
    CertificateState["DeleteFailed"] = "deleteFailed";
})(CertificateState = exports.CertificateState || (exports.CertificateState = {}));
/**
 * Defines values for CertificateFormat.
 * Possible values include: 'pfx', 'cer'
 * @readonly
 * @enum {string}
 */
var CertificateFormat;
(function (CertificateFormat) {
    CertificateFormat["Pfx"] = "pfx";
    CertificateFormat["Cer"] = "cer";
})(CertificateFormat = exports.CertificateFormat || (exports.CertificateFormat = {}));
/**
 * Defines values for JobAction.
 * Possible values include: 'none', 'disable', 'terminate'
 * @readonly
 * @enum {string}
 */
var JobAction;
(function (JobAction) {
    JobAction["None"] = "none";
    JobAction["Disable"] = "disable";
    JobAction["Terminate"] = "terminate";
})(JobAction = exports.JobAction || (exports.JobAction = {}));
/**
 * Defines values for DependencyAction.
 * Possible values include: 'satisfy', 'block'
 * @readonly
 * @enum {string}
 */
var DependencyAction;
(function (DependencyAction) {
    DependencyAction["Satisfy"] = "satisfy";
    DependencyAction["Block"] = "block";
})(DependencyAction = exports.DependencyAction || (exports.DependencyAction = {}));
/**
 * Defines values for AutoUserScope.
 * Possible values include: 'task', 'pool'
 * @readonly
 * @enum {string}
 */
var AutoUserScope;
(function (AutoUserScope) {
    AutoUserScope["Task"] = "task";
    AutoUserScope["Pool"] = "pool";
})(AutoUserScope = exports.AutoUserScope || (exports.AutoUserScope = {}));
/**
 * Defines values for ElevationLevel.
 * Possible values include: 'nonAdmin', 'admin'
 * @readonly
 * @enum {string}
 */
var ElevationLevel;
(function (ElevationLevel) {
    ElevationLevel["NonAdmin"] = "nonAdmin";
    ElevationLevel["Admin"] = "admin";
})(ElevationLevel = exports.ElevationLevel || (exports.ElevationLevel = {}));
/**
 * Defines values for OutputFileUploadCondition.
 * Possible values include: 'taskSuccess', 'taskFailure', 'taskCompletion'
 * @readonly
 * @enum {string}
 */
var OutputFileUploadCondition;
(function (OutputFileUploadCondition) {
    OutputFileUploadCondition["TaskSuccess"] = "taskSuccess";
    OutputFileUploadCondition["TaskFailure"] = "taskFailure";
    OutputFileUploadCondition["TaskCompletion"] = "taskCompletion";
})(OutputFileUploadCondition = exports.OutputFileUploadCondition || (exports.OutputFileUploadCondition = {}));
/**
 * Defines values for ComputeNodeFillType.
 * Possible values include: 'spread', 'pack'
 * @readonly
 * @enum {string}
 */
var ComputeNodeFillType;
(function (ComputeNodeFillType) {
    ComputeNodeFillType["Spread"] = "spread";
    ComputeNodeFillType["Pack"] = "pack";
})(ComputeNodeFillType = exports.ComputeNodeFillType || (exports.ComputeNodeFillType = {}));
/**
 * Defines values for CertificateStoreLocation.
 * Possible values include: 'currentUser', 'localMachine'
 * @readonly
 * @enum {string}
 */
var CertificateStoreLocation;
(function (CertificateStoreLocation) {
    CertificateStoreLocation["CurrentUser"] = "currentUser";
    CertificateStoreLocation["LocalMachine"] = "localMachine";
})(CertificateStoreLocation = exports.CertificateStoreLocation || (exports.CertificateStoreLocation = {}));
/**
 * Defines values for CertificateVisibility.
 * Possible values include: 'startTask', 'task', 'remoteUser'
 * @readonly
 * @enum {string}
 */
var CertificateVisibility;
(function (CertificateVisibility) {
    CertificateVisibility["StartTask"] = "startTask";
    CertificateVisibility["Task"] = "task";
    CertificateVisibility["RemoteUser"] = "remoteUser";
})(CertificateVisibility = exports.CertificateVisibility || (exports.CertificateVisibility = {}));
/**
 * Defines values for CachingType.
 * Possible values include: 'none', 'readOnly', 'readWrite'
 * @readonly
 * @enum {string}
 */
var CachingType;
(function (CachingType) {
    CachingType["None"] = "none";
    CachingType["ReadOnly"] = "readOnly";
    CachingType["ReadWrite"] = "readWrite";
})(CachingType = exports.CachingType || (exports.CachingType = {}));
/**
 * Defines values for StorageAccountType.
 * Possible values include: 'Standard_LRS', 'Premium_LRS'
 * @readonly
 * @enum {string}
 */
var StorageAccountType;
(function (StorageAccountType) {
    StorageAccountType["StandardLRS"] = "Standard_LRS";
    StorageAccountType["PremiumLRS"] = "Premium_LRS";
})(StorageAccountType = exports.StorageAccountType || (exports.StorageAccountType = {}));
/**
 * Defines values for InboundEndpointProtocol.
 * Possible values include: 'tcp', 'udp'
 * @readonly
 * @enum {string}
 */
var InboundEndpointProtocol;
(function (InboundEndpointProtocol) {
    InboundEndpointProtocol["Tcp"] = "tcp";
    InboundEndpointProtocol["Udp"] = "udp";
})(InboundEndpointProtocol = exports.InboundEndpointProtocol || (exports.InboundEndpointProtocol = {}));
/**
 * Defines values for NetworkSecurityGroupRuleAccess.
 * Possible values include: 'allow', 'deny'
 * @readonly
 * @enum {string}
 */
var NetworkSecurityGroupRuleAccess;
(function (NetworkSecurityGroupRuleAccess) {
    NetworkSecurityGroupRuleAccess["Allow"] = "allow";
    NetworkSecurityGroupRuleAccess["Deny"] = "deny";
})(NetworkSecurityGroupRuleAccess = exports.NetworkSecurityGroupRuleAccess || (exports.NetworkSecurityGroupRuleAccess = {}));
/**
 * Defines values for PoolLifetimeOption.
 * Possible values include: 'jobSchedule', 'job'
 * @readonly
 * @enum {string}
 */
var PoolLifetimeOption;
(function (PoolLifetimeOption) {
    PoolLifetimeOption["JobSchedule"] = "jobSchedule";
    PoolLifetimeOption["Job"] = "job";
})(PoolLifetimeOption = exports.PoolLifetimeOption || (exports.PoolLifetimeOption = {}));
/**
 * Defines values for OnAllTasksComplete.
 * Possible values include: 'noAction', 'terminateJob'
 * @readonly
 * @enum {string}
 */
var OnAllTasksComplete;
(function (OnAllTasksComplete) {
    OnAllTasksComplete["NoAction"] = "noAction";
    OnAllTasksComplete["TerminateJob"] = "terminateJob";
})(OnAllTasksComplete = exports.OnAllTasksComplete || (exports.OnAllTasksComplete = {}));
/**
 * Defines values for OnTaskFailure.
 * Possible values include: 'noAction', 'performExitOptionsJobAction'
 * @readonly
 * @enum {string}
 */
var OnTaskFailure;
(function (OnTaskFailure) {
    OnTaskFailure["NoAction"] = "noAction";
    OnTaskFailure["PerformExitOptionsJobAction"] = "performExitOptionsJobAction";
})(OnTaskFailure = exports.OnTaskFailure || (exports.OnTaskFailure = {}));
/**
 * Defines values for JobScheduleState.
 * Possible values include: 'active', 'completed', 'disabled', 'terminating',
 * 'deleting'
 * @readonly
 * @enum {string}
 */
var JobScheduleState;
(function (JobScheduleState) {
    JobScheduleState["Active"] = "active";
    JobScheduleState["Completed"] = "completed";
    JobScheduleState["Disabled"] = "disabled";
    JobScheduleState["Terminating"] = "terminating";
    JobScheduleState["Deleting"] = "deleting";
})(JobScheduleState = exports.JobScheduleState || (exports.JobScheduleState = {}));
/**
 * Defines values for ErrorCategory.
 * Possible values include: 'userError', 'serverError'
 * @readonly
 * @enum {string}
 */
var ErrorCategory;
(function (ErrorCategory) {
    ErrorCategory["UserError"] = "userError";
    ErrorCategory["ServerError"] = "serverError";
})(ErrorCategory = exports.ErrorCategory || (exports.ErrorCategory = {}));
/**
 * Defines values for JobState.
 * Possible values include: 'active', 'disabling', 'disabled', 'enabling',
 * 'terminating', 'completed', 'deleting'
 * @readonly
 * @enum {string}
 */
var JobState;
(function (JobState) {
    JobState["Active"] = "active";
    JobState["Disabling"] = "disabling";
    JobState["Disabled"] = "disabled";
    JobState["Enabling"] = "enabling";
    JobState["Terminating"] = "terminating";
    JobState["Completed"] = "completed";
    JobState["Deleting"] = "deleting";
})(JobState = exports.JobState || (exports.JobState = {}));
/**
 * Defines values for JobPreparationTaskState.
 * Possible values include: 'running', 'completed'
 * @readonly
 * @enum {string}
 */
var JobPreparationTaskState;
(function (JobPreparationTaskState) {
    JobPreparationTaskState["Running"] = "running";
    JobPreparationTaskState["Completed"] = "completed";
})(JobPreparationTaskState = exports.JobPreparationTaskState || (exports.JobPreparationTaskState = {}));
/**
 * Defines values for TaskExecutionResult.
 * Possible values include: 'success', 'failure'
 * @readonly
 * @enum {string}
 */
var TaskExecutionResult;
(function (TaskExecutionResult) {
    TaskExecutionResult["Success"] = "success";
    TaskExecutionResult["Failure"] = "failure";
})(TaskExecutionResult = exports.TaskExecutionResult || (exports.TaskExecutionResult = {}));
/**
 * Defines values for JobReleaseTaskState.
 * Possible values include: 'running', 'completed'
 * @readonly
 * @enum {string}
 */
var JobReleaseTaskState;
(function (JobReleaseTaskState) {
    JobReleaseTaskState["Running"] = "running";
    JobReleaseTaskState["Completed"] = "completed";
})(JobReleaseTaskState = exports.JobReleaseTaskState || (exports.JobReleaseTaskState = {}));
/**
 * Defines values for TaskCountValidationStatus.
 * Possible values include: 'validated', 'unvalidated'
 * @readonly
 * @enum {string}
 */
var TaskCountValidationStatus;
(function (TaskCountValidationStatus) {
    TaskCountValidationStatus["Validated"] = "validated";
    TaskCountValidationStatus["Unvalidated"] = "unvalidated";
})(TaskCountValidationStatus = exports.TaskCountValidationStatus || (exports.TaskCountValidationStatus = {}));
/**
 * Defines values for PoolState.
 * Possible values include: 'active', 'deleting', 'upgrading'
 * @readonly
 * @enum {string}
 */
var PoolState;
(function (PoolState) {
    PoolState["Active"] = "active";
    PoolState["Deleting"] = "deleting";
    PoolState["Upgrading"] = "upgrading";
})(PoolState = exports.PoolState || (exports.PoolState = {}));
/**
 * Defines values for AllocationState.
 * Possible values include: 'steady', 'resizing', 'stopping'
 * @readonly
 * @enum {string}
 */
var AllocationState;
(function (AllocationState) {
    AllocationState["Steady"] = "steady";
    AllocationState["Resizing"] = "resizing";
    AllocationState["Stopping"] = "stopping";
})(AllocationState = exports.AllocationState || (exports.AllocationState = {}));
/**
 * Defines values for TaskState.
 * Possible values include: 'active', 'preparing', 'running', 'completed'
 * @readonly
 * @enum {string}
 */
var TaskState;
(function (TaskState) {
    TaskState["Active"] = "active";
    TaskState["Preparing"] = "preparing";
    TaskState["Running"] = "running";
    TaskState["Completed"] = "completed";
})(TaskState = exports.TaskState || (exports.TaskState = {}));
/**
 * Defines values for TaskAddStatus.
 * Possible values include: 'success', 'clientError', 'serverError'
 * @readonly
 * @enum {string}
 */
var TaskAddStatus;
(function (TaskAddStatus) {
    TaskAddStatus["Success"] = "success";
    TaskAddStatus["ClientError"] = "clientError";
    TaskAddStatus["ServerError"] = "serverError";
})(TaskAddStatus = exports.TaskAddStatus || (exports.TaskAddStatus = {}));
/**
 * Defines values for SubtaskState.
 * Possible values include: 'preparing', 'running', 'completed'
 * @readonly
 * @enum {string}
 */
var SubtaskState;
(function (SubtaskState) {
    SubtaskState["Preparing"] = "preparing";
    SubtaskState["Running"] = "running";
    SubtaskState["Completed"] = "completed";
})(SubtaskState = exports.SubtaskState || (exports.SubtaskState = {}));
/**
 * Defines values for StartTaskState.
 * Possible values include: 'running', 'completed'
 * @readonly
 * @enum {string}
 */
var StartTaskState;
(function (StartTaskState) {
    StartTaskState["Running"] = "running";
    StartTaskState["Completed"] = "completed";
})(StartTaskState = exports.StartTaskState || (exports.StartTaskState = {}));
/**
 * Defines values for ComputeNodeState.
 * Possible values include: 'idle', 'rebooting', 'reimaging', 'running',
 * 'unusable', 'creating', 'starting', 'waitingForStartTask',
 * 'startTaskFailed', 'unknown', 'leavingPool', 'offline', 'preempted'
 * @readonly
 * @enum {string}
 */
var ComputeNodeState;
(function (ComputeNodeState) {
    ComputeNodeState["Idle"] = "idle";
    ComputeNodeState["Rebooting"] = "rebooting";
    ComputeNodeState["Reimaging"] = "reimaging";
    ComputeNodeState["Running"] = "running";
    ComputeNodeState["Unusable"] = "unusable";
    ComputeNodeState["Creating"] = "creating";
    ComputeNodeState["Starting"] = "starting";
    ComputeNodeState["WaitingForStartTask"] = "waitingForStartTask";
    ComputeNodeState["StartTaskFailed"] = "startTaskFailed";
    ComputeNodeState["Unknown"] = "unknown";
    ComputeNodeState["LeavingPool"] = "leavingPool";
    ComputeNodeState["Offline"] = "offline";
    ComputeNodeState["Preempted"] = "preempted";
})(ComputeNodeState = exports.ComputeNodeState || (exports.ComputeNodeState = {}));
/**
 * Defines values for SchedulingState.
 * Possible values include: 'enabled', 'disabled'
 * @readonly
 * @enum {string}
 */
var SchedulingState;
(function (SchedulingState) {
    SchedulingState["Enabled"] = "enabled";
    SchedulingState["Disabled"] = "disabled";
})(SchedulingState = exports.SchedulingState || (exports.SchedulingState = {}));
/**
 * Defines values for DisableJobOption.
 * Possible values include: 'requeue', 'terminate', 'wait'
 * @readonly
 * @enum {string}
 */
var DisableJobOption;
(function (DisableJobOption) {
    DisableJobOption["Requeue"] = "requeue";
    DisableJobOption["Terminate"] = "terminate";
    DisableJobOption["Wait"] = "wait";
})(DisableJobOption = exports.DisableJobOption || (exports.DisableJobOption = {}));
/**
 * Defines values for ComputeNodeDeallocationOption.
 * Possible values include: 'requeue', 'terminate', 'taskCompletion',
 * 'retainedData'
 * @readonly
 * @enum {string}
 */
var ComputeNodeDeallocationOption;
(function (ComputeNodeDeallocationOption) {
    ComputeNodeDeallocationOption["Requeue"] = "requeue";
    ComputeNodeDeallocationOption["Terminate"] = "terminate";
    ComputeNodeDeallocationOption["TaskCompletion"] = "taskCompletion";
    ComputeNodeDeallocationOption["RetainedData"] = "retainedData";
})(ComputeNodeDeallocationOption = exports.ComputeNodeDeallocationOption || (exports.ComputeNodeDeallocationOption = {}));
/**
 * Defines values for ComputeNodeRebootOption.
 * Possible values include: 'requeue', 'terminate', 'taskCompletion',
 * 'retainedData'
 * @readonly
 * @enum {string}
 */
var ComputeNodeRebootOption;
(function (ComputeNodeRebootOption) {
    ComputeNodeRebootOption["Requeue"] = "requeue";
    ComputeNodeRebootOption["Terminate"] = "terminate";
    ComputeNodeRebootOption["TaskCompletion"] = "taskCompletion";
    ComputeNodeRebootOption["RetainedData"] = "retainedData";
})(ComputeNodeRebootOption = exports.ComputeNodeRebootOption || (exports.ComputeNodeRebootOption = {}));
/**
 * Defines values for ComputeNodeReimageOption.
 * Possible values include: 'requeue', 'terminate', 'taskCompletion',
 * 'retainedData'
 * @readonly
 * @enum {string}
 */
var ComputeNodeReimageOption;
(function (ComputeNodeReimageOption) {
    ComputeNodeReimageOption["Requeue"] = "requeue";
    ComputeNodeReimageOption["Terminate"] = "terminate";
    ComputeNodeReimageOption["TaskCompletion"] = "taskCompletion";
    ComputeNodeReimageOption["RetainedData"] = "retainedData";
})(ComputeNodeReimageOption = exports.ComputeNodeReimageOption || (exports.ComputeNodeReimageOption = {}));
/**
 * Defines values for DisableComputeNodeSchedulingOption.
 * Possible values include: 'requeue', 'terminate', 'taskCompletion'
 * @readonly
 * @enum {string}
 */
var DisableComputeNodeSchedulingOption;
(function (DisableComputeNodeSchedulingOption) {
    DisableComputeNodeSchedulingOption["Requeue"] = "requeue";
    DisableComputeNodeSchedulingOption["Terminate"] = "terminate";
    DisableComputeNodeSchedulingOption["TaskCompletion"] = "taskCompletion";
})(DisableComputeNodeSchedulingOption = exports.DisableComputeNodeSchedulingOption || (exports.DisableComputeNodeSchedulingOption = {}));


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const application_1 = __webpack_require__(6);
exports.Application = application_1.Application;
const pool_1 = __webpack_require__(7);
exports.Pool = pool_1.Pool;
const account_1 = __webpack_require__(8);
exports.Account = account_1.Account;
const job_1 = __webpack_require__(9);
exports.Job = job_1.Job;
const certificateOperations_1 = __webpack_require__(10);
exports.CertificateOperations = certificateOperations_1.CertificateOperations;
const file_1 = __webpack_require__(11);
exports.File = file_1.File;
const jobSchedule_1 = __webpack_require__(12);
exports.JobSchedule = jobSchedule_1.JobSchedule;
const task_1 = __webpack_require__(13);
exports.Task = task_1.Task;
const computeNodeOperations_1 = __webpack_require__(14);
exports.ComputeNodeOperations = computeNodeOperations_1.ComputeNodeOperations;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const msRest = __webpack_require__(1);
const Mappers = __webpack_require__(0);
const WebResource = msRest.WebResource;
/** Class representing a Application. */
class Application {
    /**
     * Create a Application.
     * @param {BatchServiceClient} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Lists all of the applications available in the specified account.
     *
     * This operation returns only applications and versions that are available for
     * use on compute nodes; that is, that can be used in an application package
     * reference. For administrator information about applications and versions
     * that are not yet available to compute nodes, use the Azure portal or the
     * Azure Resource Manager API.
     *
     * @param {ApplicationListOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let applicationListOptions = (options && options.applicationListOptions !== undefined) ? options.applicationListOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (applicationListOptions !== null && applicationListOptions !== undefined) {
                    maxResults = applicationListOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (applicationListOptions !== null && applicationListOptions !== undefined) {
                    timeout = applicationListOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (applicationListOptions !== null && applicationListOptions !== undefined) {
                    clientRequestId = applicationListOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (applicationListOptions !== null && applicationListOptions !== undefined) {
                    returnClientRequestId = applicationListOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (applicationListOptions !== null && applicationListOptions !== undefined) {
                    ocpDate = applicationListOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'applications';
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (maxResults !== null && maxResults !== undefined) {
                queryParamsArray.push('maxresults=' + encodeURIComponent(maxResults.toString()));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.ApplicationListResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets information about the specified application.
     *
     * This operation returns only applications and versions that are available for
     * use on compute nodes; that is, that can be used in an application package
     * reference. For administrator information about applications and versions
     * that are not yet available to compute nodes, use the Azure portal or the
     * Azure Resource Manager API.
     *
     * @param {string} applicationId The ID of the application.
     *
     * @param {ApplicationGetOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(applicationId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let applicationGetOptions = (options && options.applicationGetOptions !== undefined) ? options.applicationGetOptions : undefined;
            // Validate
            try {
                if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
                    throw new Error('applicationId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (applicationGetOptions !== null && applicationGetOptions !== undefined) {
                    timeout = applicationGetOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (applicationGetOptions !== null && applicationGetOptions !== undefined) {
                    clientRequestId = applicationGetOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (applicationGetOptions !== null && applicationGetOptions !== undefined) {
                    returnClientRequestId = applicationGetOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (applicationGetOptions !== null && applicationGetOptions !== undefined) {
                    ocpDate = applicationGetOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'applications/{applicationId}';
            requestUrl = requestUrl.replace('{applicationId}', encodeURIComponent(applicationId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.ApplicationSummary;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the applications available in the specified account.
     *
     * This operation returns only applications and versions that are available for
     * use on compute nodes; that is, that can be used in an application package
     * reference. For administrator information about applications and versions
     * that are not yet available to compute nodes, use the Azure portal or the
     * Azure Resource Manager API.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {ApplicationListNextOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let applicationListNextOptions = (options && options.applicationListNextOptions !== undefined) ? options.applicationListNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (applicationListNextOptions !== null && applicationListNextOptions !== undefined) {
                    clientRequestId = applicationListNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (applicationListNextOptions !== null && applicationListNextOptions !== undefined) {
                    returnClientRequestId = applicationListNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (applicationListNextOptions !== null && applicationListNextOptions !== undefined) {
                    ocpDate = applicationListNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.ApplicationListResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    list(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    get(applicationId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(applicationId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getWithHttpOperationResponse(applicationId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
}
exports.Application = Application;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const msRest = __webpack_require__(1);
const Mappers = __webpack_require__(0);
const WebResource = msRest.WebResource;
/** Class representing a Pool. */
class Pool {
    /**
     * Create a Pool.
     * @param {BatchServiceClient} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Lists the usage metrics, aggregated by pool across individual time
     * intervals, for the specified account.
     *
     * If you do not specify a $filter clause including a poolId, the response
     * includes all pools that existed in the account in the time range of the
     * returned aggregation intervals. If you do not specify a $filter clause
     * including a startTime or endTime these filters default to the start and end
     * times of the last aggregation interval currently available; that is, only
     * the last aggregation interval is returned.
     *
     * @param {PoolListUsageMetricsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listUsageMetricsWithHttpOperationResponse(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolListUsageMetricsOptions = (options && options.poolListUsageMetricsOptions !== undefined) ? options.poolListUsageMetricsOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let startTime;
            let endTime;
            let filter;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    startTime = poolListUsageMetricsOptions.startTime;
                    if (startTime && !(startTime instanceof Date ||
                        (typeof startTime.valueOf() === 'string' && !isNaN(Date.parse(startTime))))) {
                        throw new Error('startTime must be of type date.');
                    }
                }
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    endTime = poolListUsageMetricsOptions.endTime;
                    if (endTime && !(endTime instanceof Date ||
                        (typeof endTime.valueOf() === 'string' && !isNaN(Date.parse(endTime))))) {
                        throw new Error('endTime must be of type date.');
                    }
                }
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    filter = poolListUsageMetricsOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    maxResults = poolListUsageMetricsOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    timeout = poolListUsageMetricsOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    clientRequestId = poolListUsageMetricsOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    returnClientRequestId = poolListUsageMetricsOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    ocpDate = poolListUsageMetricsOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'poolusagemetrics';
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (startTime !== null && startTime !== undefined) {
                queryParamsArray.push('starttime=' + encodeURIComponent(msRest.serializeObject(startTime)));
            }
            if (endTime !== null && endTime !== undefined) {
                queryParamsArray.push('endtime=' + encodeURIComponent(msRest.serializeObject(endTime)));
            }
            if (filter !== null && filter !== undefined) {
                queryParamsArray.push('$filter=' + encodeURIComponent(filter));
            }
            if (maxResults !== null && maxResults !== undefined) {
                queryParamsArray.push('maxresults=' + encodeURIComponent(maxResults.toString()));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.PoolListUsageMetricsResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets lifetime summary statistics for all of the pools in the
     * specified account.
     *
     * Statistics are aggregated across all pools that have ever existed in the
     * account, from account creation to the last update time of the statistics.
     *
     * @param {PoolGetAllLifetimeStatisticsOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getAllLifetimeStatisticsWithHttpOperationResponse(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolGetAllLifetimeStatisticsOptions = (options && options.poolGetAllLifetimeStatisticsOptions !== undefined) ? options.poolGetAllLifetimeStatisticsOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolGetAllLifetimeStatisticsOptions !== null && poolGetAllLifetimeStatisticsOptions !== undefined) {
                    timeout = poolGetAllLifetimeStatisticsOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolGetAllLifetimeStatisticsOptions !== null && poolGetAllLifetimeStatisticsOptions !== undefined) {
                    clientRequestId = poolGetAllLifetimeStatisticsOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolGetAllLifetimeStatisticsOptions !== null && poolGetAllLifetimeStatisticsOptions !== undefined) {
                    returnClientRequestId = poolGetAllLifetimeStatisticsOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolGetAllLifetimeStatisticsOptions !== null && poolGetAllLifetimeStatisticsOptions !== undefined) {
                    ocpDate = poolGetAllLifetimeStatisticsOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'lifetimepoolstats';
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.PoolStatistics;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Adds a pool to the specified account.
     *
     * When naming pools, avoid including sensitive information such as user names
     * or secret project names. This information may appear in telemetry logs
     * accessible to Microsoft Support engineers.
     *
     * @param {PoolAddParameter} pool The pool to be added.
     *
     * @param {PoolAddOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addWithHttpOperationResponse(pool, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolAddOptions = (options && options.poolAddOptions !== undefined) ? options.poolAddOptions : undefined;
            if (pool === null || pool === undefined) {
                pool = {};
            }
            // Validate
            try {
                if (pool === null || pool === undefined) {
                    throw new Error('pool cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolAddOptions !== null && poolAddOptions !== undefined) {
                    timeout = poolAddOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolAddOptions !== null && poolAddOptions !== undefined) {
                    clientRequestId = poolAddOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolAddOptions !== null && poolAddOptions !== undefined) {
                    returnClientRequestId = poolAddOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolAddOptions !== null && poolAddOptions !== undefined) {
                    ocpDate = poolAddOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools';
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (pool !== null && pool !== undefined) {
                    let requestModelMapper = Mappers.PoolAddParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, pool, 'pool');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(pool, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 201) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the pools in the specified account.
     *
     * @param {PoolListOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolListOptions = (options && options.poolListOptions !== undefined) ? options.poolListOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let select;
            let expand;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    filter = poolListOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    select = poolListOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    expand = poolListOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    maxResults = poolListOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    timeout = poolListOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    clientRequestId = poolListOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    returnClientRequestId = poolListOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    ocpDate = poolListOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools';
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (filter !== null && filter !== undefined) {
                queryParamsArray.push('$filter=' + encodeURIComponent(filter));
            }
            if (select !== null && select !== undefined) {
                queryParamsArray.push('$select=' + encodeURIComponent(select));
            }
            if (expand !== null && expand !== undefined) {
                queryParamsArray.push('$expand=' + encodeURIComponent(expand));
            }
            if (maxResults !== null && maxResults !== undefined) {
                queryParamsArray.push('maxresults=' + encodeURIComponent(maxResults.toString()));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.CloudPoolListResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Deletes a pool from the specified account.
     *
     * When you request that a pool be deleted, the following actions occur: the
     * pool state is set to deleting; any ongoing resize operation on the pool are
     * stopped; the Batch service starts resizing the pool to zero nodes; any tasks
     * running on existing nodes are terminated and requeued (as if a resize pool
     * operation had been requested with the default requeue option); finally, the
     * pool is removed from the system. Because running tasks are requeued, the
     * user can rerun these tasks by updating their job to target a different pool.
     * The tasks can then run on the new pool. If you want to override the requeue
     * behavior, then you should call resize pool explicitly to shrink the pool to
     * zero size before deleting the pool. If you call an Update, Patch or Delete
     * API on a pool in the deleting state, it will fail with HTTP status code 409
     * with error code PoolBeingDeleted.
     *
     * @param {string} poolId The ID of the pool to delete.
     *
     * @param {PoolDeleteMethodOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(poolId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolDeleteMethodOptions = (options && options.poolDeleteMethodOptions !== undefined) ? options.poolDeleteMethodOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    timeout = poolDeleteMethodOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    clientRequestId = poolDeleteMethodOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    returnClientRequestId = poolDeleteMethodOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    ocpDate = poolDeleteMethodOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    ifMatch = poolDeleteMethodOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    ifNoneMatch = poolDeleteMethodOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    ifModifiedSince = poolDeleteMethodOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    ifUnmodifiedSince = poolDeleteMethodOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'DELETE';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets basic properties of a pool.
     *
     * @param {string} poolId The ID of the pool to get.
     *
     * @param {PoolExistsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    existsWithHttpOperationResponse(poolId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolExistsOptions = (options && options.poolExistsOptions !== undefined) ? options.poolExistsOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    timeout = poolExistsOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    clientRequestId = poolExistsOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    returnClientRequestId = poolExistsOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    ocpDate = poolExistsOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    ifMatch = poolExistsOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    ifNoneMatch = poolExistsOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    ifModifiedSince = poolExistsOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    ifUnmodifiedSince = poolExistsOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'HEAD';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200 && statusCode !== 404) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                operationRes.bodyAsJson = (statusCode === 200);
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets information about the specified pool.
     *
     * @param {string} poolId The ID of the pool to get.
     *
     * @param {PoolGetOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(poolId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolGetOptions = (options && options.poolGetOptions !== undefined) ? options.poolGetOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let select;
            let expand;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    select = poolGetOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    expand = poolGetOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    timeout = poolGetOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    clientRequestId = poolGetOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    returnClientRequestId = poolGetOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    ocpDate = poolGetOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    ifMatch = poolGetOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    ifNoneMatch = poolGetOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    ifModifiedSince = poolGetOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    ifUnmodifiedSince = poolGetOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (select !== null && select !== undefined) {
                queryParamsArray.push('$select=' + encodeURIComponent(select));
            }
            if (expand !== null && expand !== undefined) {
                queryParamsArray.push('$expand=' + encodeURIComponent(expand));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.CloudPool;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Updates the properties of the specified pool.
     *
     * This only replaces the pool properties specified in the request. For
     * example, if the pool has a start task associated with it, and a request does
     * not specify a start task element, then the pool keeps the existing start
     * task.
     *
     * @param {string} poolId The ID of the pool to update.
     *
     * @param {PoolPatchParameter} poolPatchParameter The parameters for the
     * request.
     *
     * @param {PoolPatchOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    patchWithHttpOperationResponse(poolId, poolPatchParameter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolPatchOptions = (options && options.poolPatchOptions !== undefined) ? options.poolPatchOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (poolPatchParameter === null || poolPatchParameter === undefined) {
                    throw new Error('poolPatchParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    timeout = poolPatchOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    clientRequestId = poolPatchOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    returnClientRequestId = poolPatchOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    ocpDate = poolPatchOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    ifMatch = poolPatchOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    ifNoneMatch = poolPatchOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    ifModifiedSince = poolPatchOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    ifUnmodifiedSince = poolPatchOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'PATCH';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (poolPatchParameter !== null && poolPatchParameter !== undefined) {
                    let requestModelMapper = Mappers.PoolPatchParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, poolPatchParameter, 'poolPatchParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(poolPatchParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Disables automatic scaling for a pool.
     *
     * @param {string} poolId The ID of the pool on which to disable automatic
     * scaling.
     *
     * @param {PoolDisableAutoScaleOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    disableAutoScaleWithHttpOperationResponse(poolId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolDisableAutoScaleOptions = (options && options.poolDisableAutoScaleOptions !== undefined) ? options.poolDisableAutoScaleOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolDisableAutoScaleOptions !== null && poolDisableAutoScaleOptions !== undefined) {
                    timeout = poolDisableAutoScaleOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolDisableAutoScaleOptions !== null && poolDisableAutoScaleOptions !== undefined) {
                    clientRequestId = poolDisableAutoScaleOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolDisableAutoScaleOptions !== null && poolDisableAutoScaleOptions !== undefined) {
                    returnClientRequestId = poolDisableAutoScaleOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolDisableAutoScaleOptions !== null && poolDisableAutoScaleOptions !== undefined) {
                    ocpDate = poolDisableAutoScaleOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/disableautoscale';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Enables automatic scaling for a pool.
     *
     * You cannot enable automatic scaling on a pool if a resize operation is in
     * progress on the pool. If automatic scaling of the pool is currently
     * disabled, you must specify a valid autoscale formula as part of the request.
     * If automatic scaling of the pool is already enabled, you may specify a new
     * autoscale formula and/or a new evaluation interval. You cannot call this API
     * for the same pool more than once every 30 seconds.
     *
     * @param {string} poolId The ID of the pool on which to enable automatic
     * scaling.
     *
     * @param {PoolEnableAutoScaleParameter} poolEnableAutoScaleParameter The
     * parameters for the request.
     *
     * @param {PoolEnableAutoScaleOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    enableAutoScaleWithHttpOperationResponse(poolId, poolEnableAutoScaleParameter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolEnableAutoScaleOptions = (options && options.poolEnableAutoScaleOptions !== undefined) ? options.poolEnableAutoScaleOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (poolEnableAutoScaleParameter === null || poolEnableAutoScaleParameter === undefined) {
                    throw new Error('poolEnableAutoScaleParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    timeout = poolEnableAutoScaleOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    clientRequestId = poolEnableAutoScaleOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    returnClientRequestId = poolEnableAutoScaleOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    ocpDate = poolEnableAutoScaleOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    ifMatch = poolEnableAutoScaleOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    ifNoneMatch = poolEnableAutoScaleOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    ifModifiedSince = poolEnableAutoScaleOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    ifUnmodifiedSince = poolEnableAutoScaleOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/enableautoscale';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (poolEnableAutoScaleParameter !== null && poolEnableAutoScaleParameter !== undefined) {
                    let requestModelMapper = Mappers.PoolEnableAutoScaleParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, poolEnableAutoScaleParameter, 'poolEnableAutoScaleParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(poolEnableAutoScaleParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets the result of evaluating an automatic scaling formula on the
     * pool.
     *
     * This API is primarily for validating an autoscale formula, as it simply
     * returns the result without applying the formula to the pool. The pool must
     * have auto scaling enabled in order to evaluate a formula.
     *
     * @param {string} poolId The ID of the pool on which to evaluate the automatic
     * scaling formula.
     *
     * @param {string} autoScaleFormula The formula for the desired number of
     * compute nodes in the pool. The formula is validated and its results
     * calculated, but it is not applied to the pool. To apply the formula to the
     * pool, 'Enable automatic scaling on a pool'. For more information about
     * specifying this formula, see Automatically scale compute nodes in an Azure
     * Batch pool
     * (https://azure.microsoft.com/en-us/documentation/articles/batch-automatic-scaling).
     *
     * @param {PoolEvaluateAutoScaleOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    evaluateAutoScaleWithHttpOperationResponse(poolId, autoScaleFormula, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolEvaluateAutoScaleOptions = (options && options.poolEvaluateAutoScaleOptions !== undefined) ? options.poolEvaluateAutoScaleOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (autoScaleFormula === null || autoScaleFormula === undefined || typeof autoScaleFormula.valueOf() !== 'string') {
                    throw new Error('autoScaleFormula cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let poolEvaluateAutoScaleParameter = {};
            try {
                if (poolEvaluateAutoScaleOptions !== null && poolEvaluateAutoScaleOptions !== undefined) {
                    timeout = poolEvaluateAutoScaleOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolEvaluateAutoScaleOptions !== null && poolEvaluateAutoScaleOptions !== undefined) {
                    clientRequestId = poolEvaluateAutoScaleOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolEvaluateAutoScaleOptions !== null && poolEvaluateAutoScaleOptions !== undefined) {
                    returnClientRequestId = poolEvaluateAutoScaleOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolEvaluateAutoScaleOptions !== null && poolEvaluateAutoScaleOptions !== undefined) {
                    ocpDate = poolEvaluateAutoScaleOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (autoScaleFormula !== null && autoScaleFormula !== undefined) {
                    poolEvaluateAutoScaleParameter.autoScaleFormula = autoScaleFormula;
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/evaluateautoscale';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (poolEvaluateAutoScaleParameter !== null && poolEvaluateAutoScaleParameter !== undefined) {
                    let requestModelMapper = Mappers.PoolEvaluateAutoScaleParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, poolEvaluateAutoScaleParameter, 'poolEvaluateAutoScaleParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(poolEvaluateAutoScaleParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.AutoScaleRun;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Changes the number of compute nodes that are assigned to a pool.
     *
     * You can only resize a pool when its allocation state is steady. If the pool
     * is already resizing, the request fails with status code 409. When you resize
     * a pool, the pool's allocation state changes from steady to resizing. You
     * cannot resize pools which are configured for automatic scaling. If you try
     * to do this, the Batch service returns an error 409. If you resize a pool
     * downwards, the Batch service chooses which nodes to remove. To remove
     * specific nodes, use the pool remove nodes API instead.
     *
     * @param {string} poolId The ID of the pool to resize.
     *
     * @param {PoolResizeParameter} poolResizeParameter The parameters for the
     * request.
     *
     * @param {PoolResizeOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    resizeWithHttpOperationResponse(poolId, poolResizeParameter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolResizeOptions = (options && options.poolResizeOptions !== undefined) ? options.poolResizeOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (poolResizeParameter === null || poolResizeParameter === undefined) {
                    throw new Error('poolResizeParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    timeout = poolResizeOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    clientRequestId = poolResizeOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    returnClientRequestId = poolResizeOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    ocpDate = poolResizeOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    ifMatch = poolResizeOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    ifNoneMatch = poolResizeOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    ifModifiedSince = poolResizeOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    ifUnmodifiedSince = poolResizeOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/resize';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (poolResizeParameter !== null && poolResizeParameter !== undefined) {
                    let requestModelMapper = Mappers.PoolResizeParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, poolResizeParameter, 'poolResizeParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(poolResizeParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Stops an ongoing resize operation on the pool.
     *
     * This does not restore the pool to its previous state before the resize
     * operation: it only stops any further changes being made, and the pool
     * maintains its current state. After stopping, the pool stabilizes at the
     * number of nodes it was at when the stop operation was done. During the stop
     * operation, the pool allocation state changes first to stopping and then to
     * steady. A resize operation need not be an explicit resize pool request; this
     * API can also be used to halt the initial sizing of the pool when it is
     * created.
     *
     * @param {string} poolId The ID of the pool whose resizing you want to stop.
     *
     * @param {PoolStopResizeOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    stopResizeWithHttpOperationResponse(poolId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolStopResizeOptions = (options && options.poolStopResizeOptions !== undefined) ? options.poolStopResizeOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    timeout = poolStopResizeOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    clientRequestId = poolStopResizeOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    returnClientRequestId = poolStopResizeOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    ocpDate = poolStopResizeOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    ifMatch = poolStopResizeOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    ifNoneMatch = poolStopResizeOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    ifModifiedSince = poolStopResizeOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    ifUnmodifiedSince = poolStopResizeOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/stopresize';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Updates the properties of the specified pool.
     *
     * This fully replaces all the updateable properties of the pool. For example,
     * if the pool has a start task associated with it and if start task is not
     * specified with this request, then the Batch service will remove the existing
     * start task.
     *
     * @param {string} poolId The ID of the pool to update.
     *
     * @param {PoolUpdatePropertiesParameter} poolUpdatePropertiesParameter The
     * parameters for the request.
     *
     * @param {PoolUpdatePropertiesOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updatePropertiesWithHttpOperationResponse(poolId, poolUpdatePropertiesParameter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolUpdatePropertiesOptions = (options && options.poolUpdatePropertiesOptions !== undefined) ? options.poolUpdatePropertiesOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (poolUpdatePropertiesParameter === null || poolUpdatePropertiesParameter === undefined) {
                    throw new Error('poolUpdatePropertiesParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolUpdatePropertiesOptions !== null && poolUpdatePropertiesOptions !== undefined) {
                    timeout = poolUpdatePropertiesOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolUpdatePropertiesOptions !== null && poolUpdatePropertiesOptions !== undefined) {
                    clientRequestId = poolUpdatePropertiesOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolUpdatePropertiesOptions !== null && poolUpdatePropertiesOptions !== undefined) {
                    returnClientRequestId = poolUpdatePropertiesOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolUpdatePropertiesOptions !== null && poolUpdatePropertiesOptions !== undefined) {
                    ocpDate = poolUpdatePropertiesOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/updateproperties';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (poolUpdatePropertiesParameter !== null && poolUpdatePropertiesParameter !== undefined) {
                    let requestModelMapper = Mappers.PoolUpdatePropertiesParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, poolUpdatePropertiesParameter, 'poolUpdatePropertiesParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(poolUpdatePropertiesParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 204) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Upgrades the operating system of the specified pool.
     *
     * During an upgrade, the Batch service upgrades each compute node in the pool.
     * When a compute node is chosen for upgrade, any tasks running on that node
     * are removed from the node and returned to the queue to be rerun later (or on
     * a different compute node). The node will be unavailable until the upgrade is
     * complete. This operation results in temporarily reduced pool capacity as
     * nodes are taken out of service to be upgraded. Although the Batch service
     * tries to avoid upgrading all compute nodes at the same time, it does not
     * guarantee to do this (particularly on small pools); therefore, the pool may
     * be temporarily unavailable to run tasks. When this operation runs, the pool
     * state changes to upgrading. When all compute nodes have finished upgrading,
     * the pool state returns to active. While the upgrade is in progress, the
     * pool's currentOSVersion reflects the OS version that nodes are upgrading
     * from, and targetOSVersion reflects the OS version that nodes are upgrading
     * to. Once the upgrade is complete, currentOSVersion is updated to reflect the
     * OS version now running on all nodes. This operation can only be invoked on
     * pools created with the cloudServiceConfiguration property.
     *
     * @param {string} poolId The ID of the pool to upgrade.
     *
     * @param {string} targetOSVersion The Azure Guest OS version to be installed
     * on the virtual machines in the pool.
     *
     * @param {PoolUpgradeOSOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    upgradeOSWithHttpOperationResponse(poolId, targetOSVersion, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolUpgradeOSOptions = (options && options.poolUpgradeOSOptions !== undefined) ? options.poolUpgradeOSOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (targetOSVersion === null || targetOSVersion === undefined || typeof targetOSVersion.valueOf() !== 'string') {
                    throw new Error('targetOSVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            let poolUpgradeOSParameter = {};
            try {
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    timeout = poolUpgradeOSOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    clientRequestId = poolUpgradeOSOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    returnClientRequestId = poolUpgradeOSOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    ocpDate = poolUpgradeOSOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    ifMatch = poolUpgradeOSOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    ifNoneMatch = poolUpgradeOSOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    ifModifiedSince = poolUpgradeOSOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    ifUnmodifiedSince = poolUpgradeOSOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
                if (targetOSVersion !== null && targetOSVersion !== undefined) {
                    poolUpgradeOSParameter.targetOSVersion = targetOSVersion;
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/upgradeos';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (poolUpgradeOSParameter !== null && poolUpgradeOSParameter !== undefined) {
                    let requestModelMapper = Mappers.PoolUpgradeOSParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, poolUpgradeOSParameter, 'poolUpgradeOSParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(poolUpgradeOSParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Removes compute nodes from the specified pool.
     *
     * This operation can only run when the allocation state of the pool is steady.
     * When this operation runs, the allocation state changes from steady to
     * resizing.
     *
     * @param {string} poolId The ID of the pool from which you want to remove
     * nodes.
     *
     * @param {NodeRemoveParameter} nodeRemoveParameter The parameters for the
     * request.
     *
     * @param {PoolRemoveNodesOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    removeNodesWithHttpOperationResponse(poolId, nodeRemoveParameter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolRemoveNodesOptions = (options && options.poolRemoveNodesOptions !== undefined) ? options.poolRemoveNodesOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeRemoveParameter === null || nodeRemoveParameter === undefined) {
                    throw new Error('nodeRemoveParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    timeout = poolRemoveNodesOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    clientRequestId = poolRemoveNodesOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    returnClientRequestId = poolRemoveNodesOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    ocpDate = poolRemoveNodesOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    ifMatch = poolRemoveNodesOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    ifNoneMatch = poolRemoveNodesOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    ifModifiedSince = poolRemoveNodesOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    ifUnmodifiedSince = poolRemoveNodesOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/removenodes';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (nodeRemoveParameter !== null && nodeRemoveParameter !== undefined) {
                    let requestModelMapper = Mappers.NodeRemoveParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, nodeRemoveParameter, 'nodeRemoveParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(nodeRemoveParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the usage metrics, aggregated by pool across individual time
     * intervals, for the specified account.
     *
     * If you do not specify a $filter clause including a poolId, the response
     * includes all pools that existed in the account in the time range of the
     * returned aggregation intervals. If you do not specify a $filter clause
     * including a startTime or endTime these filters default to the start and end
     * times of the last aggregation interval currently available; that is, only
     * the last aggregation interval is returned.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {PoolListUsageMetricsNextOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listUsageMetricsNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolListUsageMetricsNextOptions = (options && options.poolListUsageMetricsNextOptions !== undefined) ? options.poolListUsageMetricsNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolListUsageMetricsNextOptions !== null && poolListUsageMetricsNextOptions !== undefined) {
                    clientRequestId = poolListUsageMetricsNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolListUsageMetricsNextOptions !== null && poolListUsageMetricsNextOptions !== undefined) {
                    returnClientRequestId = poolListUsageMetricsNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolListUsageMetricsNextOptions !== null && poolListUsageMetricsNextOptions !== undefined) {
                    ocpDate = poolListUsageMetricsNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.PoolListUsageMetricsResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the pools in the specified account.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {PoolListNextOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolListNextOptions = (options && options.poolListNextOptions !== undefined) ? options.poolListNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolListNextOptions !== null && poolListNextOptions !== undefined) {
                    clientRequestId = poolListNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolListNextOptions !== null && poolListNextOptions !== undefined) {
                    returnClientRequestId = poolListNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolListNextOptions !== null && poolListNextOptions !== undefined) {
                    ocpDate = poolListNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.CloudPoolListResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    listUsageMetrics(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listUsageMetricsWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listUsageMetricsWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    getAllLifetimeStatistics(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getAllLifetimeStatisticsWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getAllLifetimeStatisticsWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    add(pool, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.addWithHttpOperationResponse(pool, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.addWithHttpOperationResponse(pool, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    list(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    deleteMethod(poolId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteMethodWithHttpOperationResponse(poolId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deleteMethodWithHttpOperationResponse(poolId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    exists(poolId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.existsWithHttpOperationResponse(poolId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.existsWithHttpOperationResponse(poolId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    get(poolId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(poolId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getWithHttpOperationResponse(poolId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    patch(poolId, poolPatchParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.patchWithHttpOperationResponse(poolId, poolPatchParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.patchWithHttpOperationResponse(poolId, poolPatchParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    disableAutoScale(poolId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.disableAutoScaleWithHttpOperationResponse(poolId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.disableAutoScaleWithHttpOperationResponse(poolId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    enableAutoScale(poolId, poolEnableAutoScaleParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.enableAutoScaleWithHttpOperationResponse(poolId, poolEnableAutoScaleParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.enableAutoScaleWithHttpOperationResponse(poolId, poolEnableAutoScaleParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    evaluateAutoScale(poolId, autoScaleFormula, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.evaluateAutoScaleWithHttpOperationResponse(poolId, autoScaleFormula, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.evaluateAutoScaleWithHttpOperationResponse(poolId, autoScaleFormula, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    resize(poolId, poolResizeParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.resizeWithHttpOperationResponse(poolId, poolResizeParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.resizeWithHttpOperationResponse(poolId, poolResizeParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    stopResize(poolId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.stopResizeWithHttpOperationResponse(poolId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.stopResizeWithHttpOperationResponse(poolId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    updateProperties(poolId, poolUpdatePropertiesParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.updatePropertiesWithHttpOperationResponse(poolId, poolUpdatePropertiesParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.updatePropertiesWithHttpOperationResponse(poolId, poolUpdatePropertiesParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    upgradeOS(poolId, targetOSVersion, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.upgradeOSWithHttpOperationResponse(poolId, targetOSVersion, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.upgradeOSWithHttpOperationResponse(poolId, targetOSVersion, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    removeNodes(poolId, nodeRemoveParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.removeNodesWithHttpOperationResponse(poolId, nodeRemoveParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.removeNodesWithHttpOperationResponse(poolId, nodeRemoveParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listUsageMetricsNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listUsageMetricsNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listUsageMetricsNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
}
exports.Pool = Pool;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const msRest = __webpack_require__(1);
const Mappers = __webpack_require__(0);
const WebResource = msRest.WebResource;
/** Class representing a Account. */
class Account {
    /**
     * Create a Account.
     * @param {BatchServiceClient} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Lists all node agent SKUs supported by the Azure Batch service.
     *
     * @param {AccountListNodeAgentSkusOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNodeAgentSkusWithHttpOperationResponse(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let accountListNodeAgentSkusOptions = (options && options.accountListNodeAgentSkusOptions !== undefined) ? options.accountListNodeAgentSkusOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (accountListNodeAgentSkusOptions !== null && accountListNodeAgentSkusOptions !== undefined) {
                    filter = accountListNodeAgentSkusOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (accountListNodeAgentSkusOptions !== null && accountListNodeAgentSkusOptions !== undefined) {
                    maxResults = accountListNodeAgentSkusOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (accountListNodeAgentSkusOptions !== null && accountListNodeAgentSkusOptions !== undefined) {
                    timeout = accountListNodeAgentSkusOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (accountListNodeAgentSkusOptions !== null && accountListNodeAgentSkusOptions !== undefined) {
                    clientRequestId = accountListNodeAgentSkusOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (accountListNodeAgentSkusOptions !== null && accountListNodeAgentSkusOptions !== undefined) {
                    returnClientRequestId = accountListNodeAgentSkusOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (accountListNodeAgentSkusOptions !== null && accountListNodeAgentSkusOptions !== undefined) {
                    ocpDate = accountListNodeAgentSkusOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'nodeagentskus';
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (filter !== null && filter !== undefined) {
                queryParamsArray.push('$filter=' + encodeURIComponent(filter));
            }
            if (maxResults !== null && maxResults !== undefined) {
                queryParamsArray.push('maxresults=' + encodeURIComponent(maxResults.toString()));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.AccountListNodeAgentSkusResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all node agent SKUs supported by the Azure Batch service.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {AccountListNodeAgentSkusNextOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNodeAgentSkusNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let accountListNodeAgentSkusNextOptions = (options && options.accountListNodeAgentSkusNextOptions !== undefined) ? options.accountListNodeAgentSkusNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (accountListNodeAgentSkusNextOptions !== null && accountListNodeAgentSkusNextOptions !== undefined) {
                    clientRequestId = accountListNodeAgentSkusNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (accountListNodeAgentSkusNextOptions !== null && accountListNodeAgentSkusNextOptions !== undefined) {
                    returnClientRequestId = accountListNodeAgentSkusNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (accountListNodeAgentSkusNextOptions !== null && accountListNodeAgentSkusNextOptions !== undefined) {
                    ocpDate = accountListNodeAgentSkusNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.AccountListNodeAgentSkusResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    listNodeAgentSkus(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNodeAgentSkusWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listNodeAgentSkusWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listNodeAgentSkusNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNodeAgentSkusNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listNodeAgentSkusNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
}
exports.Account = Account;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const msRest = __webpack_require__(1);
const Mappers = __webpack_require__(0);
const WebResource = msRest.WebResource;
/** Class representing a Job. */
class Job {
    /**
     * Create a Job.
     * @param {BatchServiceClient} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Gets lifetime summary statistics for all of the jobs in the
     * specified account.
     *
     * Statistics are aggregated across all jobs that have ever existed in the
     * account, from account creation to the last update time of the statistics.
     *
     * @param {JobGetAllLifetimeStatisticsOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getAllLifetimeStatisticsWithHttpOperationResponse(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobGetAllLifetimeStatisticsOptions = (options && options.jobGetAllLifetimeStatisticsOptions !== undefined) ? options.jobGetAllLifetimeStatisticsOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobGetAllLifetimeStatisticsOptions !== null && jobGetAllLifetimeStatisticsOptions !== undefined) {
                    timeout = jobGetAllLifetimeStatisticsOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobGetAllLifetimeStatisticsOptions !== null && jobGetAllLifetimeStatisticsOptions !== undefined) {
                    clientRequestId = jobGetAllLifetimeStatisticsOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobGetAllLifetimeStatisticsOptions !== null && jobGetAllLifetimeStatisticsOptions !== undefined) {
                    returnClientRequestId = jobGetAllLifetimeStatisticsOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobGetAllLifetimeStatisticsOptions !== null && jobGetAllLifetimeStatisticsOptions !== undefined) {
                    ocpDate = jobGetAllLifetimeStatisticsOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'lifetimejobstats';
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.JobStatistics;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Deletes a job.
     *
     * Deleting a job also deletes all tasks that are part of that job, and all job
     * statistics. This also overrides the retention period for task data; that is,
     * if the job contains tasks which are still retained on compute nodes, the
     * Batch services deletes those tasks' working directories and all their
     * contents.  When a Delete Job request is received, the Batch service sets the
     * job to the deleting state. All update operations on a job that is in
     * deleting state will fail with status code 409 (Conflict), with additional
     * information indicating that the job is being deleted.
     *
     * @param {string} jobId The ID of the job to delete.
     *
     * @param {JobDeleteMethodOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(jobId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobDeleteMethodOptions = (options && options.jobDeleteMethodOptions !== undefined) ? options.jobDeleteMethodOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    timeout = jobDeleteMethodOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    clientRequestId = jobDeleteMethodOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    returnClientRequestId = jobDeleteMethodOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    ocpDate = jobDeleteMethodOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    ifMatch = jobDeleteMethodOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    ifNoneMatch = jobDeleteMethodOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    ifModifiedSince = jobDeleteMethodOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    ifUnmodifiedSince = jobDeleteMethodOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'DELETE';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets information about the specified job.
     *
     * @param {string} jobId The ID of the job.
     *
     * @param {JobGetOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(jobId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobGetOptions = (options && options.jobGetOptions !== undefined) ? options.jobGetOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let select;
            let expand;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    select = jobGetOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    expand = jobGetOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    timeout = jobGetOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    clientRequestId = jobGetOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    returnClientRequestId = jobGetOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    ocpDate = jobGetOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    ifMatch = jobGetOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    ifNoneMatch = jobGetOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    ifModifiedSince = jobGetOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    ifUnmodifiedSince = jobGetOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (select !== null && select !== undefined) {
                queryParamsArray.push('$select=' + encodeURIComponent(select));
            }
            if (expand !== null && expand !== undefined) {
                queryParamsArray.push('$expand=' + encodeURIComponent(expand));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.CloudJob;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Updates the properties of the specified job.
     *
     * This replaces only the job properties specified in the request. For example,
     * if the job has constraints, and a request does not specify the constraints
     * element, then the job keeps the existing constraints.
     *
     * @param {string} jobId The ID of the job whose properties you want to update.
     *
     * @param {JobPatchParameter} jobPatchParameter The parameters for the request.
     *
     * @param {JobPatchOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    patchWithHttpOperationResponse(jobId, jobPatchParameter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobPatchOptions = (options && options.jobPatchOptions !== undefined) ? options.jobPatchOptions : undefined;
            if (jobPatchParameter === null || jobPatchParameter === undefined) {
                jobPatchParameter = {};
            }
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (jobPatchParameter === null || jobPatchParameter === undefined) {
                    throw new Error('jobPatchParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    timeout = jobPatchOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    clientRequestId = jobPatchOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    returnClientRequestId = jobPatchOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    ocpDate = jobPatchOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    ifMatch = jobPatchOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    ifNoneMatch = jobPatchOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    ifModifiedSince = jobPatchOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    ifUnmodifiedSince = jobPatchOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'PATCH';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (jobPatchParameter !== null && jobPatchParameter !== undefined) {
                    let requestModelMapper = Mappers.JobPatchParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, jobPatchParameter, 'jobPatchParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(jobPatchParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Updates the properties of the specified job.
     *
     * This fully replaces all the updateable properties of the job. For example,
     * if the job has constraints associated with it and if constraints is not
     * specified with this request, then the Batch service will remove the existing
     * constraints.
     *
     * @param {string} jobId The ID of the job whose properties you want to update.
     *
     * @param {JobUpdateParameter} jobUpdateParameter The parameters for the
     * request.
     *
     * @param {JobUpdateOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updateWithHttpOperationResponse(jobId, jobUpdateParameter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobUpdateOptions = (options && options.jobUpdateOptions !== undefined) ? options.jobUpdateOptions : undefined;
            if (jobUpdateParameter === null || jobUpdateParameter === undefined) {
                jobUpdateParameter = {};
            }
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (jobUpdateParameter === null || jobUpdateParameter === undefined) {
                    throw new Error('jobUpdateParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    timeout = jobUpdateOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    clientRequestId = jobUpdateOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    returnClientRequestId = jobUpdateOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    ocpDate = jobUpdateOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    ifMatch = jobUpdateOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    ifNoneMatch = jobUpdateOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    ifModifiedSince = jobUpdateOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    ifUnmodifiedSince = jobUpdateOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'PUT';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (jobUpdateParameter !== null && jobUpdateParameter !== undefined) {
                    let requestModelMapper = Mappers.JobUpdateParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, jobUpdateParameter, 'jobUpdateParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(jobUpdateParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Disables the specified job, preventing new tasks from running.
     *
     * The Batch Service immediately moves the job to the disabling state. Batch
     * then uses the disableTasks parameter to determine what to do with the
     * currently running tasks of the job. The job remains in the disabling state
     * until the disable operation is completed and all tasks have been dealt with
     * according to the disableTasks option; the job then moves to the disabled
     * state. No new tasks are started under the job until it moves back to active
     * state. If you try to disable a job that is in any state other than active,
     * disabling, or disabled, the request fails with status code 409.
     *
     * @param {string} jobId The ID of the job to disable.
     *
     * @param {DisableJobOption} disableTasks What to do with active tasks
     * associated with the job. Values are:
     *
     * requeue - Terminate running tasks and requeue them. The tasks will run again
     * when the job is enabled.
     * terminate - Terminate running tasks. The tasks will not run again.
     * wait - Allow currently running tasks to complete. Possible values include:
     * 'requeue', 'terminate', 'wait'
     *
     * @param {JobDisableOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    disableWithHttpOperationResponse(jobId, disableTasks, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobDisableOptions = (options && options.jobDisableOptions !== undefined) ? options.jobDisableOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (disableTasks) {
                    let allowedValues = ['requeue', 'terminate', 'wait'];
                    if (!allowedValues.some(function (item) { return item === disableTasks; })) {
                        throw new Error(disableTasks + ' is not a valid value. The valid values are: ' + allowedValues);
                    }
                }
                else {
                    throw new Error('disableTasks cannot be null or undefined.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            let jobDisableParameter = {};
            try {
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    timeout = jobDisableOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    clientRequestId = jobDisableOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    returnClientRequestId = jobDisableOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    ocpDate = jobDisableOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    ifMatch = jobDisableOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    ifNoneMatch = jobDisableOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    ifModifiedSince = jobDisableOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    ifUnmodifiedSince = jobDisableOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
                if (disableTasks !== null && disableTasks !== undefined) {
                    jobDisableParameter.disableTasks = disableTasks;
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/disable';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (jobDisableParameter !== null && jobDisableParameter !== undefined) {
                    let requestModelMapper = Mappers.JobDisableParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, jobDisableParameter, 'jobDisableParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(jobDisableParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Enables the specified job, allowing new tasks to run.
     *
     * When you call this API, the Batch service sets a disabled job to the
     * enabling state. After the this operation is completed, the job moves to the
     * active state, and scheduling of new tasks under the job resumes. The Batch
     * service does not allow a task to remain in the active state for more than 7
     * days. Therefore, if you enable a job containing active tasks which were
     * added more than 7 days ago, those tasks will not run.
     *
     * @param {string} jobId The ID of the job to enable.
     *
     * @param {JobEnableOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    enableWithHttpOperationResponse(jobId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobEnableOptions = (options && options.jobEnableOptions !== undefined) ? options.jobEnableOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    timeout = jobEnableOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    clientRequestId = jobEnableOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    returnClientRequestId = jobEnableOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    ocpDate = jobEnableOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    ifMatch = jobEnableOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    ifNoneMatch = jobEnableOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    ifModifiedSince = jobEnableOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    ifUnmodifiedSince = jobEnableOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/enable';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Terminates the specified job, marking it as completed.
     *
     * When a Terminate Job request is received, the Batch service sets the job to
     * the terminating state. The Batch service then terminates any active or
     * running tasks associated with the job, and runs any required Job Release
     * tasks. The job then moves into the completed state.
     *
     * @param {string} jobId The ID of the job to terminate.
     *
     * @param {JobTerminateOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    terminateWithHttpOperationResponse(jobId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let terminateReason = (options && options.terminateReason !== undefined) ? options.terminateReason : undefined;
            let jobTerminateOptions = (options && options.jobTerminateOptions !== undefined) ? options.jobTerminateOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (terminateReason !== null && terminateReason !== undefined && typeof terminateReason.valueOf() !== 'string') {
                    throw new Error('terminateReason must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            let jobTerminateParameter;
            try {
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    timeout = jobTerminateOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    clientRequestId = jobTerminateOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    returnClientRequestId = jobTerminateOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    ocpDate = jobTerminateOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    ifMatch = jobTerminateOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    ifNoneMatch = jobTerminateOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    ifModifiedSince = jobTerminateOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    ifUnmodifiedSince = jobTerminateOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
                if (terminateReason !== null && terminateReason !== undefined) {
                    jobTerminateParameter = {};
                    jobTerminateParameter.terminateReason = terminateReason;
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/terminate';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (jobTerminateParameter !== null && jobTerminateParameter !== undefined) {
                    let requestModelMapper = Mappers.JobTerminateParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, jobTerminateParameter, 'jobTerminateParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(jobTerminateParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Adds a job to the specified account.
     *
     * The Batch service supports two ways to control the work done as part of a
     * job. In the first approach, the user specifies a Job Manager task. The Batch
     * service launches this task when it is ready to start the job. The Job
     * Manager task controls all other tasks that run under this job, by using the
     * Task APIs. In the second approach, the user directly controls the execution
     * of tasks under an active job, by using the Task APIs. Also note: when naming
     * jobs, avoid including sensitive information such as user names or secret
     * project names. This information may appear in telemetry logs accessible to
     * Microsoft Support engineers.
     *
     * @param {JobAddParameter} job The job to be added.
     *
     * @param {JobAddOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addWithHttpOperationResponse(job, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobAddOptions = (options && options.jobAddOptions !== undefined) ? options.jobAddOptions : undefined;
            if (job === null || job === undefined) {
                job = {};
            }
            // Validate
            try {
                if (job === null || job === undefined) {
                    throw new Error('job cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobAddOptions !== null && jobAddOptions !== undefined) {
                    timeout = jobAddOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobAddOptions !== null && jobAddOptions !== undefined) {
                    clientRequestId = jobAddOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobAddOptions !== null && jobAddOptions !== undefined) {
                    returnClientRequestId = jobAddOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobAddOptions !== null && jobAddOptions !== undefined) {
                    ocpDate = jobAddOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs';
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (job !== null && job !== undefined) {
                    let requestModelMapper = Mappers.JobAddParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, job, 'job');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(job, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 201) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the jobs in the specified account.
     *
     * @param {JobListOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobListOptions = (options && options.jobListOptions !== undefined) ? options.jobListOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let select;
            let expand;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    filter = jobListOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    select = jobListOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    expand = jobListOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    maxResults = jobListOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    timeout = jobListOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    clientRequestId = jobListOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    returnClientRequestId = jobListOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    ocpDate = jobListOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs';
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (filter !== null && filter !== undefined) {
                queryParamsArray.push('$filter=' + encodeURIComponent(filter));
            }
            if (select !== null && select !== undefined) {
                queryParamsArray.push('$select=' + encodeURIComponent(select));
            }
            if (expand !== null && expand !== undefined) {
                queryParamsArray.push('$expand=' + encodeURIComponent(expand));
            }
            if (maxResults !== null && maxResults !== undefined) {
                queryParamsArray.push('maxresults=' + encodeURIComponent(maxResults.toString()));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.CloudJobListResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the jobs that have been created under the specified job
     * schedule.
     *
     * @param {string} jobScheduleId The ID of the job schedule from which you want
     * to get a list of jobs.
     *
     * @param {JobListFromJobScheduleOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listFromJobScheduleWithHttpOperationResponse(jobScheduleId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobListFromJobScheduleOptions = (options && options.jobListFromJobScheduleOptions !== undefined) ? options.jobListFromJobScheduleOptions : undefined;
            // Validate
            try {
                if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
                    throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let select;
            let expand;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    filter = jobListFromJobScheduleOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    select = jobListFromJobScheduleOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    expand = jobListFromJobScheduleOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    maxResults = jobListFromJobScheduleOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    timeout = jobListFromJobScheduleOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    clientRequestId = jobListFromJobScheduleOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    returnClientRequestId = jobListFromJobScheduleOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    ocpDate = jobListFromJobScheduleOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobschedules/{jobScheduleId}/jobs';
            requestUrl = requestUrl.replace('{jobScheduleId}', encodeURIComponent(jobScheduleId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (filter !== null && filter !== undefined) {
                queryParamsArray.push('$filter=' + encodeURIComponent(filter));
            }
            if (select !== null && select !== undefined) {
                queryParamsArray.push('$select=' + encodeURIComponent(select));
            }
            if (expand !== null && expand !== undefined) {
                queryParamsArray.push('$expand=' + encodeURIComponent(expand));
            }
            if (maxResults !== null && maxResults !== undefined) {
                queryParamsArray.push('maxresults=' + encodeURIComponent(maxResults.toString()));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.CloudJobListResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the execution status of the Job Preparation and Job Release
     * task for the specified job across the compute nodes where the job has run.
     *
     * This API returns the Job Preparation and Job Release task status on all
     * compute nodes that have run the Job Preparation or Job Release task. This
     * includes nodes which have since been removed from the pool. If this API is
     * invoked on a job which has no Job Preparation or Job Release task, the Batch
     * service returns HTTP status code 409 (Conflict) with an error code of
     * JobPreparationTaskNotSpecified.
     *
     * @param {string} jobId The ID of the job.
     *
     * @param {JobListPreparationAndReleaseTaskStatusOptionalParams} [options]
     * Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listPreparationAndReleaseTaskStatusWithHttpOperationResponse(jobId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobListPreparationAndReleaseTaskStatusOptions = (options && options.jobListPreparationAndReleaseTaskStatusOptions !== undefined) ? options.jobListPreparationAndReleaseTaskStatusOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let select;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
                    filter = jobListPreparationAndReleaseTaskStatusOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
                    select = jobListPreparationAndReleaseTaskStatusOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
                    maxResults = jobListPreparationAndReleaseTaskStatusOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
                    timeout = jobListPreparationAndReleaseTaskStatusOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
                    clientRequestId = jobListPreparationAndReleaseTaskStatusOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
                    returnClientRequestId = jobListPreparationAndReleaseTaskStatusOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
                    ocpDate = jobListPreparationAndReleaseTaskStatusOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/jobpreparationandreleasetaskstatus';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (filter !== null && filter !== undefined) {
                queryParamsArray.push('$filter=' + encodeURIComponent(filter));
            }
            if (select !== null && select !== undefined) {
                queryParamsArray.push('$select=' + encodeURIComponent(select));
            }
            if (maxResults !== null && maxResults !== undefined) {
                queryParamsArray.push('maxresults=' + encodeURIComponent(maxResults.toString()));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.CloudJobListPreparationAndReleaseTaskStatusResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets the task counts for the specified job.
     *
     * Task counts provide a count of the tasks by active, running or completed
     * task state, and a count of tasks which succeeded or failed. Tasks in the
     * preparing state are counted as running. If the validationStatus is
     * unvalidated, then the Batch service has not been able to check state counts
     * against the task states as reported in the List Tasks API. The
     * validationStatus may be unvalidated if the job contains more than 200,000
     * tasks.
     *
     * @param {string} jobId The ID of the job.
     *
     * @param {JobGetTaskCountsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getTaskCountsWithHttpOperationResponse(jobId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobGetTaskCountsOptions = (options && options.jobGetTaskCountsOptions !== undefined) ? options.jobGetTaskCountsOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobGetTaskCountsOptions !== null && jobGetTaskCountsOptions !== undefined) {
                    timeout = jobGetTaskCountsOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobGetTaskCountsOptions !== null && jobGetTaskCountsOptions !== undefined) {
                    clientRequestId = jobGetTaskCountsOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobGetTaskCountsOptions !== null && jobGetTaskCountsOptions !== undefined) {
                    returnClientRequestId = jobGetTaskCountsOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobGetTaskCountsOptions !== null && jobGetTaskCountsOptions !== undefined) {
                    ocpDate = jobGetTaskCountsOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/taskcounts';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.TaskCounts;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the jobs in the specified account.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {JobListNextOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobListNextOptions = (options && options.jobListNextOptions !== undefined) ? options.jobListNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobListNextOptions !== null && jobListNextOptions !== undefined) {
                    clientRequestId = jobListNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobListNextOptions !== null && jobListNextOptions !== undefined) {
                    returnClientRequestId = jobListNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobListNextOptions !== null && jobListNextOptions !== undefined) {
                    ocpDate = jobListNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.CloudJobListResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the jobs that have been created under the specified job
     * schedule.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {JobListFromJobScheduleNextOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listFromJobScheduleNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobListFromJobScheduleNextOptions = (options && options.jobListFromJobScheduleNextOptions !== undefined) ? options.jobListFromJobScheduleNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobListFromJobScheduleNextOptions !== null && jobListFromJobScheduleNextOptions !== undefined) {
                    clientRequestId = jobListFromJobScheduleNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobListFromJobScheduleNextOptions !== null && jobListFromJobScheduleNextOptions !== undefined) {
                    returnClientRequestId = jobListFromJobScheduleNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobListFromJobScheduleNextOptions !== null && jobListFromJobScheduleNextOptions !== undefined) {
                    ocpDate = jobListFromJobScheduleNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.CloudJobListResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the execution status of the Job Preparation and Job Release
     * task for the specified job across the compute nodes where the job has run.
     *
     * This API returns the Job Preparation and Job Release task status on all
     * compute nodes that have run the Job Preparation or Job Release task. This
     * includes nodes which have since been removed from the pool. If this API is
     * invoked on a job which has no Job Preparation or Job Release task, the Batch
     * service returns HTTP status code 409 (Conflict) with an error code of
     * JobPreparationTaskNotSpecified.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {JobListPreparationAndReleaseTaskStatusNextOptionalParams} [options]
     * Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listPreparationAndReleaseTaskStatusNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobListPreparationAndReleaseTaskStatusNextOptions = (options && options.jobListPreparationAndReleaseTaskStatusNextOptions !== undefined) ? options.jobListPreparationAndReleaseTaskStatusNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobListPreparationAndReleaseTaskStatusNextOptions !== null && jobListPreparationAndReleaseTaskStatusNextOptions !== undefined) {
                    clientRequestId = jobListPreparationAndReleaseTaskStatusNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusNextOptions !== null && jobListPreparationAndReleaseTaskStatusNextOptions !== undefined) {
                    returnClientRequestId = jobListPreparationAndReleaseTaskStatusNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusNextOptions !== null && jobListPreparationAndReleaseTaskStatusNextOptions !== undefined) {
                    ocpDate = jobListPreparationAndReleaseTaskStatusNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.CloudJobListPreparationAndReleaseTaskStatusResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    getAllLifetimeStatistics(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getAllLifetimeStatisticsWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getAllLifetimeStatisticsWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    deleteMethod(jobId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteMethodWithHttpOperationResponse(jobId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deleteMethodWithHttpOperationResponse(jobId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    get(jobId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(jobId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getWithHttpOperationResponse(jobId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    patch(jobId, jobPatchParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.patchWithHttpOperationResponse(jobId, jobPatchParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.patchWithHttpOperationResponse(jobId, jobPatchParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    update(jobId, jobUpdateParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.updateWithHttpOperationResponse(jobId, jobUpdateParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.updateWithHttpOperationResponse(jobId, jobUpdateParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    disable(jobId, disableTasks, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.disableWithHttpOperationResponse(jobId, disableTasks, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.disableWithHttpOperationResponse(jobId, disableTasks, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    enable(jobId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.enableWithHttpOperationResponse(jobId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.enableWithHttpOperationResponse(jobId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    terminate(jobId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.terminateWithHttpOperationResponse(jobId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.terminateWithHttpOperationResponse(jobId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    add(job, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.addWithHttpOperationResponse(job, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.addWithHttpOperationResponse(job, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    list(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listFromJobSchedule(jobScheduleId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listFromJobScheduleWithHttpOperationResponse(jobScheduleId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listFromJobScheduleWithHttpOperationResponse(jobScheduleId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listPreparationAndReleaseTaskStatus(jobId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listPreparationAndReleaseTaskStatusWithHttpOperationResponse(jobId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listPreparationAndReleaseTaskStatusWithHttpOperationResponse(jobId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    getTaskCounts(jobId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getTaskCountsWithHttpOperationResponse(jobId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getTaskCountsWithHttpOperationResponse(jobId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listFromJobScheduleNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listFromJobScheduleNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listFromJobScheduleNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listPreparationAndReleaseTaskStatusNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listPreparationAndReleaseTaskStatusNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listPreparationAndReleaseTaskStatusNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
}
exports.Job = Job;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const msRest = __webpack_require__(1);
const Mappers = __webpack_require__(0);
const WebResource = msRest.WebResource;
/** Class representing a CertificateOperations. */
class CertificateOperations {
    /**
     * Create a CertificateOperations.
     * @param {BatchServiceClient} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Adds a certificate to the specified account.
     *
     * @param {CertificateAddParameter} certificate The certificate to be added.
     *
     * @param {CertificateAddOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addWithHttpOperationResponse(certificate, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let certificateAddOptions = (options && options.certificateAddOptions !== undefined) ? options.certificateAddOptions : undefined;
            // Validate
            try {
                if (certificate === null || certificate === undefined) {
                    throw new Error('certificate cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (certificateAddOptions !== null && certificateAddOptions !== undefined) {
                    timeout = certificateAddOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (certificateAddOptions !== null && certificateAddOptions !== undefined) {
                    clientRequestId = certificateAddOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (certificateAddOptions !== null && certificateAddOptions !== undefined) {
                    returnClientRequestId = certificateAddOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (certificateAddOptions !== null && certificateAddOptions !== undefined) {
                    ocpDate = certificateAddOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates';
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (certificate !== null && certificate !== undefined) {
                    let requestModelMapper = Mappers.CertificateAddParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, certificate, 'certificate');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(certificate, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 201) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the certificates that have been added to the specified
     * account.
     *
     * @param {CertificateListOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let certificateListOptions = (options && options.certificateListOptions !== undefined) ? options.certificateListOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let select;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (certificateListOptions !== null && certificateListOptions !== undefined) {
                    filter = certificateListOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (certificateListOptions !== null && certificateListOptions !== undefined) {
                    select = certificateListOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (certificateListOptions !== null && certificateListOptions !== undefined) {
                    maxResults = certificateListOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (certificateListOptions !== null && certificateListOptions !== undefined) {
                    timeout = certificateListOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (certificateListOptions !== null && certificateListOptions !== undefined) {
                    clientRequestId = certificateListOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (certificateListOptions !== null && certificateListOptions !== undefined) {
                    returnClientRequestId = certificateListOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (certificateListOptions !== null && certificateListOptions !== undefined) {
                    ocpDate = certificateListOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates';
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (filter !== null && filter !== undefined) {
                queryParamsArray.push('$filter=' + encodeURIComponent(filter));
            }
            if (select !== null && select !== undefined) {
                queryParamsArray.push('$select=' + encodeURIComponent(select));
            }
            if (maxResults !== null && maxResults !== undefined) {
                queryParamsArray.push('maxresults=' + encodeURIComponent(maxResults.toString()));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.CertificateListResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Cancels a failed deletion of a certificate from the specified
     * account.
     *
     * If you try to delete a certificate that is being used by a pool or compute
     * node, the status of the certificate changes to deleteFailed. If you decide
     * that you want to continue using the certificate, you can use this operation
     * to set the status of the certificate back to active. If you intend to delete
     * the certificate, you do not need to run this operation after the deletion
     * failed. You must make sure that the certificate is not being used by any
     * resources, and then you can try again to delete the certificate.
     *
     * @param {string} thumbprintAlgorithm The algorithm used to derive the
     * thumbprint parameter. This must be sha1.
     *
     * @param {string} thumbprint The thumbprint of the certificate being deleted.
     *
     * @param {CertificateCancelDeletionOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    cancelDeletionWithHttpOperationResponse(thumbprintAlgorithm, thumbprint, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let certificateCancelDeletionOptions = (options && options.certificateCancelDeletionOptions !== undefined) ? options.certificateCancelDeletionOptions : undefined;
            // Validate
            try {
                if (thumbprintAlgorithm === null || thumbprintAlgorithm === undefined || typeof thumbprintAlgorithm.valueOf() !== 'string') {
                    throw new Error('thumbprintAlgorithm cannot be null or undefined and it must be of type string.');
                }
                if (thumbprint === null || thumbprint === undefined || typeof thumbprint.valueOf() !== 'string') {
                    throw new Error('thumbprint cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (certificateCancelDeletionOptions !== null && certificateCancelDeletionOptions !== undefined) {
                    timeout = certificateCancelDeletionOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (certificateCancelDeletionOptions !== null && certificateCancelDeletionOptions !== undefined) {
                    clientRequestId = certificateCancelDeletionOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (certificateCancelDeletionOptions !== null && certificateCancelDeletionOptions !== undefined) {
                    returnClientRequestId = certificateCancelDeletionOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (certificateCancelDeletionOptions !== null && certificateCancelDeletionOptions !== undefined) {
                    ocpDate = certificateCancelDeletionOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates(thumbprintAlgorithm={thumbprintAlgorithm},thumbprint={thumbprint})/canceldelete';
            requestUrl = requestUrl.replace('{thumbprintAlgorithm}', encodeURIComponent(thumbprintAlgorithm));
            requestUrl = requestUrl.replace('{thumbprint}', encodeURIComponent(thumbprint));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 204) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Deletes a certificate from the specified account.
     *
     * You cannot delete a certificate if a resource (pool or compute node) is
     * using it. Before you can delete a certificate, you must therefore make sure
     * that the certificate is not associated with any existing pools, the
     * certificate is not installed on any compute nodes (even if you remove a
     * certificate from a pool, it is not removed from existing compute nodes in
     * that pool until they restart), and no running tasks depend on the
     * certificate. If you try to delete a certificate that is in use, the deletion
     * fails. The certificate status changes to deleteFailed. You can use Cancel
     * Delete Certificate to set the status back to active if you decide that you
     * want to continue using the certificate.
     *
     * @param {string} thumbprintAlgorithm The algorithm used to derive the
     * thumbprint parameter. This must be sha1.
     *
     * @param {string} thumbprint The thumbprint of the certificate to be deleted.
     *
     * @param {CertificateDeleteMethodOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(thumbprintAlgorithm, thumbprint, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let certificateDeleteMethodOptions = (options && options.certificateDeleteMethodOptions !== undefined) ? options.certificateDeleteMethodOptions : undefined;
            // Validate
            try {
                if (thumbprintAlgorithm === null || thumbprintAlgorithm === undefined || typeof thumbprintAlgorithm.valueOf() !== 'string') {
                    throw new Error('thumbprintAlgorithm cannot be null or undefined and it must be of type string.');
                }
                if (thumbprint === null || thumbprint === undefined || typeof thumbprint.valueOf() !== 'string') {
                    throw new Error('thumbprint cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (certificateDeleteMethodOptions !== null && certificateDeleteMethodOptions !== undefined) {
                    timeout = certificateDeleteMethodOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (certificateDeleteMethodOptions !== null && certificateDeleteMethodOptions !== undefined) {
                    clientRequestId = certificateDeleteMethodOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (certificateDeleteMethodOptions !== null && certificateDeleteMethodOptions !== undefined) {
                    returnClientRequestId = certificateDeleteMethodOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (certificateDeleteMethodOptions !== null && certificateDeleteMethodOptions !== undefined) {
                    ocpDate = certificateDeleteMethodOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates(thumbprintAlgorithm={thumbprintAlgorithm},thumbprint={thumbprint})';
            requestUrl = requestUrl.replace('{thumbprintAlgorithm}', encodeURIComponent(thumbprintAlgorithm));
            requestUrl = requestUrl.replace('{thumbprint}', encodeURIComponent(thumbprint));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'DELETE';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets information about the specified certificate.
     *
     * @param {string} thumbprintAlgorithm The algorithm used to derive the
     * thumbprint parameter. This must be sha1.
     *
     * @param {string} thumbprint The thumbprint of the certificate to get.
     *
     * @param {CertificateGetOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(thumbprintAlgorithm, thumbprint, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let certificateGetOptions = (options && options.certificateGetOptions !== undefined) ? options.certificateGetOptions : undefined;
            // Validate
            try {
                if (thumbprintAlgorithm === null || thumbprintAlgorithm === undefined || typeof thumbprintAlgorithm.valueOf() !== 'string') {
                    throw new Error('thumbprintAlgorithm cannot be null or undefined and it must be of type string.');
                }
                if (thumbprint === null || thumbprint === undefined || typeof thumbprint.valueOf() !== 'string') {
                    throw new Error('thumbprint cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let select;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (certificateGetOptions !== null && certificateGetOptions !== undefined) {
                    select = certificateGetOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (certificateGetOptions !== null && certificateGetOptions !== undefined) {
                    timeout = certificateGetOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (certificateGetOptions !== null && certificateGetOptions !== undefined) {
                    clientRequestId = certificateGetOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (certificateGetOptions !== null && certificateGetOptions !== undefined) {
                    returnClientRequestId = certificateGetOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (certificateGetOptions !== null && certificateGetOptions !== undefined) {
                    ocpDate = certificateGetOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates(thumbprintAlgorithm={thumbprintAlgorithm},thumbprint={thumbprint})';
            requestUrl = requestUrl.replace('{thumbprintAlgorithm}', encodeURIComponent(thumbprintAlgorithm));
            requestUrl = requestUrl.replace('{thumbprint}', encodeURIComponent(thumbprint));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (select !== null && select !== undefined) {
                queryParamsArray.push('$select=' + encodeURIComponent(select));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.Certificate;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the certificates that have been added to the specified
     * account.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {CertificateListNextOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let certificateListNextOptions = (options && options.certificateListNextOptions !== undefined) ? options.certificateListNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (certificateListNextOptions !== null && certificateListNextOptions !== undefined) {
                    clientRequestId = certificateListNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (certificateListNextOptions !== null && certificateListNextOptions !== undefined) {
                    returnClientRequestId = certificateListNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (certificateListNextOptions !== null && certificateListNextOptions !== undefined) {
                    ocpDate = certificateListNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.CertificateListResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    add(certificate, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.addWithHttpOperationResponse(certificate, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.addWithHttpOperationResponse(certificate, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    list(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    cancelDeletion(thumbprintAlgorithm, thumbprint, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.cancelDeletionWithHttpOperationResponse(thumbprintAlgorithm, thumbprint, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.cancelDeletionWithHttpOperationResponse(thumbprintAlgorithm, thumbprint, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    deleteMethod(thumbprintAlgorithm, thumbprint, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteMethodWithHttpOperationResponse(thumbprintAlgorithm, thumbprint, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deleteMethodWithHttpOperationResponse(thumbprintAlgorithm, thumbprint, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    get(thumbprintAlgorithm, thumbprint, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(thumbprintAlgorithm, thumbprint, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getWithHttpOperationResponse(thumbprintAlgorithm, thumbprint, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
}
exports.CertificateOperations = CertificateOperations;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const msRest = __webpack_require__(1);
const Mappers = __webpack_require__(0);
const WebResource = msRest.WebResource;
/** Class representing a File. */
class File {
    /**
     * Create a File.
     * @param {BatchServiceClient} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Deletes the specified task file from the compute node where the
     * task ran.
     *
     * @param {string} jobId The ID of the job that contains the task.
     *
     * @param {string} taskId The ID of the task whose file you want to delete.
     *
     * @param {string} filePath The path to the task file or directory that you
     * want to delete.
     *
     * @param {FileDeleteFromTaskOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteFromTaskWithHttpOperationResponse(jobId, taskId, filePath, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let recursive = (options && options.recursive !== undefined) ? options.recursive : undefined;
            let fileDeleteFromTaskOptions = (options && options.fileDeleteFromTaskOptions !== undefined) ? options.fileDeleteFromTaskOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (filePath === null || filePath === undefined || typeof filePath.valueOf() !== 'string') {
                    throw new Error('filePath cannot be null or undefined and it must be of type string.');
                }
                if (recursive !== null && recursive !== undefined && typeof recursive !== 'boolean') {
                    throw new Error('recursive must be of type boolean.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (fileDeleteFromTaskOptions !== null && fileDeleteFromTaskOptions !== undefined) {
                    timeout = fileDeleteFromTaskOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (fileDeleteFromTaskOptions !== null && fileDeleteFromTaskOptions !== undefined) {
                    clientRequestId = fileDeleteFromTaskOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileDeleteFromTaskOptions !== null && fileDeleteFromTaskOptions !== undefined) {
                    returnClientRequestId = fileDeleteFromTaskOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileDeleteFromTaskOptions !== null && fileDeleteFromTaskOptions !== undefined) {
                    ocpDate = fileDeleteFromTaskOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/tasks/{taskId}/files/{filePath}';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            requestUrl = requestUrl.replace('{taskId}', encodeURIComponent(taskId));
            requestUrl = requestUrl.replace('{filePath}', encodeURIComponent(filePath));
            let queryParamsArray = [];
            if (recursive !== null && recursive !== undefined) {
                queryParamsArray.push('recursive=' + encodeURIComponent(recursive.toString()));
            }
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'DELETE';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Returns the content of the specified task file.
     *
     * @param {string} jobId The ID of the job that contains the task.
     *
     * @param {string} taskId The ID of the task whose file you want to retrieve.
     *
     * @param {string} filePath The path to the task file that you want to get the
     * content of.
     *
     * @param {FileGetFromTaskOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getFromTaskWithHttpOperationResponse(jobId, taskId, filePath, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let fileGetFromTaskOptions = (options && options.fileGetFromTaskOptions !== undefined) ? options.fileGetFromTaskOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (filePath === null || filePath === undefined || typeof filePath.valueOf() !== 'string') {
                    throw new Error('filePath cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ocpRange;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (fileGetFromTaskOptions !== null && fileGetFromTaskOptions !== undefined) {
                    timeout = fileGetFromTaskOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (fileGetFromTaskOptions !== null && fileGetFromTaskOptions !== undefined) {
                    clientRequestId = fileGetFromTaskOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileGetFromTaskOptions !== null && fileGetFromTaskOptions !== undefined) {
                    returnClientRequestId = fileGetFromTaskOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileGetFromTaskOptions !== null && fileGetFromTaskOptions !== undefined) {
                    ocpDate = fileGetFromTaskOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (fileGetFromTaskOptions !== null && fileGetFromTaskOptions !== undefined) {
                    ocpRange = fileGetFromTaskOptions.ocpRange;
                    if (ocpRange !== null && ocpRange !== undefined && typeof ocpRange.valueOf() !== 'string') {
                        throw new Error('ocpRange must be of type string.');
                    }
                }
                if (fileGetFromTaskOptions !== null && fileGetFromTaskOptions !== undefined) {
                    ifModifiedSince = fileGetFromTaskOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (fileGetFromTaskOptions !== null && fileGetFromTaskOptions !== undefined) {
                    ifUnmodifiedSince = fileGetFromTaskOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/tasks/{taskId}/files/{filePath}';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            requestUrl = requestUrl.replace('{taskId}', encodeURIComponent(taskId));
            requestUrl = requestUrl.replace('{filePath}', encodeURIComponent(filePath));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ocpRange !== undefined && ocpRange !== null) {
                httpRequest.headers['ocp-range'] = ocpRange;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            httpRequest.rawResponse = true;
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(`Unexpected status code: ${statusCode}`);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets the properties of the specified task file.
     *
     * @param {string} jobId The ID of the job that contains the task.
     *
     * @param {string} taskId The ID of the task whose file you want to get the
     * properties of.
     *
     * @param {string} filePath The path to the task file that you want to get the
     * properties of.
     *
     * @param {FileGetPropertiesFromTaskOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getPropertiesFromTaskWithHttpOperationResponse(jobId, taskId, filePath, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let fileGetPropertiesFromTaskOptions = (options && options.fileGetPropertiesFromTaskOptions !== undefined) ? options.fileGetPropertiesFromTaskOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (filePath === null || filePath === undefined || typeof filePath.valueOf() !== 'string') {
                    throw new Error('filePath cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (fileGetPropertiesFromTaskOptions !== null && fileGetPropertiesFromTaskOptions !== undefined) {
                    timeout = fileGetPropertiesFromTaskOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (fileGetPropertiesFromTaskOptions !== null && fileGetPropertiesFromTaskOptions !== undefined) {
                    clientRequestId = fileGetPropertiesFromTaskOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileGetPropertiesFromTaskOptions !== null && fileGetPropertiesFromTaskOptions !== undefined) {
                    returnClientRequestId = fileGetPropertiesFromTaskOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileGetPropertiesFromTaskOptions !== null && fileGetPropertiesFromTaskOptions !== undefined) {
                    ocpDate = fileGetPropertiesFromTaskOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (fileGetPropertiesFromTaskOptions !== null && fileGetPropertiesFromTaskOptions !== undefined) {
                    ifModifiedSince = fileGetPropertiesFromTaskOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (fileGetPropertiesFromTaskOptions !== null && fileGetPropertiesFromTaskOptions !== undefined) {
                    ifUnmodifiedSince = fileGetPropertiesFromTaskOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/tasks/{taskId}/files/{filePath}';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            requestUrl = requestUrl.replace('{taskId}', encodeURIComponent(taskId));
            requestUrl = requestUrl.replace('{filePath}', encodeURIComponent(filePath));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'HEAD';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Deletes the specified file from the compute node.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node from which you want to
     * delete the file.
     *
     * @param {string} filePath The path to the file or directory that you want to
     * delete.
     *
     * @param {FileDeleteFromComputeNodeOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteFromComputeNodeWithHttpOperationResponse(poolId, nodeId, filePath, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let recursive = (options && options.recursive !== undefined) ? options.recursive : undefined;
            let fileDeleteFromComputeNodeOptions = (options && options.fileDeleteFromComputeNodeOptions !== undefined) ? options.fileDeleteFromComputeNodeOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (filePath === null || filePath === undefined || typeof filePath.valueOf() !== 'string') {
                    throw new Error('filePath cannot be null or undefined and it must be of type string.');
                }
                if (recursive !== null && recursive !== undefined && typeof recursive !== 'boolean') {
                    throw new Error('recursive must be of type boolean.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (fileDeleteFromComputeNodeOptions !== null && fileDeleteFromComputeNodeOptions !== undefined) {
                    timeout = fileDeleteFromComputeNodeOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (fileDeleteFromComputeNodeOptions !== null && fileDeleteFromComputeNodeOptions !== undefined) {
                    clientRequestId = fileDeleteFromComputeNodeOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileDeleteFromComputeNodeOptions !== null && fileDeleteFromComputeNodeOptions !== undefined) {
                    returnClientRequestId = fileDeleteFromComputeNodeOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileDeleteFromComputeNodeOptions !== null && fileDeleteFromComputeNodeOptions !== undefined) {
                    ocpDate = fileDeleteFromComputeNodeOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes/{nodeId}/files/{filePath}';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            requestUrl = requestUrl.replace('{nodeId}', encodeURIComponent(nodeId));
            requestUrl = requestUrl.replace('{filePath}', encodeURIComponent(filePath));
            let queryParamsArray = [];
            if (recursive !== null && recursive !== undefined) {
                queryParamsArray.push('recursive=' + encodeURIComponent(recursive.toString()));
            }
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'DELETE';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Returns the content of the specified compute node file.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node that contains the file.
     *
     * @param {string} filePath The path to the compute node file that you want to
     * get the content of.
     *
     * @param {FileGetFromComputeNodeOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getFromComputeNodeWithHttpOperationResponse(poolId, nodeId, filePath, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let fileGetFromComputeNodeOptions = (options && options.fileGetFromComputeNodeOptions !== undefined) ? options.fileGetFromComputeNodeOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (filePath === null || filePath === undefined || typeof filePath.valueOf() !== 'string') {
                    throw new Error('filePath cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ocpRange;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (fileGetFromComputeNodeOptions !== null && fileGetFromComputeNodeOptions !== undefined) {
                    timeout = fileGetFromComputeNodeOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (fileGetFromComputeNodeOptions !== null && fileGetFromComputeNodeOptions !== undefined) {
                    clientRequestId = fileGetFromComputeNodeOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileGetFromComputeNodeOptions !== null && fileGetFromComputeNodeOptions !== undefined) {
                    returnClientRequestId = fileGetFromComputeNodeOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileGetFromComputeNodeOptions !== null && fileGetFromComputeNodeOptions !== undefined) {
                    ocpDate = fileGetFromComputeNodeOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (fileGetFromComputeNodeOptions !== null && fileGetFromComputeNodeOptions !== undefined) {
                    ocpRange = fileGetFromComputeNodeOptions.ocpRange;
                    if (ocpRange !== null && ocpRange !== undefined && typeof ocpRange.valueOf() !== 'string') {
                        throw new Error('ocpRange must be of type string.');
                    }
                }
                if (fileGetFromComputeNodeOptions !== null && fileGetFromComputeNodeOptions !== undefined) {
                    ifModifiedSince = fileGetFromComputeNodeOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (fileGetFromComputeNodeOptions !== null && fileGetFromComputeNodeOptions !== undefined) {
                    ifUnmodifiedSince = fileGetFromComputeNodeOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes/{nodeId}/files/{filePath}';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            requestUrl = requestUrl.replace('{nodeId}', encodeURIComponent(nodeId));
            requestUrl = requestUrl.replace('{filePath}', encodeURIComponent(filePath));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ocpRange !== undefined && ocpRange !== null) {
                httpRequest.headers['ocp-range'] = ocpRange;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            httpRequest.rawResponse = true;
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(`Unexpected status code: ${statusCode}`);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets the properties of the specified compute node file.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node that contains the file.
     *
     * @param {string} filePath The path to the compute node file that you want to
     * get the properties of.
     *
     * @param {FileGetPropertiesFromComputeNodeOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getPropertiesFromComputeNodeWithHttpOperationResponse(poolId, nodeId, filePath, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let fileGetPropertiesFromComputeNodeOptions = (options && options.fileGetPropertiesFromComputeNodeOptions !== undefined) ? options.fileGetPropertiesFromComputeNodeOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (filePath === null || filePath === undefined || typeof filePath.valueOf() !== 'string') {
                    throw new Error('filePath cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (fileGetPropertiesFromComputeNodeOptions !== null && fileGetPropertiesFromComputeNodeOptions !== undefined) {
                    timeout = fileGetPropertiesFromComputeNodeOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (fileGetPropertiesFromComputeNodeOptions !== null && fileGetPropertiesFromComputeNodeOptions !== undefined) {
                    clientRequestId = fileGetPropertiesFromComputeNodeOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileGetPropertiesFromComputeNodeOptions !== null && fileGetPropertiesFromComputeNodeOptions !== undefined) {
                    returnClientRequestId = fileGetPropertiesFromComputeNodeOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileGetPropertiesFromComputeNodeOptions !== null && fileGetPropertiesFromComputeNodeOptions !== undefined) {
                    ocpDate = fileGetPropertiesFromComputeNodeOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (fileGetPropertiesFromComputeNodeOptions !== null && fileGetPropertiesFromComputeNodeOptions !== undefined) {
                    ifModifiedSince = fileGetPropertiesFromComputeNodeOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (fileGetPropertiesFromComputeNodeOptions !== null && fileGetPropertiesFromComputeNodeOptions !== undefined) {
                    ifUnmodifiedSince = fileGetPropertiesFromComputeNodeOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes/{nodeId}/files/{filePath}';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            requestUrl = requestUrl.replace('{nodeId}', encodeURIComponent(nodeId));
            requestUrl = requestUrl.replace('{filePath}', encodeURIComponent(filePath));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'HEAD';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the files in a task's directory on its compute node.
     *
     * @param {string} jobId The ID of the job that contains the task.
     *
     * @param {string} taskId The ID of the task whose files you want to list.
     *
     * @param {FileListFromTaskOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listFromTaskWithHttpOperationResponse(jobId, taskId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let recursive = (options && options.recursive !== undefined) ? options.recursive : undefined;
            let fileListFromTaskOptions = (options && options.fileListFromTaskOptions !== undefined) ? options.fileListFromTaskOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (recursive !== null && recursive !== undefined && typeof recursive !== 'boolean') {
                    throw new Error('recursive must be of type boolean.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (fileListFromTaskOptions !== null && fileListFromTaskOptions !== undefined) {
                    filter = fileListFromTaskOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (fileListFromTaskOptions !== null && fileListFromTaskOptions !== undefined) {
                    maxResults = fileListFromTaskOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (fileListFromTaskOptions !== null && fileListFromTaskOptions !== undefined) {
                    timeout = fileListFromTaskOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (fileListFromTaskOptions !== null && fileListFromTaskOptions !== undefined) {
                    clientRequestId = fileListFromTaskOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileListFromTaskOptions !== null && fileListFromTaskOptions !== undefined) {
                    returnClientRequestId = fileListFromTaskOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileListFromTaskOptions !== null && fileListFromTaskOptions !== undefined) {
                    ocpDate = fileListFromTaskOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/tasks/{taskId}/files';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            requestUrl = requestUrl.replace('{taskId}', encodeURIComponent(taskId));
            let queryParamsArray = [];
            if (recursive !== null && recursive !== undefined) {
                queryParamsArray.push('recursive=' + encodeURIComponent(recursive.toString()));
            }
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (filter !== null && filter !== undefined) {
                queryParamsArray.push('$filter=' + encodeURIComponent(filter));
            }
            if (maxResults !== null && maxResults !== undefined) {
                queryParamsArray.push('maxresults=' + encodeURIComponent(maxResults.toString()));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.NodeFileListResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the files in task directories on the specified compute
     * node.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node whose files you want to
     * list.
     *
     * @param {FileListFromComputeNodeOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listFromComputeNodeWithHttpOperationResponse(poolId, nodeId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let recursive = (options && options.recursive !== undefined) ? options.recursive : undefined;
            let fileListFromComputeNodeOptions = (options && options.fileListFromComputeNodeOptions !== undefined) ? options.fileListFromComputeNodeOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (recursive !== null && recursive !== undefined && typeof recursive !== 'boolean') {
                    throw new Error('recursive must be of type boolean.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (fileListFromComputeNodeOptions !== null && fileListFromComputeNodeOptions !== undefined) {
                    filter = fileListFromComputeNodeOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (fileListFromComputeNodeOptions !== null && fileListFromComputeNodeOptions !== undefined) {
                    maxResults = fileListFromComputeNodeOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (fileListFromComputeNodeOptions !== null && fileListFromComputeNodeOptions !== undefined) {
                    timeout = fileListFromComputeNodeOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (fileListFromComputeNodeOptions !== null && fileListFromComputeNodeOptions !== undefined) {
                    clientRequestId = fileListFromComputeNodeOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileListFromComputeNodeOptions !== null && fileListFromComputeNodeOptions !== undefined) {
                    returnClientRequestId = fileListFromComputeNodeOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileListFromComputeNodeOptions !== null && fileListFromComputeNodeOptions !== undefined) {
                    ocpDate = fileListFromComputeNodeOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes/{nodeId}/files';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            requestUrl = requestUrl.replace('{nodeId}', encodeURIComponent(nodeId));
            let queryParamsArray = [];
            if (recursive !== null && recursive !== undefined) {
                queryParamsArray.push('recursive=' + encodeURIComponent(recursive.toString()));
            }
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (filter !== null && filter !== undefined) {
                queryParamsArray.push('$filter=' + encodeURIComponent(filter));
            }
            if (maxResults !== null && maxResults !== undefined) {
                queryParamsArray.push('maxresults=' + encodeURIComponent(maxResults.toString()));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.NodeFileListResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the files in a task's directory on its compute node.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {FileListFromTaskNextOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listFromTaskNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let fileListFromTaskNextOptions = (options && options.fileListFromTaskNextOptions !== undefined) ? options.fileListFromTaskNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (fileListFromTaskNextOptions !== null && fileListFromTaskNextOptions !== undefined) {
                    clientRequestId = fileListFromTaskNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileListFromTaskNextOptions !== null && fileListFromTaskNextOptions !== undefined) {
                    returnClientRequestId = fileListFromTaskNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileListFromTaskNextOptions !== null && fileListFromTaskNextOptions !== undefined) {
                    ocpDate = fileListFromTaskNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.NodeFileListResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the files in task directories on the specified compute
     * node.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {FileListFromComputeNodeNextOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listFromComputeNodeNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let fileListFromComputeNodeNextOptions = (options && options.fileListFromComputeNodeNextOptions !== undefined) ? options.fileListFromComputeNodeNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (fileListFromComputeNodeNextOptions !== null && fileListFromComputeNodeNextOptions !== undefined) {
                    clientRequestId = fileListFromComputeNodeNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileListFromComputeNodeNextOptions !== null && fileListFromComputeNodeNextOptions !== undefined) {
                    returnClientRequestId = fileListFromComputeNodeNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileListFromComputeNodeNextOptions !== null && fileListFromComputeNodeNextOptions !== undefined) {
                    ocpDate = fileListFromComputeNodeNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.NodeFileListResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    deleteFromTask(jobId, taskId, filePath, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteFromTaskWithHttpOperationResponse(jobId, taskId, filePath, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deleteFromTaskWithHttpOperationResponse(jobId, taskId, filePath, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    getFromTask(jobId, taskId, filePath, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getFromTaskWithHttpOperationResponse(jobId, taskId, filePath, options).then((operationRes) => {
                return Promise.resolve(operationRes.response);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getFromTaskWithHttpOperationResponse(jobId, taskId, filePath, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.response;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    getPropertiesFromTask(jobId, taskId, filePath, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getPropertiesFromTaskWithHttpOperationResponse(jobId, taskId, filePath, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getPropertiesFromTaskWithHttpOperationResponse(jobId, taskId, filePath, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    deleteFromComputeNode(poolId, nodeId, filePath, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteFromComputeNodeWithHttpOperationResponse(poolId, nodeId, filePath, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deleteFromComputeNodeWithHttpOperationResponse(poolId, nodeId, filePath, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    getFromComputeNode(poolId, nodeId, filePath, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getFromComputeNodeWithHttpOperationResponse(poolId, nodeId, filePath, options).then((operationRes) => {
                return Promise.resolve(operationRes.response);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getFromComputeNodeWithHttpOperationResponse(poolId, nodeId, filePath, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.response;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    getPropertiesFromComputeNode(poolId, nodeId, filePath, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getPropertiesFromComputeNodeWithHttpOperationResponse(poolId, nodeId, filePath, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getPropertiesFromComputeNodeWithHttpOperationResponse(poolId, nodeId, filePath, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listFromTask(jobId, taskId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listFromTaskWithHttpOperationResponse(jobId, taskId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listFromTaskWithHttpOperationResponse(jobId, taskId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listFromComputeNode(poolId, nodeId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listFromComputeNodeWithHttpOperationResponse(poolId, nodeId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listFromComputeNodeWithHttpOperationResponse(poolId, nodeId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listFromTaskNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listFromTaskNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listFromTaskNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listFromComputeNodeNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listFromComputeNodeNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listFromComputeNodeNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
}
exports.File = File;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const msRest = __webpack_require__(1);
const Mappers = __webpack_require__(0);
const WebResource = msRest.WebResource;
/** Class representing a JobSchedule. */
class JobSchedule {
    /**
     * Create a JobSchedule.
     * @param {BatchServiceClient} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Checks the specified job schedule exists.
     *
     * @param {string} jobScheduleId The ID of the job schedule which you want to
     * check.
     *
     * @param {JobScheduleExistsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    existsWithHttpOperationResponse(jobScheduleId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleExistsOptions = (options && options.jobScheduleExistsOptions !== undefined) ? options.jobScheduleExistsOptions : undefined;
            // Validate
            try {
                if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
                    throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined) {
                    timeout = jobScheduleExistsOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined) {
                    clientRequestId = jobScheduleExistsOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined) {
                    returnClientRequestId = jobScheduleExistsOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined) {
                    ocpDate = jobScheduleExistsOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined) {
                    ifMatch = jobScheduleExistsOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined) {
                    ifNoneMatch = jobScheduleExistsOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined) {
                    ifModifiedSince = jobScheduleExistsOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined) {
                    ifUnmodifiedSince = jobScheduleExistsOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobschedules/{jobScheduleId}';
            requestUrl = requestUrl.replace('{jobScheduleId}', encodeURIComponent(jobScheduleId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'HEAD';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200 && statusCode !== 404) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                operationRes.bodyAsJson = (statusCode === 200);
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Deletes a job schedule from the specified account.
     *
     * When you delete a job schedule, this also deletes all jobs and tasks under
     * that schedule. When tasks are deleted, all the files in their working
     * directories on the compute nodes are also deleted (the retention period is
     * ignored). The job schedule statistics are no longer accessible once the job
     * schedule is deleted, though they are still counted towards account lifetime
     * statistics.
     *
     * @param {string} jobScheduleId The ID of the job schedule to delete.
     *
     * @param {JobScheduleDeleteMethodOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(jobScheduleId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleDeleteMethodOptions = (options && options.jobScheduleDeleteMethodOptions !== undefined) ? options.jobScheduleDeleteMethodOptions : undefined;
            // Validate
            try {
                if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
                    throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined) {
                    timeout = jobScheduleDeleteMethodOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined) {
                    clientRequestId = jobScheduleDeleteMethodOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined) {
                    returnClientRequestId = jobScheduleDeleteMethodOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined) {
                    ocpDate = jobScheduleDeleteMethodOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined) {
                    ifMatch = jobScheduleDeleteMethodOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined) {
                    ifNoneMatch = jobScheduleDeleteMethodOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined) {
                    ifModifiedSince = jobScheduleDeleteMethodOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined) {
                    ifUnmodifiedSince = jobScheduleDeleteMethodOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobschedules/{jobScheduleId}';
            requestUrl = requestUrl.replace('{jobScheduleId}', encodeURIComponent(jobScheduleId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'DELETE';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets information about the specified job schedule.
     *
     * @param {string} jobScheduleId The ID of the job schedule to get.
     *
     * @param {JobScheduleGetOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(jobScheduleId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleGetOptions = (options && options.jobScheduleGetOptions !== undefined) ? options.jobScheduleGetOptions : undefined;
            // Validate
            try {
                if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
                    throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let select;
            let expand;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    select = jobScheduleGetOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    expand = jobScheduleGetOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    timeout = jobScheduleGetOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    clientRequestId = jobScheduleGetOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    returnClientRequestId = jobScheduleGetOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    ocpDate = jobScheduleGetOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    ifMatch = jobScheduleGetOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    ifNoneMatch = jobScheduleGetOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    ifModifiedSince = jobScheduleGetOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    ifUnmodifiedSince = jobScheduleGetOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobschedules/{jobScheduleId}';
            requestUrl = requestUrl.replace('{jobScheduleId}', encodeURIComponent(jobScheduleId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (select !== null && select !== undefined) {
                queryParamsArray.push('$select=' + encodeURIComponent(select));
            }
            if (expand !== null && expand !== undefined) {
                queryParamsArray.push('$expand=' + encodeURIComponent(expand));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.CloudJobSchedule;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Updates the properties of the specified job schedule.
     *
     * This replaces only the job schedule properties specified in the request. For
     * example, if the schedule property is not specified with this request, then
     * the Batch service will keep the existing schedule. Changes to a job schedule
     * only impact jobs created by the schedule after the update has taken place;
     * currently running jobs are unaffected.
     *
     * @param {string} jobScheduleId The ID of the job schedule to update.
     *
     * @param {JobSchedulePatchParameter} jobSchedulePatchParameter The parameters
     * for the request.
     *
     * @param {JobSchedulePatchOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    patchWithHttpOperationResponse(jobScheduleId, jobSchedulePatchParameter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobSchedulePatchOptions = (options && options.jobSchedulePatchOptions !== undefined) ? options.jobSchedulePatchOptions : undefined;
            if (jobSchedulePatchParameter === null || jobSchedulePatchParameter === undefined) {
                jobSchedulePatchParameter = {};
            }
            // Validate
            try {
                if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
                    throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
                }
                if (jobSchedulePatchParameter === null || jobSchedulePatchParameter === undefined) {
                    throw new Error('jobSchedulePatchParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined) {
                    timeout = jobSchedulePatchOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined) {
                    clientRequestId = jobSchedulePatchOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined) {
                    returnClientRequestId = jobSchedulePatchOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined) {
                    ocpDate = jobSchedulePatchOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined) {
                    ifMatch = jobSchedulePatchOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined) {
                    ifNoneMatch = jobSchedulePatchOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined) {
                    ifModifiedSince = jobSchedulePatchOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined) {
                    ifUnmodifiedSince = jobSchedulePatchOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobschedules/{jobScheduleId}';
            requestUrl = requestUrl.replace('{jobScheduleId}', encodeURIComponent(jobScheduleId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'PATCH';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (jobSchedulePatchParameter !== null && jobSchedulePatchParameter !== undefined) {
                    let requestModelMapper = Mappers.JobSchedulePatchParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, jobSchedulePatchParameter, 'jobSchedulePatchParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(jobSchedulePatchParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Updates the properties of the specified job schedule.
     *
     * This fully replaces all the updateable properties of the job schedule. For
     * example, if the schedule property is not specified with this request, then
     * the Batch service will remove the existing schedule. Changes to a job
     * schedule only impact jobs created by the schedule after the update has taken
     * place; currently running jobs are unaffected.
     *
     * @param {string} jobScheduleId The ID of the job schedule to update.
     *
     * @param {JobScheduleUpdateParameter} jobScheduleUpdateParameter The
     * parameters for the request.
     *
     * @param {JobScheduleUpdateOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updateWithHttpOperationResponse(jobScheduleId, jobScheduleUpdateParameter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleUpdateOptions = (options && options.jobScheduleUpdateOptions !== undefined) ? options.jobScheduleUpdateOptions : undefined;
            if (jobScheduleUpdateParameter === null || jobScheduleUpdateParameter === undefined) {
                jobScheduleUpdateParameter = {};
            }
            // Validate
            try {
                if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
                    throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
                }
                if (jobScheduleUpdateParameter === null || jobScheduleUpdateParameter === undefined) {
                    throw new Error('jobScheduleUpdateParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined) {
                    timeout = jobScheduleUpdateOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined) {
                    clientRequestId = jobScheduleUpdateOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined) {
                    returnClientRequestId = jobScheduleUpdateOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined) {
                    ocpDate = jobScheduleUpdateOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined) {
                    ifMatch = jobScheduleUpdateOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined) {
                    ifNoneMatch = jobScheduleUpdateOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined) {
                    ifModifiedSince = jobScheduleUpdateOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined) {
                    ifUnmodifiedSince = jobScheduleUpdateOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobschedules/{jobScheduleId}';
            requestUrl = requestUrl.replace('{jobScheduleId}', encodeURIComponent(jobScheduleId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'PUT';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (jobScheduleUpdateParameter !== null && jobScheduleUpdateParameter !== undefined) {
                    let requestModelMapper = Mappers.JobScheduleUpdateParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, jobScheduleUpdateParameter, 'jobScheduleUpdateParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(jobScheduleUpdateParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Disables a job schedule.
     *
     * No new jobs will be created until the job schedule is enabled again.
     *
     * @param {string} jobScheduleId The ID of the job schedule to disable.
     *
     * @param {JobScheduleDisableOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    disableWithHttpOperationResponse(jobScheduleId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleDisableOptions = (options && options.jobScheduleDisableOptions !== undefined) ? options.jobScheduleDisableOptions : undefined;
            // Validate
            try {
                if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
                    throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined) {
                    timeout = jobScheduleDisableOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined) {
                    clientRequestId = jobScheduleDisableOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined) {
                    returnClientRequestId = jobScheduleDisableOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined) {
                    ocpDate = jobScheduleDisableOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined) {
                    ifMatch = jobScheduleDisableOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined) {
                    ifNoneMatch = jobScheduleDisableOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined) {
                    ifModifiedSince = jobScheduleDisableOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined) {
                    ifUnmodifiedSince = jobScheduleDisableOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobschedules/{jobScheduleId}/disable';
            requestUrl = requestUrl.replace('{jobScheduleId}', encodeURIComponent(jobScheduleId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 204) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Enables a job schedule.
     *
     * @param {string} jobScheduleId The ID of the job schedule to enable.
     *
     * @param {JobScheduleEnableOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    enableWithHttpOperationResponse(jobScheduleId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleEnableOptions = (options && options.jobScheduleEnableOptions !== undefined) ? options.jobScheduleEnableOptions : undefined;
            // Validate
            try {
                if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
                    throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined) {
                    timeout = jobScheduleEnableOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined) {
                    clientRequestId = jobScheduleEnableOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined) {
                    returnClientRequestId = jobScheduleEnableOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined) {
                    ocpDate = jobScheduleEnableOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined) {
                    ifMatch = jobScheduleEnableOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined) {
                    ifNoneMatch = jobScheduleEnableOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined) {
                    ifModifiedSince = jobScheduleEnableOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined) {
                    ifUnmodifiedSince = jobScheduleEnableOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobschedules/{jobScheduleId}/enable';
            requestUrl = requestUrl.replace('{jobScheduleId}', encodeURIComponent(jobScheduleId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 204) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Terminates a job schedule.
     *
     * @param {string} jobScheduleId The ID of the job schedule to terminates.
     *
     * @param {JobScheduleTerminateOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    terminateWithHttpOperationResponse(jobScheduleId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleTerminateOptions = (options && options.jobScheduleTerminateOptions !== undefined) ? options.jobScheduleTerminateOptions : undefined;
            // Validate
            try {
                if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
                    throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined) {
                    timeout = jobScheduleTerminateOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined) {
                    clientRequestId = jobScheduleTerminateOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined) {
                    returnClientRequestId = jobScheduleTerminateOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined) {
                    ocpDate = jobScheduleTerminateOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined) {
                    ifMatch = jobScheduleTerminateOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined) {
                    ifNoneMatch = jobScheduleTerminateOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined) {
                    ifModifiedSince = jobScheduleTerminateOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined) {
                    ifUnmodifiedSince = jobScheduleTerminateOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobschedules/{jobScheduleId}/terminate';
            requestUrl = requestUrl.replace('{jobScheduleId}', encodeURIComponent(jobScheduleId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Adds a job schedule to the specified account.
     *
     * @param {JobScheduleAddParameter} cloudJobSchedule The job schedule to be
     * added.
     *
     * @param {JobScheduleAddOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addWithHttpOperationResponse(cloudJobSchedule, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleAddOptions = (options && options.jobScheduleAddOptions !== undefined) ? options.jobScheduleAddOptions : undefined;
            if (cloudJobSchedule === null || cloudJobSchedule === undefined) {
                cloudJobSchedule = {};
            }
            // Validate
            try {
                if (cloudJobSchedule === null || cloudJobSchedule === undefined) {
                    throw new Error('cloudJobSchedule cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobScheduleAddOptions !== null && jobScheduleAddOptions !== undefined) {
                    timeout = jobScheduleAddOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobScheduleAddOptions !== null && jobScheduleAddOptions !== undefined) {
                    clientRequestId = jobScheduleAddOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleAddOptions !== null && jobScheduleAddOptions !== undefined) {
                    returnClientRequestId = jobScheduleAddOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleAddOptions !== null && jobScheduleAddOptions !== undefined) {
                    ocpDate = jobScheduleAddOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobschedules';
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (cloudJobSchedule !== null && cloudJobSchedule !== undefined) {
                    let requestModelMapper = Mappers.JobScheduleAddParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, cloudJobSchedule, 'cloudJobSchedule');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(cloudJobSchedule, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 201) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the job schedules in the specified account.
     *
     * @param {JobScheduleListOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleListOptions = (options && options.jobScheduleListOptions !== undefined) ? options.jobScheduleListOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let select;
            let expand;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined) {
                    filter = jobScheduleListOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined) {
                    select = jobScheduleListOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined) {
                    expand = jobScheduleListOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined) {
                    maxResults = jobScheduleListOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined) {
                    timeout = jobScheduleListOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined) {
                    clientRequestId = jobScheduleListOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined) {
                    returnClientRequestId = jobScheduleListOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined) {
                    ocpDate = jobScheduleListOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobschedules';
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (filter !== null && filter !== undefined) {
                queryParamsArray.push('$filter=' + encodeURIComponent(filter));
            }
            if (select !== null && select !== undefined) {
                queryParamsArray.push('$select=' + encodeURIComponent(select));
            }
            if (expand !== null && expand !== undefined) {
                queryParamsArray.push('$expand=' + encodeURIComponent(expand));
            }
            if (maxResults !== null && maxResults !== undefined) {
                queryParamsArray.push('maxresults=' + encodeURIComponent(maxResults.toString()));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.CloudJobScheduleListResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the job schedules in the specified account.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {JobScheduleListNextOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleListNextOptions = (options && options.jobScheduleListNextOptions !== undefined) ? options.jobScheduleListNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobScheduleListNextOptions !== null && jobScheduleListNextOptions !== undefined) {
                    clientRequestId = jobScheduleListNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleListNextOptions !== null && jobScheduleListNextOptions !== undefined) {
                    returnClientRequestId = jobScheduleListNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleListNextOptions !== null && jobScheduleListNextOptions !== undefined) {
                    ocpDate = jobScheduleListNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.CloudJobScheduleListResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    exists(jobScheduleId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.existsWithHttpOperationResponse(jobScheduleId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.existsWithHttpOperationResponse(jobScheduleId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    deleteMethod(jobScheduleId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteMethodWithHttpOperationResponse(jobScheduleId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deleteMethodWithHttpOperationResponse(jobScheduleId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    get(jobScheduleId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(jobScheduleId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getWithHttpOperationResponse(jobScheduleId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    patch(jobScheduleId, jobSchedulePatchParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.patchWithHttpOperationResponse(jobScheduleId, jobSchedulePatchParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.patchWithHttpOperationResponse(jobScheduleId, jobSchedulePatchParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    update(jobScheduleId, jobScheduleUpdateParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.updateWithHttpOperationResponse(jobScheduleId, jobScheduleUpdateParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.updateWithHttpOperationResponse(jobScheduleId, jobScheduleUpdateParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    disable(jobScheduleId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.disableWithHttpOperationResponse(jobScheduleId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.disableWithHttpOperationResponse(jobScheduleId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    enable(jobScheduleId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.enableWithHttpOperationResponse(jobScheduleId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.enableWithHttpOperationResponse(jobScheduleId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    terminate(jobScheduleId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.terminateWithHttpOperationResponse(jobScheduleId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.terminateWithHttpOperationResponse(jobScheduleId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    add(cloudJobSchedule, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.addWithHttpOperationResponse(cloudJobSchedule, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.addWithHttpOperationResponse(cloudJobSchedule, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    list(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
}
exports.JobSchedule = JobSchedule;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const msRest = __webpack_require__(1);
const Mappers = __webpack_require__(0);
const WebResource = msRest.WebResource;
/** Class representing a Task. */
class Task {
    /**
     * Create a Task.
     * @param {BatchServiceClient} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Adds a task to the specified job.
     *
     * The maximum lifetime of a task from addition to completion is 7 days. If a
     * task has not completed within 7 days of being added it will be terminated by
     * the Batch service and left in whatever state it was in at that time.
     *
     * @param {string} jobId The ID of the job to which the task is to be added.
     *
     * @param {TaskAddParameter} task The task to be added.
     *
     * @param {TaskAddOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addWithHttpOperationResponse(jobId, task, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let taskAddOptions = (options && options.taskAddOptions !== undefined) ? options.taskAddOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (task === null || task === undefined) {
                    throw new Error('task cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (taskAddOptions !== null && taskAddOptions !== undefined) {
                    timeout = taskAddOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (taskAddOptions !== null && taskAddOptions !== undefined) {
                    clientRequestId = taskAddOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskAddOptions !== null && taskAddOptions !== undefined) {
                    returnClientRequestId = taskAddOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskAddOptions !== null && taskAddOptions !== undefined) {
                    ocpDate = taskAddOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/tasks';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (task !== null && task !== undefined) {
                    let requestModelMapper = Mappers.TaskAddParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, task, 'task');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(task, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 201) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the tasks that are associated with the specified job.
     *
     * For multi-instance tasks, information such as affinityId, executionInfo and
     * nodeInfo refer to the primary task. Use the list subtasks API to retrieve
     * information about subtasks.
     *
     * @param {string} jobId The ID of the job.
     *
     * @param {TaskListOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(jobId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let taskListOptions = (options && options.taskListOptions !== undefined) ? options.taskListOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let select;
            let expand;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (taskListOptions !== null && taskListOptions !== undefined) {
                    filter = taskListOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (taskListOptions !== null && taskListOptions !== undefined) {
                    select = taskListOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (taskListOptions !== null && taskListOptions !== undefined) {
                    expand = taskListOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (taskListOptions !== null && taskListOptions !== undefined) {
                    maxResults = taskListOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (taskListOptions !== null && taskListOptions !== undefined) {
                    timeout = taskListOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (taskListOptions !== null && taskListOptions !== undefined) {
                    clientRequestId = taskListOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskListOptions !== null && taskListOptions !== undefined) {
                    returnClientRequestId = taskListOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskListOptions !== null && taskListOptions !== undefined) {
                    ocpDate = taskListOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/tasks';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (filter !== null && filter !== undefined) {
                queryParamsArray.push('$filter=' + encodeURIComponent(filter));
            }
            if (select !== null && select !== undefined) {
                queryParamsArray.push('$select=' + encodeURIComponent(select));
            }
            if (expand !== null && expand !== undefined) {
                queryParamsArray.push('$expand=' + encodeURIComponent(expand));
            }
            if (maxResults !== null && maxResults !== undefined) {
                queryParamsArray.push('maxresults=' + encodeURIComponent(maxResults.toString()));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.CloudTaskListResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Adds a collection of tasks to the specified job.
     *
     * Note that each task must have a unique ID. The Batch service may not return
     * the results for each task in the same order the tasks were submitted in this
     * request. If the server times out or the connection is closed during the
     * request, the request may have been partially or fully processed, or not at
     * all. In such cases, the user should re-issue the request. Note that it is up
     * to the user to correctly handle failures when re-issuing a request. For
     * example, you should use the same task IDs during a retry so that if the
     * prior operation succeeded, the retry will not create extra tasks
     * unexpectedly. If the response contains any tasks which failed to add, a
     * client can retry the request. In a retry, it is most efficient to resubmit
     * only tasks that failed to add, and to omit tasks that were successfully
     * added on the first attempt. The maximum lifetime of a task from addition to
     * completion is 7 days. If a task has not completed within 7 days of being
     * added it will be terminated by the Batch service and left in whatever state
     * it was in at that time.
     *
     * @param {string} jobId The ID of the job to which the task collection is to
     * be added.
     *
     * @param {TaskAddParameter[]} value The collection of tasks to add. The total
     * serialized size of this collection must be less than 4MB. If it is greater
     * than 4MB (for example if each task has 100's of resource files or
     * environment variables), the request will fail with code
     * 'RequestBodyTooLarge' and should be retried again with fewer tasks.
     *
     * @param {TaskAddCollectionOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addCollectionWithHttpOperationResponse(jobId, value, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let taskAddCollectionOptions = (options && options.taskAddCollectionOptions !== undefined) ? options.taskAddCollectionOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (value !== null && value !== undefined) {
                    if (value.length > 100) {
                        throw new Error('"value" should satisfy the constraint - "MaxItems": 100');
                    }
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let taskCollection = {};
            try {
                if (taskAddCollectionOptions !== null && taskAddCollectionOptions !== undefined) {
                    timeout = taskAddCollectionOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (taskAddCollectionOptions !== null && taskAddCollectionOptions !== undefined) {
                    clientRequestId = taskAddCollectionOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskAddCollectionOptions !== null && taskAddCollectionOptions !== undefined) {
                    returnClientRequestId = taskAddCollectionOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskAddCollectionOptions !== null && taskAddCollectionOptions !== undefined) {
                    ocpDate = taskAddCollectionOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (value !== null && value !== undefined) {
                    taskCollection.value = value;
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/addtaskcollection';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (taskCollection !== null && taskCollection !== undefined) {
                    let requestModelMapper = Mappers.TaskAddCollectionParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, taskCollection, 'taskCollection');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(taskCollection, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.TaskAddCollectionResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Deletes a task from the specified job.
     *
     * When a task is deleted, all of the files in its directory on the compute
     * node where it ran are also deleted (regardless of the retention time). For
     * multi-instance tasks, the delete task operation applies synchronously to the
     * primary task; subtasks and their files are then deleted asynchronously in
     * the background.
     *
     * @param {string} jobId The ID of the job from which to delete the task.
     *
     * @param {string} taskId The ID of the task to delete.
     *
     * @param {TaskDeleteMethodOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(jobId, taskId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let taskDeleteMethodOptions = (options && options.taskDeleteMethodOptions !== undefined) ? options.taskDeleteMethodOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (taskDeleteMethodOptions !== null && taskDeleteMethodOptions !== undefined) {
                    timeout = taskDeleteMethodOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (taskDeleteMethodOptions !== null && taskDeleteMethodOptions !== undefined) {
                    clientRequestId = taskDeleteMethodOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskDeleteMethodOptions !== null && taskDeleteMethodOptions !== undefined) {
                    returnClientRequestId = taskDeleteMethodOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskDeleteMethodOptions !== null && taskDeleteMethodOptions !== undefined) {
                    ocpDate = taskDeleteMethodOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (taskDeleteMethodOptions !== null && taskDeleteMethodOptions !== undefined) {
                    ifMatch = taskDeleteMethodOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (taskDeleteMethodOptions !== null && taskDeleteMethodOptions !== undefined) {
                    ifNoneMatch = taskDeleteMethodOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (taskDeleteMethodOptions !== null && taskDeleteMethodOptions !== undefined) {
                    ifModifiedSince = taskDeleteMethodOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (taskDeleteMethodOptions !== null && taskDeleteMethodOptions !== undefined) {
                    ifUnmodifiedSince = taskDeleteMethodOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/tasks/{taskId}';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            requestUrl = requestUrl.replace('{taskId}', encodeURIComponent(taskId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'DELETE';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets information about the specified task.
     *
     * For multi-instance tasks, information such as affinityId, executionInfo and
     * nodeInfo refer to the primary task. Use the list subtasks API to retrieve
     * information about subtasks.
     *
     * @param {string} jobId The ID of the job that contains the task.
     *
     * @param {string} taskId The ID of the task to get information about.
     *
     * @param {TaskGetOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(jobId, taskId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let taskGetOptions = (options && options.taskGetOptions !== undefined) ? options.taskGetOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let select;
            let expand;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    select = taskGetOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    expand = taskGetOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    timeout = taskGetOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    clientRequestId = taskGetOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    returnClientRequestId = taskGetOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    ocpDate = taskGetOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    ifMatch = taskGetOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    ifNoneMatch = taskGetOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    ifModifiedSince = taskGetOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    ifUnmodifiedSince = taskGetOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/tasks/{taskId}';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            requestUrl = requestUrl.replace('{taskId}', encodeURIComponent(taskId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (select !== null && select !== undefined) {
                queryParamsArray.push('$select=' + encodeURIComponent(select));
            }
            if (expand !== null && expand !== undefined) {
                queryParamsArray.push('$expand=' + encodeURIComponent(expand));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.CloudTask;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Updates the properties of the specified task.
     *
     * @param {string} jobId The ID of the job containing the task.
     *
     * @param {string} taskId The ID of the task to update.
     *
     * @param {TaskUpdateOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updateWithHttpOperationResponse(jobId, taskId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let constraints = (options && options.constraints !== undefined) ? options.constraints : undefined;
            let taskUpdateOptions = (options && options.taskUpdateOptions !== undefined) ? options.taskUpdateOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            let taskUpdateParameter = {};
            try {
                if (taskUpdateOptions !== null && taskUpdateOptions !== undefined) {
                    timeout = taskUpdateOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (taskUpdateOptions !== null && taskUpdateOptions !== undefined) {
                    clientRequestId = taskUpdateOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskUpdateOptions !== null && taskUpdateOptions !== undefined) {
                    returnClientRequestId = taskUpdateOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskUpdateOptions !== null && taskUpdateOptions !== undefined) {
                    ocpDate = taskUpdateOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (taskUpdateOptions !== null && taskUpdateOptions !== undefined) {
                    ifMatch = taskUpdateOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (taskUpdateOptions !== null && taskUpdateOptions !== undefined) {
                    ifNoneMatch = taskUpdateOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (taskUpdateOptions !== null && taskUpdateOptions !== undefined) {
                    ifModifiedSince = taskUpdateOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (taskUpdateOptions !== null && taskUpdateOptions !== undefined) {
                    ifUnmodifiedSince = taskUpdateOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
                if (constraints !== null && constraints !== undefined) {
                    taskUpdateParameter.constraints = constraints;
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/tasks/{taskId}';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            requestUrl = requestUrl.replace('{taskId}', encodeURIComponent(taskId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'PUT';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (taskUpdateParameter !== null && taskUpdateParameter !== undefined) {
                    let requestModelMapper = Mappers.TaskUpdateParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, taskUpdateParameter, 'taskUpdateParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(taskUpdateParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the subtasks that are associated with the specified
     * multi-instance task.
     *
     * If the task is not a multi-instance task then this returns an empty
     * collection.
     *
     * @param {string} jobId The ID of the job.
     *
     * @param {string} taskId The ID of the task.
     *
     * @param {TaskListSubtasksOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listSubtasksWithHttpOperationResponse(jobId, taskId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let taskListSubtasksOptions = (options && options.taskListSubtasksOptions !== undefined) ? options.taskListSubtasksOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let select;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (taskListSubtasksOptions !== null && taskListSubtasksOptions !== undefined) {
                    select = taskListSubtasksOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (taskListSubtasksOptions !== null && taskListSubtasksOptions !== undefined) {
                    timeout = taskListSubtasksOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (taskListSubtasksOptions !== null && taskListSubtasksOptions !== undefined) {
                    clientRequestId = taskListSubtasksOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskListSubtasksOptions !== null && taskListSubtasksOptions !== undefined) {
                    returnClientRequestId = taskListSubtasksOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskListSubtasksOptions !== null && taskListSubtasksOptions !== undefined) {
                    ocpDate = taskListSubtasksOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/tasks/{taskId}/subtasksinfo';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            requestUrl = requestUrl.replace('{taskId}', encodeURIComponent(taskId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (select !== null && select !== undefined) {
                queryParamsArray.push('$select=' + encodeURIComponent(select));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.CloudTaskListSubtasksResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Terminates the specified task.
     *
     * When the task has been terminated, it moves to the completed state. For
     * multi-instance tasks, the terminate task operation applies synchronously to
     * the primary task; subtasks are then terminated asynchronously in the
     * background.
     *
     * @param {string} jobId The ID of the job containing the task.
     *
     * @param {string} taskId The ID of the task to terminate.
     *
     * @param {TaskTerminateOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    terminateWithHttpOperationResponse(jobId, taskId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let taskTerminateOptions = (options && options.taskTerminateOptions !== undefined) ? options.taskTerminateOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (taskTerminateOptions !== null && taskTerminateOptions !== undefined) {
                    timeout = taskTerminateOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (taskTerminateOptions !== null && taskTerminateOptions !== undefined) {
                    clientRequestId = taskTerminateOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskTerminateOptions !== null && taskTerminateOptions !== undefined) {
                    returnClientRequestId = taskTerminateOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskTerminateOptions !== null && taskTerminateOptions !== undefined) {
                    ocpDate = taskTerminateOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (taskTerminateOptions !== null && taskTerminateOptions !== undefined) {
                    ifMatch = taskTerminateOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (taskTerminateOptions !== null && taskTerminateOptions !== undefined) {
                    ifNoneMatch = taskTerminateOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (taskTerminateOptions !== null && taskTerminateOptions !== undefined) {
                    ifModifiedSince = taskTerminateOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (taskTerminateOptions !== null && taskTerminateOptions !== undefined) {
                    ifUnmodifiedSince = taskTerminateOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/tasks/{taskId}/terminate';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            requestUrl = requestUrl.replace('{taskId}', encodeURIComponent(taskId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 204) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Reactivates a task, allowing it to run again even if its retry
     * count has been exhausted.
     *
     * Reactivation makes a task eligible to be retried again up to its maximum
     * retry count. The task's state is changed to active. As the task is no longer
     * in the completed state, any previous exit code or failure information is no
     * longer available after reactivation. Each time a task is reactivated, its
     * retry count is reset to 0. Reactivation will fail for tasks that are not
     * completed or that previously completed successfully (with an exit code of
     * 0). Additionally, it will fail if the job has completed (or is terminating
     * or deleting).
     *
     * @param {string} jobId The ID of the job containing the task.
     *
     * @param {string} taskId The ID of the task to reactivate.
     *
     * @param {TaskReactivateOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    reactivateWithHttpOperationResponse(jobId, taskId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let taskReactivateOptions = (options && options.taskReactivateOptions !== undefined) ? options.taskReactivateOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (taskReactivateOptions !== null && taskReactivateOptions !== undefined) {
                    timeout = taskReactivateOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (taskReactivateOptions !== null && taskReactivateOptions !== undefined) {
                    clientRequestId = taskReactivateOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskReactivateOptions !== null && taskReactivateOptions !== undefined) {
                    returnClientRequestId = taskReactivateOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskReactivateOptions !== null && taskReactivateOptions !== undefined) {
                    ocpDate = taskReactivateOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (taskReactivateOptions !== null && taskReactivateOptions !== undefined) {
                    ifMatch = taskReactivateOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (taskReactivateOptions !== null && taskReactivateOptions !== undefined) {
                    ifNoneMatch = taskReactivateOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (taskReactivateOptions !== null && taskReactivateOptions !== undefined) {
                    ifModifiedSince = taskReactivateOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (taskReactivateOptions !== null && taskReactivateOptions !== undefined) {
                    ifUnmodifiedSince = taskReactivateOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/tasks/{taskId}/reactivate';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            requestUrl = requestUrl.replace('{taskId}', encodeURIComponent(taskId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 204) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the tasks that are associated with the specified job.
     *
     * For multi-instance tasks, information such as affinityId, executionInfo and
     * nodeInfo refer to the primary task. Use the list subtasks API to retrieve
     * information about subtasks.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {TaskListNextOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let taskListNextOptions = (options && options.taskListNextOptions !== undefined) ? options.taskListNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (taskListNextOptions !== null && taskListNextOptions !== undefined) {
                    clientRequestId = taskListNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskListNextOptions !== null && taskListNextOptions !== undefined) {
                    returnClientRequestId = taskListNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskListNextOptions !== null && taskListNextOptions !== undefined) {
                    ocpDate = taskListNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.CloudTaskListResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    add(jobId, task, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.addWithHttpOperationResponse(jobId, task, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.addWithHttpOperationResponse(jobId, task, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    list(jobId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listWithHttpOperationResponse(jobId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listWithHttpOperationResponse(jobId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    addCollection(jobId, value, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.addCollectionWithHttpOperationResponse(jobId, value, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.addCollectionWithHttpOperationResponse(jobId, value, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    deleteMethod(jobId, taskId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteMethodWithHttpOperationResponse(jobId, taskId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deleteMethodWithHttpOperationResponse(jobId, taskId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    get(jobId, taskId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(jobId, taskId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getWithHttpOperationResponse(jobId, taskId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    update(jobId, taskId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.updateWithHttpOperationResponse(jobId, taskId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.updateWithHttpOperationResponse(jobId, taskId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listSubtasks(jobId, taskId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listSubtasksWithHttpOperationResponse(jobId, taskId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listSubtasksWithHttpOperationResponse(jobId, taskId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    terminate(jobId, taskId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.terminateWithHttpOperationResponse(jobId, taskId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.terminateWithHttpOperationResponse(jobId, taskId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    reactivate(jobId, taskId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.reactivateWithHttpOperationResponse(jobId, taskId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.reactivateWithHttpOperationResponse(jobId, taskId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
}
exports.Task = Task;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const msRest = __webpack_require__(1);
const Mappers = __webpack_require__(0);
const WebResource = msRest.WebResource;
/** Class representing a ComputeNodeOperations. */
class ComputeNodeOperations {
    /**
     * Create a ComputeNodeOperations.
     * @param {BatchServiceClient} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Adds a user account to the specified compute node.
     *
     * You can add a user account to a node only when it is in the idle or running
     * state.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the machine on which you want to create a
     * user account.
     *
     * @param {ComputeNodeUser} user The user account to be created.
     *
     * @param {ComputeNodeAddUserOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addUserWithHttpOperationResponse(poolId, nodeId, user, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let computeNodeAddUserOptions = (options && options.computeNodeAddUserOptions !== undefined) ? options.computeNodeAddUserOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (user === null || user === undefined) {
                    throw new Error('user cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeAddUserOptions !== null && computeNodeAddUserOptions !== undefined) {
                    timeout = computeNodeAddUserOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeAddUserOptions !== null && computeNodeAddUserOptions !== undefined) {
                    clientRequestId = computeNodeAddUserOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeAddUserOptions !== null && computeNodeAddUserOptions !== undefined) {
                    returnClientRequestId = computeNodeAddUserOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeAddUserOptions !== null && computeNodeAddUserOptions !== undefined) {
                    ocpDate = computeNodeAddUserOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes/{nodeId}/users';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            requestUrl = requestUrl.replace('{nodeId}', encodeURIComponent(nodeId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (user !== null && user !== undefined) {
                    let requestModelMapper = Mappers.ComputeNodeUser;
                    requestModel = client.serializer.serialize(requestModelMapper, user, 'user');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(user, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 201) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Deletes a user account from the specified compute node.
     *
     * You can delete a user account to a node only when it is in the idle or
     * running state.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the machine on which you want to delete a
     * user account.
     *
     * @param {string} userName The name of the user account to delete.
     *
     * @param {ComputeNodeDeleteUserOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteUserWithHttpOperationResponse(poolId, nodeId, userName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let computeNodeDeleteUserOptions = (options && options.computeNodeDeleteUserOptions !== undefined) ? options.computeNodeDeleteUserOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (userName === null || userName === undefined || typeof userName.valueOf() !== 'string') {
                    throw new Error('userName cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeDeleteUserOptions !== null && computeNodeDeleteUserOptions !== undefined) {
                    timeout = computeNodeDeleteUserOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeDeleteUserOptions !== null && computeNodeDeleteUserOptions !== undefined) {
                    clientRequestId = computeNodeDeleteUserOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeDeleteUserOptions !== null && computeNodeDeleteUserOptions !== undefined) {
                    returnClientRequestId = computeNodeDeleteUserOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeDeleteUserOptions !== null && computeNodeDeleteUserOptions !== undefined) {
                    ocpDate = computeNodeDeleteUserOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes/{nodeId}/users/{userName}';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            requestUrl = requestUrl.replace('{nodeId}', encodeURIComponent(nodeId));
            requestUrl = requestUrl.replace('{userName}', encodeURIComponent(userName));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'DELETE';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Updates the password and expiration time of a user account on the
     * specified compute node.
     *
     * This operation replaces of all the updateable properties of the account. For
     * example, if the expiryTime element is not specified, the current value is
     * replaced with the default value, not left unmodified. You can update a user
     * account on a node only when it is in the idle or running state.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the machine on which you want to update a
     * user account.
     *
     * @param {string} userName The name of the user account to update.
     *
     * @param {NodeUpdateUserParameter} nodeUpdateUserParameter The parameters for
     * the request.
     *
     * @param {ComputeNodeUpdateUserOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updateUserWithHttpOperationResponse(poolId, nodeId, userName, nodeUpdateUserParameter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let computeNodeUpdateUserOptions = (options && options.computeNodeUpdateUserOptions !== undefined) ? options.computeNodeUpdateUserOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (userName === null || userName === undefined || typeof userName.valueOf() !== 'string') {
                    throw new Error('userName cannot be null or undefined and it must be of type string.');
                }
                if (nodeUpdateUserParameter === null || nodeUpdateUserParameter === undefined) {
                    throw new Error('nodeUpdateUserParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeUpdateUserOptions !== null && computeNodeUpdateUserOptions !== undefined) {
                    timeout = computeNodeUpdateUserOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeUpdateUserOptions !== null && computeNodeUpdateUserOptions !== undefined) {
                    clientRequestId = computeNodeUpdateUserOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeUpdateUserOptions !== null && computeNodeUpdateUserOptions !== undefined) {
                    returnClientRequestId = computeNodeUpdateUserOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeUpdateUserOptions !== null && computeNodeUpdateUserOptions !== undefined) {
                    ocpDate = computeNodeUpdateUserOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes/{nodeId}/users/{userName}';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            requestUrl = requestUrl.replace('{nodeId}', encodeURIComponent(nodeId));
            requestUrl = requestUrl.replace('{userName}', encodeURIComponent(userName));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'PUT';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (nodeUpdateUserParameter !== null && nodeUpdateUserParameter !== undefined) {
                    let requestModelMapper = Mappers.NodeUpdateUserParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, nodeUpdateUserParameter, 'nodeUpdateUserParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(nodeUpdateUserParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets information about the specified compute node.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node that you want to get
     * information about.
     *
     * @param {ComputeNodeGetOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(poolId, nodeId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let computeNodeGetOptions = (options && options.computeNodeGetOptions !== undefined) ? options.computeNodeGetOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let select;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeGetOptions !== null && computeNodeGetOptions !== undefined) {
                    select = computeNodeGetOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (computeNodeGetOptions !== null && computeNodeGetOptions !== undefined) {
                    timeout = computeNodeGetOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeGetOptions !== null && computeNodeGetOptions !== undefined) {
                    clientRequestId = computeNodeGetOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeGetOptions !== null && computeNodeGetOptions !== undefined) {
                    returnClientRequestId = computeNodeGetOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeGetOptions !== null && computeNodeGetOptions !== undefined) {
                    ocpDate = computeNodeGetOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes/{nodeId}';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            requestUrl = requestUrl.replace('{nodeId}', encodeURIComponent(nodeId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (select !== null && select !== undefined) {
                queryParamsArray.push('$select=' + encodeURIComponent(select));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.ComputeNode;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Restarts the specified compute node.
     *
     * You can restart a node only if it is in an idle or running state.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node that you want to restart.
     *
     * @param {ComputeNodeRebootOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    rebootWithHttpOperationResponse(poolId, nodeId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let nodeRebootOption = (options && options.nodeRebootOption !== undefined) ? options.nodeRebootOption : undefined;
            let computeNodeRebootOptions = (options && options.computeNodeRebootOptions !== undefined) ? options.computeNodeRebootOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (nodeRebootOption) {
                    let allowedValues = ['requeue', 'terminate', 'taskCompletion', 'retainedData'];
                    if (!allowedValues.some(function (item) { return item === nodeRebootOption; })) {
                        throw new Error(nodeRebootOption + ' is not a valid value. The valid values are: ' + allowedValues);
                    }
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let nodeRebootParameter;
            try {
                if (computeNodeRebootOptions !== null && computeNodeRebootOptions !== undefined) {
                    timeout = computeNodeRebootOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeRebootOptions !== null && computeNodeRebootOptions !== undefined) {
                    clientRequestId = computeNodeRebootOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeRebootOptions !== null && computeNodeRebootOptions !== undefined) {
                    returnClientRequestId = computeNodeRebootOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeRebootOptions !== null && computeNodeRebootOptions !== undefined) {
                    ocpDate = computeNodeRebootOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (nodeRebootOption !== null && nodeRebootOption !== undefined) {
                    nodeRebootParameter = {};
                    nodeRebootParameter.nodeRebootOption = nodeRebootOption;
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes/{nodeId}/reboot';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            requestUrl = requestUrl.replace('{nodeId}', encodeURIComponent(nodeId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (nodeRebootParameter !== null && nodeRebootParameter !== undefined) {
                    let requestModelMapper = Mappers.NodeRebootParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, nodeRebootParameter, 'nodeRebootParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(nodeRebootParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Reinstalls the operating system on the specified compute node.
     *
     * You can reinstall the operating system on a node only if it is in an idle or
     * running state. This API can be invoked only on pools created with the cloud
     * service configuration property.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node that you want to restart.
     *
     * @param {ComputeNodeReimageOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    reimageWithHttpOperationResponse(poolId, nodeId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let nodeReimageOption = (options && options.nodeReimageOption !== undefined) ? options.nodeReimageOption : undefined;
            let computeNodeReimageOptions = (options && options.computeNodeReimageOptions !== undefined) ? options.computeNodeReimageOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (nodeReimageOption) {
                    let allowedValues = ['requeue', 'terminate', 'taskCompletion', 'retainedData'];
                    if (!allowedValues.some(function (item) { return item === nodeReimageOption; })) {
                        throw new Error(nodeReimageOption + ' is not a valid value. The valid values are: ' + allowedValues);
                    }
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let nodeReimageParameter;
            try {
                if (computeNodeReimageOptions !== null && computeNodeReimageOptions !== undefined) {
                    timeout = computeNodeReimageOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeReimageOptions !== null && computeNodeReimageOptions !== undefined) {
                    clientRequestId = computeNodeReimageOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeReimageOptions !== null && computeNodeReimageOptions !== undefined) {
                    returnClientRequestId = computeNodeReimageOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeReimageOptions !== null && computeNodeReimageOptions !== undefined) {
                    ocpDate = computeNodeReimageOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (nodeReimageOption !== null && nodeReimageOption !== undefined) {
                    nodeReimageParameter = {};
                    nodeReimageParameter.nodeReimageOption = nodeReimageOption;
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes/{nodeId}/reimage';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            requestUrl = requestUrl.replace('{nodeId}', encodeURIComponent(nodeId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (nodeReimageParameter !== null && nodeReimageParameter !== undefined) {
                    let requestModelMapper = Mappers.NodeReimageParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, nodeReimageParameter, 'nodeReimageParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(nodeReimageParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Disables task scheduling on the specified compute node.
     *
     * You can disable task scheduling on a node only if its current scheduling
     * state is enabled.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node on which you want to
     * disable task scheduling.
     *
     * @param {ComputeNodeDisableSchedulingOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    disableSchedulingWithHttpOperationResponse(poolId, nodeId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let nodeDisableSchedulingOption = (options && options.nodeDisableSchedulingOption !== undefined) ? options.nodeDisableSchedulingOption : undefined;
            let computeNodeDisableSchedulingOptions = (options && options.computeNodeDisableSchedulingOptions !== undefined) ? options.computeNodeDisableSchedulingOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (nodeDisableSchedulingOption) {
                    let allowedValues = ['requeue', 'terminate', 'taskCompletion'];
                    if (!allowedValues.some(function (item) { return item === nodeDisableSchedulingOption; })) {
                        throw new Error(nodeDisableSchedulingOption + ' is not a valid value. The valid values are: ' + allowedValues);
                    }
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let nodeDisableSchedulingParameter;
            try {
                if (computeNodeDisableSchedulingOptions !== null && computeNodeDisableSchedulingOptions !== undefined) {
                    timeout = computeNodeDisableSchedulingOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeDisableSchedulingOptions !== null && computeNodeDisableSchedulingOptions !== undefined) {
                    clientRequestId = computeNodeDisableSchedulingOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeDisableSchedulingOptions !== null && computeNodeDisableSchedulingOptions !== undefined) {
                    returnClientRequestId = computeNodeDisableSchedulingOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeDisableSchedulingOptions !== null && computeNodeDisableSchedulingOptions !== undefined) {
                    ocpDate = computeNodeDisableSchedulingOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (nodeDisableSchedulingOption !== null && nodeDisableSchedulingOption !== undefined) {
                    nodeDisableSchedulingParameter = {};
                    nodeDisableSchedulingParameter.nodeDisableSchedulingOption = nodeDisableSchedulingOption;
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes/{nodeId}/disablescheduling';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            requestUrl = requestUrl.replace('{nodeId}', encodeURIComponent(nodeId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (nodeDisableSchedulingParameter !== null && nodeDisableSchedulingParameter !== undefined) {
                    let requestModelMapper = Mappers.NodeDisableSchedulingParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, nodeDisableSchedulingParameter, 'nodeDisableSchedulingParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(nodeDisableSchedulingParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Enables task scheduling on the specified compute node.
     *
     * You can enable task scheduling on a node only if its current scheduling
     * state is disabled
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node on which you want to
     * enable task scheduling.
     *
     * @param {ComputeNodeEnableSchedulingOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    enableSchedulingWithHttpOperationResponse(poolId, nodeId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let computeNodeEnableSchedulingOptions = (options && options.computeNodeEnableSchedulingOptions !== undefined) ? options.computeNodeEnableSchedulingOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeEnableSchedulingOptions !== null && computeNodeEnableSchedulingOptions !== undefined) {
                    timeout = computeNodeEnableSchedulingOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeEnableSchedulingOptions !== null && computeNodeEnableSchedulingOptions !== undefined) {
                    clientRequestId = computeNodeEnableSchedulingOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeEnableSchedulingOptions !== null && computeNodeEnableSchedulingOptions !== undefined) {
                    returnClientRequestId = computeNodeEnableSchedulingOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeEnableSchedulingOptions !== null && computeNodeEnableSchedulingOptions !== undefined) {
                    ocpDate = computeNodeEnableSchedulingOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes/{nodeId}/enablescheduling';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            requestUrl = requestUrl.replace('{nodeId}', encodeURIComponent(nodeId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets the settings required for remote login to a compute node.
     *
     * Before you can remotely login to a node using the remote login settings, you
     * must create a user account on the node. This API can be invoked only on
     * pools created with the virtual machine configuration property. For pools
     * created with a cloud service configuration, see the GetRemoteDesktop API.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node for which to obtain the
     * remote login settings.
     *
     * @param {ComputeNodeGetRemoteLoginSettingsOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getRemoteLoginSettingsWithHttpOperationResponse(poolId, nodeId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let computeNodeGetRemoteLoginSettingsOptions = (options && options.computeNodeGetRemoteLoginSettingsOptions !== undefined) ? options.computeNodeGetRemoteLoginSettingsOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeGetRemoteLoginSettingsOptions !== null && computeNodeGetRemoteLoginSettingsOptions !== undefined) {
                    timeout = computeNodeGetRemoteLoginSettingsOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeGetRemoteLoginSettingsOptions !== null && computeNodeGetRemoteLoginSettingsOptions !== undefined) {
                    clientRequestId = computeNodeGetRemoteLoginSettingsOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeGetRemoteLoginSettingsOptions !== null && computeNodeGetRemoteLoginSettingsOptions !== undefined) {
                    returnClientRequestId = computeNodeGetRemoteLoginSettingsOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeGetRemoteLoginSettingsOptions !== null && computeNodeGetRemoteLoginSettingsOptions !== undefined) {
                    ocpDate = computeNodeGetRemoteLoginSettingsOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes/{nodeId}/remoteloginsettings';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            requestUrl = requestUrl.replace('{nodeId}', encodeURIComponent(nodeId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.ComputeNodeGetRemoteLoginSettingsResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets the Remote Desktop Protocol file for the specified compute
     * node.
     *
     * Before you can access a node by using the RDP file, you must create a user
     * account on the node. This API can only be invoked on pools created with a
     * cloud service configuration. For pools created with a virtual machine
     * configuration, see the GetRemoteLoginSettings API.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node for which you want to get
     * the Remote Desktop Protocol file.
     *
     * @param {ComputeNodeGetRemoteDesktopOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getRemoteDesktopWithHttpOperationResponse(poolId, nodeId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let computeNodeGetRemoteDesktopOptions = (options && options.computeNodeGetRemoteDesktopOptions !== undefined) ? options.computeNodeGetRemoteDesktopOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeGetRemoteDesktopOptions !== null && computeNodeGetRemoteDesktopOptions !== undefined) {
                    timeout = computeNodeGetRemoteDesktopOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeGetRemoteDesktopOptions !== null && computeNodeGetRemoteDesktopOptions !== undefined) {
                    clientRequestId = computeNodeGetRemoteDesktopOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeGetRemoteDesktopOptions !== null && computeNodeGetRemoteDesktopOptions !== undefined) {
                    returnClientRequestId = computeNodeGetRemoteDesktopOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeGetRemoteDesktopOptions !== null && computeNodeGetRemoteDesktopOptions !== undefined) {
                    ocpDate = computeNodeGetRemoteDesktopOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes/{nodeId}/rdp';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            requestUrl = requestUrl.replace('{nodeId}', encodeURIComponent(nodeId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            httpRequest.rawResponse = true;
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(`Unexpected status code: ${statusCode}`);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the compute nodes in the specified pool.
     *
     * @param {string} poolId The ID of the pool from which you want to list nodes.
     *
     * @param {ComputeNodeListOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(poolId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let computeNodeListOptions = (options && options.computeNodeListOptions !== undefined) ? options.computeNodeListOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let select;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeListOptions !== null && computeNodeListOptions !== undefined) {
                    filter = computeNodeListOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (computeNodeListOptions !== null && computeNodeListOptions !== undefined) {
                    select = computeNodeListOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (computeNodeListOptions !== null && computeNodeListOptions !== undefined) {
                    maxResults = computeNodeListOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (computeNodeListOptions !== null && computeNodeListOptions !== undefined) {
                    timeout = computeNodeListOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeListOptions !== null && computeNodeListOptions !== undefined) {
                    clientRequestId = computeNodeListOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeListOptions !== null && computeNodeListOptions !== undefined) {
                    returnClientRequestId = computeNodeListOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeListOptions !== null && computeNodeListOptions !== undefined) {
                    ocpDate = computeNodeListOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (filter !== null && filter !== undefined) {
                queryParamsArray.push('$filter=' + encodeURIComponent(filter));
            }
            if (select !== null && select !== undefined) {
                queryParamsArray.push('$select=' + encodeURIComponent(select));
            }
            if (maxResults !== null && maxResults !== undefined) {
                queryParamsArray.push('maxresults=' + encodeURIComponent(maxResults.toString()));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParamsArray.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.ComputeNodeListResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the compute nodes in the specified pool.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {ComputeNodeListNextOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let computeNodeListNextOptions = (options && options.computeNodeListNextOptions !== undefined) ? options.computeNodeListNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeListNextOptions !== null && computeNodeListNextOptions !== undefined) {
                    clientRequestId = computeNodeListNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeListNextOptions !== null && computeNodeListNextOptions !== undefined) {
                    returnClientRequestId = computeNodeListNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeListNextOptions !== null && computeNodeListNextOptions !== undefined) {
                    ocpDate = computeNodeListNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.ComputeNodeListResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    addUser(poolId, nodeId, user, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.addUserWithHttpOperationResponse(poolId, nodeId, user, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.addUserWithHttpOperationResponse(poolId, nodeId, user, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    deleteUser(poolId, nodeId, userName, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteUserWithHttpOperationResponse(poolId, nodeId, userName, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deleteUserWithHttpOperationResponse(poolId, nodeId, userName, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    updateUser(poolId, nodeId, userName, nodeUpdateUserParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.updateUserWithHttpOperationResponse(poolId, nodeId, userName, nodeUpdateUserParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.updateUserWithHttpOperationResponse(poolId, nodeId, userName, nodeUpdateUserParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    get(poolId, nodeId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(poolId, nodeId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getWithHttpOperationResponse(poolId, nodeId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    reboot(poolId, nodeId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.rebootWithHttpOperationResponse(poolId, nodeId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.rebootWithHttpOperationResponse(poolId, nodeId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    reimage(poolId, nodeId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.reimageWithHttpOperationResponse(poolId, nodeId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.reimageWithHttpOperationResponse(poolId, nodeId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    disableScheduling(poolId, nodeId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.disableSchedulingWithHttpOperationResponse(poolId, nodeId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.disableSchedulingWithHttpOperationResponse(poolId, nodeId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    enableScheduling(poolId, nodeId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.enableSchedulingWithHttpOperationResponse(poolId, nodeId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.enableSchedulingWithHttpOperationResponse(poolId, nodeId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    getRemoteLoginSettings(poolId, nodeId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getRemoteLoginSettingsWithHttpOperationResponse(poolId, nodeId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getRemoteLoginSettingsWithHttpOperationResponse(poolId, nodeId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    getRemoteDesktop(poolId, nodeId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getRemoteDesktopWithHttpOperationResponse(poolId, nodeId, options).then((operationRes) => {
                return Promise.resolve(operationRes.response);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getRemoteDesktopWithHttpOperationResponse(poolId, nodeId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.response;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    list(poolId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listWithHttpOperationResponse(poolId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listWithHttpOperationResponse(poolId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
}
exports.ComputeNodeOperations = ComputeNodeOperations;


/***/ })
/******/ ]);
//# sourceMappingURL=batchServiceClientBundle.js.map