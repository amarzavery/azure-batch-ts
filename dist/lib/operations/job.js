"use strict";
/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const msRest = require("ms-rest-js");
const Mappers = require("../models/mappers");
const WebResource = msRest.WebResource;
/** Class representing a Job. */
class Job {
    /**
     * Create a Job.
     * @param {BatchServiceClientContext} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Gets lifetime summary statistics for all of the jobs in the
     * specified account.
     *
     * Statistics are aggregated across all jobs that have ever existed in the
     * account, from account creation to the last update time of the statistics.
     * The statistics may not be immediately available. The Batch service performs
     * periodic roll-up of statistics. The typical delay is about 30 minutes.
     *
     * @param {JobGetAllLifetimeStatisticsOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getAllLifetimeStatisticsWithHttpOperationResponse(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobGetAllLifetimeStatisticsOptions = (options && options.jobGetAllLifetimeStatisticsOptions !== undefined) ? options.jobGetAllLifetimeStatisticsOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobGetAllLifetimeStatisticsOptions !== null && jobGetAllLifetimeStatisticsOptions !== undefined) {
                    timeout = jobGetAllLifetimeStatisticsOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobGetAllLifetimeStatisticsOptions !== null && jobGetAllLifetimeStatisticsOptions !== undefined) {
                    clientRequestId = jobGetAllLifetimeStatisticsOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobGetAllLifetimeStatisticsOptions !== null && jobGetAllLifetimeStatisticsOptions !== undefined) {
                    returnClientRequestId = jobGetAllLifetimeStatisticsOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobGetAllLifetimeStatisticsOptions !== null && jobGetAllLifetimeStatisticsOptions !== undefined) {
                    ocpDate = jobGetAllLifetimeStatisticsOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "lifetimejobstats",
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.JobStatistics;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobGetAllLifetimeStatisticsHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Deletes a job.
     *
     * Deleting a job also deletes all tasks that are part of that job, and all job
     * statistics. This also overrides the retention period for task data; that is,
     * if the job contains tasks which are still retained on compute nodes, the
     * Batch services deletes those tasks' working directories and all their
     * contents.  When a Delete Job request is received, the Batch service sets the
     * job to the deleting state. All update operations on a job that is in
     * deleting state will fail with status code 409 (Conflict), with additional
     * information indicating that the job is being deleted.
     *
     * @param {string} jobId The ID of the job to delete.
     *
     * @param {JobDeleteMethodOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(jobId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobDeleteMethodOptions = (options && options.jobDeleteMethodOptions !== undefined) ? options.jobDeleteMethodOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    timeout = jobDeleteMethodOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    clientRequestId = jobDeleteMethodOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    returnClientRequestId = jobDeleteMethodOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    ocpDate = jobDeleteMethodOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    ifMatch = jobDeleteMethodOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    ifNoneMatch = jobDeleteMethodOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    ifModifiedSince = jobDeleteMethodOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    ifUnmodifiedSince = jobDeleteMethodOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 202) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobDeleteHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets information about the specified job.
     *
     * @param {string} jobId The ID of the job.
     *
     * @param {JobGetOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(jobId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobGetOptions = (options && options.jobGetOptions !== undefined) ? options.jobGetOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let select;
            let expand;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    select = jobGetOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    expand = jobGetOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    timeout = jobGetOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    clientRequestId = jobGetOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    returnClientRequestId = jobGetOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    ocpDate = jobGetOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    ifMatch = jobGetOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    ifNoneMatch = jobGetOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    ifModifiedSince = jobGetOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    ifUnmodifiedSince = jobGetOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    select,
                    expand,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "select",
                            mapper: {
                                serializedName: "$select",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "expand",
                            mapper: {
                                serializedName: "$expand",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.CloudJob;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobGetHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Updates the properties of the specified job.
     *
     * This replaces only the job properties specified in the request. For example,
     * if the job has constraints, and a request does not specify the constraints
     * element, then the job keeps the existing constraints.
     *
     * @param {string} jobId The ID of the job whose properties you want to update.
     *
     * @param {JobPatchParameter} jobPatchParameter The parameters for the request.
     *
     * @param {JobPatchOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    patchWithHttpOperationResponse(jobId, jobPatchParameter, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobPatchOptions = (options && options.jobPatchOptions !== undefined) ? options.jobPatchOptions : undefined;
            if (jobPatchParameter === null || jobPatchParameter === undefined) {
                jobPatchParameter = {};
            }
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (jobPatchParameter === null || jobPatchParameter === undefined) {
                    throw new Error('jobPatchParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    timeout = jobPatchOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    clientRequestId = jobPatchOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    returnClientRequestId = jobPatchOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    ocpDate = jobPatchOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    ifMatch = jobPatchOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    ifNoneMatch = jobPatchOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    ifModifiedSince = jobPatchOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    ifUnmodifiedSince = jobPatchOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    jobPatchParameter,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PATCH",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.JobPatchParameter,
                    requestBodyName: "jobPatchParameter",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobPatchHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Updates the properties of the specified job.
     *
     * This fully replaces all the updateable properties of the job. For example,
     * if the job has constraints associated with it and if constraints is not
     * specified with this request, then the Batch service will remove the existing
     * constraints.
     *
     * @param {string} jobId The ID of the job whose properties you want to update.
     *
     * @param {JobUpdateParameter} jobUpdateParameter The parameters for the
     * request.
     *
     * @param {JobUpdateOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updateWithHttpOperationResponse(jobId, jobUpdateParameter, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobUpdateOptions = (options && options.jobUpdateOptions !== undefined) ? options.jobUpdateOptions : undefined;
            if (jobUpdateParameter === null || jobUpdateParameter === undefined) {
                jobUpdateParameter = {};
            }
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (jobUpdateParameter === null || jobUpdateParameter === undefined) {
                    throw new Error('jobUpdateParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    timeout = jobUpdateOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    clientRequestId = jobUpdateOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    returnClientRequestId = jobUpdateOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    ocpDate = jobUpdateOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    ifMatch = jobUpdateOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    ifNoneMatch = jobUpdateOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    ifModifiedSince = jobUpdateOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    ifUnmodifiedSince = jobUpdateOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    jobUpdateParameter,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PUT",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.JobUpdateParameter,
                    requestBodyName: "jobUpdateParameter",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobUpdateHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Disables the specified job, preventing new tasks from running.
     *
     * The Batch Service immediately moves the job to the disabling state. Batch
     * then uses the disableTasks parameter to determine what to do with the
     * currently running tasks of the job. The job remains in the disabling state
     * until the disable operation is completed and all tasks have been dealt with
     * according to the disableTasks option; the job then moves to the disabled
     * state. No new tasks are started under the job until it moves back to active
     * state. If you try to disable a job that is in any state other than active,
     * disabling, or disabled, the request fails with status code 409.
     *
     * @param {string} jobId The ID of the job to disable.
     *
     * @param {JobDisableParameter} jobDisableParameter The parameters for the
     * request.
     *
     * @param {JobDisableOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    disableWithHttpOperationResponse(jobId, jobDisableParameter, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobDisableOptions = (options && options.jobDisableOptions !== undefined) ? options.jobDisableOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (jobDisableParameter === null || jobDisableParameter === undefined) {
                    throw new Error('jobDisableParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    timeout = jobDisableOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    clientRequestId = jobDisableOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    returnClientRequestId = jobDisableOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    ocpDate = jobDisableOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    ifMatch = jobDisableOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    ifNoneMatch = jobDisableOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    ifModifiedSince = jobDisableOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    ifUnmodifiedSince = jobDisableOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    jobDisableParameter,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}/disable",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.JobDisableParameter,
                    requestBodyName: "jobDisableParameter",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 202) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobDisableHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Enables the specified job, allowing new tasks to run.
     *
     * When you call this API, the Batch service sets a disabled job to the
     * enabling state. After the this operation is completed, the job moves to the
     * active state, and scheduling of new tasks under the job resumes. The Batch
     * service does not allow a task to remain in the active state for more than 7
     * days. Therefore, if you enable a job containing active tasks which were
     * added more than 7 days ago, those tasks will not run.
     *
     * @param {string} jobId The ID of the job to enable.
     *
     * @param {JobEnableOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    enableWithHttpOperationResponse(jobId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobEnableOptions = (options && options.jobEnableOptions !== undefined) ? options.jobEnableOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    timeout = jobEnableOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    clientRequestId = jobEnableOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    returnClientRequestId = jobEnableOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    ocpDate = jobEnableOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    ifMatch = jobEnableOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    ifNoneMatch = jobEnableOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    ifModifiedSince = jobEnableOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    ifUnmodifiedSince = jobEnableOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}/enable",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 202) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobEnableHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Terminates the specified job, marking it as completed.
     *
     * When a Terminate Job request is received, the Batch service sets the job to
     * the terminating state. The Batch service then terminates any running tasks
     * associated with the job and runs any required job release tasks. Then the
     * job moves into the completed state. If there are any tasks in the job in the
     * active state, they will remain in the active state. Once a job is
     * terminated, new tasks cannot be added and any remaining active tasks will
     * not be scheduled.
     *
     * @param {string} jobId The ID of the job to terminate.
     *
     * @param {JobTerminateOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    terminateWithHttpOperationResponse(jobId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobTerminateParameter = (options && options.jobTerminateParameter !== undefined) ? options.jobTerminateParameter : undefined;
            let jobTerminateOptions = (options && options.jobTerminateOptions !== undefined) ? options.jobTerminateOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    timeout = jobTerminateOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    clientRequestId = jobTerminateOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    returnClientRequestId = jobTerminateOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    ocpDate = jobTerminateOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    ifMatch = jobTerminateOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    ifNoneMatch = jobTerminateOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    ifModifiedSince = jobTerminateOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    ifUnmodifiedSince = jobTerminateOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    jobTerminateParameter,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate,
                    ifMatch,
                    ifNoneMatch,
                    ifModifiedSince,
                    ifUnmodifiedSince
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}/terminate",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifMatch",
                            mapper: {
                                serializedName: "If-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifNoneMatch",
                            mapper: {
                                serializedName: "If-None-Match",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "ifModifiedSince",
                            mapper: {
                                serializedName: "If-Modified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        },
                        {
                            parameterName: "ifUnmodifiedSince",
                            mapper: {
                                serializedName: "If-Unmodified-Since",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.JobTerminateParameter,
                    requestBodyName: "jobTerminateParameter",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 202) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobTerminateHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Adds a job to the specified account.
     *
     * The Batch service supports two ways to control the work done as part of a
     * job. In the first approach, the user specifies a Job Manager task. The Batch
     * service launches this task when it is ready to start the job. The Job
     * Manager task controls all other tasks that run under this job, by using the
     * Task APIs. In the second approach, the user directly controls the execution
     * of tasks under an active job, by using the Task APIs. Also note: when naming
     * jobs, avoid including sensitive information such as user names or secret
     * project names. This information may appear in telemetry logs accessible to
     * Microsoft Support engineers.
     *
     * @param {JobAddParameter} job The job to be added.
     *
     * @param {JobAddOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addWithHttpOperationResponse(job, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobAddOptions = (options && options.jobAddOptions !== undefined) ? options.jobAddOptions : undefined;
            if (job === null || job === undefined) {
                job = {};
            }
            // Validate
            try {
                if (job === null || job === undefined) {
                    throw new Error('job cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobAddOptions !== null && jobAddOptions !== undefined) {
                    timeout = jobAddOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobAddOptions !== null && jobAddOptions !== undefined) {
                    clientRequestId = jobAddOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobAddOptions !== null && jobAddOptions !== undefined) {
                    returnClientRequestId = jobAddOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobAddOptions !== null && jobAddOptions !== undefined) {
                    ocpDate = jobAddOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    job,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.client.baseUri,
                    path: "jobs",
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ],
                    requestBodyMapper: Mappers.JobAddParameter,
                    requestBodyName: "job",
                    contentType: "application/json; odata=minimalmetadata; charset=utf-8"
                });
                let statusCode = operationRes.status;
                if (statusCode !== 201) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 201) {
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobAddHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the jobs in the specified account.
     *
     * @param {JobListOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobListOptions = (options && options.jobListOptions !== undefined) ? options.jobListOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let select;
            let expand;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    filter = jobListOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    select = jobListOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    expand = jobListOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    maxResults = jobListOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    timeout = jobListOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    clientRequestId = jobListOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    returnClientRequestId = jobListOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    ocpDate = jobListOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    filter,
                    select,
                    expand,
                    maxResults,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "jobs",
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "filter",
                            mapper: {
                                serializedName: "$filter",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "select",
                            mapper: {
                                serializedName: "$select",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "expand",
                            mapper: {
                                serializedName: "$expand",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "maxResults",
                            mapper: {
                                serializedName: "maxresults",
                                defaultValue: 1000,
                                constraints: {
                                    InclusiveMaximum: 1000,
                                    InclusiveMinimum: 1
                                },
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.CloudJobListResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobListHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the jobs that have been created under the specified job
     * schedule.
     *
     * @param {string} jobScheduleId The ID of the job schedule from which you want
     * to get a list of jobs.
     *
     * @param {JobListFromJobScheduleOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listFromJobScheduleWithHttpOperationResponse(jobScheduleId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobListFromJobScheduleOptions = (options && options.jobListFromJobScheduleOptions !== undefined) ? options.jobListFromJobScheduleOptions : undefined;
            // Validate
            try {
                if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
                    throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let select;
            let expand;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    filter = jobListFromJobScheduleOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    select = jobListFromJobScheduleOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    expand = jobListFromJobScheduleOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    maxResults = jobListFromJobScheduleOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    timeout = jobListFromJobScheduleOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    clientRequestId = jobListFromJobScheduleOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    returnClientRequestId = jobListFromJobScheduleOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    ocpDate = jobListFromJobScheduleOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobScheduleId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    filter,
                    select,
                    expand,
                    maxResults,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "jobschedules/{jobScheduleId}/jobs",
                    urlParameters: [
                        {
                            parameterName: "jobScheduleId",
                            mapper: {
                                required: true,
                                serializedName: "jobScheduleId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "filter",
                            mapper: {
                                serializedName: "$filter",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "select",
                            mapper: {
                                serializedName: "$select",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "expand",
                            mapper: {
                                serializedName: "$expand",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "maxResults",
                            mapper: {
                                serializedName: "maxresults",
                                defaultValue: 1000,
                                constraints: {
                                    InclusiveMaximum: 1000,
                                    InclusiveMinimum: 1
                                },
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.CloudJobListResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobListFromJobScheduleHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the execution status of the Job Preparation and Job Release
     * task for the specified job across the compute nodes where the job has run.
     *
     * This API returns the Job Preparation and Job Release task status on all
     * compute nodes that have run the Job Preparation or Job Release task. This
     * includes nodes which have since been removed from the pool. If this API is
     * invoked on a job which has no Job Preparation or Job Release task, the Batch
     * service returns HTTP status code 409 (Conflict) with an error code of
     * JobPreparationTaskNotSpecified.
     *
     * @param {string} jobId The ID of the job.
     *
     * @param {JobListPreparationAndReleaseTaskStatusOptionalParams} [options]
     * Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listPreparationAndReleaseTaskStatusWithHttpOperationResponse(jobId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobListPreparationAndReleaseTaskStatusOptions = (options && options.jobListPreparationAndReleaseTaskStatusOptions !== undefined) ? options.jobListPreparationAndReleaseTaskStatusOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let select;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
                    filter = jobListPreparationAndReleaseTaskStatusOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
                    select = jobListPreparationAndReleaseTaskStatusOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
                    maxResults = jobListPreparationAndReleaseTaskStatusOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
                    timeout = jobListPreparationAndReleaseTaskStatusOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
                    clientRequestId = jobListPreparationAndReleaseTaskStatusOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
                    returnClientRequestId = jobListPreparationAndReleaseTaskStatusOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
                    ocpDate = jobListPreparationAndReleaseTaskStatusOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    filter,
                    select,
                    maxResults,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}/jobpreparationandreleasetaskstatus",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "filter",
                            mapper: {
                                serializedName: "$filter",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "select",
                            mapper: {
                                serializedName: "$select",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "maxResults",
                            mapper: {
                                serializedName: "maxresults",
                                defaultValue: 1000,
                                constraints: {
                                    InclusiveMaximum: 1000,
                                    InclusiveMinimum: 1
                                },
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.CloudJobListPreparationAndReleaseTaskStatusResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobListPreparationAndReleaseTaskStatusHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets the task counts for the specified job.
     *
     * Task counts provide a count of the tasks by active, running or completed
     * task state, and a count of tasks which succeeded or failed. Tasks in the
     * preparing state are counted as running. If the validationStatus is
     * unvalidated, then the Batch service has not been able to check state counts
     * against the task states as reported in the List Tasks API. The
     * validationStatus may be unvalidated if the job contains more than 200,000
     * tasks.
     *
     * @param {string} jobId The ID of the job.
     *
     * @param {JobGetTaskCountsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getTaskCountsWithHttpOperationResponse(jobId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobGetTaskCountsOptions = (options && options.jobGetTaskCountsOptions !== undefined) ? options.jobGetTaskCountsOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobGetTaskCountsOptions !== null && jobGetTaskCountsOptions !== undefined) {
                    timeout = jobGetTaskCountsOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobGetTaskCountsOptions !== null && jobGetTaskCountsOptions !== undefined) {
                    clientRequestId = jobGetTaskCountsOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobGetTaskCountsOptions !== null && jobGetTaskCountsOptions !== undefined) {
                    returnClientRequestId = jobGetTaskCountsOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobGetTaskCountsOptions !== null && jobGetTaskCountsOptions !== undefined) {
                    ocpDate = jobGetTaskCountsOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    jobId,
                    "this.client.apiVersion": this.client.apiVersion,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    timeout,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.client.baseUri,
                    path: "jobs/{jobId}/taskcounts",
                    urlParameters: [
                        {
                            parameterName: "jobId",
                            mapper: {
                                required: true,
                                serializedName: "jobId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterName: "this.client.apiVersion",
                            mapper: {
                                required: true,
                                serializedName: "api-version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "timeout",
                            mapper: {
                                serializedName: "timeout",
                                defaultValue: 30,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.TaskCounts;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobGetTaskCountsHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the jobs in the specified account.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {JobListNextOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNextWithHttpOperationResponse(nextPageLink, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobListNextOptions = (options && options.jobListNextOptions !== undefined) ? options.jobListNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobListNextOptions !== null && jobListNextOptions !== undefined) {
                    clientRequestId = jobListNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobListNextOptions !== null && jobListNextOptions !== undefined) {
                    returnClientRequestId = jobListNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobListNextOptions !== null && jobListNextOptions !== undefined) {
                    ocpDate = jobListNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    nextPageLink,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: "https://batch.core.windows.net",
                    path: "{nextLink}",
                    urlParameters: [
                        {
                            parameterName: "nextPageLink",
                            skipEncoding: true,
                            mapper: {
                                required: true,
                                serializedName: "nextLink",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.CloudJobListResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobListHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the jobs that have been created under the specified job
     * schedule.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {JobListFromJobScheduleNextOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listFromJobScheduleNextWithHttpOperationResponse(nextPageLink, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobListFromJobScheduleNextOptions = (options && options.jobListFromJobScheduleNextOptions !== undefined) ? options.jobListFromJobScheduleNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobListFromJobScheduleNextOptions !== null && jobListFromJobScheduleNextOptions !== undefined) {
                    clientRequestId = jobListFromJobScheduleNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobListFromJobScheduleNextOptions !== null && jobListFromJobScheduleNextOptions !== undefined) {
                    returnClientRequestId = jobListFromJobScheduleNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobListFromJobScheduleNextOptions !== null && jobListFromJobScheduleNextOptions !== undefined) {
                    ocpDate = jobListFromJobScheduleNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    nextPageLink,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: "https://batch.core.windows.net",
                    path: "{nextLink}",
                    urlParameters: [
                        {
                            parameterName: "nextPageLink",
                            skipEncoding: true,
                            mapper: {
                                required: true,
                                serializedName: "nextLink",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.CloudJobListResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobListFromJobScheduleHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the execution status of the Job Preparation and Job Release
     * task for the specified job across the compute nodes where the job has run.
     *
     * This API returns the Job Preparation and Job Release task status on all
     * compute nodes that have run the Job Preparation or Job Release task. This
     * includes nodes which have since been removed from the pool. If this API is
     * invoked on a job which has no Job Preparation or Job Release task, the Batch
     * service returns HTTP status code 409 (Conflict) with an error code of
     * JobPreparationTaskNotSpecified.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {JobListPreparationAndReleaseTaskStatusNextOptionalParams} [options]
     * Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listPreparationAndReleaseTaskStatusNextWithHttpOperationResponse(nextPageLink, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobListPreparationAndReleaseTaskStatusNextOptions = (options && options.jobListPreparationAndReleaseTaskStatusNextOptions !== undefined) ? options.jobListPreparationAndReleaseTaskStatusNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobListPreparationAndReleaseTaskStatusNextOptions !== null && jobListPreparationAndReleaseTaskStatusNextOptions !== undefined) {
                    clientRequestId = jobListPreparationAndReleaseTaskStatusNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusNextOptions !== null && jobListPreparationAndReleaseTaskStatusNextOptions !== undefined) {
                    returnClientRequestId = jobListPreparationAndReleaseTaskStatusNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusNextOptions !== null && jobListPreparationAndReleaseTaskStatusNextOptions !== undefined) {
                    ocpDate = jobListPreparationAndReleaseTaskStatusNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    nextPageLink,
                    "this.client.acceptLanguage": this.client.acceptLanguage,
                    clientRequestId,
                    returnClientRequestId,
                    ocpDate
                }, options);
                operationRes = yield client.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: "https://batch.core.windows.net",
                    path: "{nextLink}",
                    urlParameters: [
                        {
                            parameterName: "nextPageLink",
                            skipEncoding: true,
                            mapper: {
                                required: true,
                                serializedName: "nextLink",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    headerParameters: [
                        {
                            parameterName: "this.client.acceptLanguage",
                            mapper: {
                                serializedName: "accept-language",
                                defaultValue: 'en-US',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterName: "clientRequestId",
                            mapper: {
                                serializedName: "client-request-id",
                                type: {
                                    name: "Uuid"
                                }
                            }
                        },
                        {
                            parameterName: "returnClientRequestId",
                            mapper: {
                                serializedName: "return-client-request-id",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterName: "ocpDate",
                            mapper: {
                                serializedName: "ocp-date",
                                type: {
                                    name: "DateTimeRfc1123"
                                }
                            }
                        }
                    ]
                });
                let statusCode = operationRes.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = operationRes.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(operationRes);
                    let parsedErrorResponse = operationRes.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            const resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            const resultMapper = Mappers.CloudJobListPreparationAndReleaseTaskStatusResult;
                            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.JobListPreparationAndReleaseTaskStatusHeaders, operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    getAllLifetimeStatistics(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getAllLifetimeStatisticsWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getAllLifetimeStatisticsWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    deleteMethod(jobId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteMethodWithHttpOperationResponse(jobId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deleteMethodWithHttpOperationResponse(jobId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    get(jobId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(jobId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getWithHttpOperationResponse(jobId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    patch(jobId, jobPatchParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.patchWithHttpOperationResponse(jobId, jobPatchParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.patchWithHttpOperationResponse(jobId, jobPatchParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    update(jobId, jobUpdateParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.updateWithHttpOperationResponse(jobId, jobUpdateParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.updateWithHttpOperationResponse(jobId, jobUpdateParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    disable(jobId, jobDisableParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.disableWithHttpOperationResponse(jobId, jobDisableParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.disableWithHttpOperationResponse(jobId, jobDisableParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    enable(jobId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.enableWithHttpOperationResponse(jobId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.enableWithHttpOperationResponse(jobId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    terminate(jobId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.terminateWithHttpOperationResponse(jobId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.terminateWithHttpOperationResponse(jobId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    add(job, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.addWithHttpOperationResponse(job, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.addWithHttpOperationResponse(job, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    list(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    listFromJobSchedule(jobScheduleId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listFromJobScheduleWithHttpOperationResponse(jobScheduleId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listFromJobScheduleWithHttpOperationResponse(jobScheduleId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    listPreparationAndReleaseTaskStatus(jobId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listPreparationAndReleaseTaskStatusWithHttpOperationResponse(jobId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listPreparationAndReleaseTaskStatusWithHttpOperationResponse(jobId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getTaskCounts(jobId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getTaskCountsWithHttpOperationResponse(jobId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getTaskCountsWithHttpOperationResponse(jobId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    listNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    listFromJobScheduleNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listFromJobScheduleNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listFromJobScheduleNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    listPreparationAndReleaseTaskStatusNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listPreparationAndReleaseTaskStatusNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listPreparationAndReleaseTaskStatusNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
}
exports.Job = Job;
//# sourceMappingURL=job.js.map