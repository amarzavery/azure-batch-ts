"use strict";
/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const msRest = require("ms-rest-ts");
const Mappers = require("../models/mappers");
const WebResource = msRest.WebResource;
/** Class representing a Pool. */
class Pool {
    /**
     * Create a Pool.
     * @param {BatchServiceClient} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Lists the usage metrics, aggregated by pool across individual time
     * intervals, for the specified account.
     *
     * If you do not specify a $filter clause including a poolId, the response
     * includes all pools that existed in the account in the time range of the
     * returned aggregation intervals. If you do not specify a $filter clause
     * including a startTime or endTime these filters default to the start and end
     * times of the last aggregation interval currently available; that is, only
     * the last aggregation interval is returned.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolListUsageMetricsOptions] Additional parameters
     * for the operation
     *
     * @param {date} [options.poolListUsageMetricsOptions.startTime] The earliest
     * time from which to include metrics. This must be at least two and a half
     * hours before the current time. If not specified this defaults to the start
     * time of the last aggregation interval currently available.
     *
     * @param {date} [options.poolListUsageMetricsOptions.endTime] The latest time
     * from which to include metrics. This must be at least two hours before the
     * current time. If not specified this defaults to the end time of the last
     * aggregation interval currently available.
     *
     * @param {string} [options.poolListUsageMetricsOptions.filter] An OData
     * $filter clause. If this is not specified the response includes all pools
     * that existed in the account in the time range of the returned aggregation
     * intervals.
     *
     * @param {number} [options.poolListUsageMetricsOptions.maxResults] The maximum
     * number of items to return in the response. A maximum of 1000 results will be
     * returned.
     *
     * @param {number} [options.poolListUsageMetricsOptions.timeout] The maximum
     * time that the server can spend processing the request, in seconds. The
     * default is 30 seconds.
     *
     * @param {string} [options.poolListUsageMetricsOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolListUsageMetricsOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.poolListUsageMetricsOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<PoolListUsageMetricsResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listUsageMetricsWithHttpOperationResponse(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolListUsageMetricsOptions = (options && options.poolListUsageMetricsOptions !== undefined) ? options.poolListUsageMetricsOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let startTime;
            let endTime;
            let filter;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    startTime = poolListUsageMetricsOptions.startTime;
                    if (startTime && !(startTime instanceof Date ||
                        (typeof startTime.valueOf() === 'string' && !isNaN(Date.parse(startTime))))) {
                        throw new Error('startTime must be of type date.');
                    }
                }
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    endTime = poolListUsageMetricsOptions.endTime;
                    if (endTime && !(endTime instanceof Date ||
                        (typeof endTime.valueOf() === 'string' && !isNaN(Date.parse(endTime))))) {
                        throw new Error('endTime must be of type date.');
                    }
                }
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    filter = poolListUsageMetricsOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    maxResults = poolListUsageMetricsOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    timeout = poolListUsageMetricsOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    clientRequestId = poolListUsageMetricsOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    returnClientRequestId = poolListUsageMetricsOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    ocpDate = poolListUsageMetricsOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'poolusagemetrics';
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (startTime !== null && startTime !== undefined) {
                queryParameters.push('starttime=' + encodeURIComponent(msRest.serializeObject(startTime)));
            }
            if (endTime !== null && endTime !== undefined) {
                queryParameters.push('endtime=' + encodeURIComponent(msRest.serializeObject(endTime)));
            }
            if (filter !== null && filter !== undefined) {
                queryParameters.push('$filter=' + encodeURIComponent(filter));
            }
            if (maxResults !== null && maxResults !== undefined) {
                queryParameters.push('maxresults=' + encodeURIComponent(maxResults.toString()));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.PoolListUsageMetricsResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets lifetime summary statistics for all of the pools in the
     * specified account.
     *
     * Statistics are aggregated across all pools that have ever existed in the
     * account, from account creation to the last update time of the statistics.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolGetAllLifetimeStatisticsOptions] Additional
     * parameters for the operation
     *
     * @param {number} [options.poolGetAllLifetimeStatisticsOptions.timeout] The
     * maximum time that the server can spend processing the request, in seconds.
     * The default is 30 seconds.
     *
     * @param {string}
     * [options.poolGetAllLifetimeStatisticsOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean}
     * [options.poolGetAllLifetimeStatisticsOptions.returnClientRequestId] Whether
     * the server should return the client-request-id in the response.
     *
     * @param {date} [options.poolGetAllLifetimeStatisticsOptions.ocpDate] The time
     * the request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<PoolStatistics>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getAllLifetimeStatisticsWithHttpOperationResponse(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolGetAllLifetimeStatisticsOptions = (options && options.poolGetAllLifetimeStatisticsOptions !== undefined) ? options.poolGetAllLifetimeStatisticsOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolGetAllLifetimeStatisticsOptions !== null && poolGetAllLifetimeStatisticsOptions !== undefined) {
                    timeout = poolGetAllLifetimeStatisticsOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolGetAllLifetimeStatisticsOptions !== null && poolGetAllLifetimeStatisticsOptions !== undefined) {
                    clientRequestId = poolGetAllLifetimeStatisticsOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolGetAllLifetimeStatisticsOptions !== null && poolGetAllLifetimeStatisticsOptions !== undefined) {
                    returnClientRequestId = poolGetAllLifetimeStatisticsOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolGetAllLifetimeStatisticsOptions !== null && poolGetAllLifetimeStatisticsOptions !== undefined) {
                    ocpDate = poolGetAllLifetimeStatisticsOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'lifetimepoolstats';
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.PoolStatistics;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Adds a pool to the specified account.
     *
     * When naming pools, avoid including sensitive information such as user names
     * or secret project names. This information may appear in telemetry logs
     * accessible to Microsoft Support engineers.
     *
     * @param {object} pool The pool to be added.
     *
     * @param {string} pool.id A string that uniquely identifies the pool within
     * the account. The ID can contain any combination of alphanumeric characters
     * including hyphens and underscores, and cannot contain more than 64
     * characters. The ID is case-preserving and case-insensitive (that is, you may
     * not have two pool IDs within an account that differ only by case).
     *
     * @param {string} [pool.displayName] The display name for the pool. The
     * display name need not be unique and can contain any Unicode characters up to
     * a maximum length of 1024.
     *
     * @param {string} pool.vmSize The size of virtual machines in the pool. All
     * virtual machines in a pool are the same size. For information about
     * available sizes of virtual machines for Cloud Services pools (pools created
     * with cloudServiceConfiguration), see Sizes for Cloud Services
     * (http://azure.microsoft.com/documentation/articles/cloud-services-sizes-specs/).
     * Batch supports all Cloud Services VM sizes except ExtraSmall, A1V2 and A2V2.
     * For information about available VM sizes for pools using images from the
     * Virtual Machines Marketplace (pools created with
     * virtualMachineConfiguration) see Sizes for Virtual Machines (Linux)
     * (https://azure.microsoft.com/documentation/articles/virtual-machines-linux-sizes/)
     * or Sizes for Virtual Machines (Windows)
     * (https://azure.microsoft.com/documentation/articles/virtual-machines-windows-sizes/).
     * Batch supports all Azure VM sizes except STANDARD_A0 and those with premium
     * storage (STANDARD_GS, STANDARD_DS, and STANDARD_DSV2 series).
     *
     * @param {object} [pool.cloudServiceConfiguration] The cloud service
     * configuration for the pool. This property and virtualMachineConfiguration
     * are mutually exclusive and one of the properties must be specified. This
     * property cannot be specified if the Batch account was created with its
     * poolAllocationMode property set to 'UserSubscription'.
     *
     * @param {string} pool.cloudServiceConfiguration.osFamily The Azure Guest OS
     * family to be installed on the virtual machines in the pool. Possible values
     * are: 2 - OS Family 2, equivalent to Windows Server 2008 R2 SP1. 3 - OS
     * Family 3, equivalent to Windows Server 2012. 4 - OS Family 4, equivalent to
     * Windows Server 2012 R2. 5 - OS Family 5, equivalent to Windows Server 2016.
     * For more information, see Azure Guest OS Releases
     * (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
     *
     * @param {string} [pool.cloudServiceConfiguration.targetOSVersion] The Azure
     * Guest OS version to be installed on the virtual machines in the pool. The
     * default value is * which specifies the latest operating system version for
     * the specified OS family.
     *
     * @param {string} [pool.cloudServiceConfiguration.currentOSVersion] The Azure
     * Guest OS Version currently installed on the virtual machines in the pool.
     * This may differ from targetOSVersion if the pool state is Upgrading. In this
     * case some virtual machines may be on the targetOSVersion and some may be on
     * the currentOSVersion during the upgrade process. Once all virtual machines
     * have upgraded, currentOSVersion is updated to be the same as
     * targetOSVersion.
     *
     * @param {object} [pool.virtualMachineConfiguration] The virtual machine
     * configuration for the pool. This property and cloudServiceConfiguration are
     * mutually exclusive and one of the properties must be specified.
     *
     * @param {object} [pool.virtualMachineConfiguration.imageReference] A
     * reference to the Azure Virtual Machines Marketplace image to use. This
     * property and osDisk are mutually exclusive and one of the properties must be
     * specified.
     *
     * @param {string} pool.virtualMachineConfiguration.imageReference.publisher
     * The publisher of the Azure Virtual Machines Marketplace image. For example,
     * Canonical or MicrosoftWindowsServer.
     *
     * @param {string} pool.virtualMachineConfiguration.imageReference.offer The
     * offer type of the Azure Virtual Machines Marketplace image. For example,
     * UbuntuServer or WindowsServer.
     *
     * @param {string} pool.virtualMachineConfiguration.imageReference.sku The SKU
     * of the Azure Virtual Machines Marketplace image. For example, 14.04.0-LTS or
     * 2012-R2-Datacenter.
     *
     * @param {string} [pool.virtualMachineConfiguration.imageReference.version]
     * The version of the Azure Virtual Machines Marketplace image. A value of
     * 'latest' can be specified to select the latest version of an image. If
     * omitted, the default is 'latest'.
     *
     * @param {object} [pool.virtualMachineConfiguration.osDisk] A reference to the
     * OS disk image to use. This property can be specified only if the Batch
     * account was created with its poolAllocationMode property set to
     * 'UserSubscription'. This property and imageReference are mutually exclusive
     * and one of the properties must be specified.
     *
     * @param {array} pool.virtualMachineConfiguration.osDisk.imageUris The
     * collection of Virtual Hard Disk (VHD) URIs. All the VHDs must be identical
     * and must reside in an Azure Storage account within the same subscription and
     * same region as the Batch account. For best performance, it is recommended
     * that each VHD resides in a separate Azure Storage account. Each VHD can
     * serve upto 20 Windows compute nodes or 40 Linux compute nodes. You must
     * supply enough VHD URIs to satisfy the 'targetDedicated' property of the
     * pool. If you do not supply enough VHD URIs, the pool will partially allocate
     * compute nodes, and a resize error will occur.
     *
     * @param {string} [pool.virtualMachineConfiguration.osDisk.caching] The type
     * of caching to enable for the OS disk. Values are:
     *
     * none - The caching mode for the disk is not enabled.
     * readOnly - The caching mode for the disk is read only.
     * readWrite - The caching mode for the disk is read and write.
     *
     * The default value for caching is none. For information about the caching
     * options see:
     * https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/27/exploring-windows-azure-drives-disks-and-images/.
     * Possible values include: 'none', 'readOnly', 'readWrite'
     *
     * @param {string} pool.virtualMachineConfiguration.nodeAgentSKUId The SKU of
     * the Batch node agent to be provisioned on compute nodes in the pool. The
     * Batch node agent is a program that runs on each node in the pool, and
     * provides the command-and-control interface between the node and the Batch
     * service. There are different implementations of the node agent, known as
     * SKUs, for different operating systems. You must specify a node agent SKU
     * which matches the selected image reference. To get the list of supported
     * node agent SKUs along with their list of verified image references, see the
     * 'List supported node agent SKUs' operation.
     *
     * @param {object} [pool.virtualMachineConfiguration.windowsConfiguration]
     * Windows operating system settings on the virtual machine. This property must
     * not be specified if the imageReference or osDisk property specifies a Linux
     * OS image.
     *
     * @param {boolean}
     * [pool.virtualMachineConfiguration.windowsConfiguration.enableAutomaticUpdates]
     * Whether automatic updates are enabled on the virtual machine. If omitted,
     * the default value is true.
     *
     * @param {moment.duration} [pool.resizeTimeout] The timeout for allocation of
     * compute nodes to the pool. This timeout applies only to manual scaling; it
     * has no effect when enableAutoScale is set to true. The default value is 15
     * minutes. The minimum value is 5 minutes. If you specify a value less than 5
     * minutes, the Batch service returns an error; if you are calling the REST API
     * directly, the HTTP status code is 400 (Bad Request).
     *
     * @param {number} [pool.targetDedicatedNodes] The desired number of dedicated
     * compute nodes in the pool. This property must not be specified if
     * enableAutoScale is set to true. If enableAutoScale is set to false, then you
     * must set either targetDedicatedNodes, targetLowPriorityNodes, or both.
     *
     * @param {number} [pool.targetLowPriorityNodes] The desired number of
     * low-priority compute nodes in the pool. This property must not be specified
     * if enableAutoScale is set to true. If enableAutoScale is set to false, then
     * you must set either targetDedicatedNodes, targetLowPriorityNodes, or both.
     *
     * @param {boolean} [pool.enableAutoScale] Whether the pool size should
     * automatically adjust over time. If false, at least one of
     * targetDedicateNodes and targetLowPriorityNodes must be specified. If true,
     * the autoScaleFormula property is required and the pool automatically resizes
     * according to the formula. The default value is false.
     *
     * @param {string} [pool.autoScaleFormula] A formula for the desired number of
     * compute nodes in the pool. This property must not be specified if
     * enableAutoScale is set to false. It is required if enableAutoScale is set to
     * true. The formula is checked for validity before the pool is created. If the
     * formula is not valid, the Batch service rejects the request with detailed
     * error information. For more information about specifying this formula, see
     * 'Automatically scale compute nodes in an Azure Batch pool'
     * (https://azure.microsoft.com/documentation/articles/batch-automatic-scaling/).
     *
     * @param {moment.duration} [pool.autoScaleEvaluationInterval] The time
     * interval at which to automatically adjust the pool size according to the
     * autoscale formula. The default value is 15 minutes. The minimum and maximum
     * value are 5 minutes and 168 hours respectively. If you specify a value less
     * than 5 minutes or greater than 168 hours, the Batch service returns an
     * error; if you are calling the REST API directly, the HTTP status code is 400
     * (Bad Request).
     *
     * @param {boolean} [pool.enableInterNodeCommunication] Whether the pool
     * permits direct communication between nodes. Enabling inter-node
     * communication limits the maximum size of the pool due to deployment
     * restrictions on the nodes of the pool. This may result in the pool not
     * reaching its desired size. The default value is false.
     *
     * @param {object} [pool.networkConfiguration] The network configuration for
     * the pool.
     *
     * @param {string} [pool.networkConfiguration.subnetId] The ARM resource
     * identifier of the virtual network subnet which the compute nodes of the pool
     * will join. This is of the form
     * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
     * The virtual network must be in the same region and subscription as the Azure
     * Batch account. The specified subnet should have enough free IP addresses to
     * accommodate the number of nodes in the pool. If the subnet doesn't have
     * enough free IP addresses, the pool will partially allocate compute nodes,
     * and a resize error will occur. The 'MicrosoftAzureBatch' service principal
     * must have the 'Classic Virtual Machine Contributor' Role-Based Access
     * Control (RBAC) role for the specified VNet. The specified subnet must allow
     * communication from the Azure Batch service to be able to schedule tasks on
     * the compute nodes. This can be verified by checking if the specified VNet
     * has any associated Network Security Groups (NSG). If communication to the
     * compute nodes in the specified subnet is denied by an NSG, then the Batch
     * service will set the state of the compute nodes to unusable. For pools
     * created via virtualMachineConfiguration the Batch account must have
     * poolAllocationMode userSubscription in order to use a VNet. If the specified
     * VNet has any associated Network Security Groups (NSG), then a few reserved
     * system ports must be enabled for inbound communication. For pools created
     * with a virtual machine configuration, enable ports 29876 and 29877, as well
     * as port 22 for Linux and port 3389 for Windows. For pools created with a
     * cloud service configuration, enable ports 10100, 20100, and 30100. Also
     * enable outbound connections to Azure Storage on port 443. For more details
     * see:
     * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration
     *
     * @param {object} [pool.networkConfiguration.endpointConfiguration] The
     * configuration for endpoints on compute nodes in the Batch pool. Pool
     * endpoint configuration is only supported on pools with the
     * virtualMachineConfiguration property.
     *
     * @param {array}
     * pool.networkConfiguration.endpointConfiguration.inboundNATPools A list of
     * inbound NAT pools that can be used to address specific ports on an
     * individual compute node externally. The maximum number of inbound NAT pools
     * per Batch pool is 5. If the maximum number of inbound NAT pools is exceeded
     * the request fails with HTTP status code 400.
     *
     * @param {object} [pool.startTask] A task specified to run on each compute
     * node as it joins the pool. The task runs when the node is added to the pool
     * or when the node is restarted.
     *
     * @param {string} pool.startTask.commandLine The command line of the start
     * task. The command line does not run under a shell, and therefore cannot take
     * advantage of shell features such as environment variable expansion. If you
     * want to take advantage of such features, you should invoke the shell in the
     * command line, for example using "cmd /c MyCommand" in Windows or "/bin/sh -c
     * MyCommand" in Linux.
     *
     * @param {array} [pool.startTask.resourceFiles] A list of files that the Batch
     * service will download to the compute node before running the command line.
     * Files listed under this element are located in the task's working directory.
     *
     * @param {array} [pool.startTask.environmentSettings] A list of environment
     * variable settings for the start task.
     *
     * @param {object} [pool.startTask.userIdentity] The user identity under which
     * the start task runs. If omitted, the task runs as a non-administrative user
     * unique to the task.
     *
     * @param {string} [pool.startTask.userIdentity.userName] The name of the user
     * identity under which the task is run. The userName and autoUser properties
     * are mutually exclusive; you must specify one but not both.
     *
     * @param {object} [pool.startTask.userIdentity.autoUser] The auto user under
     * which the task is run. The userName and autoUser properties are mutually
     * exclusive; you must specify one but not both.
     *
     * @param {string} [pool.startTask.userIdentity.autoUser.scope] The scope for
     * the auto user Values are:
     *
     * pool - specifies that the task runs as the common auto user account which is
     * created on every node in a pool.
     * task - specifies that the service should create a new user for the task.
     * The default value is task. Possible values include: 'task', 'pool'
     *
     * @param {string} [pool.startTask.userIdentity.autoUser.elevationLevel] The
     * elevation level of the auto user. nonAdmin - The auto user is a standard
     * user without elevated access. admin - The auto user is a user with elevated
     * access and operates with full Administrator permissions. The default value
     * is nonAdmin. Possible values include: 'nonAdmin', 'admin'
     *
     * @param {number} [pool.startTask.maxTaskRetryCount] The maximum number of
     * times the task may be retried. The Batch service retries a task if its exit
     * code is nonzero. Note that this value specifically controls the number of
     * retries. The Batch service will try the task once, and may then retry up to
     * this limit. For example, if the maximum retry count is 3, Batch tries the
     * task up to 4 times (one initial try and 3 retries). If the maximum retry
     * count is 0, the Batch service does not retry the task. If the maximum retry
     * count is -1, the Batch service retries the task without limit.
     *
     * @param {boolean} [pool.startTask.waitForSuccess] Whether the Batch service
     * should wait for the start task to complete successfully (that is, to exit
     * with exit code 0) before scheduling any tasks on the compute node. If true
     * and the start task fails on a compute node, the Batch service retries the
     * start task up to its maximum retry count (maxTaskRetryCount). If the task
     * has still not completed successfully after all retries, then the Batch
     * service marks the compute node unusable, and will not schedule tasks to it.
     * This condition can be detected via the node state and failure info details.
     * If false, the Batch service will not wait for the start task to complete. In
     * this case, other tasks can start executing on the compute node while the
     * start task is still running; and even if the start task fails, new tasks
     * will continue to be scheduled on the node. The default is false.
     *
     * @param {array} [pool.certificateReferences] The list of certificates to be
     * installed on each compute node in the pool. For Windows compute nodes, the
     * Batch service installs the certificates to the specified certificate store
     * and location. For Linux compute nodes, the certificates are stored in a
     * directory inside the task working directory and an environment variable
     * AZ_BATCH_CERTIFICATES_DIR is supplied to the task to query for this
     * location. For certificates with visibility of 'remoteUser', a 'certs'
     * directory is created in the user's home directory (e.g.,
     * /home/{user-name}/certs) and certificates are placed in that directory.
     *
     * @param {array} [pool.applicationPackageReferences] The list of application
     * packages to be installed on each compute node in the pool.
     *
     * @param {array} [pool.applicationLicenses] The list of application licenses
     * the Batch service will make available on each compute node in the pool. The
     * list of application licenses must be a subset of available Batch service
     * application licenses. If a license is requested which is not supported, pool
     * creation will fail.
     *
     * @param {number} [pool.maxTasksPerNode] The maximum number of tasks that can
     * run concurrently on a single compute node in the pool. The default value is
     * 1. The maximum value of this setting depends on the size of the compute
     * nodes in the pool (the vmSize setting).
     *
     * @param {object} [pool.taskSchedulingPolicy] How tasks are distributed across
     * compute nodes in a pool.
     *
     * @param {string} pool.taskSchedulingPolicy.nodeFillType How tasks are
     * distributed across compute nodes in a pool. Values are:
     *
     * pack - As many tasks as possible (maxTasksPerNode) should be assigned to
     * each node in the pool before any tasks are assigned to the next node in the
     * pool.
     * spread - Tasks should be assigned evenly across all nodes in the pool.
     * Possible values include: 'spread', 'pack'
     *
     * @param {array} [pool.userAccounts] The list of user accounts to be created
     * on each node in the pool.
     *
     * @param {array} [pool.metadata] A list of name-value pairs associated with
     * the pool as metadata. The Batch service does not assign any meaning to
     * metadata; it is solely for the use of user code.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolAddOptions] Additional parameters for the
     * operation
     *
     * @param {number} [options.poolAddOptions.timeout] The maximum time that the
     * server can spend processing the request, in seconds. The default is 30
     * seconds.
     *
     * @param {string} [options.poolAddOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolAddOptions.returnClientRequestId] Whether the
     * server should return the client-request-id in the response.
     *
     * @param {date} [options.poolAddOptions.ocpDate] The time the request was
     * issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addWithHttpOperationResponse(pool, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolAddOptions = (options && options.poolAddOptions !== undefined) ? options.poolAddOptions : undefined;
            // Validate
            try {
                if (pool === null || pool === undefined) {
                    throw new Error('pool cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolAddOptions !== null && poolAddOptions !== undefined) {
                    timeout = poolAddOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolAddOptions !== null && poolAddOptions !== undefined) {
                    clientRequestId = poolAddOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolAddOptions !== null && poolAddOptions !== undefined) {
                    returnClientRequestId = poolAddOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolAddOptions !== null && poolAddOptions !== undefined) {
                    ocpDate = poolAddOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools';
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (pool !== null && pool !== undefined) {
                    let requestModelMapper = Mappers.PoolAddParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, pool, 'pool');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(pool, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 201) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the pools in the specified account.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolListOptions] Additional parameters for the
     * operation
     *
     * @param {string} [options.poolListOptions.filter] An OData $filter clause.
     *
     * @param {string} [options.poolListOptions.select] An OData $select clause.
     *
     * @param {string} [options.poolListOptions.expand] An OData $expand clause.
     *
     * @param {number} [options.poolListOptions.maxResults] The maximum number of
     * items to return in the response. A maximum of 1000 pools can be returned.
     *
     * @param {number} [options.poolListOptions.timeout] The maximum time that the
     * server can spend processing the request, in seconds. The default is 30
     * seconds.
     *
     * @param {string} [options.poolListOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolListOptions.returnClientRequestId] Whether the
     * server should return the client-request-id in the response.
     *
     * @param {date} [options.poolListOptions.ocpDate] The time the request was
     * issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<CloudPoolListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolListOptions = (options && options.poolListOptions !== undefined) ? options.poolListOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let select;
            let expand;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    filter = poolListOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    select = poolListOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    expand = poolListOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    maxResults = poolListOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    timeout = poolListOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    clientRequestId = poolListOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    returnClientRequestId = poolListOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    ocpDate = poolListOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools';
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (filter !== null && filter !== undefined) {
                queryParameters.push('$filter=' + encodeURIComponent(filter));
            }
            if (select !== null && select !== undefined) {
                queryParameters.push('$select=' + encodeURIComponent(select));
            }
            if (expand !== null && expand !== undefined) {
                queryParameters.push('$expand=' + encodeURIComponent(expand));
            }
            if (maxResults !== null && maxResults !== undefined) {
                queryParameters.push('maxresults=' + encodeURIComponent(maxResults.toString()));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.CloudPoolListResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Deletes a pool from the specified account.
     *
     * When you request that a pool be deleted, the following actions occur: the
     * pool state is set to deleting; any ongoing resize operation on the pool are
     * stopped; the Batch service starts resizing the pool to zero nodes; any tasks
     * running on existing nodes are terminated and requeued (as if a resize pool
     * operation had been requested with the default requeue option); finally, the
     * pool is removed from the system. Because running tasks are requeued, the
     * user can rerun these tasks by updating their job to target a different pool.
     * The tasks can then run on the new pool. If you want to override the requeue
     * behavior, then you should call resize pool explicitly to shrink the pool to
     * zero size before deleting the pool. If you call an Update, Patch or Delete
     * API on a pool in the deleting state, it will fail with HTTP status code 409
     * with error code PoolBeingDeleted.
     *
     * @param {string} poolId The ID of the pool to delete.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolDeleteMethodOptions] Additional parameters for
     * the operation
     *
     * @param {number} [options.poolDeleteMethodOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.poolDeleteMethodOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolDeleteMethodOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.poolDeleteMethodOptions.ocpDate] The time the request
     * was issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.poolDeleteMethodOptions.ifMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.
     *
     * @param {string} [options.poolDeleteMethodOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.poolDeleteMethodOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.poolDeleteMethodOptions.ifUnmodifiedSince] A
     * timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service
     * has not been modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(poolId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolDeleteMethodOptions = (options && options.poolDeleteMethodOptions !== undefined) ? options.poolDeleteMethodOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    timeout = poolDeleteMethodOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    clientRequestId = poolDeleteMethodOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    returnClientRequestId = poolDeleteMethodOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    ocpDate = poolDeleteMethodOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    ifMatch = poolDeleteMethodOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    ifNoneMatch = poolDeleteMethodOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    ifModifiedSince = poolDeleteMethodOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    ifUnmodifiedSince = poolDeleteMethodOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'DELETE';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets basic properties of a pool.
     *
     * @param {string} poolId The ID of the pool to get.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolExistsOptions] Additional parameters for the
     * operation
     *
     * @param {number} [options.poolExistsOptions.timeout] The maximum time that
     * the server can spend processing the request, in seconds. The default is 30
     * seconds.
     *
     * @param {string} [options.poolExistsOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolExistsOptions.returnClientRequestId] Whether
     * the server should return the client-request-id in the response.
     *
     * @param {date} [options.poolExistsOptions.ocpDate] The time the request was
     * issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.poolExistsOptions.ifMatch] An ETag value associated
     * with the version of the resource known to the client. The operation will be
     * performed only if the resource's current ETag on the service exactly matches
     * the value specified by the client.
     *
     * @param {string} [options.poolExistsOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.poolExistsOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.poolExistsOptions.ifUnmodifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has not been
     * modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<boolean>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    existsWithHttpOperationResponse(poolId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolExistsOptions = (options && options.poolExistsOptions !== undefined) ? options.poolExistsOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    timeout = poolExistsOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    clientRequestId = poolExistsOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    returnClientRequestId = poolExistsOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    ocpDate = poolExistsOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    ifMatch = poolExistsOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    ifNoneMatch = poolExistsOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    ifModifiedSince = poolExistsOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    ifUnmodifiedSince = poolExistsOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'HEAD';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200 && statusCode !== 404) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                operationRes.bodyAsJson = (statusCode === 200);
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets information about the specified pool.
     *
     * @param {string} poolId The ID of the pool to get.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolGetOptions] Additional parameters for the
     * operation
     *
     * @param {string} [options.poolGetOptions.select] An OData $select clause.
     *
     * @param {string} [options.poolGetOptions.expand] An OData $expand clause.
     *
     * @param {number} [options.poolGetOptions.timeout] The maximum time that the
     * server can spend processing the request, in seconds. The default is 30
     * seconds.
     *
     * @param {string} [options.poolGetOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolGetOptions.returnClientRequestId] Whether the
     * server should return the client-request-id in the response.
     *
     * @param {date} [options.poolGetOptions.ocpDate] The time the request was
     * issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.poolGetOptions.ifMatch] An ETag value associated
     * with the version of the resource known to the client. The operation will be
     * performed only if the resource's current ETag on the service exactly matches
     * the value specified by the client.
     *
     * @param {string} [options.poolGetOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.poolGetOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.poolGetOptions.ifUnmodifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has not been
     * modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<CloudPool>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(poolId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolGetOptions = (options && options.poolGetOptions !== undefined) ? options.poolGetOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let select;
            let expand;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    select = poolGetOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    expand = poolGetOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    timeout = poolGetOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    clientRequestId = poolGetOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    returnClientRequestId = poolGetOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    ocpDate = poolGetOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    ifMatch = poolGetOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    ifNoneMatch = poolGetOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    ifModifiedSince = poolGetOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    ifUnmodifiedSince = poolGetOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (select !== null && select !== undefined) {
                queryParameters.push('$select=' + encodeURIComponent(select));
            }
            if (expand !== null && expand !== undefined) {
                queryParameters.push('$expand=' + encodeURIComponent(expand));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.CloudPool;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Updates the properties of the specified pool.
     *
     * This only replaces the pool properties specified in the request. For
     * example, if the pool has a start task associated with it, and a request does
     * not specify a start task element, then the pool keeps the existing start
     * task.
     *
     * @param {string} poolId The ID of the pool to update.
     *
     * @param {object} poolPatchParameter The parameters for the request.
     *
     * @param {object} [poolPatchParameter.startTask] A task to run on each compute
     * node as it joins the pool. The task runs when the node is added to the pool
     * or when the node is restarted. If this element is present, it overwrites any
     * existing start task. If omitted, any existing start task is left unchanged.
     *
     * @param {string} poolPatchParameter.startTask.commandLine The command line of
     * the start task. The command line does not run under a shell, and therefore
     * cannot take advantage of shell features such as environment variable
     * expansion. If you want to take advantage of such features, you should invoke
     * the shell in the command line, for example using "cmd /c MyCommand" in
     * Windows or "/bin/sh -c MyCommand" in Linux.
     *
     * @param {array} [poolPatchParameter.startTask.resourceFiles] A list of files
     * that the Batch service will download to the compute node before running the
     * command line. Files listed under this element are located in the task's
     * working directory.
     *
     * @param {array} [poolPatchParameter.startTask.environmentSettings] A list of
     * environment variable settings for the start task.
     *
     * @param {object} [poolPatchParameter.startTask.userIdentity] The user
     * identity under which the start task runs. If omitted, the task runs as a
     * non-administrative user unique to the task.
     *
     * @param {string} [poolPatchParameter.startTask.userIdentity.userName] The
     * name of the user identity under which the task is run. The userName and
     * autoUser properties are mutually exclusive; you must specify one but not
     * both.
     *
     * @param {object} [poolPatchParameter.startTask.userIdentity.autoUser] The
     * auto user under which the task is run. The userName and autoUser properties
     * are mutually exclusive; you must specify one but not both.
     *
     * @param {string} [poolPatchParameter.startTask.userIdentity.autoUser.scope]
     * The scope for the auto user Values are:
     *
     * pool - specifies that the task runs as the common auto user account which is
     * created on every node in a pool.
     * task - specifies that the service should create a new user for the task.
     * The default value is task. Possible values include: 'task', 'pool'
     *
     * @param {string}
     * [poolPatchParameter.startTask.userIdentity.autoUser.elevationLevel] The
     * elevation level of the auto user. nonAdmin - The auto user is a standard
     * user without elevated access. admin - The auto user is a user with elevated
     * access and operates with full Administrator permissions. The default value
     * is nonAdmin. Possible values include: 'nonAdmin', 'admin'
     *
     * @param {number} [poolPatchParameter.startTask.maxTaskRetryCount] The maximum
     * number of times the task may be retried. The Batch service retries a task if
     * its exit code is nonzero. Note that this value specifically controls the
     * number of retries. The Batch service will try the task once, and may then
     * retry up to this limit. For example, if the maximum retry count is 3, Batch
     * tries the task up to 4 times (one initial try and 3 retries). If the maximum
     * retry count is 0, the Batch service does not retry the task. If the maximum
     * retry count is -1, the Batch service retries the task without limit.
     *
     * @param {boolean} [poolPatchParameter.startTask.waitForSuccess] Whether the
     * Batch service should wait for the start task to complete successfully (that
     * is, to exit with exit code 0) before scheduling any tasks on the compute
     * node. If true and the start task fails on a compute node, the Batch service
     * retries the start task up to its maximum retry count (maxTaskRetryCount). If
     * the task has still not completed successfully after all retries, then the
     * Batch service marks the compute node unusable, and will not schedule tasks
     * to it. This condition can be detected via the node state and failure info
     * details. If false, the Batch service will not wait for the start task to
     * complete. In this case, other tasks can start executing on the compute node
     * while the start task is still running; and even if the start task fails, new
     * tasks will continue to be scheduled on the node. The default is false.
     *
     * @param {array} [poolPatchParameter.certificateReferences] A list of
     * certificates to be installed on each compute node in the pool. If this
     * element is present, it replaces any existing certificate references
     * configured on the pool. If omitted, any existing certificate references are
     * left unchanged. For Windows compute nodes, the Batch service installs the
     * certificates to the specified certificate store and location. For Linux
     * compute nodes, the certificates are stored in a directory inside the task
     * working directory and an environment variable AZ_BATCH_CERTIFICATES_DIR is
     * supplied to the task to query for this location. For certificates with
     * visibility of 'remoteUser', a 'certs' directory is created in the user's
     * home directory (e.g., /home/{user-name}/certs) and certificates are placed
     * in that directory.
     *
     * @param {array} [poolPatchParameter.applicationPackageReferences] A list of
     * application packages to be installed on each compute node in the pool.
     * Changes to application package references affect all new compute nodes
     * joining the pool, but do not affect compute nodes that are already in the
     * pool until they are rebooted or reimaged. If this element is present, it
     * replaces any existing application package references. If you specify an
     * empty collection, then all application package references are removed from
     * the pool. If omitted, any existing application package references are left
     * unchanged.
     *
     * @param {array} [poolPatchParameter.metadata] A list of name-value pairs
     * associated with the pool as metadata. If this element is present, it
     * replaces any existing metadata configured on the pool. If you specify an
     * empty collection, any metadata is removed from the pool. If omitted, any
     * existing metadata is left unchanged.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolPatchOptions] Additional parameters for the
     * operation
     *
     * @param {number} [options.poolPatchOptions.timeout] The maximum time that the
     * server can spend processing the request, in seconds. The default is 30
     * seconds.
     *
     * @param {string} [options.poolPatchOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolPatchOptions.returnClientRequestId] Whether
     * the server should return the client-request-id in the response.
     *
     * @param {date} [options.poolPatchOptions.ocpDate] The time the request was
     * issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.poolPatchOptions.ifMatch] An ETag value associated
     * with the version of the resource known to the client. The operation will be
     * performed only if the resource's current ETag on the service exactly matches
     * the value specified by the client.
     *
     * @param {string} [options.poolPatchOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.poolPatchOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.poolPatchOptions.ifUnmodifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has not been
     * modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    patchWithHttpOperationResponse(poolId, poolPatchParameter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolPatchOptions = (options && options.poolPatchOptions !== undefined) ? options.poolPatchOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (poolPatchParameter === null || poolPatchParameter === undefined) {
                    throw new Error('poolPatchParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    timeout = poolPatchOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    clientRequestId = poolPatchOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    returnClientRequestId = poolPatchOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    ocpDate = poolPatchOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    ifMatch = poolPatchOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    ifNoneMatch = poolPatchOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    ifModifiedSince = poolPatchOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    ifUnmodifiedSince = poolPatchOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'PATCH';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (poolPatchParameter !== null && poolPatchParameter !== undefined) {
                    let requestModelMapper = Mappers.PoolPatchParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, poolPatchParameter, 'poolPatchParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(poolPatchParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Disables automatic scaling for a pool.
     *
     * @param {string} poolId The ID of the pool on which to disable automatic
     * scaling.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolDisableAutoScaleOptions] Additional parameters
     * for the operation
     *
     * @param {number} [options.poolDisableAutoScaleOptions.timeout] The maximum
     * time that the server can spend processing the request, in seconds. The
     * default is 30 seconds.
     *
     * @param {string} [options.poolDisableAutoScaleOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolDisableAutoScaleOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.poolDisableAutoScaleOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    disableAutoScaleWithHttpOperationResponse(poolId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolDisableAutoScaleOptions = (options && options.poolDisableAutoScaleOptions !== undefined) ? options.poolDisableAutoScaleOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolDisableAutoScaleOptions !== null && poolDisableAutoScaleOptions !== undefined) {
                    timeout = poolDisableAutoScaleOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolDisableAutoScaleOptions !== null && poolDisableAutoScaleOptions !== undefined) {
                    clientRequestId = poolDisableAutoScaleOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolDisableAutoScaleOptions !== null && poolDisableAutoScaleOptions !== undefined) {
                    returnClientRequestId = poolDisableAutoScaleOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolDisableAutoScaleOptions !== null && poolDisableAutoScaleOptions !== undefined) {
                    ocpDate = poolDisableAutoScaleOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/disableautoscale';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Enables automatic scaling for a pool.
     *
     * You cannot enable automatic scaling on a pool if a resize operation is in
     * progress on the pool. If automatic scaling of the pool is currently
     * disabled, you must specify a valid autoscale formula as part of the request.
     * If automatic scaling of the pool is already enabled, you may specify a new
     * autoscale formula and/or a new evaluation interval. You cannot call this API
     * for the same pool more than once every 30 seconds.
     *
     * @param {string} poolId The ID of the pool on which to enable automatic
     * scaling.
     *
     * @param {object} poolEnableAutoScaleParameter The parameters for the request.
     *
     * @param {string} [poolEnableAutoScaleParameter.autoScaleFormula] The formula
     * for the desired number of compute nodes in the pool. The formula is checked
     * for validity before it is applied to the pool. If the formula is not valid,
     * the Batch service rejects the request with detailed error information. For
     * more information about specifying this formula, see Automatically scale
     * compute nodes in an Azure Batch pool
     * (https://azure.microsoft.com/en-us/documentation/articles/batch-automatic-scaling).
     *
     * @param {moment.duration}
     * [poolEnableAutoScaleParameter.autoScaleEvaluationInterval] The time interval
     * at which to automatically adjust the pool size according to the autoscale
     * formula. The default value is 15 minutes. The minimum and maximum value are
     * 5 minutes and 168 hours respectively. If you specify a value less than 5
     * minutes or greater than 168 hours, the Batch service rejects the request
     * with an invalid property value error; if you are calling the REST API
     * directly, the HTTP status code is 400 (Bad Request). If you specify a new
     * interval, then the existing autoscale evaluation schedule will be stopped
     * and a new autoscale evaluation schedule will be started, with its starting
     * time being the time when this request was issued.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolEnableAutoScaleOptions] Additional parameters
     * for the operation
     *
     * @param {number} [options.poolEnableAutoScaleOptions.timeout] The maximum
     * time that the server can spend processing the request, in seconds. The
     * default is 30 seconds.
     *
     * @param {string} [options.poolEnableAutoScaleOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolEnableAutoScaleOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.poolEnableAutoScaleOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {string} [options.poolEnableAutoScaleOptions.ifMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.
     *
     * @param {string} [options.poolEnableAutoScaleOptions.ifNoneMatch] An ETag
     * value associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.poolEnableAutoScaleOptions.ifModifiedSince] A
     * timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service
     * has been modified since the specified time.
     *
     * @param {date} [options.poolEnableAutoScaleOptions.ifUnmodifiedSince] A
     * timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service
     * has not been modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    enableAutoScaleWithHttpOperationResponse(poolId, poolEnableAutoScaleParameter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolEnableAutoScaleOptions = (options && options.poolEnableAutoScaleOptions !== undefined) ? options.poolEnableAutoScaleOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (poolEnableAutoScaleParameter === null || poolEnableAutoScaleParameter === undefined) {
                    throw new Error('poolEnableAutoScaleParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    timeout = poolEnableAutoScaleOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    clientRequestId = poolEnableAutoScaleOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    returnClientRequestId = poolEnableAutoScaleOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    ocpDate = poolEnableAutoScaleOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    ifMatch = poolEnableAutoScaleOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    ifNoneMatch = poolEnableAutoScaleOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    ifModifiedSince = poolEnableAutoScaleOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    ifUnmodifiedSince = poolEnableAutoScaleOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/enableautoscale';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (poolEnableAutoScaleParameter !== null && poolEnableAutoScaleParameter !== undefined) {
                    let requestModelMapper = Mappers.PoolEnableAutoScaleParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, poolEnableAutoScaleParameter, 'poolEnableAutoScaleParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(poolEnableAutoScaleParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets the result of evaluating an automatic scaling formula on the
     * pool.
     *
     * This API is primarily for validating an autoscale formula, as it simply
     * returns the result without applying the formula to the pool. The pool must
     * have auto scaling enabled in order to evaluate a formula.
     *
     * @param {string} poolId The ID of the pool on which to evaluate the automatic
     * scaling formula.
     *
     * @param {string} autoScaleFormula The formula for the desired number of
     * compute nodes in the pool. The formula is validated and its results
     * calculated, but it is not applied to the pool. To apply the formula to the
     * pool, 'Enable automatic scaling on a pool'. For more information about
     * specifying this formula, see Automatically scale compute nodes in an Azure
     * Batch pool
     * (https://azure.microsoft.com/en-us/documentation/articles/batch-automatic-scaling).
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolEvaluateAutoScaleOptions] Additional parameters
     * for the operation
     *
     * @param {number} [options.poolEvaluateAutoScaleOptions.timeout] The maximum
     * time that the server can spend processing the request, in seconds. The
     * default is 30 seconds.
     *
     * @param {string} [options.poolEvaluateAutoScaleOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean}
     * [options.poolEvaluateAutoScaleOptions.returnClientRequestId] Whether the
     * server should return the client-request-id in the response.
     *
     * @param {date} [options.poolEvaluateAutoScaleOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<AutoScaleRun>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    evaluateAutoScaleWithHttpOperationResponse(poolId, autoScaleFormula, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolEvaluateAutoScaleOptions = (options && options.poolEvaluateAutoScaleOptions !== undefined) ? options.poolEvaluateAutoScaleOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (autoScaleFormula === null || autoScaleFormula === undefined || typeof autoScaleFormula.valueOf() !== 'string') {
                    throw new Error('autoScaleFormula cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let poolEvaluateAutoScaleParameter = {};
            try {
                if (poolEvaluateAutoScaleOptions !== null && poolEvaluateAutoScaleOptions !== undefined) {
                    timeout = poolEvaluateAutoScaleOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolEvaluateAutoScaleOptions !== null && poolEvaluateAutoScaleOptions !== undefined) {
                    clientRequestId = poolEvaluateAutoScaleOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolEvaluateAutoScaleOptions !== null && poolEvaluateAutoScaleOptions !== undefined) {
                    returnClientRequestId = poolEvaluateAutoScaleOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolEvaluateAutoScaleOptions !== null && poolEvaluateAutoScaleOptions !== undefined) {
                    ocpDate = poolEvaluateAutoScaleOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (autoScaleFormula !== null && autoScaleFormula !== undefined) {
                    poolEvaluateAutoScaleParameter.autoScaleFormula = autoScaleFormula;
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/evaluateautoscale';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (poolEvaluateAutoScaleParameter !== null && poolEvaluateAutoScaleParameter !== undefined) {
                    let requestModelMapper = Mappers.PoolEvaluateAutoScaleParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, poolEvaluateAutoScaleParameter, 'poolEvaluateAutoScaleParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(poolEvaluateAutoScaleParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.AutoScaleRun;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Changes the number of compute nodes that are assigned to a pool.
     *
     * You can only resize a pool when its allocation state is steady. If the pool
     * is already resizing, the request fails with status code 409. When you resize
     * a pool, the pool's allocation state changes from steady to resizing. You
     * cannot resize pools which are configured for automatic scaling. If you try
     * to do this, the Batch service returns an error 409. If you resize a pool
     * downwards, the Batch service chooses which nodes to remove. To remove
     * specific nodes, use the pool remove nodes API instead.
     *
     * @param {string} poolId The ID of the pool to resize.
     *
     * @param {object} poolResizeParameter The parameters for the request.
     *
     * @param {number} [poolResizeParameter.targetDedicatedNodes] The desired
     * number of dedicated compute nodes in the pool.
     *
     * @param {number} [poolResizeParameter.targetLowPriorityNodes] The desired
     * number of low-priority compute nodes in the pool.
     *
     * @param {moment.duration} [poolResizeParameter.resizeTimeout] The timeout for
     * allocation of compute nodes to the pool or removal of compute nodes from the
     * pool. The default value is 15 minutes. The minimum value is 5 minutes. If
     * you specify a value less than 5 minutes, the Batch service returns an error;
     * if you are calling the REST API directly, the HTTP status code is 400 (Bad
     * Request).
     *
     * @param {string} [poolResizeParameter.nodeDeallocationOption] Determines what
     * to do with a node and its running task(s) if the pool size is decreasing.
     * The default value is requeue. Possible values include: 'requeue',
     * 'terminate', 'taskCompletion', 'retainedData'
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolResizeOptions] Additional parameters for the
     * operation
     *
     * @param {number} [options.poolResizeOptions.timeout] The maximum time that
     * the server can spend processing the request, in seconds. The default is 30
     * seconds.
     *
     * @param {string} [options.poolResizeOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolResizeOptions.returnClientRequestId] Whether
     * the server should return the client-request-id in the response.
     *
     * @param {date} [options.poolResizeOptions.ocpDate] The time the request was
     * issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.poolResizeOptions.ifMatch] An ETag value associated
     * with the version of the resource known to the client. The operation will be
     * performed only if the resource's current ETag on the service exactly matches
     * the value specified by the client.
     *
     * @param {string} [options.poolResizeOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.poolResizeOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.poolResizeOptions.ifUnmodifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has not been
     * modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    resizeWithHttpOperationResponse(poolId, poolResizeParameter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolResizeOptions = (options && options.poolResizeOptions !== undefined) ? options.poolResizeOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (poolResizeParameter === null || poolResizeParameter === undefined) {
                    throw new Error('poolResizeParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    timeout = poolResizeOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    clientRequestId = poolResizeOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    returnClientRequestId = poolResizeOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    ocpDate = poolResizeOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    ifMatch = poolResizeOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    ifNoneMatch = poolResizeOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    ifModifiedSince = poolResizeOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    ifUnmodifiedSince = poolResizeOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/resize';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (poolResizeParameter !== null && poolResizeParameter !== undefined) {
                    let requestModelMapper = Mappers.PoolResizeParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, poolResizeParameter, 'poolResizeParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(poolResizeParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Stops an ongoing resize operation on the pool.
     *
     * This does not restore the pool to its previous state before the resize
     * operation: it only stops any further changes being made, and the pool
     * maintains its current state. After stopping, the pool stabilizes at the
     * number of nodes it was at when the stop operation was done. During the stop
     * operation, the pool allocation state changes first to stopping and then to
     * steady. A resize operation need not be an explicit resize pool request; this
     * API can also be used to halt the initial sizing of the pool when it is
     * created.
     *
     * @param {string} poolId The ID of the pool whose resizing you want to stop.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolStopResizeOptions] Additional parameters for
     * the operation
     *
     * @param {number} [options.poolStopResizeOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.poolStopResizeOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolStopResizeOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.poolStopResizeOptions.ocpDate] The time the request
     * was issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.poolStopResizeOptions.ifMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.
     *
     * @param {string} [options.poolStopResizeOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.poolStopResizeOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.poolStopResizeOptions.ifUnmodifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has not been
     * modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    stopResizeWithHttpOperationResponse(poolId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolStopResizeOptions = (options && options.poolStopResizeOptions !== undefined) ? options.poolStopResizeOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    timeout = poolStopResizeOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    clientRequestId = poolStopResizeOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    returnClientRequestId = poolStopResizeOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    ocpDate = poolStopResizeOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    ifMatch = poolStopResizeOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    ifNoneMatch = poolStopResizeOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    ifModifiedSince = poolStopResizeOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    ifUnmodifiedSince = poolStopResizeOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/stopresize';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Updates the properties of the specified pool.
     *
     * This fully replaces all the updateable properties of the pool. For example,
     * if the pool has a start task associated with it and if start task is not
     * specified with this request, then the Batch service will remove the existing
     * start task.
     *
     * @param {string} poolId The ID of the pool to update.
     *
     * @param {object} poolUpdatePropertiesParameter The parameters for the
     * request.
     *
     * @param {object} [poolUpdatePropertiesParameter.startTask] A task to run on
     * each compute node as it joins the pool. The task runs when the node is added
     * to the pool or when the node is restarted. If this element is present, it
     * overwrites any existing start task. If omitted, any existing start task is
     * removed from the pool.
     *
     * @param {string} poolUpdatePropertiesParameter.startTask.commandLine The
     * command line of the start task. The command line does not run under a shell,
     * and therefore cannot take advantage of shell features such as environment
     * variable expansion. If you want to take advantage of such features, you
     * should invoke the shell in the command line, for example using "cmd /c
     * MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux.
     *
     * @param {array} [poolUpdatePropertiesParameter.startTask.resourceFiles] A
     * list of files that the Batch service will download to the compute node
     * before running the command line. Files listed under this element are located
     * in the task's working directory.
     *
     * @param {array} [poolUpdatePropertiesParameter.startTask.environmentSettings]
     * A list of environment variable settings for the start task.
     *
     * @param {object} [poolUpdatePropertiesParameter.startTask.userIdentity] The
     * user identity under which the start task runs. If omitted, the task runs as
     * a non-administrative user unique to the task.
     *
     * @param {string}
     * [poolUpdatePropertiesParameter.startTask.userIdentity.userName] The name of
     * the user identity under which the task is run. The userName and autoUser
     * properties are mutually exclusive; you must specify one but not both.
     *
     * @param {object}
     * [poolUpdatePropertiesParameter.startTask.userIdentity.autoUser] The auto
     * user under which the task is run. The userName and autoUser properties are
     * mutually exclusive; you must specify one but not both.
     *
     * @param {string}
     * [poolUpdatePropertiesParameter.startTask.userIdentity.autoUser.scope] The
     * scope for the auto user Values are:
     *
     * pool - specifies that the task runs as the common auto user account which is
     * created on every node in a pool.
     * task - specifies that the service should create a new user for the task.
     * The default value is task. Possible values include: 'task', 'pool'
     *
     * @param {string}
     * [poolUpdatePropertiesParameter.startTask.userIdentity.autoUser.elevationLevel]
     * The elevation level of the auto user. nonAdmin - The auto user is a standard
     * user without elevated access. admin - The auto user is a user with elevated
     * access and operates with full Administrator permissions. The default value
     * is nonAdmin. Possible values include: 'nonAdmin', 'admin'
     *
     * @param {number} [poolUpdatePropertiesParameter.startTask.maxTaskRetryCount]
     * The maximum number of times the task may be retried. The Batch service
     * retries a task if its exit code is nonzero. Note that this value
     * specifically controls the number of retries. The Batch service will try the
     * task once, and may then retry up to this limit. For example, if the maximum
     * retry count is 3, Batch tries the task up to 4 times (one initial try and 3
     * retries). If the maximum retry count is 0, the Batch service does not retry
     * the task. If the maximum retry count is -1, the Batch service retries the
     * task without limit.
     *
     * @param {boolean} [poolUpdatePropertiesParameter.startTask.waitForSuccess]
     * Whether the Batch service should wait for the start task to complete
     * successfully (that is, to exit with exit code 0) before scheduling any tasks
     * on the compute node. If true and the start task fails on a compute node, the
     * Batch service retries the start task up to its maximum retry count
     * (maxTaskRetryCount). If the task has still not completed successfully after
     * all retries, then the Batch service marks the compute node unusable, and
     * will not schedule tasks to it. This condition can be detected via the node
     * state and failure info details. If false, the Batch service will not wait
     * for the start task to complete. In this case, other tasks can start
     * executing on the compute node while the start task is still running; and
     * even if the start task fails, new tasks will continue to be scheduled on the
     * node. The default is false.
     *
     * @param {array} poolUpdatePropertiesParameter.certificateReferences A list of
     * certificates to be installed on each compute node in the pool. This list
     * replaces any existing certificate references configured on the pool. If you
     * specify an empty collection, any existing certificate references are removed
     * from the pool. For Windows compute nodes, the Batch service installs the
     * certificates to the specified certificate store and location. For Linux
     * compute nodes, the certificates are stored in a directory inside the task
     * working directory and an environment variable AZ_BATCH_CERTIFICATES_DIR is
     * supplied to the task to query for this location. For certificates with
     * visibility of 'remoteUser', a 'certs' directory is created in the user's
     * home directory (e.g., /home/{user-name}/certs) and certificates are placed
     * in that directory.
     *
     * @param {array} poolUpdatePropertiesParameter.applicationPackageReferences A
     * list of application packages to be installed on each compute node in the
     * pool. The list replaces any existing application package references on the
     * pool. Changes to application package references affect all new compute nodes
     * joining the pool, but do not affect compute nodes that are already in the
     * pool until they are rebooted or reimaged. If omitted, or if you specify an
     * empty collection, any existing application packages references are removed
     * from the pool.
     *
     * @param {array} poolUpdatePropertiesParameter.metadata A list of name-value
     * pairs associated with the pool as metadata. This list replaces any existing
     * metadata configured on the pool. If omitted, or if you specify an empty
     * collection, any existing metadata is removed from the pool.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolUpdatePropertiesOptions] Additional parameters
     * for the operation
     *
     * @param {number} [options.poolUpdatePropertiesOptions.timeout] The maximum
     * time that the server can spend processing the request, in seconds. The
     * default is 30 seconds.
     *
     * @param {string} [options.poolUpdatePropertiesOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolUpdatePropertiesOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.poolUpdatePropertiesOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updatePropertiesWithHttpOperationResponse(poolId, poolUpdatePropertiesParameter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolUpdatePropertiesOptions = (options && options.poolUpdatePropertiesOptions !== undefined) ? options.poolUpdatePropertiesOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (poolUpdatePropertiesParameter === null || poolUpdatePropertiesParameter === undefined) {
                    throw new Error('poolUpdatePropertiesParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolUpdatePropertiesOptions !== null && poolUpdatePropertiesOptions !== undefined) {
                    timeout = poolUpdatePropertiesOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolUpdatePropertiesOptions !== null && poolUpdatePropertiesOptions !== undefined) {
                    clientRequestId = poolUpdatePropertiesOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolUpdatePropertiesOptions !== null && poolUpdatePropertiesOptions !== undefined) {
                    returnClientRequestId = poolUpdatePropertiesOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolUpdatePropertiesOptions !== null && poolUpdatePropertiesOptions !== undefined) {
                    ocpDate = poolUpdatePropertiesOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/updateproperties';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (poolUpdatePropertiesParameter !== null && poolUpdatePropertiesParameter !== undefined) {
                    let requestModelMapper = Mappers.PoolUpdatePropertiesParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, poolUpdatePropertiesParameter, 'poolUpdatePropertiesParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(poolUpdatePropertiesParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 204) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Upgrades the operating system of the specified pool.
     *
     * During an upgrade, the Batch service upgrades each compute node in the pool.
     * When a compute node is chosen for upgrade, any tasks running on that node
     * are removed from the node and returned to the queue to be rerun later (or on
     * a different compute node). The node will be unavailable until the upgrade is
     * complete. This operation results in temporarily reduced pool capacity as
     * nodes are taken out of service to be upgraded. Although the Batch service
     * tries to avoid upgrading all compute nodes at the same time, it does not
     * guarantee to do this (particularly on small pools); therefore, the pool may
     * be temporarily unavailable to run tasks. When this operation runs, the pool
     * state changes to upgrading. When all compute nodes have finished upgrading,
     * the pool state returns to active. While the upgrade is in progress, the
     * pool's currentOSVersion reflects the OS version that nodes are upgrading
     * from, and targetOSVersion reflects the OS version that nodes are upgrading
     * to. Once the upgrade is complete, currentOSVersion is updated to reflect the
     * OS version now running on all nodes. This operation can only be invoked on
     * pools created with the cloudServiceConfiguration property.
     *
     * @param {string} poolId The ID of the pool to upgrade.
     *
     * @param {string} targetOSVersion The Azure Guest OS version to be installed
     * on the virtual machines in the pool.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolUpgradeOSOptions] Additional parameters for the
     * operation
     *
     * @param {number} [options.poolUpgradeOSOptions.timeout] The maximum time that
     * the server can spend processing the request, in seconds. The default is 30
     * seconds.
     *
     * @param {string} [options.poolUpgradeOSOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolUpgradeOSOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.poolUpgradeOSOptions.ocpDate] The time the request
     * was issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.poolUpgradeOSOptions.ifMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.
     *
     * @param {string} [options.poolUpgradeOSOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.poolUpgradeOSOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.poolUpgradeOSOptions.ifUnmodifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has not been
     * modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    upgradeOSWithHttpOperationResponse(poolId, targetOSVersion, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolUpgradeOSOptions = (options && options.poolUpgradeOSOptions !== undefined) ? options.poolUpgradeOSOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (targetOSVersion === null || targetOSVersion === undefined || typeof targetOSVersion.valueOf() !== 'string') {
                    throw new Error('targetOSVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            let poolUpgradeOSParameter = {};
            try {
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    timeout = poolUpgradeOSOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    clientRequestId = poolUpgradeOSOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    returnClientRequestId = poolUpgradeOSOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    ocpDate = poolUpgradeOSOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    ifMatch = poolUpgradeOSOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    ifNoneMatch = poolUpgradeOSOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    ifModifiedSince = poolUpgradeOSOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    ifUnmodifiedSince = poolUpgradeOSOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
                if (targetOSVersion !== null && targetOSVersion !== undefined) {
                    poolUpgradeOSParameter.targetOSVersion = targetOSVersion;
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/upgradeos';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (poolUpgradeOSParameter !== null && poolUpgradeOSParameter !== undefined) {
                    let requestModelMapper = Mappers.PoolUpgradeOSParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, poolUpgradeOSParameter, 'poolUpgradeOSParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(poolUpgradeOSParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Removes compute nodes from the specified pool.
     *
     * This operation can only run when the allocation state of the pool is steady.
     * When this operation runs, the allocation state changes from steady to
     * resizing.
     *
     * @param {string} poolId The ID of the pool from which you want to remove
     * nodes.
     *
     * @param {object} nodeRemoveParameter The parameters for the request.
     *
     * @param {array} nodeRemoveParameter.nodeList A list containing the IDs of the
     * compute nodes to be removed from the specified pool.
     *
     * @param {moment.duration} [nodeRemoveParameter.resizeTimeout] The timeout for
     * removal of compute nodes to the pool. The default value is 15 minutes. The
     * minimum value is 5 minutes. If you specify a value less than 5 minutes, the
     * Batch service returns an error; if you are calling the REST API directly,
     * the HTTP status code is 400 (Bad Request).
     *
     * @param {string} [nodeRemoveParameter.nodeDeallocationOption] Determines what
     * to do with a node and its running task(s) after it has been selected for
     * deallocation. The default value is requeue. Possible values include:
     * 'requeue', 'terminate', 'taskCompletion', 'retainedData'
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolRemoveNodesOptions] Additional parameters for
     * the operation
     *
     * @param {number} [options.poolRemoveNodesOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.poolRemoveNodesOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolRemoveNodesOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.poolRemoveNodesOptions.ocpDate] The time the request
     * was issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.poolRemoveNodesOptions.ifMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.
     *
     * @param {string} [options.poolRemoveNodesOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.poolRemoveNodesOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.poolRemoveNodesOptions.ifUnmodifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has not been
     * modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    removeNodesWithHttpOperationResponse(poolId, nodeRemoveParameter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolRemoveNodesOptions = (options && options.poolRemoveNodesOptions !== undefined) ? options.poolRemoveNodesOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeRemoveParameter === null || nodeRemoveParameter === undefined) {
                    throw new Error('nodeRemoveParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    timeout = poolRemoveNodesOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    clientRequestId = poolRemoveNodesOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    returnClientRequestId = poolRemoveNodesOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    ocpDate = poolRemoveNodesOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    ifMatch = poolRemoveNodesOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    ifNoneMatch = poolRemoveNodesOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    ifModifiedSince = poolRemoveNodesOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    ifUnmodifiedSince = poolRemoveNodesOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/removenodes';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (nodeRemoveParameter !== null && nodeRemoveParameter !== undefined) {
                    let requestModelMapper = Mappers.NodeRemoveParameter;
                    requestModel = client.serializer.serialize(requestModelMapper, nodeRemoveParameter, 'nodeRemoveParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(nodeRemoveParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the usage metrics, aggregated by pool across individual time
     * intervals, for the specified account.
     *
     * If you do not specify a $filter clause including a poolId, the response
     * includes all pools that existed in the account in the time range of the
     * returned aggregation intervals. If you do not specify a $filter clause
     * including a startTime or endTime these filters default to the start and end
     * times of the last aggregation interval currently available; that is, only
     * the last aggregation interval is returned.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolListUsageMetricsNextOptions] Additional
     * parameters for the operation
     *
     * @param {string} [options.poolListUsageMetricsNextOptions.clientRequestId]
     * The caller-generated request identity, in the form of a GUID with no
     * decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean}
     * [options.poolListUsageMetricsNextOptions.returnClientRequestId] Whether the
     * server should return the client-request-id in the response.
     *
     * @param {date} [options.poolListUsageMetricsNextOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<PoolListUsageMetricsResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listUsageMetricsNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolListUsageMetricsNextOptions = (options && options.poolListUsageMetricsNextOptions !== undefined) ? options.poolListUsageMetricsNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolListUsageMetricsNextOptions !== null && poolListUsageMetricsNextOptions !== undefined) {
                    clientRequestId = poolListUsageMetricsNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolListUsageMetricsNextOptions !== null && poolListUsageMetricsNextOptions !== undefined) {
                    returnClientRequestId = poolListUsageMetricsNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolListUsageMetricsNextOptions !== null && poolListUsageMetricsNextOptions !== undefined) {
                    ocpDate = poolListUsageMetricsNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.PoolListUsageMetricsResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the pools in the specified account.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolListNextOptions] Additional parameters for the
     * operation
     *
     * @param {string} [options.poolListNextOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolListNextOptions.returnClientRequestId] Whether
     * the server should return the client-request-id in the response.
     *
     * @param {date} [options.poolListNextOptions.ocpDate] The time the request was
     * issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<CloudPoolListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolListNextOptions = (options && options.poolListNextOptions !== undefined) ? options.poolListNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolListNextOptions !== null && poolListNextOptions !== undefined) {
                    clientRequestId = poolListNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolListNextOptions !== null && poolListNextOptions !== undefined) {
                    returnClientRequestId = poolListNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolListNextOptions !== null && poolListNextOptions !== undefined) {
                    ocpDate = poolListNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.BatchError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.CloudPoolListResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    listUsageMetrics(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listUsageMetricsWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listUsageMetricsWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    getAllLifetimeStatistics(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getAllLifetimeStatisticsWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getAllLifetimeStatisticsWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    add(pool, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.addWithHttpOperationResponse(pool, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.addWithHttpOperationResponse(pool, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    list(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    deleteMethod(poolId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteMethodWithHttpOperationResponse(poolId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deleteMethodWithHttpOperationResponse(poolId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    exists(poolId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.existsWithHttpOperationResponse(poolId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.existsWithHttpOperationResponse(poolId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    get(poolId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(poolId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getWithHttpOperationResponse(poolId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    patch(poolId, poolPatchParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.patchWithHttpOperationResponse(poolId, poolPatchParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.patchWithHttpOperationResponse(poolId, poolPatchParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    disableAutoScale(poolId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.disableAutoScaleWithHttpOperationResponse(poolId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.disableAutoScaleWithHttpOperationResponse(poolId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    enableAutoScale(poolId, poolEnableAutoScaleParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.enableAutoScaleWithHttpOperationResponse(poolId, poolEnableAutoScaleParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.enableAutoScaleWithHttpOperationResponse(poolId, poolEnableAutoScaleParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    evaluateAutoScale(poolId, autoScaleFormula, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.evaluateAutoScaleWithHttpOperationResponse(poolId, autoScaleFormula, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.evaluateAutoScaleWithHttpOperationResponse(poolId, autoScaleFormula, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    resize(poolId, poolResizeParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.resizeWithHttpOperationResponse(poolId, poolResizeParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.resizeWithHttpOperationResponse(poolId, poolResizeParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    stopResize(poolId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.stopResizeWithHttpOperationResponse(poolId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.stopResizeWithHttpOperationResponse(poolId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    updateProperties(poolId, poolUpdatePropertiesParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.updatePropertiesWithHttpOperationResponse(poolId, poolUpdatePropertiesParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.updatePropertiesWithHttpOperationResponse(poolId, poolUpdatePropertiesParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    upgradeOS(poolId, targetOSVersion, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.upgradeOSWithHttpOperationResponse(poolId, targetOSVersion, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.upgradeOSWithHttpOperationResponse(poolId, targetOSVersion, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    removeNodes(poolId, nodeRemoveParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.removeNodesWithHttpOperationResponse(poolId, nodeRemoveParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.removeNodesWithHttpOperationResponse(poolId, nodeRemoveParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listUsageMetricsNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listUsageMetricsNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listUsageMetricsNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
}
exports.Pool = Pool;
//# sourceMappingURL=pool.js.map