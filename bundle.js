var className =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 21);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const webResource_1 = __webpack_require__(5);
exports.WebResource = webResource_1.WebResource;
const httpOperationResponse_1 = __webpack_require__(13);
exports.HttpOperationResponse = httpOperationResponse_1.HttpOperationResponse;
const restError_1 = __webpack_require__(12);
exports.RestError = restError_1.RestError;
const serviceClient_1 = __webpack_require__(29);
exports.ServiceClient = serviceClient_1.ServiceClient;
const constants_1 = __webpack_require__(4);
exports.Constants = constants_1.Constants;
const requestPipeline_1 = __webpack_require__(14);
exports.RequestPipeline = requestPipeline_1.RequestPipeline;
const logFilter_1 = __webpack_require__(34);
exports.LogFilter = logFilter_1.LogFilter;
const baseFilter_1 = __webpack_require__(3);
exports.BaseFilter = baseFilter_1.BaseFilter;
const exponentialRetryPolicyFilter_1 = __webpack_require__(15);
exports.ExponentialRetryPolicyFilter = exponentialRetryPolicyFilter_1.ExponentialRetryPolicyFilter;
const systemErrorRetryPolicyFilter_1 = __webpack_require__(16);
exports.SystemErrorRetryPolicyFilter = systemErrorRetryPolicyFilter_1.SystemErrorRetryPolicyFilter;
const redirectFilter_1 = __webpack_require__(17);
exports.RedirectFilter = redirectFilter_1.RedirectFilter;
const signingFilter_1 = __webpack_require__(18);
exports.SigningFilter = signingFilter_1.SigningFilter;
const msRestUserAgentFilter_1 = __webpack_require__(19);
exports.MsRestUserAgentFilter = msRestUserAgentFilter_1.MsRestUserAgentFilter;
const serializer_1 = __webpack_require__(35);
exports.MapperType = serializer_1.MapperType;
exports.Serializer = serializer_1.Serializer;
exports.serializeObject = serializer_1.serializeObject;
const utils_1 = __webpack_require__(2);
exports.stripRequest = utils_1.stripRequest;
exports.stripResponse = utils_1.stripResponse;
exports.delay = utils_1.delay;
exports.executePromisesSequentially = utils_1.executePromisesSequentially;
exports.generateUuid = utils_1.generateUuid;
exports.encodeUri = utils_1.encodeUri;
exports.promiseToCallback = utils_1.promiseToCallback;
exports.promiseToServiceCallback = utils_1.promiseToServiceCallback;
exports.isValidUuid = utils_1.isValidUuid;
exports.dispatchRequest = utils_1.dispatchRequest;
// Credentials
const tokenCredentials_1 = __webpack_require__(39);
exports.TokenCredentials = tokenCredentials_1.TokenCredentials;
const basicAuthenticationCredentials_1 = __webpack_require__(40);
exports.BasicAuthenticationCredentials = basicAuthenticationCredentials_1.BasicAuthenticationCredentials;
const isStream = __webpack_require__(20);
exports.isStream = isStream;
//# sourceMappingURL=msRest.js.map

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ms_rest_azure_ts__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ms_rest_azure_ts___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_ms_rest_azure_ts__);
/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

const CloudError = __WEBPACK_IMPORTED_MODULE_0_ms_rest_azure_ts__["CloudErrorMapper"];
/* harmony export (immutable) */ __webpack_exports__["CloudError"] = CloudError;

const BaseResource = __WEBPACK_IMPORTED_MODULE_0_ms_rest_azure_ts__["BaseResourceMapper"];
/* harmony export (immutable) */ __webpack_exports__["BaseResource"] = BaseResource;

const PoolUsageMetrics = {
    required: false,
    serializedName: 'PoolUsageMetrics',
    type: {
        name: 'Composite',
        className: 'PoolUsageMetrics',
        modelProperties: {
            poolId: {
                required: true,
                serializedName: 'poolId',
                type: {
                    name: 'String'
                }
            },
            startTime: {
                required: true,
                serializedName: 'startTime',
                type: {
                    name: 'DateTime'
                }
            },
            endTime: {
                required: true,
                serializedName: 'endTime',
                type: {
                    name: 'DateTime'
                }
            },
            vmSize: {
                required: true,
                serializedName: 'vmSize',
                type: {
                    name: 'String'
                }
            },
            totalCoreHours: {
                required: true,
                serializedName: 'totalCoreHours',
                type: {
                    name: 'Number'
                }
            },
            dataIngressGiB: {
                required: true,
                serializedName: 'dataIngressGiB',
                type: {
                    name: 'Number'
                }
            },
            dataEgressGiB: {
                required: true,
                serializedName: 'dataEgressGiB',
                type: {
                    name: 'Number'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolUsageMetrics"] = PoolUsageMetrics;

const ImageReference = {
    required: false,
    serializedName: 'ImageReference',
    type: {
        name: 'Composite',
        className: 'ImageReference',
        modelProperties: {
            publisher: {
                required: true,
                serializedName: 'publisher',
                type: {
                    name: 'String'
                }
            },
            offer: {
                required: true,
                serializedName: 'offer',
                type: {
                    name: 'String'
                }
            },
            sku: {
                required: true,
                serializedName: 'sku',
                type: {
                    name: 'String'
                }
            },
            version: {
                required: false,
                serializedName: 'version',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ImageReference"] = ImageReference;

const NodeAgentSku = {
    required: false,
    serializedName: 'NodeAgentSku',
    type: {
        name: 'Composite',
        className: 'NodeAgentSku',
        modelProperties: {
            id: {
                required: false,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            verifiedImageReferences: {
                required: false,
                serializedName: 'verifiedImageReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ImageReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'ImageReference'
                        }
                    }
                }
            },
            osType: {
                required: false,
                serializedName: 'osType',
                type: {
                    name: 'Enum',
                    allowedValues: ['linux', 'windows']
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["NodeAgentSku"] = NodeAgentSku;

const AuthenticationTokenSettings = {
    required: false,
    serializedName: 'AuthenticationTokenSettings',
    type: {
        name: 'Composite',
        className: 'AuthenticationTokenSettings',
        modelProperties: {
            access: {
                required: false,
                serializedName: 'access',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'AccessScopeElementType',
                        type: {
                            name: 'Enum',
                            allowedValues: ['job']
                        }
                    }
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["AuthenticationTokenSettings"] = AuthenticationTokenSettings;

const UsageStatistics = {
    required: false,
    serializedName: 'UsageStatistics',
    type: {
        name: 'Composite',
        className: 'UsageStatistics',
        modelProperties: {
            startTime: {
                required: true,
                serializedName: 'startTime',
                type: {
                    name: 'DateTime'
                }
            },
            lastUpdateTime: {
                required: true,
                serializedName: 'lastUpdateTime',
                type: {
                    name: 'DateTime'
                }
            },
            dedicatedCoreTime: {
                required: true,
                serializedName: 'dedicatedCoreTime',
                type: {
                    name: 'TimeSpan'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["UsageStatistics"] = UsageStatistics;

const ResourceStatistics = {
    required: false,
    serializedName: 'ResourceStatistics',
    type: {
        name: 'Composite',
        className: 'ResourceStatistics',
        modelProperties: {
            startTime: {
                required: true,
                serializedName: 'startTime',
                type: {
                    name: 'DateTime'
                }
            },
            lastUpdateTime: {
                required: true,
                serializedName: 'lastUpdateTime',
                type: {
                    name: 'DateTime'
                }
            },
            avgCPUPercentage: {
                required: true,
                serializedName: 'avgCPUPercentage',
                type: {
                    name: 'Number'
                }
            },
            avgMemoryGiB: {
                required: true,
                serializedName: 'avgMemoryGiB',
                type: {
                    name: 'Number'
                }
            },
            peakMemoryGiB: {
                required: true,
                serializedName: 'peakMemoryGiB',
                type: {
                    name: 'Number'
                }
            },
            avgDiskGiB: {
                required: true,
                serializedName: 'avgDiskGiB',
                type: {
                    name: 'Number'
                }
            },
            peakDiskGiB: {
                required: true,
                serializedName: 'peakDiskGiB',
                type: {
                    name: 'Number'
                }
            },
            diskReadIOps: {
                required: true,
                serializedName: 'diskReadIOps',
                type: {
                    name: 'Number'
                }
            },
            diskWriteIOps: {
                required: true,
                serializedName: 'diskWriteIOps',
                type: {
                    name: 'Number'
                }
            },
            diskReadGiB: {
                required: true,
                serializedName: 'diskReadGiB',
                type: {
                    name: 'Number'
                }
            },
            diskWriteGiB: {
                required: true,
                serializedName: 'diskWriteGiB',
                type: {
                    name: 'Number'
                }
            },
            networkReadGiB: {
                required: true,
                serializedName: 'networkReadGiB',
                type: {
                    name: 'Number'
                }
            },
            networkWriteGiB: {
                required: true,
                serializedName: 'networkWriteGiB',
                type: {
                    name: 'Number'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ResourceStatistics"] = ResourceStatistics;

const PoolStatistics = {
    required: false,
    serializedName: 'PoolStatistics',
    type: {
        name: 'Composite',
        className: 'PoolStatistics',
        modelProperties: {
            url: {
                required: true,
                serializedName: 'url',
                type: {
                    name: 'String'
                }
            },
            startTime: {
                required: true,
                serializedName: 'startTime',
                type: {
                    name: 'DateTime'
                }
            },
            lastUpdateTime: {
                required: true,
                serializedName: 'lastUpdateTime',
                type: {
                    name: 'DateTime'
                }
            },
            usageStats: {
                required: false,
                serializedName: 'usageStats',
                type: {
                    name: 'Composite',
                    className: 'UsageStatistics'
                }
            },
            resourceStats: {
                required: false,
                serializedName: 'resourceStats',
                type: {
                    name: 'Composite',
                    className: 'ResourceStatistics'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolStatistics"] = PoolStatistics;

const JobStatistics = {
    required: false,
    serializedName: 'JobStatistics',
    type: {
        name: 'Composite',
        className: 'JobStatistics',
        modelProperties: {
            url: {
                required: true,
                serializedName: 'url',
                type: {
                    name: 'String'
                }
            },
            startTime: {
                required: true,
                serializedName: 'startTime',
                type: {
                    name: 'DateTime'
                }
            },
            lastUpdateTime: {
                required: true,
                serializedName: 'lastUpdateTime',
                type: {
                    name: 'DateTime'
                }
            },
            userCPUTime: {
                required: true,
                serializedName: 'userCPUTime',
                type: {
                    name: 'TimeSpan'
                }
            },
            kernelCPUTime: {
                required: true,
                serializedName: 'kernelCPUTime',
                type: {
                    name: 'TimeSpan'
                }
            },
            wallClockTime: {
                required: true,
                serializedName: 'wallClockTime',
                type: {
                    name: 'TimeSpan'
                }
            },
            readIOps: {
                required: true,
                serializedName: 'readIOps',
                type: {
                    name: 'Number'
                }
            },
            writeIOps: {
                required: true,
                serializedName: 'writeIOps',
                type: {
                    name: 'Number'
                }
            },
            readIOGiB: {
                required: true,
                serializedName: 'readIOGiB',
                type: {
                    name: 'Number'
                }
            },
            writeIOGiB: {
                required: true,
                serializedName: 'writeIOGiB',
                type: {
                    name: 'Number'
                }
            },
            numSucceededTasks: {
                required: true,
                serializedName: 'numSucceededTasks',
                type: {
                    name: 'Number'
                }
            },
            numFailedTasks: {
                required: true,
                serializedName: 'numFailedTasks',
                type: {
                    name: 'Number'
                }
            },
            numTaskRetries: {
                required: true,
                serializedName: 'numTaskRetries',
                type: {
                    name: 'Number'
                }
            },
            waitTime: {
                required: true,
                serializedName: 'waitTime',
                type: {
                    name: 'TimeSpan'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobStatistics"] = JobStatistics;

const NameValuePair = {
    required: false,
    serializedName: 'NameValuePair',
    type: {
        name: 'Composite',
        className: 'NameValuePair',
        modelProperties: {
            name: {
                required: false,
                serializedName: 'name',
                type: {
                    name: 'String'
                }
            },
            value: {
                required: false,
                serializedName: 'value',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["NameValuePair"] = NameValuePair;

const DeleteCertificateError = {
    required: false,
    serializedName: 'DeleteCertificateError',
    type: {
        name: 'Composite',
        className: 'DeleteCertificateError',
        modelProperties: {
            code: {
                required: false,
                serializedName: 'code',
                type: {
                    name: 'String'
                }
            },
            message: {
                required: false,
                serializedName: 'message',
                type: {
                    name: 'String'
                }
            },
            values: {
                required: false,
                serializedName: 'values',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'NameValuePairElementType',
                        type: {
                            name: 'Composite',
                            className: 'NameValuePair'
                        }
                    }
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["DeleteCertificateError"] = DeleteCertificateError;

const Certificate = {
    required: false,
    serializedName: 'Certificate',
    type: {
        name: 'Composite',
        className: 'Certificate',
        modelProperties: {
            thumbprint: {
                required: false,
                serializedName: 'thumbprint',
                type: {
                    name: 'String'
                }
            },
            thumbprintAlgorithm: {
                required: false,
                serializedName: 'thumbprintAlgorithm',
                type: {
                    name: 'String'
                }
            },
            url: {
                required: false,
                serializedName: 'url',
                type: {
                    name: 'String'
                }
            },
            state: {
                required: false,
                serializedName: 'state',
                type: {
                    name: 'Enum',
                    allowedValues: ['active', 'deleting', 'deleteFailed']
                }
            },
            stateTransitionTime: {
                required: false,
                serializedName: 'stateTransitionTime',
                type: {
                    name: 'DateTime'
                }
            },
            previousState: {
                required: false,
                serializedName: 'previousState',
                type: {
                    name: 'Enum',
                    allowedValues: ['active', 'deleting', 'deleteFailed']
                }
            },
            previousStateTransitionTime: {
                required: false,
                serializedName: 'previousStateTransitionTime',
                type: {
                    name: 'DateTime'
                }
            },
            publicData: {
                required: false,
                serializedName: 'publicData',
                type: {
                    name: 'String'
                }
            },
            deleteCertificateError: {
                required: false,
                serializedName: 'deleteCertificateError',
                type: {
                    name: 'Composite',
                    className: 'DeleteCertificateError'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["Certificate"] = Certificate;

const ApplicationPackageReference = {
    required: false,
    serializedName: 'ApplicationPackageReference',
    type: {
        name: 'Composite',
        className: 'ApplicationPackageReference',
        modelProperties: {
            applicationId: {
                required: true,
                serializedName: 'applicationId',
                type: {
                    name: 'String'
                }
            },
            version: {
                required: false,
                serializedName: 'version',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ApplicationPackageReference"] = ApplicationPackageReference;

const ApplicationSummary = {
    required: false,
    serializedName: 'ApplicationSummary',
    type: {
        name: 'Composite',
        className: 'ApplicationSummary',
        modelProperties: {
            id: {
                required: true,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            displayName: {
                required: true,
                serializedName: 'displayName',
                type: {
                    name: 'String'
                }
            },
            versions: {
                required: true,
                serializedName: 'versions',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'stringElementType',
                        type: {
                            name: 'String'
                        }
                    }
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ApplicationSummary"] = ApplicationSummary;

const CertificateAddParameter = {
    required: false,
    serializedName: 'CertificateAddParameter',
    type: {
        name: 'Composite',
        className: 'CertificateAddParameter',
        modelProperties: {
            thumbprint: {
                required: true,
                serializedName: 'thumbprint',
                type: {
                    name: 'String'
                }
            },
            thumbprintAlgorithm: {
                required: true,
                serializedName: 'thumbprintAlgorithm',
                type: {
                    name: 'String'
                }
            },
            data: {
                required: true,
                serializedName: 'data',
                type: {
                    name: 'String'
                }
            },
            certificateFormat: {
                required: false,
                serializedName: 'certificateFormat',
                type: {
                    name: 'Enum',
                    allowedValues: ['pfx', 'cer']
                }
            },
            password: {
                required: false,
                serializedName: 'password',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["CertificateAddParameter"] = CertificateAddParameter;

const FileProperties = {
    required: false,
    serializedName: 'FileProperties',
    type: {
        name: 'Composite',
        className: 'FileProperties',
        modelProperties: {
            creationTime: {
                required: false,
                serializedName: 'creationTime',
                type: {
                    name: 'DateTime'
                }
            },
            lastModified: {
                required: true,
                serializedName: 'lastModified',
                type: {
                    name: 'DateTime'
                }
            },
            contentLength: {
                required: true,
                serializedName: 'contentLength',
                type: {
                    name: 'Number'
                }
            },
            contentType: {
                required: false,
                serializedName: 'contentType',
                type: {
                    name: 'String'
                }
            },
            fileMode: {
                required: false,
                serializedName: 'fileMode',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["FileProperties"] = FileProperties;

const NodeFile = {
    required: false,
    serializedName: 'NodeFile',
    type: {
        name: 'Composite',
        className: 'NodeFile',
        modelProperties: {
            name: {
                required: false,
                serializedName: 'name',
                type: {
                    name: 'String'
                }
            },
            url: {
                required: false,
                serializedName: 'url',
                type: {
                    name: 'String'
                }
            },
            isDirectory: {
                required: false,
                serializedName: 'isDirectory',
                type: {
                    name: 'Boolean'
                }
            },
            properties: {
                required: false,
                serializedName: 'properties',
                type: {
                    name: 'Composite',
                    className: 'FileProperties'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["NodeFile"] = NodeFile;

const Schedule = {
    required: false,
    serializedName: 'Schedule',
    type: {
        name: 'Composite',
        className: 'Schedule',
        modelProperties: {
            doNotRunUntil: {
                required: false,
                serializedName: 'doNotRunUntil',
                type: {
                    name: 'DateTime'
                }
            },
            doNotRunAfter: {
                required: false,
                serializedName: 'doNotRunAfter',
                type: {
                    name: 'DateTime'
                }
            },
            startWindow: {
                required: false,
                serializedName: 'startWindow',
                type: {
                    name: 'TimeSpan'
                }
            },
            recurrenceInterval: {
                required: false,
                serializedName: 'recurrenceInterval',
                type: {
                    name: 'TimeSpan'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["Schedule"] = Schedule;

const JobConstraints = {
    required: false,
    serializedName: 'JobConstraints',
    type: {
        name: 'Composite',
        className: 'JobConstraints',
        modelProperties: {
            maxWallClockTime: {
                required: false,
                serializedName: 'maxWallClockTime',
                type: {
                    name: 'TimeSpan'
                }
            },
            maxTaskRetryCount: {
                required: false,
                serializedName: 'maxTaskRetryCount',
                type: {
                    name: 'Number'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobConstraints"] = JobConstraints;

const ResourceFile = {
    required: false,
    serializedName: 'ResourceFile',
    type: {
        name: 'Composite',
        className: 'ResourceFile',
        modelProperties: {
            blobSource: {
                required: true,
                serializedName: 'blobSource',
                type: {
                    name: 'String'
                }
            },
            filePath: {
                required: true,
                serializedName: 'filePath',
                type: {
                    name: 'String'
                }
            },
            fileMode: {
                required: false,
                serializedName: 'fileMode',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ResourceFile"] = ResourceFile;

const EnvironmentSetting = {
    required: false,
    serializedName: 'EnvironmentSetting',
    type: {
        name: 'Composite',
        className: 'EnvironmentSetting',
        modelProperties: {
            name: {
                required: true,
                serializedName: 'name',
                type: {
                    name: 'String'
                }
            },
            value: {
                required: false,
                serializedName: 'value',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["EnvironmentSetting"] = EnvironmentSetting;

const ExitOptions = {
    required: false,
    serializedName: 'ExitOptions',
    type: {
        name: 'Composite',
        className: 'ExitOptions',
        modelProperties: {
            jobAction: {
                required: false,
                serializedName: 'jobAction',
                type: {
                    name: 'Enum',
                    allowedValues: ['none', 'disable', 'terminate']
                }
            },
            dependencyAction: {
                required: false,
                serializedName: 'dependencyAction',
                type: {
                    name: 'Enum',
                    allowedValues: ['satisfy', 'block']
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ExitOptions"] = ExitOptions;

const ExitCodeMapping = {
    required: false,
    serializedName: 'ExitCodeMapping',
    type: {
        name: 'Composite',
        className: 'ExitCodeMapping',
        modelProperties: {
            code: {
                required: true,
                serializedName: 'code',
                type: {
                    name: 'Number'
                }
            },
            exitOptions: {
                required: true,
                serializedName: 'exitOptions',
                type: {
                    name: 'Composite',
                    className: 'ExitOptions'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ExitCodeMapping"] = ExitCodeMapping;

const ExitCodeRangeMapping = {
    required: false,
    serializedName: 'ExitCodeRangeMapping',
    type: {
        name: 'Composite',
        className: 'ExitCodeRangeMapping',
        modelProperties: {
            start: {
                required: true,
                serializedName: 'start',
                type: {
                    name: 'Number'
                }
            },
            end: {
                required: true,
                serializedName: 'end',
                type: {
                    name: 'Number'
                }
            },
            exitOptions: {
                required: true,
                serializedName: 'exitOptions',
                type: {
                    name: 'Composite',
                    className: 'ExitOptions'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ExitCodeRangeMapping"] = ExitCodeRangeMapping;

const ExitConditions = {
    required: false,
    serializedName: 'ExitConditions',
    type: {
        name: 'Composite',
        className: 'ExitConditions',
        modelProperties: {
            exitCodes: {
                required: false,
                serializedName: 'exitCodes',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ExitCodeMappingElementType',
                        type: {
                            name: 'Composite',
                            className: 'ExitCodeMapping'
                        }
                    }
                }
            },
            exitCodeRanges: {
                required: false,
                serializedName: 'exitCodeRanges',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ExitCodeRangeMappingElementType',
                        type: {
                            name: 'Composite',
                            className: 'ExitCodeRangeMapping'
                        }
                    }
                }
            },
            preProcessingError: {
                required: false,
                serializedName: 'preProcessingError',
                type: {
                    name: 'Composite',
                    className: 'ExitOptions'
                }
            },
            fileUploadError: {
                required: false,
                serializedName: 'fileUploadError',
                type: {
                    name: 'Composite',
                    className: 'ExitOptions'
                }
            },
            default: {
                required: false,
                serializedName: 'default',
                type: {
                    name: 'Composite',
                    className: 'ExitOptions'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ExitConditions"] = ExitConditions;

const AutoUserSpecification = {
    required: false,
    serializedName: 'AutoUserSpecification',
    type: {
        name: 'Composite',
        className: 'AutoUserSpecification',
        modelProperties: {
            scope: {
                required: false,
                serializedName: 'scope',
                type: {
                    name: 'Enum',
                    allowedValues: ['task', 'pool']
                }
            },
            elevationLevel: {
                required: false,
                serializedName: 'elevationLevel',
                type: {
                    name: 'Enum',
                    allowedValues: ['nonAdmin', 'admin']
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["AutoUserSpecification"] = AutoUserSpecification;

const UserIdentity = {
    required: false,
    serializedName: 'UserIdentity',
    type: {
        name: 'Composite',
        className: 'UserIdentity',
        modelProperties: {
            userName: {
                required: false,
                serializedName: 'username',
                type: {
                    name: 'String'
                }
            },
            autoUser: {
                required: false,
                serializedName: 'autoUser',
                type: {
                    name: 'Composite',
                    className: 'AutoUserSpecification'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["UserIdentity"] = UserIdentity;

const LinuxUserConfiguration = {
    required: false,
    serializedName: 'LinuxUserConfiguration',
    type: {
        name: 'Composite',
        className: 'LinuxUserConfiguration',
        modelProperties: {
            uid: {
                required: false,
                serializedName: 'uid',
                type: {
                    name: 'Number'
                }
            },
            gid: {
                required: false,
                serializedName: 'gid',
                type: {
                    name: 'Number'
                }
            },
            sshPrivateKey: {
                required: false,
                serializedName: 'sshPrivateKey',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["LinuxUserConfiguration"] = LinuxUserConfiguration;

const UserAccount = {
    required: false,
    serializedName: 'UserAccount',
    type: {
        name: 'Composite',
        className: 'UserAccount',
        modelProperties: {
            name: {
                required: true,
                serializedName: 'name',
                type: {
                    name: 'String'
                }
            },
            password: {
                required: true,
                serializedName: 'password',
                type: {
                    name: 'String'
                }
            },
            elevationLevel: {
                required: false,
                serializedName: 'elevationLevel',
                type: {
                    name: 'Enum',
                    allowedValues: ['nonAdmin', 'admin']
                }
            },
            linuxUserConfiguration: {
                required: false,
                serializedName: 'linuxUserConfiguration',
                type: {
                    name: 'Composite',
                    className: 'LinuxUserConfiguration'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["UserAccount"] = UserAccount;

const TaskConstraints = {
    required: false,
    serializedName: 'TaskConstraints',
    type: {
        name: 'Composite',
        className: 'TaskConstraints',
        modelProperties: {
            maxWallClockTime: {
                required: false,
                serializedName: 'maxWallClockTime',
                type: {
                    name: 'TimeSpan'
                }
            },
            retentionTime: {
                required: false,
                serializedName: 'retentionTime',
                type: {
                    name: 'TimeSpan'
                }
            },
            maxTaskRetryCount: {
                required: false,
                serializedName: 'maxTaskRetryCount',
                type: {
                    name: 'Number'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["TaskConstraints"] = TaskConstraints;

const OutputFileBlobContainerDestination = {
    required: false,
    serializedName: 'OutputFileBlobContainerDestination',
    type: {
        name: 'Composite',
        className: 'OutputFileBlobContainerDestination',
        modelProperties: {
            path: {
                required: false,
                serializedName: 'path',
                type: {
                    name: 'String'
                }
            },
            containerUrl: {
                required: true,
                serializedName: 'containerUrl',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["OutputFileBlobContainerDestination"] = OutputFileBlobContainerDestination;

const OutputFileDestination = {
    required: false,
    serializedName: 'OutputFileDestination',
    type: {
        name: 'Composite',
        className: 'OutputFileDestination',
        modelProperties: {
            container: {
                required: false,
                serializedName: 'container',
                type: {
                    name: 'Composite',
                    className: 'OutputFileBlobContainerDestination'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["OutputFileDestination"] = OutputFileDestination;

const OutputFileUploadOptions = {
    required: false,
    serializedName: 'OutputFileUploadOptions',
    type: {
        name: 'Composite',
        className: 'OutputFileUploadOptions',
        modelProperties: {
            uploadCondition: {
                required: true,
                serializedName: 'uploadCondition',
                type: {
                    name: 'Enum',
                    allowedValues: ['taskSuccess', 'taskFailure', 'taskCompletion']
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["OutputFileUploadOptions"] = OutputFileUploadOptions;

const OutputFile = {
    required: false,
    serializedName: 'OutputFile',
    type: {
        name: 'Composite',
        className: 'OutputFile',
        modelProperties: {
            filePattern: {
                required: true,
                serializedName: 'filePattern',
                type: {
                    name: 'String'
                }
            },
            destination: {
                required: true,
                serializedName: 'destination',
                type: {
                    name: 'Composite',
                    className: 'OutputFileDestination'
                }
            },
            uploadOptions: {
                required: true,
                serializedName: 'uploadOptions',
                type: {
                    name: 'Composite',
                    className: 'OutputFileUploadOptions'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["OutputFile"] = OutputFile;

const JobManagerTask = {
    required: false,
    serializedName: 'JobManagerTask',
    type: {
        name: 'Composite',
        className: 'JobManagerTask',
        modelProperties: {
            id: {
                required: true,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            displayName: {
                required: false,
                serializedName: 'displayName',
                type: {
                    name: 'String'
                }
            },
            commandLine: {
                required: true,
                serializedName: 'commandLine',
                type: {
                    name: 'String'
                }
            },
            resourceFiles: {
                required: false,
                serializedName: 'resourceFiles',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ResourceFileElementType',
                        type: {
                            name: 'Composite',
                            className: 'ResourceFile'
                        }
                    }
                }
            },
            outputFiles: {
                required: false,
                serializedName: 'outputFiles',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'OutputFileElementType',
                        type: {
                            name: 'Composite',
                            className: 'OutputFile'
                        }
                    }
                }
            },
            environmentSettings: {
                required: false,
                serializedName: 'environmentSettings',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'EnvironmentSettingElementType',
                        type: {
                            name: 'Composite',
                            className: 'EnvironmentSetting'
                        }
                    }
                }
            },
            constraints: {
                required: false,
                serializedName: 'constraints',
                type: {
                    name: 'Composite',
                    className: 'TaskConstraints'
                }
            },
            killJobOnCompletion: {
                required: false,
                serializedName: 'killJobOnCompletion',
                type: {
                    name: 'Boolean'
                }
            },
            userIdentity: {
                required: false,
                serializedName: 'userIdentity',
                type: {
                    name: 'Composite',
                    className: 'UserIdentity'
                }
            },
            runExclusive: {
                required: false,
                serializedName: 'runExclusive',
                type: {
                    name: 'Boolean'
                }
            },
            applicationPackageReferences: {
                required: false,
                serializedName: 'applicationPackageReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ApplicationPackageReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'ApplicationPackageReference'
                        }
                    }
                }
            },
            authenticationTokenSettings: {
                required: false,
                serializedName: 'authenticationTokenSettings',
                type: {
                    name: 'Composite',
                    className: 'AuthenticationTokenSettings'
                }
            },
            allowLowPriorityNode: {
                required: false,
                serializedName: 'allowLowPriorityNode',
                type: {
                    name: 'Boolean'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobManagerTask"] = JobManagerTask;

const JobPreparationTask = {
    required: false,
    serializedName: 'JobPreparationTask',
    type: {
        name: 'Composite',
        className: 'JobPreparationTask',
        modelProperties: {
            id: {
                required: false,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            commandLine: {
                required: true,
                serializedName: 'commandLine',
                type: {
                    name: 'String'
                }
            },
            resourceFiles: {
                required: false,
                serializedName: 'resourceFiles',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ResourceFileElementType',
                        type: {
                            name: 'Composite',
                            className: 'ResourceFile'
                        }
                    }
                }
            },
            environmentSettings: {
                required: false,
                serializedName: 'environmentSettings',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'EnvironmentSettingElementType',
                        type: {
                            name: 'Composite',
                            className: 'EnvironmentSetting'
                        }
                    }
                }
            },
            constraints: {
                required: false,
                serializedName: 'constraints',
                type: {
                    name: 'Composite',
                    className: 'TaskConstraints'
                }
            },
            waitForSuccess: {
                required: false,
                serializedName: 'waitForSuccess',
                type: {
                    name: 'Boolean'
                }
            },
            userIdentity: {
                required: false,
                serializedName: 'userIdentity',
                type: {
                    name: 'Composite',
                    className: 'UserIdentity'
                }
            },
            rerunOnNodeRebootAfterSuccess: {
                required: false,
                serializedName: 'rerunOnNodeRebootAfterSuccess',
                type: {
                    name: 'Boolean'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobPreparationTask"] = JobPreparationTask;

const JobReleaseTask = {
    required: false,
    serializedName: 'JobReleaseTask',
    type: {
        name: 'Composite',
        className: 'JobReleaseTask',
        modelProperties: {
            id: {
                required: false,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            commandLine: {
                required: true,
                serializedName: 'commandLine',
                type: {
                    name: 'String'
                }
            },
            resourceFiles: {
                required: false,
                serializedName: 'resourceFiles',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ResourceFileElementType',
                        type: {
                            name: 'Composite',
                            className: 'ResourceFile'
                        }
                    }
                }
            },
            environmentSettings: {
                required: false,
                serializedName: 'environmentSettings',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'EnvironmentSettingElementType',
                        type: {
                            name: 'Composite',
                            className: 'EnvironmentSetting'
                        }
                    }
                }
            },
            maxWallClockTime: {
                required: false,
                serializedName: 'maxWallClockTime',
                type: {
                    name: 'TimeSpan'
                }
            },
            retentionTime: {
                required: false,
                serializedName: 'retentionTime',
                type: {
                    name: 'TimeSpan'
                }
            },
            userIdentity: {
                required: false,
                serializedName: 'userIdentity',
                type: {
                    name: 'Composite',
                    className: 'UserIdentity'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobReleaseTask"] = JobReleaseTask;

const TaskSchedulingPolicy = {
    required: false,
    serializedName: 'TaskSchedulingPolicy',
    type: {
        name: 'Composite',
        className: 'TaskSchedulingPolicy',
        modelProperties: {
            nodeFillType: {
                required: true,
                serializedName: 'nodeFillType',
                type: {
                    name: 'Enum',
                    allowedValues: ['spread', 'pack']
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["TaskSchedulingPolicy"] = TaskSchedulingPolicy;

const StartTask = {
    required: false,
    serializedName: 'StartTask',
    type: {
        name: 'Composite',
        className: 'StartTask',
        modelProperties: {
            commandLine: {
                required: true,
                serializedName: 'commandLine',
                type: {
                    name: 'String'
                }
            },
            resourceFiles: {
                required: false,
                serializedName: 'resourceFiles',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ResourceFileElementType',
                        type: {
                            name: 'Composite',
                            className: 'ResourceFile'
                        }
                    }
                }
            },
            environmentSettings: {
                required: false,
                serializedName: 'environmentSettings',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'EnvironmentSettingElementType',
                        type: {
                            name: 'Composite',
                            className: 'EnvironmentSetting'
                        }
                    }
                }
            },
            userIdentity: {
                required: false,
                serializedName: 'userIdentity',
                type: {
                    name: 'Composite',
                    className: 'UserIdentity'
                }
            },
            maxTaskRetryCount: {
                required: false,
                serializedName: 'maxTaskRetryCount',
                type: {
                    name: 'Number'
                }
            },
            waitForSuccess: {
                required: false,
                serializedName: 'waitForSuccess',
                type: {
                    name: 'Boolean'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["StartTask"] = StartTask;

const CertificateReference = {
    required: false,
    serializedName: 'CertificateReference',
    type: {
        name: 'Composite',
        className: 'CertificateReference',
        modelProperties: {
            thumbprint: {
                required: true,
                serializedName: 'thumbprint',
                type: {
                    name: 'String'
                }
            },
            thumbprintAlgorithm: {
                required: true,
                serializedName: 'thumbprintAlgorithm',
                type: {
                    name: 'String'
                }
            },
            storeLocation: {
                required: false,
                serializedName: 'storeLocation',
                type: {
                    name: 'Enum',
                    allowedValues: ['currentUser', 'localMachine']
                }
            },
            storeName: {
                required: false,
                serializedName: 'storeName',
                type: {
                    name: 'String'
                }
            },
            visibility: {
                required: false,
                serializedName: 'visibility',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'CertificateVisibilityElementType',
                        type: {
                            name: 'Enum',
                            allowedValues: ['startTask', 'task', 'remoteUser']
                        }
                    }
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["CertificateReference"] = CertificateReference;

const MetadataItem = {
    required: false,
    serializedName: 'MetadataItem',
    type: {
        name: 'Composite',
        className: 'MetadataItem',
        modelProperties: {
            name: {
                required: true,
                serializedName: 'name',
                type: {
                    name: 'String'
                }
            },
            value: {
                required: true,
                serializedName: 'value',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["MetadataItem"] = MetadataItem;

const CloudServiceConfiguration = {
    required: false,
    serializedName: 'CloudServiceConfiguration',
    type: {
        name: 'Composite',
        className: 'CloudServiceConfiguration',
        modelProperties: {
            osFamily: {
                required: true,
                serializedName: 'osFamily',
                type: {
                    name: 'String'
                }
            },
            targetOSVersion: {
                required: false,
                serializedName: 'targetOSVersion',
                type: {
                    name: 'String'
                }
            },
            currentOSVersion: {
                required: false,
                serializedName: 'currentOSVersion',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["CloudServiceConfiguration"] = CloudServiceConfiguration;

const OSDisk = {
    required: false,
    serializedName: 'OSDisk',
    type: {
        name: 'Composite',
        className: 'OSDisk',
        modelProperties: {
            imageUris: {
                required: true,
                serializedName: 'imageUris',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'stringElementType',
                        type: {
                            name: 'String'
                        }
                    }
                }
            },
            caching: {
                required: false,
                serializedName: 'caching',
                type: {
                    name: 'Enum',
                    allowedValues: ['none', 'readOnly', 'readWrite']
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["OSDisk"] = OSDisk;

const WindowsConfiguration = {
    required: false,
    serializedName: 'WindowsConfiguration',
    type: {
        name: 'Composite',
        className: 'WindowsConfiguration',
        modelProperties: {
            enableAutomaticUpdates: {
                required: false,
                serializedName: 'enableAutomaticUpdates',
                type: {
                    name: 'Boolean'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["WindowsConfiguration"] = WindowsConfiguration;

const VirtualMachineConfiguration = {
    required: false,
    serializedName: 'VirtualMachineConfiguration',
    type: {
        name: 'Composite',
        className: 'VirtualMachineConfiguration',
        modelProperties: {
            imageReference: {
                required: false,
                serializedName: 'imageReference',
                type: {
                    name: 'Composite',
                    className: 'ImageReference'
                }
            },
            osDisk: {
                required: false,
                serializedName: 'osDisk',
                type: {
                    name: 'Composite',
                    className: 'OSDisk'
                }
            },
            nodeAgentSKUId: {
                required: true,
                serializedName: 'nodeAgentSKUId',
                type: {
                    name: 'String'
                }
            },
            windowsConfiguration: {
                required: false,
                serializedName: 'windowsConfiguration',
                type: {
                    name: 'Composite',
                    className: 'WindowsConfiguration'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["VirtualMachineConfiguration"] = VirtualMachineConfiguration;

const NetworkSecurityGroupRule = {
    required: false,
    serializedName: 'NetworkSecurityGroupRule',
    type: {
        name: 'Composite',
        className: 'NetworkSecurityGroupRule',
        modelProperties: {
            priority: {
                required: true,
                serializedName: 'priority',
                type: {
                    name: 'Number'
                }
            },
            access: {
                required: true,
                serializedName: 'access',
                type: {
                    name: 'Enum',
                    allowedValues: ['allow', 'deny']
                }
            },
            sourceAddressPrefix: {
                required: true,
                serializedName: 'sourceAddressPrefix',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["NetworkSecurityGroupRule"] = NetworkSecurityGroupRule;

const InboundNATPool = {
    required: false,
    serializedName: 'InboundNATPool',
    type: {
        name: 'Composite',
        className: 'InboundNATPool',
        modelProperties: {
            name: {
                required: true,
                serializedName: 'name',
                type: {
                    name: 'String'
                }
            },
            protocol: {
                required: true,
                serializedName: 'protocol',
                type: {
                    name: 'Enum',
                    allowedValues: ['tcp', 'udp']
                }
            },
            backendPort: {
                required: true,
                serializedName: 'backendPort',
                type: {
                    name: 'Number'
                }
            },
            frontendPortRangeStart: {
                required: true,
                serializedName: 'frontendPortRangeStart',
                type: {
                    name: 'Number'
                }
            },
            frontendPortRangeEnd: {
                required: true,
                serializedName: 'frontendPortRangeEnd',
                type: {
                    name: 'Number'
                }
            },
            networkSecurityGroupRules: {
                required: false,
                serializedName: 'networkSecurityGroupRules',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'NetworkSecurityGroupRuleElementType',
                        type: {
                            name: 'Composite',
                            className: 'NetworkSecurityGroupRule'
                        }
                    }
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["InboundNATPool"] = InboundNATPool;

const PoolEndpointConfiguration = {
    required: false,
    serializedName: 'PoolEndpointConfiguration',
    type: {
        name: 'Composite',
        className: 'PoolEndpointConfiguration',
        modelProperties: {
            inboundNATPools: {
                required: true,
                serializedName: 'inboundNATPools',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'InboundNATPoolElementType',
                        type: {
                            name: 'Composite',
                            className: 'InboundNATPool'
                        }
                    }
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolEndpointConfiguration"] = PoolEndpointConfiguration;

const NetworkConfiguration = {
    required: false,
    serializedName: 'NetworkConfiguration',
    type: {
        name: 'Composite',
        className: 'NetworkConfiguration',
        modelProperties: {
            subnetId: {
                required: false,
                serializedName: 'subnetId',
                type: {
                    name: 'String'
                }
            },
            endpointConfiguration: {
                required: false,
                serializedName: 'endpointConfiguration',
                type: {
                    name: 'Composite',
                    className: 'PoolEndpointConfiguration'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["NetworkConfiguration"] = NetworkConfiguration;

const PoolSpecification = {
    required: false,
    serializedName: 'PoolSpecification',
    type: {
        name: 'Composite',
        className: 'PoolSpecification',
        modelProperties: {
            displayName: {
                required: false,
                serializedName: 'displayName',
                type: {
                    name: 'String'
                }
            },
            vmSize: {
                required: true,
                serializedName: 'vmSize',
                type: {
                    name: 'String'
                }
            },
            cloudServiceConfiguration: {
                required: false,
                serializedName: 'cloudServiceConfiguration',
                type: {
                    name: 'Composite',
                    className: 'CloudServiceConfiguration'
                }
            },
            virtualMachineConfiguration: {
                required: false,
                serializedName: 'virtualMachineConfiguration',
                type: {
                    name: 'Composite',
                    className: 'VirtualMachineConfiguration'
                }
            },
            maxTasksPerNode: {
                required: false,
                serializedName: 'maxTasksPerNode',
                type: {
                    name: 'Number'
                }
            },
            taskSchedulingPolicy: {
                required: false,
                serializedName: 'taskSchedulingPolicy',
                type: {
                    name: 'Composite',
                    className: 'TaskSchedulingPolicy'
                }
            },
            resizeTimeout: {
                required: false,
                serializedName: 'resizeTimeout',
                type: {
                    name: 'TimeSpan'
                }
            },
            targetDedicatedNodes: {
                required: false,
                serializedName: 'targetDedicatedNodes',
                type: {
                    name: 'Number'
                }
            },
            targetLowPriorityNodes: {
                required: false,
                serializedName: 'targetLowPriorityNodes',
                type: {
                    name: 'Number'
                }
            },
            enableAutoScale: {
                required: false,
                serializedName: 'enableAutoScale',
                type: {
                    name: 'Boolean'
                }
            },
            autoScaleFormula: {
                required: false,
                serializedName: 'autoScaleFormula',
                type: {
                    name: 'String'
                }
            },
            autoScaleEvaluationInterval: {
                required: false,
                serializedName: 'autoScaleEvaluationInterval',
                type: {
                    name: 'TimeSpan'
                }
            },
            enableInterNodeCommunication: {
                required: false,
                serializedName: 'enableInterNodeCommunication',
                type: {
                    name: 'Boolean'
                }
            },
            networkConfiguration: {
                required: false,
                serializedName: 'networkConfiguration',
                type: {
                    name: 'Composite',
                    className: 'NetworkConfiguration'
                }
            },
            startTask: {
                required: false,
                serializedName: 'startTask',
                type: {
                    name: 'Composite',
                    className: 'StartTask'
                }
            },
            certificateReferences: {
                required: false,
                serializedName: 'certificateReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'CertificateReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'CertificateReference'
                        }
                    }
                }
            },
            applicationPackageReferences: {
                required: false,
                serializedName: 'applicationPackageReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ApplicationPackageReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'ApplicationPackageReference'
                        }
                    }
                }
            },
            applicationLicenses: {
                required: false,
                serializedName: 'applicationLicenses',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'stringElementType',
                        type: {
                            name: 'String'
                        }
                    }
                }
            },
            userAccounts: {
                required: false,
                serializedName: 'userAccounts',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'UserAccountElementType',
                        type: {
                            name: 'Composite',
                            className: 'UserAccount'
                        }
                    }
                }
            },
            metadata: {
                required: false,
                serializedName: 'metadata',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'MetadataItemElementType',
                        type: {
                            name: 'Composite',
                            className: 'MetadataItem'
                        }
                    }
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolSpecification"] = PoolSpecification;

const AutoPoolSpecification = {
    required: false,
    serializedName: 'AutoPoolSpecification',
    type: {
        name: 'Composite',
        className: 'AutoPoolSpecification',
        modelProperties: {
            autoPoolIdPrefix: {
                required: false,
                serializedName: 'autoPoolIdPrefix',
                type: {
                    name: 'String'
                }
            },
            poolLifetimeOption: {
                required: true,
                serializedName: 'poolLifetimeOption',
                type: {
                    name: 'Enum',
                    allowedValues: ['jobSchedule', 'job']
                }
            },
            keepAlive: {
                required: false,
                serializedName: 'keepAlive',
                type: {
                    name: 'Boolean'
                }
            },
            pool: {
                required: false,
                serializedName: 'pool',
                type: {
                    name: 'Composite',
                    className: 'PoolSpecification'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["AutoPoolSpecification"] = AutoPoolSpecification;

const PoolInformation = {
    required: false,
    serializedName: 'PoolInformation',
    type: {
        name: 'Composite',
        className: 'PoolInformation',
        modelProperties: {
            poolId: {
                required: false,
                serializedName: 'poolId',
                type: {
                    name: 'String'
                }
            },
            autoPoolSpecification: {
                required: false,
                serializedName: 'autoPoolSpecification',
                type: {
                    name: 'Composite',
                    className: 'AutoPoolSpecification'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolInformation"] = PoolInformation;

const JobSpecification = {
    required: false,
    serializedName: 'JobSpecification',
    type: {
        name: 'Composite',
        className: 'JobSpecification',
        modelProperties: {
            priority: {
                required: false,
                serializedName: 'priority',
                type: {
                    name: 'Number'
                }
            },
            displayName: {
                required: false,
                serializedName: 'displayName',
                type: {
                    name: 'String'
                }
            },
            usesTaskDependencies: {
                required: false,
                serializedName: 'usesTaskDependencies',
                type: {
                    name: 'Boolean'
                }
            },
            onAllTasksComplete: {
                required: false,
                serializedName: 'onAllTasksComplete',
                type: {
                    name: 'Enum',
                    allowedValues: ['noAction', 'terminateJob']
                }
            },
            onTaskFailure: {
                required: false,
                serializedName: 'onTaskFailure',
                type: {
                    name: 'Enum',
                    allowedValues: ['noAction', 'performExitOptionsJobAction']
                }
            },
            constraints: {
                required: false,
                serializedName: 'constraints',
                type: {
                    name: 'Composite',
                    className: 'JobConstraints'
                }
            },
            jobManagerTask: {
                required: false,
                serializedName: 'jobManagerTask',
                type: {
                    name: 'Composite',
                    className: 'JobManagerTask'
                }
            },
            jobPreparationTask: {
                required: false,
                serializedName: 'jobPreparationTask',
                type: {
                    name: 'Composite',
                    className: 'JobPreparationTask'
                }
            },
            jobReleaseTask: {
                required: false,
                serializedName: 'jobReleaseTask',
                type: {
                    name: 'Composite',
                    className: 'JobReleaseTask'
                }
            },
            commonEnvironmentSettings: {
                required: false,
                serializedName: 'commonEnvironmentSettings',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'EnvironmentSettingElementType',
                        type: {
                            name: 'Composite',
                            className: 'EnvironmentSetting'
                        }
                    }
                }
            },
            poolInfo: {
                required: true,
                serializedName: 'poolInfo',
                type: {
                    name: 'Composite',
                    className: 'PoolInformation'
                }
            },
            metadata: {
                required: false,
                serializedName: 'metadata',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'MetadataItemElementType',
                        type: {
                            name: 'Composite',
                            className: 'MetadataItem'
                        }
                    }
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobSpecification"] = JobSpecification;

const RecentJob = {
    required: false,
    serializedName: 'RecentJob',
    type: {
        name: 'Composite',
        className: 'RecentJob',
        modelProperties: {
            id: {
                required: false,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            url: {
                required: false,
                serializedName: 'url',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["RecentJob"] = RecentJob;

const JobScheduleExecutionInformation = {
    required: false,
    serializedName: 'JobScheduleExecutionInformation',
    type: {
        name: 'Composite',
        className: 'JobScheduleExecutionInformation',
        modelProperties: {
            nextRunTime: {
                required: false,
                serializedName: 'nextRunTime',
                type: {
                    name: 'DateTime'
                }
            },
            recentJob: {
                required: false,
                serializedName: 'recentJob',
                type: {
                    name: 'Composite',
                    className: 'RecentJob'
                }
            },
            endTime: {
                required: false,
                serializedName: 'endTime',
                type: {
                    name: 'DateTime'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobScheduleExecutionInformation"] = JobScheduleExecutionInformation;

const JobScheduleStatistics = {
    required: false,
    serializedName: 'JobScheduleStatistics',
    type: {
        name: 'Composite',
        className: 'JobScheduleStatistics',
        modelProperties: {
            url: {
                required: true,
                serializedName: 'url',
                type: {
                    name: 'String'
                }
            },
            startTime: {
                required: true,
                serializedName: 'startTime',
                type: {
                    name: 'DateTime'
                }
            },
            lastUpdateTime: {
                required: true,
                serializedName: 'lastUpdateTime',
                type: {
                    name: 'DateTime'
                }
            },
            userCPUTime: {
                required: true,
                serializedName: 'userCPUTime',
                type: {
                    name: 'TimeSpan'
                }
            },
            kernelCPUTime: {
                required: true,
                serializedName: 'kernelCPUTime',
                type: {
                    name: 'TimeSpan'
                }
            },
            wallClockTime: {
                required: true,
                serializedName: 'wallClockTime',
                type: {
                    name: 'TimeSpan'
                }
            },
            readIOps: {
                required: true,
                serializedName: 'readIOps',
                type: {
                    name: 'Number'
                }
            },
            writeIOps: {
                required: true,
                serializedName: 'writeIOps',
                type: {
                    name: 'Number'
                }
            },
            readIOGiB: {
                required: true,
                serializedName: 'readIOGiB',
                type: {
                    name: 'Number'
                }
            },
            writeIOGiB: {
                required: true,
                serializedName: 'writeIOGiB',
                type: {
                    name: 'Number'
                }
            },
            numSucceededTasks: {
                required: true,
                serializedName: 'numSucceededTasks',
                type: {
                    name: 'Number'
                }
            },
            numFailedTasks: {
                required: true,
                serializedName: 'numFailedTasks',
                type: {
                    name: 'Number'
                }
            },
            numTaskRetries: {
                required: true,
                serializedName: 'numTaskRetries',
                type: {
                    name: 'Number'
                }
            },
            waitTime: {
                required: true,
                serializedName: 'waitTime',
                type: {
                    name: 'TimeSpan'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobScheduleStatistics"] = JobScheduleStatistics;

const CloudJobSchedule = {
    required: false,
    serializedName: 'CloudJobSchedule',
    type: {
        name: 'Composite',
        className: 'CloudJobSchedule',
        modelProperties: {
            id: {
                required: false,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            displayName: {
                required: false,
                serializedName: 'displayName',
                type: {
                    name: 'String'
                }
            },
            url: {
                required: false,
                serializedName: 'url',
                type: {
                    name: 'String'
                }
            },
            eTag: {
                required: false,
                serializedName: 'eTag',
                type: {
                    name: 'String'
                }
            },
            lastModified: {
                required: false,
                serializedName: 'lastModified',
                type: {
                    name: 'DateTime'
                }
            },
            creationTime: {
                required: false,
                serializedName: 'creationTime',
                type: {
                    name: 'DateTime'
                }
            },
            state: {
                required: false,
                serializedName: 'state',
                type: {
                    name: 'Enum',
                    allowedValues: ['active', 'completed', 'disabled', 'terminating', 'deleting']
                }
            },
            stateTransitionTime: {
                required: false,
                serializedName: 'stateTransitionTime',
                type: {
                    name: 'DateTime'
                }
            },
            previousState: {
                required: false,
                serializedName: 'previousState',
                type: {
                    name: 'Enum',
                    allowedValues: ['active', 'completed', 'disabled', 'terminating', 'deleting']
                }
            },
            previousStateTransitionTime: {
                required: false,
                serializedName: 'previousStateTransitionTime',
                type: {
                    name: 'DateTime'
                }
            },
            schedule: {
                required: false,
                serializedName: 'schedule',
                type: {
                    name: 'Composite',
                    className: 'Schedule'
                }
            },
            jobSpecification: {
                required: false,
                serializedName: 'jobSpecification',
                type: {
                    name: 'Composite',
                    className: 'JobSpecification'
                }
            },
            executionInfo: {
                required: false,
                serializedName: 'executionInfo',
                type: {
                    name: 'Composite',
                    className: 'JobScheduleExecutionInformation'
                }
            },
            metadata: {
                required: false,
                serializedName: 'metadata',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'MetadataItemElementType',
                        type: {
                            name: 'Composite',
                            className: 'MetadataItem'
                        }
                    }
                }
            },
            stats: {
                required: false,
                serializedName: 'stats',
                type: {
                    name: 'Composite',
                    className: 'JobScheduleStatistics'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["CloudJobSchedule"] = CloudJobSchedule;

const JobScheduleAddParameter = {
    required: false,
    serializedName: 'JobScheduleAddParameter',
    type: {
        name: 'Composite',
        className: 'JobScheduleAddParameter',
        modelProperties: {
            id: {
                required: true,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            displayName: {
                required: false,
                serializedName: 'displayName',
                type: {
                    name: 'String'
                }
            },
            schedule: {
                required: true,
                serializedName: 'schedule',
                type: {
                    name: 'Composite',
                    className: 'Schedule'
                }
            },
            jobSpecification: {
                required: true,
                serializedName: 'jobSpecification',
                type: {
                    name: 'Composite',
                    className: 'JobSpecification'
                }
            },
            metadata: {
                required: false,
                serializedName: 'metadata',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'MetadataItemElementType',
                        type: {
                            name: 'Composite',
                            className: 'MetadataItem'
                        }
                    }
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobScheduleAddParameter"] = JobScheduleAddParameter;

const JobSchedulingError = {
    required: false,
    serializedName: 'JobSchedulingError',
    type: {
        name: 'Composite',
        className: 'JobSchedulingError',
        modelProperties: {
            category: {
                required: true,
                serializedName: 'category',
                type: {
                    name: 'Enum',
                    allowedValues: ['userError', 'serverError']
                }
            },
            code: {
                required: false,
                serializedName: 'code',
                type: {
                    name: 'String'
                }
            },
            message: {
                required: false,
                serializedName: 'message',
                type: {
                    name: 'String'
                }
            },
            details: {
                required: false,
                serializedName: 'details',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'NameValuePairElementType',
                        type: {
                            name: 'Composite',
                            className: 'NameValuePair'
                        }
                    }
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobSchedulingError"] = JobSchedulingError;

const JobExecutionInformation = {
    required: false,
    serializedName: 'JobExecutionInformation',
    type: {
        name: 'Composite',
        className: 'JobExecutionInformation',
        modelProperties: {
            startTime: {
                required: true,
                serializedName: 'startTime',
                type: {
                    name: 'DateTime'
                }
            },
            endTime: {
                required: false,
                serializedName: 'endTime',
                type: {
                    name: 'DateTime'
                }
            },
            poolId: {
                required: false,
                serializedName: 'poolId',
                type: {
                    name: 'String'
                }
            },
            schedulingError: {
                required: false,
                serializedName: 'schedulingError',
                type: {
                    name: 'Composite',
                    className: 'JobSchedulingError'
                }
            },
            terminateReason: {
                required: false,
                serializedName: 'terminateReason',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobExecutionInformation"] = JobExecutionInformation;

const CloudJob = {
    required: false,
    serializedName: 'CloudJob',
    type: {
        name: 'Composite',
        className: 'CloudJob',
        modelProperties: {
            id: {
                required: false,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            displayName: {
                required: false,
                serializedName: 'displayName',
                type: {
                    name: 'String'
                }
            },
            usesTaskDependencies: {
                required: false,
                serializedName: 'usesTaskDependencies',
                type: {
                    name: 'Boolean'
                }
            },
            url: {
                required: false,
                serializedName: 'url',
                type: {
                    name: 'String'
                }
            },
            eTag: {
                required: false,
                serializedName: 'eTag',
                type: {
                    name: 'String'
                }
            },
            lastModified: {
                required: false,
                serializedName: 'lastModified',
                type: {
                    name: 'DateTime'
                }
            },
            creationTime: {
                required: false,
                serializedName: 'creationTime',
                type: {
                    name: 'DateTime'
                }
            },
            state: {
                required: false,
                serializedName: 'state',
                type: {
                    name: 'Enum',
                    allowedValues: ['active', 'disabling', 'disabled', 'enabling', 'terminating', 'completed', 'deleting']
                }
            },
            stateTransitionTime: {
                required: false,
                serializedName: 'stateTransitionTime',
                type: {
                    name: 'DateTime'
                }
            },
            previousState: {
                required: false,
                serializedName: 'previousState',
                type: {
                    name: 'Enum',
                    allowedValues: ['active', 'disabling', 'disabled', 'enabling', 'terminating', 'completed', 'deleting']
                }
            },
            previousStateTransitionTime: {
                required: false,
                serializedName: 'previousStateTransitionTime',
                type: {
                    name: 'DateTime'
                }
            },
            priority: {
                required: false,
                serializedName: 'priority',
                type: {
                    name: 'Number'
                }
            },
            constraints: {
                required: false,
                serializedName: 'constraints',
                type: {
                    name: 'Composite',
                    className: 'JobConstraints'
                }
            },
            jobManagerTask: {
                required: false,
                serializedName: 'jobManagerTask',
                type: {
                    name: 'Composite',
                    className: 'JobManagerTask'
                }
            },
            jobPreparationTask: {
                required: false,
                serializedName: 'jobPreparationTask',
                type: {
                    name: 'Composite',
                    className: 'JobPreparationTask'
                }
            },
            jobReleaseTask: {
                required: false,
                serializedName: 'jobReleaseTask',
                type: {
                    name: 'Composite',
                    className: 'JobReleaseTask'
                }
            },
            commonEnvironmentSettings: {
                required: false,
                serializedName: 'commonEnvironmentSettings',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'EnvironmentSettingElementType',
                        type: {
                            name: 'Composite',
                            className: 'EnvironmentSetting'
                        }
                    }
                }
            },
            poolInfo: {
                required: false,
                serializedName: 'poolInfo',
                type: {
                    name: 'Composite',
                    className: 'PoolInformation'
                }
            },
            onAllTasksComplete: {
                required: false,
                serializedName: 'onAllTasksComplete',
                type: {
                    name: 'Enum',
                    allowedValues: ['noAction', 'terminateJob']
                }
            },
            onTaskFailure: {
                required: false,
                serializedName: 'onTaskFailure',
                type: {
                    name: 'Enum',
                    allowedValues: ['noAction', 'performExitOptionsJobAction']
                }
            },
            metadata: {
                required: false,
                serializedName: 'metadata',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'MetadataItemElementType',
                        type: {
                            name: 'Composite',
                            className: 'MetadataItem'
                        }
                    }
                }
            },
            executionInfo: {
                required: false,
                serializedName: 'executionInfo',
                type: {
                    name: 'Composite',
                    className: 'JobExecutionInformation'
                }
            },
            stats: {
                required: false,
                serializedName: 'stats',
                type: {
                    name: 'Composite',
                    className: 'JobStatistics'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["CloudJob"] = CloudJob;

const JobAddParameter = {
    required: false,
    serializedName: 'JobAddParameter',
    type: {
        name: 'Composite',
        className: 'JobAddParameter',
        modelProperties: {
            id: {
                required: true,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            displayName: {
                required: false,
                serializedName: 'displayName',
                type: {
                    name: 'String'
                }
            },
            priority: {
                required: false,
                serializedName: 'priority',
                type: {
                    name: 'Number'
                }
            },
            constraints: {
                required: false,
                serializedName: 'constraints',
                type: {
                    name: 'Composite',
                    className: 'JobConstraints'
                }
            },
            jobManagerTask: {
                required: false,
                serializedName: 'jobManagerTask',
                type: {
                    name: 'Composite',
                    className: 'JobManagerTask'
                }
            },
            jobPreparationTask: {
                required: false,
                serializedName: 'jobPreparationTask',
                type: {
                    name: 'Composite',
                    className: 'JobPreparationTask'
                }
            },
            jobReleaseTask: {
                required: false,
                serializedName: 'jobReleaseTask',
                type: {
                    name: 'Composite',
                    className: 'JobReleaseTask'
                }
            },
            commonEnvironmentSettings: {
                required: false,
                serializedName: 'commonEnvironmentSettings',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'EnvironmentSettingElementType',
                        type: {
                            name: 'Composite',
                            className: 'EnvironmentSetting'
                        }
                    }
                }
            },
            poolInfo: {
                required: true,
                serializedName: 'poolInfo',
                type: {
                    name: 'Composite',
                    className: 'PoolInformation'
                }
            },
            onAllTasksComplete: {
                required: false,
                serializedName: 'onAllTasksComplete',
                type: {
                    name: 'Enum',
                    allowedValues: ['noAction', 'terminateJob']
                }
            },
            onTaskFailure: {
                required: false,
                serializedName: 'onTaskFailure',
                type: {
                    name: 'Enum',
                    allowedValues: ['noAction', 'performExitOptionsJobAction']
                }
            },
            metadata: {
                required: false,
                serializedName: 'metadata',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'MetadataItemElementType',
                        type: {
                            name: 'Composite',
                            className: 'MetadataItem'
                        }
                    }
                }
            },
            usesTaskDependencies: {
                required: false,
                serializedName: 'usesTaskDependencies',
                type: {
                    name: 'Boolean'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobAddParameter"] = JobAddParameter;

const TaskFailureInformation = {
    required: false,
    serializedName: 'TaskFailureInformation',
    type: {
        name: 'Composite',
        className: 'TaskFailureInformation',
        modelProperties: {
            category: {
                required: true,
                serializedName: 'category',
                type: {
                    name: 'Enum',
                    allowedValues: ['userError', 'serverError']
                }
            },
            code: {
                required: false,
                serializedName: 'code',
                type: {
                    name: 'String'
                }
            },
            message: {
                required: false,
                serializedName: 'message',
                type: {
                    name: 'String'
                }
            },
            details: {
                required: false,
                serializedName: 'details',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'NameValuePairElementType',
                        type: {
                            name: 'Composite',
                            className: 'NameValuePair'
                        }
                    }
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["TaskFailureInformation"] = TaskFailureInformation;

const JobPreparationTaskExecutionInformation = {
    required: false,
    serializedName: 'JobPreparationTaskExecutionInformation',
    type: {
        name: 'Composite',
        className: 'JobPreparationTaskExecutionInformation',
        modelProperties: {
            startTime: {
                required: true,
                serializedName: 'startTime',
                type: {
                    name: 'DateTime'
                }
            },
            endTime: {
                required: false,
                serializedName: 'endTime',
                type: {
                    name: 'DateTime'
                }
            },
            state: {
                required: true,
                serializedName: 'state',
                type: {
                    name: 'Enum',
                    allowedValues: ['running', 'completed']
                }
            },
            taskRootDirectory: {
                required: false,
                serializedName: 'taskRootDirectory',
                type: {
                    name: 'String'
                }
            },
            taskRootDirectoryUrl: {
                required: false,
                serializedName: 'taskRootDirectoryUrl',
                type: {
                    name: 'String'
                }
            },
            exitCode: {
                required: false,
                serializedName: 'exitCode',
                type: {
                    name: 'Number'
                }
            },
            failureInfo: {
                required: false,
                serializedName: 'failureInfo',
                type: {
                    name: 'Composite',
                    className: 'TaskFailureInformation'
                }
            },
            retryCount: {
                required: true,
                serializedName: 'retryCount',
                type: {
                    name: 'Number'
                }
            },
            lastRetryTime: {
                required: false,
                serializedName: 'lastRetryTime',
                type: {
                    name: 'DateTime'
                }
            },
            result: {
                required: false,
                serializedName: 'result',
                type: {
                    name: 'Enum',
                    allowedValues: ['success', 'failure']
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobPreparationTaskExecutionInformation"] = JobPreparationTaskExecutionInformation;

const JobReleaseTaskExecutionInformation = {
    required: false,
    serializedName: 'JobReleaseTaskExecutionInformation',
    type: {
        name: 'Composite',
        className: 'JobReleaseTaskExecutionInformation',
        modelProperties: {
            startTime: {
                required: true,
                serializedName: 'startTime',
                type: {
                    name: 'DateTime'
                }
            },
            endTime: {
                required: false,
                serializedName: 'endTime',
                type: {
                    name: 'DateTime'
                }
            },
            state: {
                required: true,
                serializedName: 'state',
                type: {
                    name: 'Enum',
                    allowedValues: ['running', 'completed']
                }
            },
            taskRootDirectory: {
                required: false,
                serializedName: 'taskRootDirectory',
                type: {
                    name: 'String'
                }
            },
            taskRootDirectoryUrl: {
                required: false,
                serializedName: 'taskRootDirectoryUrl',
                type: {
                    name: 'String'
                }
            },
            exitCode: {
                required: false,
                serializedName: 'exitCode',
                type: {
                    name: 'Number'
                }
            },
            failureInfo: {
                required: false,
                serializedName: 'failureInfo',
                type: {
                    name: 'Composite',
                    className: 'TaskFailureInformation'
                }
            },
            result: {
                required: false,
                serializedName: 'result',
                type: {
                    name: 'Enum',
                    allowedValues: ['success', 'failure']
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobReleaseTaskExecutionInformation"] = JobReleaseTaskExecutionInformation;

const JobPreparationAndReleaseTaskExecutionInformation = {
    required: false,
    serializedName: 'JobPreparationAndReleaseTaskExecutionInformation',
    type: {
        name: 'Composite',
        className: 'JobPreparationAndReleaseTaskExecutionInformation',
        modelProperties: {
            poolId: {
                required: false,
                serializedName: 'poolId',
                type: {
                    name: 'String'
                }
            },
            nodeId: {
                required: false,
                serializedName: 'nodeId',
                type: {
                    name: 'String'
                }
            },
            nodeUrl: {
                required: false,
                serializedName: 'nodeUrl',
                type: {
                    name: 'String'
                }
            },
            jobPreparationTaskExecutionInfo: {
                required: false,
                serializedName: 'jobPreparationTaskExecutionInfo',
                type: {
                    name: 'Composite',
                    className: 'JobPreparationTaskExecutionInformation'
                }
            },
            jobReleaseTaskExecutionInfo: {
                required: false,
                serializedName: 'jobReleaseTaskExecutionInfo',
                type: {
                    name: 'Composite',
                    className: 'JobReleaseTaskExecutionInformation'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobPreparationAndReleaseTaskExecutionInformation"] = JobPreparationAndReleaseTaskExecutionInformation;

const TaskCounts = {
    required: false,
    serializedName: 'TaskCounts',
    type: {
        name: 'Composite',
        className: 'TaskCounts',
        modelProperties: {
            active: {
                required: true,
                serializedName: 'active',
                type: {
                    name: 'Number'
                }
            },
            running: {
                required: true,
                serializedName: 'running',
                type: {
                    name: 'Number'
                }
            },
            completed: {
                required: true,
                serializedName: 'completed',
                type: {
                    name: 'Number'
                }
            },
            succeeded: {
                required: true,
                serializedName: 'succeeded',
                type: {
                    name: 'Number'
                }
            },
            failed: {
                required: true,
                serializedName: 'failed',
                type: {
                    name: 'Number'
                }
            },
            validationStatus: {
                required: true,
                serializedName: 'validationStatus',
                type: {
                    name: 'Enum',
                    allowedValues: ['validated', 'unvalidated']
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["TaskCounts"] = TaskCounts;

const AutoScaleRunError = {
    required: false,
    serializedName: 'AutoScaleRunError',
    type: {
        name: 'Composite',
        className: 'AutoScaleRunError',
        modelProperties: {
            code: {
                required: false,
                serializedName: 'code',
                type: {
                    name: 'String'
                }
            },
            message: {
                required: false,
                serializedName: 'message',
                type: {
                    name: 'String'
                }
            },
            values: {
                required: false,
                serializedName: 'values',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'NameValuePairElementType',
                        type: {
                            name: 'Composite',
                            className: 'NameValuePair'
                        }
                    }
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["AutoScaleRunError"] = AutoScaleRunError;

const AutoScaleRun = {
    required: false,
    serializedName: 'AutoScaleRun',
    type: {
        name: 'Composite',
        className: 'AutoScaleRun',
        modelProperties: {
            timestamp: {
                required: true,
                serializedName: 'timestamp',
                type: {
                    name: 'DateTime'
                }
            },
            results: {
                required: false,
                serializedName: 'results',
                type: {
                    name: 'String'
                }
            },
            error: {
                required: false,
                serializedName: 'error',
                type: {
                    name: 'Composite',
                    className: 'AutoScaleRunError'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["AutoScaleRun"] = AutoScaleRun;

const ResizeError = {
    required: false,
    serializedName: 'ResizeError',
    type: {
        name: 'Composite',
        className: 'ResizeError',
        modelProperties: {
            code: {
                required: false,
                serializedName: 'code',
                type: {
                    name: 'String'
                }
            },
            message: {
                required: false,
                serializedName: 'message',
                type: {
                    name: 'String'
                }
            },
            values: {
                required: false,
                serializedName: 'values',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'NameValuePairElementType',
                        type: {
                            name: 'Composite',
                            className: 'NameValuePair'
                        }
                    }
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ResizeError"] = ResizeError;

const CloudPool = {
    required: false,
    serializedName: 'CloudPool',
    type: {
        name: 'Composite',
        className: 'CloudPool',
        modelProperties: {
            id: {
                required: false,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            displayName: {
                required: false,
                serializedName: 'displayName',
                type: {
                    name: 'String'
                }
            },
            url: {
                required: false,
                serializedName: 'url',
                type: {
                    name: 'String'
                }
            },
            eTag: {
                required: false,
                serializedName: 'eTag',
                type: {
                    name: 'String'
                }
            },
            lastModified: {
                required: false,
                serializedName: 'lastModified',
                type: {
                    name: 'DateTime'
                }
            },
            creationTime: {
                required: false,
                serializedName: 'creationTime',
                type: {
                    name: 'DateTime'
                }
            },
            state: {
                required: false,
                serializedName: 'state',
                type: {
                    name: 'Enum',
                    allowedValues: ['active', 'deleting', 'upgrading']
                }
            },
            stateTransitionTime: {
                required: false,
                serializedName: 'stateTransitionTime',
                type: {
                    name: 'DateTime'
                }
            },
            allocationState: {
                required: false,
                serializedName: 'allocationState',
                type: {
                    name: 'Enum',
                    allowedValues: ['steady', 'resizing', 'stopping']
                }
            },
            allocationStateTransitionTime: {
                required: false,
                serializedName: 'allocationStateTransitionTime',
                type: {
                    name: 'DateTime'
                }
            },
            vmSize: {
                required: false,
                serializedName: 'vmSize',
                type: {
                    name: 'String'
                }
            },
            cloudServiceConfiguration: {
                required: false,
                serializedName: 'cloudServiceConfiguration',
                type: {
                    name: 'Composite',
                    className: 'CloudServiceConfiguration'
                }
            },
            virtualMachineConfiguration: {
                required: false,
                serializedName: 'virtualMachineConfiguration',
                type: {
                    name: 'Composite',
                    className: 'VirtualMachineConfiguration'
                }
            },
            resizeTimeout: {
                required: false,
                serializedName: 'resizeTimeout',
                type: {
                    name: 'TimeSpan'
                }
            },
            resizeErrors: {
                required: false,
                serializedName: 'resizeErrors',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ResizeErrorElementType',
                        type: {
                            name: 'Composite',
                            className: 'ResizeError'
                        }
                    }
                }
            },
            currentDedicatedNodes: {
                required: false,
                serializedName: 'currentDedicatedNodes',
                type: {
                    name: 'Number'
                }
            },
            currentLowPriorityNodes: {
                required: false,
                serializedName: 'currentLowPriorityNodes',
                type: {
                    name: 'Number'
                }
            },
            targetDedicatedNodes: {
                required: false,
                serializedName: 'targetDedicatedNodes',
                type: {
                    name: 'Number'
                }
            },
            targetLowPriorityNodes: {
                required: false,
                serializedName: 'targetLowPriorityNodes',
                type: {
                    name: 'Number'
                }
            },
            enableAutoScale: {
                required: false,
                serializedName: 'enableAutoScale',
                type: {
                    name: 'Boolean'
                }
            },
            autoScaleFormula: {
                required: false,
                serializedName: 'autoScaleFormula',
                type: {
                    name: 'String'
                }
            },
            autoScaleEvaluationInterval: {
                required: false,
                serializedName: 'autoScaleEvaluationInterval',
                type: {
                    name: 'TimeSpan'
                }
            },
            autoScaleRun: {
                required: false,
                serializedName: 'autoScaleRun',
                type: {
                    name: 'Composite',
                    className: 'AutoScaleRun'
                }
            },
            enableInterNodeCommunication: {
                required: false,
                serializedName: 'enableInterNodeCommunication',
                type: {
                    name: 'Boolean'
                }
            },
            networkConfiguration: {
                required: false,
                serializedName: 'networkConfiguration',
                type: {
                    name: 'Composite',
                    className: 'NetworkConfiguration'
                }
            },
            startTask: {
                required: false,
                serializedName: 'startTask',
                type: {
                    name: 'Composite',
                    className: 'StartTask'
                }
            },
            certificateReferences: {
                required: false,
                serializedName: 'certificateReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'CertificateReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'CertificateReference'
                        }
                    }
                }
            },
            applicationPackageReferences: {
                required: false,
                serializedName: 'applicationPackageReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ApplicationPackageReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'ApplicationPackageReference'
                        }
                    }
                }
            },
            applicationLicenses: {
                required: false,
                serializedName: 'applicationLicenses',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'stringElementType',
                        type: {
                            name: 'String'
                        }
                    }
                }
            },
            maxTasksPerNode: {
                required: false,
                serializedName: 'maxTasksPerNode',
                type: {
                    name: 'Number'
                }
            },
            taskSchedulingPolicy: {
                required: false,
                serializedName: 'taskSchedulingPolicy',
                type: {
                    name: 'Composite',
                    className: 'TaskSchedulingPolicy'
                }
            },
            userAccounts: {
                required: false,
                serializedName: 'userAccounts',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'UserAccountElementType',
                        type: {
                            name: 'Composite',
                            className: 'UserAccount'
                        }
                    }
                }
            },
            metadata: {
                required: false,
                serializedName: 'metadata',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'MetadataItemElementType',
                        type: {
                            name: 'Composite',
                            className: 'MetadataItem'
                        }
                    }
                }
            },
            stats: {
                required: false,
                serializedName: 'stats',
                type: {
                    name: 'Composite',
                    className: 'PoolStatistics'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["CloudPool"] = CloudPool;

const PoolAddParameter = {
    required: false,
    serializedName: 'PoolAddParameter',
    type: {
        name: 'Composite',
        className: 'PoolAddParameter',
        modelProperties: {
            id: {
                required: true,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            displayName: {
                required: false,
                serializedName: 'displayName',
                type: {
                    name: 'String'
                }
            },
            vmSize: {
                required: true,
                serializedName: 'vmSize',
                type: {
                    name: 'String'
                }
            },
            cloudServiceConfiguration: {
                required: false,
                serializedName: 'cloudServiceConfiguration',
                type: {
                    name: 'Composite',
                    className: 'CloudServiceConfiguration'
                }
            },
            virtualMachineConfiguration: {
                required: false,
                serializedName: 'virtualMachineConfiguration',
                type: {
                    name: 'Composite',
                    className: 'VirtualMachineConfiguration'
                }
            },
            resizeTimeout: {
                required: false,
                serializedName: 'resizeTimeout',
                type: {
                    name: 'TimeSpan'
                }
            },
            targetDedicatedNodes: {
                required: false,
                serializedName: 'targetDedicatedNodes',
                type: {
                    name: 'Number'
                }
            },
            targetLowPriorityNodes: {
                required: false,
                serializedName: 'targetLowPriorityNodes',
                type: {
                    name: 'Number'
                }
            },
            enableAutoScale: {
                required: false,
                serializedName: 'enableAutoScale',
                type: {
                    name: 'Boolean'
                }
            },
            autoScaleFormula: {
                required: false,
                serializedName: 'autoScaleFormula',
                type: {
                    name: 'String'
                }
            },
            autoScaleEvaluationInterval: {
                required: false,
                serializedName: 'autoScaleEvaluationInterval',
                type: {
                    name: 'TimeSpan'
                }
            },
            enableInterNodeCommunication: {
                required: false,
                serializedName: 'enableInterNodeCommunication',
                type: {
                    name: 'Boolean'
                }
            },
            networkConfiguration: {
                required: false,
                serializedName: 'networkConfiguration',
                type: {
                    name: 'Composite',
                    className: 'NetworkConfiguration'
                }
            },
            startTask: {
                required: false,
                serializedName: 'startTask',
                type: {
                    name: 'Composite',
                    className: 'StartTask'
                }
            },
            certificateReferences: {
                required: false,
                serializedName: 'certificateReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'CertificateReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'CertificateReference'
                        }
                    }
                }
            },
            applicationPackageReferences: {
                required: false,
                serializedName: 'applicationPackageReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ApplicationPackageReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'ApplicationPackageReference'
                        }
                    }
                }
            },
            applicationLicenses: {
                required: false,
                serializedName: 'applicationLicenses',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'stringElementType',
                        type: {
                            name: 'String'
                        }
                    }
                }
            },
            maxTasksPerNode: {
                required: false,
                serializedName: 'maxTasksPerNode',
                type: {
                    name: 'Number'
                }
            },
            taskSchedulingPolicy: {
                required: false,
                serializedName: 'taskSchedulingPolicy',
                type: {
                    name: 'Composite',
                    className: 'TaskSchedulingPolicy'
                }
            },
            userAccounts: {
                required: false,
                serializedName: 'userAccounts',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'UserAccountElementType',
                        type: {
                            name: 'Composite',
                            className: 'UserAccount'
                        }
                    }
                }
            },
            metadata: {
                required: false,
                serializedName: 'metadata',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'MetadataItemElementType',
                        type: {
                            name: 'Composite',
                            className: 'MetadataItem'
                        }
                    }
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolAddParameter"] = PoolAddParameter;

const AffinityInformation = {
    required: false,
    serializedName: 'AffinityInformation',
    type: {
        name: 'Composite',
        className: 'AffinityInformation',
        modelProperties: {
            affinityId: {
                required: true,
                serializedName: 'affinityId',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["AffinityInformation"] = AffinityInformation;

const TaskExecutionInformation = {
    required: false,
    serializedName: 'TaskExecutionInformation',
    type: {
        name: 'Composite',
        className: 'TaskExecutionInformation',
        modelProperties: {
            startTime: {
                required: false,
                serializedName: 'startTime',
                type: {
                    name: 'DateTime'
                }
            },
            endTime: {
                required: false,
                serializedName: 'endTime',
                type: {
                    name: 'DateTime'
                }
            },
            exitCode: {
                required: false,
                serializedName: 'exitCode',
                type: {
                    name: 'Number'
                }
            },
            failureInfo: {
                required: false,
                serializedName: 'failureInfo',
                type: {
                    name: 'Composite',
                    className: 'TaskFailureInformation'
                }
            },
            retryCount: {
                required: true,
                serializedName: 'retryCount',
                type: {
                    name: 'Number'
                }
            },
            lastRetryTime: {
                required: false,
                serializedName: 'lastRetryTime',
                type: {
                    name: 'DateTime'
                }
            },
            requeueCount: {
                required: true,
                serializedName: 'requeueCount',
                type: {
                    name: 'Number'
                }
            },
            lastRequeueTime: {
                required: false,
                serializedName: 'lastRequeueTime',
                type: {
                    name: 'DateTime'
                }
            },
            result: {
                required: false,
                serializedName: 'result',
                type: {
                    name: 'Enum',
                    allowedValues: ['success', 'failure']
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["TaskExecutionInformation"] = TaskExecutionInformation;

const ComputeNodeInformation = {
    required: false,
    serializedName: 'ComputeNodeInformation',
    type: {
        name: 'Composite',
        className: 'ComputeNodeInformation',
        modelProperties: {
            affinityId: {
                required: false,
                serializedName: 'affinityId',
                type: {
                    name: 'String'
                }
            },
            nodeUrl: {
                required: false,
                serializedName: 'nodeUrl',
                type: {
                    name: 'String'
                }
            },
            poolId: {
                required: false,
                serializedName: 'poolId',
                type: {
                    name: 'String'
                }
            },
            nodeId: {
                required: false,
                serializedName: 'nodeId',
                type: {
                    name: 'String'
                }
            },
            taskRootDirectory: {
                required: false,
                serializedName: 'taskRootDirectory',
                type: {
                    name: 'String'
                }
            },
            taskRootDirectoryUrl: {
                required: false,
                serializedName: 'taskRootDirectoryUrl',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ComputeNodeInformation"] = ComputeNodeInformation;

const MultiInstanceSettings = {
    required: false,
    serializedName: 'MultiInstanceSettings',
    type: {
        name: 'Composite',
        className: 'MultiInstanceSettings',
        modelProperties: {
            numberOfInstances: {
                required: true,
                serializedName: 'numberOfInstances',
                type: {
                    name: 'Number'
                }
            },
            coordinationCommandLine: {
                required: false,
                serializedName: 'coordinationCommandLine',
                type: {
                    name: 'String'
                }
            },
            commonResourceFiles: {
                required: false,
                serializedName: 'commonResourceFiles',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ResourceFileElementType',
                        type: {
                            name: 'Composite',
                            className: 'ResourceFile'
                        }
                    }
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["MultiInstanceSettings"] = MultiInstanceSettings;

const TaskStatistics = {
    required: false,
    serializedName: 'TaskStatistics',
    type: {
        name: 'Composite',
        className: 'TaskStatistics',
        modelProperties: {
            url: {
                required: true,
                serializedName: 'url',
                type: {
                    name: 'String'
                }
            },
            startTime: {
                required: true,
                serializedName: 'startTime',
                type: {
                    name: 'DateTime'
                }
            },
            lastUpdateTime: {
                required: true,
                serializedName: 'lastUpdateTime',
                type: {
                    name: 'DateTime'
                }
            },
            userCPUTime: {
                required: true,
                serializedName: 'userCPUTime',
                type: {
                    name: 'TimeSpan'
                }
            },
            kernelCPUTime: {
                required: true,
                serializedName: 'kernelCPUTime',
                type: {
                    name: 'TimeSpan'
                }
            },
            wallClockTime: {
                required: true,
                serializedName: 'wallClockTime',
                type: {
                    name: 'TimeSpan'
                }
            },
            readIOps: {
                required: true,
                serializedName: 'readIOps',
                type: {
                    name: 'Number'
                }
            },
            writeIOps: {
                required: true,
                serializedName: 'writeIOps',
                type: {
                    name: 'Number'
                }
            },
            readIOGiB: {
                required: true,
                serializedName: 'readIOGiB',
                type: {
                    name: 'Number'
                }
            },
            writeIOGiB: {
                required: true,
                serializedName: 'writeIOGiB',
                type: {
                    name: 'Number'
                }
            },
            waitTime: {
                required: true,
                serializedName: 'waitTime',
                type: {
                    name: 'TimeSpan'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["TaskStatistics"] = TaskStatistics;

const TaskIdRange = {
    required: false,
    serializedName: 'TaskIdRange',
    type: {
        name: 'Composite',
        className: 'TaskIdRange',
        modelProperties: {
            start: {
                required: true,
                serializedName: 'start',
                type: {
                    name: 'Number'
                }
            },
            end: {
                required: true,
                serializedName: 'end',
                type: {
                    name: 'Number'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["TaskIdRange"] = TaskIdRange;

const TaskDependencies = {
    required: false,
    serializedName: 'TaskDependencies',
    type: {
        name: 'Composite',
        className: 'TaskDependencies',
        modelProperties: {
            taskIds: {
                required: false,
                serializedName: 'taskIds',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'stringElementType',
                        type: {
                            name: 'String'
                        }
                    }
                }
            },
            taskIdRanges: {
                required: false,
                serializedName: 'taskIdRanges',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'TaskIdRangeElementType',
                        type: {
                            name: 'Composite',
                            className: 'TaskIdRange'
                        }
                    }
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["TaskDependencies"] = TaskDependencies;

const CloudTask = {
    required: false,
    serializedName: 'CloudTask',
    type: {
        name: 'Composite',
        className: 'CloudTask',
        modelProperties: {
            id: {
                required: false,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            displayName: {
                required: false,
                serializedName: 'displayName',
                type: {
                    name: 'String'
                }
            },
            url: {
                required: false,
                serializedName: 'url',
                type: {
                    name: 'String'
                }
            },
            eTag: {
                required: false,
                serializedName: 'eTag',
                type: {
                    name: 'String'
                }
            },
            lastModified: {
                required: false,
                serializedName: 'lastModified',
                type: {
                    name: 'DateTime'
                }
            },
            creationTime: {
                required: false,
                serializedName: 'creationTime',
                type: {
                    name: 'DateTime'
                }
            },
            exitConditions: {
                required: false,
                serializedName: 'exitConditions',
                type: {
                    name: 'Composite',
                    className: 'ExitConditions'
                }
            },
            state: {
                required: false,
                serializedName: 'state',
                type: {
                    name: 'Enum',
                    allowedValues: ['active', 'preparing', 'running', 'completed']
                }
            },
            stateTransitionTime: {
                required: false,
                serializedName: 'stateTransitionTime',
                type: {
                    name: 'DateTime'
                }
            },
            previousState: {
                required: false,
                serializedName: 'previousState',
                type: {
                    name: 'Enum',
                    allowedValues: ['active', 'preparing', 'running', 'completed']
                }
            },
            previousStateTransitionTime: {
                required: false,
                serializedName: 'previousStateTransitionTime',
                type: {
                    name: 'DateTime'
                }
            },
            commandLine: {
                required: false,
                serializedName: 'commandLine',
                type: {
                    name: 'String'
                }
            },
            resourceFiles: {
                required: false,
                serializedName: 'resourceFiles',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ResourceFileElementType',
                        type: {
                            name: 'Composite',
                            className: 'ResourceFile'
                        }
                    }
                }
            },
            outputFiles: {
                required: false,
                serializedName: 'outputFiles',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'OutputFileElementType',
                        type: {
                            name: 'Composite',
                            className: 'OutputFile'
                        }
                    }
                }
            },
            environmentSettings: {
                required: false,
                serializedName: 'environmentSettings',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'EnvironmentSettingElementType',
                        type: {
                            name: 'Composite',
                            className: 'EnvironmentSetting'
                        }
                    }
                }
            },
            affinityInfo: {
                required: false,
                serializedName: 'affinityInfo',
                type: {
                    name: 'Composite',
                    className: 'AffinityInformation'
                }
            },
            constraints: {
                required: false,
                serializedName: 'constraints',
                type: {
                    name: 'Composite',
                    className: 'TaskConstraints'
                }
            },
            userIdentity: {
                required: false,
                serializedName: 'userIdentity',
                type: {
                    name: 'Composite',
                    className: 'UserIdentity'
                }
            },
            executionInfo: {
                required: false,
                serializedName: 'executionInfo',
                type: {
                    name: 'Composite',
                    className: 'TaskExecutionInformation'
                }
            },
            nodeInfo: {
                required: false,
                serializedName: 'nodeInfo',
                type: {
                    name: 'Composite',
                    className: 'ComputeNodeInformation'
                }
            },
            multiInstanceSettings: {
                required: false,
                serializedName: 'multiInstanceSettings',
                type: {
                    name: 'Composite',
                    className: 'MultiInstanceSettings'
                }
            },
            stats: {
                required: false,
                serializedName: 'stats',
                type: {
                    name: 'Composite',
                    className: 'TaskStatistics'
                }
            },
            dependsOn: {
                required: false,
                serializedName: 'dependsOn',
                type: {
                    name: 'Composite',
                    className: 'TaskDependencies'
                }
            },
            applicationPackageReferences: {
                required: false,
                serializedName: 'applicationPackageReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ApplicationPackageReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'ApplicationPackageReference'
                        }
                    }
                }
            },
            authenticationTokenSettings: {
                required: false,
                serializedName: 'authenticationTokenSettings',
                type: {
                    name: 'Composite',
                    className: 'AuthenticationTokenSettings'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["CloudTask"] = CloudTask;

const TaskAddParameter = {
    required: false,
    serializedName: 'TaskAddParameter',
    type: {
        name: 'Composite',
        className: 'TaskAddParameter',
        modelProperties: {
            id: {
                required: true,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            displayName: {
                required: false,
                serializedName: 'displayName',
                type: {
                    name: 'String'
                }
            },
            commandLine: {
                required: true,
                serializedName: 'commandLine',
                type: {
                    name: 'String'
                }
            },
            exitConditions: {
                required: false,
                serializedName: 'exitConditions',
                type: {
                    name: 'Composite',
                    className: 'ExitConditions'
                }
            },
            resourceFiles: {
                required: false,
                serializedName: 'resourceFiles',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ResourceFileElementType',
                        type: {
                            name: 'Composite',
                            className: 'ResourceFile'
                        }
                    }
                }
            },
            outputFiles: {
                required: false,
                serializedName: 'outputFiles',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'OutputFileElementType',
                        type: {
                            name: 'Composite',
                            className: 'OutputFile'
                        }
                    }
                }
            },
            environmentSettings: {
                required: false,
                serializedName: 'environmentSettings',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'EnvironmentSettingElementType',
                        type: {
                            name: 'Composite',
                            className: 'EnvironmentSetting'
                        }
                    }
                }
            },
            affinityInfo: {
                required: false,
                serializedName: 'affinityInfo',
                type: {
                    name: 'Composite',
                    className: 'AffinityInformation'
                }
            },
            constraints: {
                required: false,
                serializedName: 'constraints',
                type: {
                    name: 'Composite',
                    className: 'TaskConstraints'
                }
            },
            userIdentity: {
                required: false,
                serializedName: 'userIdentity',
                type: {
                    name: 'Composite',
                    className: 'UserIdentity'
                }
            },
            multiInstanceSettings: {
                required: false,
                serializedName: 'multiInstanceSettings',
                type: {
                    name: 'Composite',
                    className: 'MultiInstanceSettings'
                }
            },
            dependsOn: {
                required: false,
                serializedName: 'dependsOn',
                type: {
                    name: 'Composite',
                    className: 'TaskDependencies'
                }
            },
            applicationPackageReferences: {
                required: false,
                serializedName: 'applicationPackageReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ApplicationPackageReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'ApplicationPackageReference'
                        }
                    }
                }
            },
            authenticationTokenSettings: {
                required: false,
                serializedName: 'authenticationTokenSettings',
                type: {
                    name: 'Composite',
                    className: 'AuthenticationTokenSettings'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["TaskAddParameter"] = TaskAddParameter;

const TaskAddCollectionParameter = {
    required: false,
    serializedName: 'TaskAddCollectionParameter',
    type: {
        name: 'Composite',
        className: 'TaskAddCollectionParameter',
        modelProperties: {
            value: {
                required: true,
                serializedName: 'value',
                constraints: {
                    MaxItems: 100
                },
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'TaskAddParameterElementType',
                        type: {
                            name: 'Composite',
                            className: 'TaskAddParameter'
                        }
                    }
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["TaskAddCollectionParameter"] = TaskAddCollectionParameter;

const ErrorMessage = {
    required: false,
    serializedName: 'ErrorMessage',
    type: {
        name: 'Composite',
        className: 'ErrorMessage',
        modelProperties: {
            lang: {
                required: false,
                serializedName: 'lang',
                type: {
                    name: 'String'
                }
            },
            value: {
                required: false,
                serializedName: 'value',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ErrorMessage"] = ErrorMessage;

const BatchErrorDetail = {
    required: false,
    serializedName: 'BatchErrorDetail',
    type: {
        name: 'Composite',
        className: 'BatchErrorDetail',
        modelProperties: {
            key: {
                required: false,
                serializedName: 'key',
                type: {
                    name: 'String'
                }
            },
            value: {
                required: false,
                serializedName: 'value',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["BatchErrorDetail"] = BatchErrorDetail;

const BatchError = {
    required: false,
    serializedName: 'BatchError',
    type: {
        name: 'Composite',
        className: 'BatchError',
        modelProperties: {
            code: {
                required: false,
                serializedName: 'code',
                type: {
                    name: 'String'
                }
            },
            message: {
                required: false,
                serializedName: 'message',
                type: {
                    name: 'Composite',
                    className: 'ErrorMessage'
                }
            },
            values: {
                required: false,
                serializedName: 'values',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'BatchErrorDetailElementType',
                        type: {
                            name: 'Composite',
                            className: 'BatchErrorDetail'
                        }
                    }
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["BatchError"] = BatchError;

const TaskAddResult = {
    required: false,
    serializedName: 'TaskAddResult',
    type: {
        name: 'Composite',
        className: 'TaskAddResult',
        modelProperties: {
            status: {
                required: true,
                serializedName: 'status',
                type: {
                    name: 'Enum',
                    allowedValues: ['success', 'clientError', 'serverError']
                }
            },
            taskId: {
                required: true,
                serializedName: 'taskId',
                type: {
                    name: 'String'
                }
            },
            eTag: {
                required: false,
                serializedName: 'eTag',
                type: {
                    name: 'String'
                }
            },
            lastModified: {
                required: false,
                serializedName: 'lastModified',
                type: {
                    name: 'DateTime'
                }
            },
            location: {
                required: false,
                serializedName: 'location',
                type: {
                    name: 'String'
                }
            },
            error: {
                required: false,
                serializedName: 'error',
                type: {
                    name: 'Composite',
                    className: 'BatchError'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["TaskAddResult"] = TaskAddResult;

const TaskAddCollectionResult = {
    required: false,
    serializedName: 'TaskAddCollectionResult',
    type: {
        name: 'Composite',
        className: 'TaskAddCollectionResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: 'value',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'TaskAddResultElementType',
                        type: {
                            name: 'Composite',
                            className: 'TaskAddResult'
                        }
                    }
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["TaskAddCollectionResult"] = TaskAddCollectionResult;

const SubtaskInformation = {
    required: false,
    serializedName: 'SubtaskInformation',
    type: {
        name: 'Composite',
        className: 'SubtaskInformation',
        modelProperties: {
            id: {
                required: false,
                serializedName: 'id',
                type: {
                    name: 'Number'
                }
            },
            nodeInfo: {
                required: false,
                serializedName: 'nodeInfo',
                type: {
                    name: 'Composite',
                    className: 'ComputeNodeInformation'
                }
            },
            startTime: {
                required: false,
                serializedName: 'startTime',
                type: {
                    name: 'DateTime'
                }
            },
            endTime: {
                required: false,
                serializedName: 'endTime',
                type: {
                    name: 'DateTime'
                }
            },
            exitCode: {
                required: false,
                serializedName: 'exitCode',
                type: {
                    name: 'Number'
                }
            },
            failureInfo: {
                required: false,
                serializedName: 'failureInfo',
                type: {
                    name: 'Composite',
                    className: 'TaskFailureInformation'
                }
            },
            state: {
                required: false,
                serializedName: 'state',
                type: {
                    name: 'Enum',
                    allowedValues: ['preparing', 'running', 'completed']
                }
            },
            stateTransitionTime: {
                required: false,
                serializedName: 'stateTransitionTime',
                type: {
                    name: 'DateTime'
                }
            },
            previousState: {
                required: false,
                serializedName: 'previousState',
                type: {
                    name: 'Enum',
                    allowedValues: ['preparing', 'running', 'completed']
                }
            },
            previousStateTransitionTime: {
                required: false,
                serializedName: 'previousStateTransitionTime',
                type: {
                    name: 'DateTime'
                }
            },
            result: {
                required: false,
                serializedName: 'result',
                type: {
                    name: 'Enum',
                    allowedValues: ['success', 'failure']
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["SubtaskInformation"] = SubtaskInformation;

const CloudTaskListSubtasksResult = {
    required: false,
    serializedName: 'CloudTaskListSubtasksResult',
    type: {
        name: 'Composite',
        className: 'CloudTaskListSubtasksResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: 'value',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'SubtaskInformationElementType',
                        type: {
                            name: 'Composite',
                            className: 'SubtaskInformation'
                        }
                    }
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["CloudTaskListSubtasksResult"] = CloudTaskListSubtasksResult;

const TaskInformation = {
    required: false,
    serializedName: 'TaskInformation',
    type: {
        name: 'Composite',
        className: 'TaskInformation',
        modelProperties: {
            taskUrl: {
                required: false,
                serializedName: 'taskUrl',
                type: {
                    name: 'String'
                }
            },
            jobId: {
                required: false,
                serializedName: 'jobId',
                type: {
                    name: 'String'
                }
            },
            taskId: {
                required: false,
                serializedName: 'taskId',
                type: {
                    name: 'String'
                }
            },
            subtaskId: {
                required: false,
                serializedName: 'subtaskId',
                type: {
                    name: 'Number'
                }
            },
            taskState: {
                required: true,
                serializedName: 'taskState',
                type: {
                    name: 'Enum',
                    allowedValues: ['active', 'preparing', 'running', 'completed']
                }
            },
            executionInfo: {
                required: false,
                serializedName: 'executionInfo',
                type: {
                    name: 'Composite',
                    className: 'TaskExecutionInformation'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["TaskInformation"] = TaskInformation;

const StartTaskInformation = {
    required: false,
    serializedName: 'StartTaskInformation',
    type: {
        name: 'Composite',
        className: 'StartTaskInformation',
        modelProperties: {
            state: {
                required: true,
                serializedName: 'state',
                type: {
                    name: 'Enum',
                    allowedValues: ['running', 'completed']
                }
            },
            startTime: {
                required: true,
                serializedName: 'startTime',
                type: {
                    name: 'DateTime'
                }
            },
            endTime: {
                required: false,
                serializedName: 'endTime',
                type: {
                    name: 'DateTime'
                }
            },
            exitCode: {
                required: false,
                serializedName: 'exitCode',
                type: {
                    name: 'Number'
                }
            },
            failureInfo: {
                required: false,
                serializedName: 'failureInfo',
                type: {
                    name: 'Composite',
                    className: 'TaskFailureInformation'
                }
            },
            retryCount: {
                required: true,
                serializedName: 'retryCount',
                type: {
                    name: 'Number'
                }
            },
            lastRetryTime: {
                required: false,
                serializedName: 'lastRetryTime',
                type: {
                    name: 'DateTime'
                }
            },
            result: {
                required: false,
                serializedName: 'result',
                type: {
                    name: 'Enum',
                    allowedValues: ['success', 'failure']
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["StartTaskInformation"] = StartTaskInformation;

const ComputeNodeError = {
    required: false,
    serializedName: 'ComputeNodeError',
    type: {
        name: 'Composite',
        className: 'ComputeNodeError',
        modelProperties: {
            code: {
                required: false,
                serializedName: 'code',
                type: {
                    name: 'String'
                }
            },
            message: {
                required: false,
                serializedName: 'message',
                type: {
                    name: 'String'
                }
            },
            errorDetails: {
                required: false,
                serializedName: 'errorDetails',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'NameValuePairElementType',
                        type: {
                            name: 'Composite',
                            className: 'NameValuePair'
                        }
                    }
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ComputeNodeError"] = ComputeNodeError;

const InboundEndpoint = {
    required: false,
    serializedName: 'InboundEndpoint',
    type: {
        name: 'Composite',
        className: 'InboundEndpoint',
        modelProperties: {
            name: {
                required: true,
                serializedName: 'name',
                type: {
                    name: 'String'
                }
            },
            protocol: {
                required: true,
                serializedName: 'protocol',
                type: {
                    name: 'Enum',
                    allowedValues: ['tcp', 'udp']
                }
            },
            publicIPAddress: {
                required: true,
                serializedName: 'publicIPAddress',
                type: {
                    name: 'String'
                }
            },
            publicFQDN: {
                required: true,
                serializedName: 'publicFQDN',
                type: {
                    name: 'String'
                }
            },
            frontendPort: {
                required: true,
                serializedName: 'frontendPort',
                type: {
                    name: 'Number'
                }
            },
            backendPort: {
                required: true,
                serializedName: 'backendPort',
                type: {
                    name: 'Number'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["InboundEndpoint"] = InboundEndpoint;

const ComputeNodeEndpointConfiguration = {
    required: false,
    serializedName: 'ComputeNodeEndpointConfiguration',
    type: {
        name: 'Composite',
        className: 'ComputeNodeEndpointConfiguration',
        modelProperties: {
            inboundEndpoints: {
                required: true,
                serializedName: 'inboundEndpoints',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'InboundEndpointElementType',
                        type: {
                            name: 'Composite',
                            className: 'InboundEndpoint'
                        }
                    }
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ComputeNodeEndpointConfiguration"] = ComputeNodeEndpointConfiguration;

const ComputeNode = {
    required: false,
    serializedName: 'ComputeNode',
    type: {
        name: 'Composite',
        className: 'ComputeNode',
        modelProperties: {
            id: {
                required: false,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            url: {
                required: false,
                serializedName: 'url',
                type: {
                    name: 'String'
                }
            },
            state: {
                required: false,
                serializedName: 'state',
                type: {
                    name: 'Enum',
                    allowedValues: ['idle', 'rebooting', 'reimaging', 'running', 'unusable', 'creating', 'starting', 'waitingForStartTask', 'startTaskFailed', 'unknown', 'leavingPool', 'offline', 'preempted']
                }
            },
            schedulingState: {
                required: false,
                serializedName: 'schedulingState',
                type: {
                    name: 'Enum',
                    allowedValues: ['enabled', 'disabled']
                }
            },
            stateTransitionTime: {
                required: false,
                serializedName: 'stateTransitionTime',
                type: {
                    name: 'DateTime'
                }
            },
            lastBootTime: {
                required: false,
                serializedName: 'lastBootTime',
                type: {
                    name: 'DateTime'
                }
            },
            allocationTime: {
                required: false,
                serializedName: 'allocationTime',
                type: {
                    name: 'DateTime'
                }
            },
            ipAddress: {
                required: false,
                serializedName: 'ipAddress',
                type: {
                    name: 'String'
                }
            },
            affinityId: {
                required: false,
                serializedName: 'affinityId',
                type: {
                    name: 'String'
                }
            },
            vmSize: {
                required: false,
                serializedName: 'vmSize',
                type: {
                    name: 'String'
                }
            },
            totalTasksRun: {
                required: false,
                serializedName: 'totalTasksRun',
                type: {
                    name: 'Number'
                }
            },
            runningTasksCount: {
                required: false,
                serializedName: 'runningTasksCount',
                type: {
                    name: 'Number'
                }
            },
            totalTasksSucceeded: {
                required: false,
                serializedName: 'totalTasksSucceeded',
                type: {
                    name: 'Number'
                }
            },
            recentTasks: {
                required: false,
                serializedName: 'recentTasks',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'TaskInformationElementType',
                        type: {
                            name: 'Composite',
                            className: 'TaskInformation'
                        }
                    }
                }
            },
            startTask: {
                required: false,
                serializedName: 'startTask',
                type: {
                    name: 'Composite',
                    className: 'StartTask'
                }
            },
            startTaskInfo: {
                required: false,
                serializedName: 'startTaskInfo',
                type: {
                    name: 'Composite',
                    className: 'StartTaskInformation'
                }
            },
            certificateReferences: {
                required: false,
                serializedName: 'certificateReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'CertificateReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'CertificateReference'
                        }
                    }
                }
            },
            errors: {
                required: false,
                serializedName: 'errors',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ComputeNodeErrorElementType',
                        type: {
                            name: 'Composite',
                            className: 'ComputeNodeError'
                        }
                    }
                }
            },
            isDedicated: {
                required: false,
                serializedName: 'isDedicated',
                type: {
                    name: 'Boolean'
                }
            },
            endpointConfiguration: {
                required: false,
                serializedName: 'endpointConfiguration',
                type: {
                    name: 'Composite',
                    className: 'ComputeNodeEndpointConfiguration'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ComputeNode"] = ComputeNode;

const ComputeNodeUser = {
    required: false,
    serializedName: 'ComputeNodeUser',
    type: {
        name: 'Composite',
        className: 'ComputeNodeUser',
        modelProperties: {
            name: {
                required: true,
                serializedName: 'name',
                type: {
                    name: 'String'
                }
            },
            isAdmin: {
                required: false,
                serializedName: 'isAdmin',
                type: {
                    name: 'Boolean'
                }
            },
            expiryTime: {
                required: false,
                serializedName: 'expiryTime',
                type: {
                    name: 'DateTime'
                }
            },
            password: {
                required: false,
                serializedName: 'password',
                type: {
                    name: 'String'
                }
            },
            sshPublicKey: {
                required: false,
                serializedName: 'sshPublicKey',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ComputeNodeUser"] = ComputeNodeUser;

const ComputeNodeGetRemoteLoginSettingsResult = {
    required: false,
    serializedName: 'ComputeNodeGetRemoteLoginSettingsResult',
    type: {
        name: 'Composite',
        className: 'ComputeNodeGetRemoteLoginSettingsResult',
        modelProperties: {
            remoteLoginIPAddress: {
                required: true,
                serializedName: 'remoteLoginIPAddress',
                type: {
                    name: 'String'
                }
            },
            remoteLoginPort: {
                required: true,
                serializedName: 'remoteLoginPort',
                type: {
                    name: 'Number'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ComputeNodeGetRemoteLoginSettingsResult"] = ComputeNodeGetRemoteLoginSettingsResult;

const JobSchedulePatchParameter = {
    required: false,
    serializedName: 'JobSchedulePatchParameter',
    type: {
        name: 'Composite',
        className: 'JobSchedulePatchParameter',
        modelProperties: {
            schedule: {
                required: false,
                serializedName: 'schedule',
                type: {
                    name: 'Composite',
                    className: 'Schedule'
                }
            },
            jobSpecification: {
                required: false,
                serializedName: 'jobSpecification',
                type: {
                    name: 'Composite',
                    className: 'JobSpecification'
                }
            },
            metadata: {
                required: false,
                serializedName: 'metadata',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'MetadataItemElementType',
                        type: {
                            name: 'Composite',
                            className: 'MetadataItem'
                        }
                    }
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobSchedulePatchParameter"] = JobSchedulePatchParameter;

const JobScheduleUpdateParameter = {
    required: false,
    serializedName: 'JobScheduleUpdateParameter',
    type: {
        name: 'Composite',
        className: 'JobScheduleUpdateParameter',
        modelProperties: {
            schedule: {
                required: true,
                serializedName: 'schedule',
                type: {
                    name: 'Composite',
                    className: 'Schedule'
                }
            },
            jobSpecification: {
                required: true,
                serializedName: 'jobSpecification',
                type: {
                    name: 'Composite',
                    className: 'JobSpecification'
                }
            },
            metadata: {
                required: false,
                serializedName: 'metadata',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'MetadataItemElementType',
                        type: {
                            name: 'Composite',
                            className: 'MetadataItem'
                        }
                    }
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobScheduleUpdateParameter"] = JobScheduleUpdateParameter;

const JobDisableParameter = {
    required: false,
    serializedName: 'JobDisableParameter',
    type: {
        name: 'Composite',
        className: 'JobDisableParameter',
        modelProperties: {
            disableTasks: {
                required: true,
                serializedName: 'disableTasks',
                type: {
                    name: 'Enum',
                    allowedValues: ['requeue', 'terminate', 'wait']
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobDisableParameter"] = JobDisableParameter;

const JobTerminateParameter = {
    required: false,
    serializedName: 'JobTerminateParameter',
    type: {
        name: 'Composite',
        className: 'JobTerminateParameter',
        modelProperties: {
            terminateReason: {
                required: false,
                serializedName: 'terminateReason',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobTerminateParameter"] = JobTerminateParameter;

const JobPatchParameter = {
    required: false,
    serializedName: 'JobPatchParameter',
    type: {
        name: 'Composite',
        className: 'JobPatchParameter',
        modelProperties: {
            priority: {
                required: false,
                serializedName: 'priority',
                type: {
                    name: 'Number'
                }
            },
            onAllTasksComplete: {
                required: false,
                serializedName: 'onAllTasksComplete',
                type: {
                    name: 'Enum',
                    allowedValues: ['noAction', 'terminateJob']
                }
            },
            constraints: {
                required: false,
                serializedName: 'constraints',
                type: {
                    name: 'Composite',
                    className: 'JobConstraints'
                }
            },
            poolInfo: {
                required: false,
                serializedName: 'poolInfo',
                type: {
                    name: 'Composite',
                    className: 'PoolInformation'
                }
            },
            metadata: {
                required: false,
                serializedName: 'metadata',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'MetadataItemElementType',
                        type: {
                            name: 'Composite',
                            className: 'MetadataItem'
                        }
                    }
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobPatchParameter"] = JobPatchParameter;

const JobUpdateParameter = {
    required: false,
    serializedName: 'JobUpdateParameter',
    type: {
        name: 'Composite',
        className: 'JobUpdateParameter',
        modelProperties: {
            priority: {
                required: false,
                serializedName: 'priority',
                type: {
                    name: 'Number'
                }
            },
            constraints: {
                required: false,
                serializedName: 'constraints',
                type: {
                    name: 'Composite',
                    className: 'JobConstraints'
                }
            },
            poolInfo: {
                required: true,
                serializedName: 'poolInfo',
                type: {
                    name: 'Composite',
                    className: 'PoolInformation'
                }
            },
            metadata: {
                required: false,
                serializedName: 'metadata',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'MetadataItemElementType',
                        type: {
                            name: 'Composite',
                            className: 'MetadataItem'
                        }
                    }
                }
            },
            onAllTasksComplete: {
                required: false,
                serializedName: 'onAllTasksComplete',
                type: {
                    name: 'Enum',
                    allowedValues: ['noAction', 'terminateJob']
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobUpdateParameter"] = JobUpdateParameter;

const PoolEnableAutoScaleParameter = {
    required: false,
    serializedName: 'PoolEnableAutoScaleParameter',
    type: {
        name: 'Composite',
        className: 'PoolEnableAutoScaleParameter',
        modelProperties: {
            autoScaleFormula: {
                required: false,
                serializedName: 'autoScaleFormula',
                type: {
                    name: 'String'
                }
            },
            autoScaleEvaluationInterval: {
                required: false,
                serializedName: 'autoScaleEvaluationInterval',
                type: {
                    name: 'TimeSpan'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolEnableAutoScaleParameter"] = PoolEnableAutoScaleParameter;

const PoolEvaluateAutoScaleParameter = {
    required: false,
    serializedName: 'PoolEvaluateAutoScaleParameter',
    type: {
        name: 'Composite',
        className: 'PoolEvaluateAutoScaleParameter',
        modelProperties: {
            autoScaleFormula: {
                required: true,
                serializedName: 'autoScaleFormula',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolEvaluateAutoScaleParameter"] = PoolEvaluateAutoScaleParameter;

const PoolResizeParameter = {
    required: false,
    serializedName: 'PoolResizeParameter',
    type: {
        name: 'Composite',
        className: 'PoolResizeParameter',
        modelProperties: {
            targetDedicatedNodes: {
                required: false,
                serializedName: 'targetDedicatedNodes',
                type: {
                    name: 'Number'
                }
            },
            targetLowPriorityNodes: {
                required: false,
                serializedName: 'targetLowPriorityNodes',
                type: {
                    name: 'Number'
                }
            },
            resizeTimeout: {
                required: false,
                serializedName: 'resizeTimeout',
                type: {
                    name: 'TimeSpan'
                }
            },
            nodeDeallocationOption: {
                required: false,
                serializedName: 'nodeDeallocationOption',
                type: {
                    name: 'Enum',
                    allowedValues: ['requeue', 'terminate', 'taskCompletion', 'retainedData']
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolResizeParameter"] = PoolResizeParameter;

const PoolUpdatePropertiesParameter = {
    required: false,
    serializedName: 'PoolUpdatePropertiesParameter',
    type: {
        name: 'Composite',
        className: 'PoolUpdatePropertiesParameter',
        modelProperties: {
            startTask: {
                required: false,
                serializedName: 'startTask',
                type: {
                    name: 'Composite',
                    className: 'StartTask'
                }
            },
            certificateReferences: {
                required: true,
                serializedName: 'certificateReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'CertificateReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'CertificateReference'
                        }
                    }
                }
            },
            applicationPackageReferences: {
                required: true,
                serializedName: 'applicationPackageReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ApplicationPackageReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'ApplicationPackageReference'
                        }
                    }
                }
            },
            metadata: {
                required: true,
                serializedName: 'metadata',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'MetadataItemElementType',
                        type: {
                            name: 'Composite',
                            className: 'MetadataItem'
                        }
                    }
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolUpdatePropertiesParameter"] = PoolUpdatePropertiesParameter;

const PoolUpgradeOSParameter = {
    required: false,
    serializedName: 'PoolUpgradeOSParameter',
    type: {
        name: 'Composite',
        className: 'PoolUpgradeOSParameter',
        modelProperties: {
            targetOSVersion: {
                required: true,
                serializedName: 'targetOSVersion',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolUpgradeOSParameter"] = PoolUpgradeOSParameter;

const PoolPatchParameter = {
    required: false,
    serializedName: 'PoolPatchParameter',
    type: {
        name: 'Composite',
        className: 'PoolPatchParameter',
        modelProperties: {
            startTask: {
                required: false,
                serializedName: 'startTask',
                type: {
                    name: 'Composite',
                    className: 'StartTask'
                }
            },
            certificateReferences: {
                required: false,
                serializedName: 'certificateReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'CertificateReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'CertificateReference'
                        }
                    }
                }
            },
            applicationPackageReferences: {
                required: false,
                serializedName: 'applicationPackageReferences',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ApplicationPackageReferenceElementType',
                        type: {
                            name: 'Composite',
                            className: 'ApplicationPackageReference'
                        }
                    }
                }
            },
            metadata: {
                required: false,
                serializedName: 'metadata',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'MetadataItemElementType',
                        type: {
                            name: 'Composite',
                            className: 'MetadataItem'
                        }
                    }
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolPatchParameter"] = PoolPatchParameter;

const TaskUpdateParameter = {
    required: false,
    serializedName: 'TaskUpdateParameter',
    type: {
        name: 'Composite',
        className: 'TaskUpdateParameter',
        modelProperties: {
            constraints: {
                required: false,
                serializedName: 'constraints',
                type: {
                    name: 'Composite',
                    className: 'TaskConstraints'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["TaskUpdateParameter"] = TaskUpdateParameter;

const NodeUpdateUserParameter = {
    required: false,
    serializedName: 'NodeUpdateUserParameter',
    type: {
        name: 'Composite',
        className: 'NodeUpdateUserParameter',
        modelProperties: {
            password: {
                required: false,
                serializedName: 'password',
                type: {
                    name: 'String'
                }
            },
            expiryTime: {
                required: false,
                serializedName: 'expiryTime',
                type: {
                    name: 'DateTime'
                }
            },
            sshPublicKey: {
                required: false,
                serializedName: 'sshPublicKey',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["NodeUpdateUserParameter"] = NodeUpdateUserParameter;

const NodeRebootParameter = {
    required: false,
    serializedName: 'NodeRebootParameter',
    type: {
        name: 'Composite',
        className: 'NodeRebootParameter',
        modelProperties: {
            nodeRebootOption: {
                required: false,
                serializedName: 'nodeRebootOption',
                type: {
                    name: 'Enum',
                    allowedValues: ['requeue', 'terminate', 'taskCompletion', 'retainedData']
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["NodeRebootParameter"] = NodeRebootParameter;

const NodeReimageParameter = {
    required: false,
    serializedName: 'NodeReimageParameter',
    type: {
        name: 'Composite',
        className: 'NodeReimageParameter',
        modelProperties: {
            nodeReimageOption: {
                required: false,
                serializedName: 'nodeReimageOption',
                type: {
                    name: 'Enum',
                    allowedValues: ['requeue', 'terminate', 'taskCompletion', 'retainedData']
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["NodeReimageParameter"] = NodeReimageParameter;

const NodeDisableSchedulingParameter = {
    required: false,
    serializedName: 'NodeDisableSchedulingParameter',
    type: {
        name: 'Composite',
        className: 'NodeDisableSchedulingParameter',
        modelProperties: {
            nodeDisableSchedulingOption: {
                required: false,
                serializedName: 'nodeDisableSchedulingOption',
                type: {
                    name: 'Enum',
                    allowedValues: ['requeue', 'terminate', 'taskCompletion']
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["NodeDisableSchedulingParameter"] = NodeDisableSchedulingParameter;

const NodeRemoveParameter = {
    required: false,
    serializedName: 'NodeRemoveParameter',
    type: {
        name: 'Composite',
        className: 'NodeRemoveParameter',
        modelProperties: {
            nodeList: {
                required: true,
                serializedName: 'nodeList',
                constraints: {
                    MaxItems: 100
                },
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'stringElementType',
                        type: {
                            name: 'String'
                        }
                    }
                }
            },
            resizeTimeout: {
                required: false,
                serializedName: 'resizeTimeout',
                type: {
                    name: 'TimeSpan'
                }
            },
            nodeDeallocationOption: {
                required: false,
                serializedName: 'nodeDeallocationOption',
                type: {
                    name: 'Enum',
                    allowedValues: ['requeue', 'terminate', 'taskCompletion', 'retainedData']
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["NodeRemoveParameter"] = NodeRemoveParameter;

const ApplicationListOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ApplicationListOptions',
        modelProperties: {
            maxResults: {
                required: false,
                defaultValue: 1000,
                type: {
                    name: 'Number'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ApplicationListOptions"] = ApplicationListOptions;

const ApplicationGetOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ApplicationGetOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ApplicationGetOptions"] = ApplicationGetOptions;

const PoolListUsageMetricsOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolListUsageMetricsOptions',
        modelProperties: {
            startTime: {
                required: false,
                type: {
                    name: 'DateTime'
                }
            },
            endTime: {
                required: false,
                type: {
                    name: 'DateTime'
                }
            },
            filter: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            maxResults: {
                required: false,
                defaultValue: 1000,
                type: {
                    name: 'Number'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolListUsageMetricsOptions"] = PoolListUsageMetricsOptions;

const PoolGetAllLifetimeStatisticsOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolGetAllLifetimeStatisticsOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolGetAllLifetimeStatisticsOptions"] = PoolGetAllLifetimeStatisticsOptions;

const PoolAddOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolAddOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolAddOptions"] = PoolAddOptions;

const PoolListOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolListOptions',
        modelProperties: {
            filter: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            expand: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            maxResults: {
                required: false,
                defaultValue: 1000,
                type: {
                    name: 'Number'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolListOptions"] = PoolListOptions;

const PoolDeleteMethodOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolDeleteMethodOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolDeleteMethodOptions"] = PoolDeleteMethodOptions;

const PoolExistsOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolExistsOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolExistsOptions"] = PoolExistsOptions;

const PoolGetOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolGetOptions',
        modelProperties: {
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            expand: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolGetOptions"] = PoolGetOptions;

const PoolPatchOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolPatchOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolPatchOptions"] = PoolPatchOptions;

const PoolDisableAutoScaleOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolDisableAutoScaleOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolDisableAutoScaleOptions"] = PoolDisableAutoScaleOptions;

const PoolEnableAutoScaleOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolEnableAutoScaleOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolEnableAutoScaleOptions"] = PoolEnableAutoScaleOptions;

const PoolEvaluateAutoScaleOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolEvaluateAutoScaleOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolEvaluateAutoScaleOptions"] = PoolEvaluateAutoScaleOptions;

const PoolResizeOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolResizeOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolResizeOptions"] = PoolResizeOptions;

const PoolStopResizeOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolStopResizeOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolStopResizeOptions"] = PoolStopResizeOptions;

const PoolUpdatePropertiesOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolUpdatePropertiesOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolUpdatePropertiesOptions"] = PoolUpdatePropertiesOptions;

const PoolUpgradeOSOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolUpgradeOSOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolUpgradeOSOptions"] = PoolUpgradeOSOptions;

const PoolRemoveNodesOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolRemoveNodesOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolRemoveNodesOptions"] = PoolRemoveNodesOptions;

const AccountListNodeAgentSkusOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'AccountListNodeAgentSkusOptions',
        modelProperties: {
            filter: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            maxResults: {
                required: false,
                defaultValue: 1000,
                type: {
                    name: 'Number'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["AccountListNodeAgentSkusOptions"] = AccountListNodeAgentSkusOptions;

const JobGetAllLifetimeStatisticsOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobGetAllLifetimeStatisticsOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobGetAllLifetimeStatisticsOptions"] = JobGetAllLifetimeStatisticsOptions;

const JobDeleteMethodOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobDeleteMethodOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobDeleteMethodOptions"] = JobDeleteMethodOptions;

const JobGetOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobGetOptions',
        modelProperties: {
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            expand: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobGetOptions"] = JobGetOptions;

const JobPatchOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobPatchOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobPatchOptions"] = JobPatchOptions;

const JobUpdateOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobUpdateOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobUpdateOptions"] = JobUpdateOptions;

const JobDisableOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobDisableOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobDisableOptions"] = JobDisableOptions;

const JobEnableOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobEnableOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobEnableOptions"] = JobEnableOptions;

const JobTerminateOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobTerminateOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobTerminateOptions"] = JobTerminateOptions;

const JobAddOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobAddOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobAddOptions"] = JobAddOptions;

const JobListOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobListOptions',
        modelProperties: {
            filter: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            expand: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            maxResults: {
                required: false,
                defaultValue: 1000,
                type: {
                    name: 'Number'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobListOptions"] = JobListOptions;

const JobListFromJobScheduleOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobListFromJobScheduleOptions',
        modelProperties: {
            filter: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            expand: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            maxResults: {
                required: false,
                defaultValue: 1000,
                type: {
                    name: 'Number'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobListFromJobScheduleOptions"] = JobListFromJobScheduleOptions;

const JobListPreparationAndReleaseTaskStatusOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobListPreparationAndReleaseTaskStatusOptions',
        modelProperties: {
            filter: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            maxResults: {
                required: false,
                defaultValue: 1000,
                type: {
                    name: 'Number'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobListPreparationAndReleaseTaskStatusOptions"] = JobListPreparationAndReleaseTaskStatusOptions;

const JobGetTaskCountsOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobGetTaskCountsOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobGetTaskCountsOptions"] = JobGetTaskCountsOptions;

const CertificateAddOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'CertificateAddOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["CertificateAddOptions"] = CertificateAddOptions;

const CertificateListOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'CertificateListOptions',
        modelProperties: {
            filter: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            maxResults: {
                required: false,
                defaultValue: 1000,
                type: {
                    name: 'Number'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["CertificateListOptions"] = CertificateListOptions;

const CertificateCancelDeletionOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'CertificateCancelDeletionOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["CertificateCancelDeletionOptions"] = CertificateCancelDeletionOptions;

const CertificateDeleteMethodOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'CertificateDeleteMethodOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["CertificateDeleteMethodOptions"] = CertificateDeleteMethodOptions;

const CertificateGetOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'CertificateGetOptions',
        modelProperties: {
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["CertificateGetOptions"] = CertificateGetOptions;

const FileDeleteFromTaskOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'FileDeleteFromTaskOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["FileDeleteFromTaskOptions"] = FileDeleteFromTaskOptions;

const FileGetFromTaskOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'FileGetFromTaskOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ocpRange: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["FileGetFromTaskOptions"] = FileGetFromTaskOptions;

const FileGetPropertiesFromTaskOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'FileGetPropertiesFromTaskOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["FileGetPropertiesFromTaskOptions"] = FileGetPropertiesFromTaskOptions;

const FileDeleteFromComputeNodeOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'FileDeleteFromComputeNodeOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["FileDeleteFromComputeNodeOptions"] = FileDeleteFromComputeNodeOptions;

const FileGetFromComputeNodeOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'FileGetFromComputeNodeOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ocpRange: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["FileGetFromComputeNodeOptions"] = FileGetFromComputeNodeOptions;

const FileGetPropertiesFromComputeNodeOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'FileGetPropertiesFromComputeNodeOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["FileGetPropertiesFromComputeNodeOptions"] = FileGetPropertiesFromComputeNodeOptions;

const FileListFromTaskOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'FileListFromTaskOptions',
        modelProperties: {
            filter: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            maxResults: {
                required: false,
                defaultValue: 1000,
                type: {
                    name: 'Number'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["FileListFromTaskOptions"] = FileListFromTaskOptions;

const FileListFromComputeNodeOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'FileListFromComputeNodeOptions',
        modelProperties: {
            filter: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            maxResults: {
                required: false,
                defaultValue: 1000,
                type: {
                    name: 'Number'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["FileListFromComputeNodeOptions"] = FileListFromComputeNodeOptions;

const JobScheduleExistsOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobScheduleExistsOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobScheduleExistsOptions"] = JobScheduleExistsOptions;

const JobScheduleDeleteMethodOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobScheduleDeleteMethodOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobScheduleDeleteMethodOptions"] = JobScheduleDeleteMethodOptions;

const JobScheduleGetOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobScheduleGetOptions',
        modelProperties: {
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            expand: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobScheduleGetOptions"] = JobScheduleGetOptions;

const JobSchedulePatchOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobSchedulePatchOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobSchedulePatchOptions"] = JobSchedulePatchOptions;

const JobScheduleUpdateOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobScheduleUpdateOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobScheduleUpdateOptions"] = JobScheduleUpdateOptions;

const JobScheduleDisableOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobScheduleDisableOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobScheduleDisableOptions"] = JobScheduleDisableOptions;

const JobScheduleEnableOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobScheduleEnableOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobScheduleEnableOptions"] = JobScheduleEnableOptions;

const JobScheduleTerminateOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobScheduleTerminateOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobScheduleTerminateOptions"] = JobScheduleTerminateOptions;

const JobScheduleAddOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobScheduleAddOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobScheduleAddOptions"] = JobScheduleAddOptions;

const JobScheduleListOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobScheduleListOptions',
        modelProperties: {
            filter: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            expand: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            maxResults: {
                required: false,
                defaultValue: 1000,
                type: {
                    name: 'Number'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobScheduleListOptions"] = JobScheduleListOptions;

const TaskAddOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'TaskAddOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["TaskAddOptions"] = TaskAddOptions;

const TaskListOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'TaskListOptions',
        modelProperties: {
            filter: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            expand: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            maxResults: {
                required: false,
                defaultValue: 1000,
                type: {
                    name: 'Number'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["TaskListOptions"] = TaskListOptions;

const TaskAddCollectionOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'TaskAddCollectionOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["TaskAddCollectionOptions"] = TaskAddCollectionOptions;

const TaskDeleteMethodOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'TaskDeleteMethodOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["TaskDeleteMethodOptions"] = TaskDeleteMethodOptions;

const TaskGetOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'TaskGetOptions',
        modelProperties: {
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            expand: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["TaskGetOptions"] = TaskGetOptions;

const TaskUpdateOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'TaskUpdateOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["TaskUpdateOptions"] = TaskUpdateOptions;

const TaskListSubtasksOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'TaskListSubtasksOptions',
        modelProperties: {
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["TaskListSubtasksOptions"] = TaskListSubtasksOptions;

const TaskTerminateOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'TaskTerminateOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["TaskTerminateOptions"] = TaskTerminateOptions;

const TaskReactivateOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'TaskReactivateOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifNoneMatch: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            ifModifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            },
            ifUnmodifiedSince: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["TaskReactivateOptions"] = TaskReactivateOptions;

const ComputeNodeAddUserOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ComputeNodeAddUserOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ComputeNodeAddUserOptions"] = ComputeNodeAddUserOptions;

const ComputeNodeDeleteUserOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ComputeNodeDeleteUserOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ComputeNodeDeleteUserOptions"] = ComputeNodeDeleteUserOptions;

const ComputeNodeUpdateUserOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ComputeNodeUpdateUserOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ComputeNodeUpdateUserOptions"] = ComputeNodeUpdateUserOptions;

const ComputeNodeGetOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ComputeNodeGetOptions',
        modelProperties: {
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ComputeNodeGetOptions"] = ComputeNodeGetOptions;

const ComputeNodeRebootOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ComputeNodeRebootOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ComputeNodeRebootOptions"] = ComputeNodeRebootOptions;

const ComputeNodeReimageOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ComputeNodeReimageOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ComputeNodeReimageOptions"] = ComputeNodeReimageOptions;

const ComputeNodeDisableSchedulingOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ComputeNodeDisableSchedulingOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ComputeNodeDisableSchedulingOptions"] = ComputeNodeDisableSchedulingOptions;

const ComputeNodeEnableSchedulingOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ComputeNodeEnableSchedulingOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ComputeNodeEnableSchedulingOptions"] = ComputeNodeEnableSchedulingOptions;

const ComputeNodeGetRemoteLoginSettingsOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ComputeNodeGetRemoteLoginSettingsOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ComputeNodeGetRemoteLoginSettingsOptions"] = ComputeNodeGetRemoteLoginSettingsOptions;

const ComputeNodeGetRemoteDesktopOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ComputeNodeGetRemoteDesktopOptions',
        modelProperties: {
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ComputeNodeGetRemoteDesktopOptions"] = ComputeNodeGetRemoteDesktopOptions;

const ComputeNodeListOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ComputeNodeListOptions',
        modelProperties: {
            filter: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            select: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            maxResults: {
                required: false,
                defaultValue: 1000,
                type: {
                    name: 'Number'
                }
            },
            timeout: {
                required: false,
                defaultValue: 30,
                type: {
                    name: 'Number'
                }
            },
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ComputeNodeListOptions"] = ComputeNodeListOptions;

const ApplicationListNextOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ApplicationListNextOptions',
        modelProperties: {
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ApplicationListNextOptions"] = ApplicationListNextOptions;

const PoolListUsageMetricsNextOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolListUsageMetricsNextOptions',
        modelProperties: {
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolListUsageMetricsNextOptions"] = PoolListUsageMetricsNextOptions;

const PoolListNextOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'PoolListNextOptions',
        modelProperties: {
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolListNextOptions"] = PoolListNextOptions;

const AccountListNodeAgentSkusNextOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'AccountListNodeAgentSkusNextOptions',
        modelProperties: {
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["AccountListNodeAgentSkusNextOptions"] = AccountListNodeAgentSkusNextOptions;

const JobListNextOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobListNextOptions',
        modelProperties: {
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobListNextOptions"] = JobListNextOptions;

const JobListFromJobScheduleNextOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobListFromJobScheduleNextOptions',
        modelProperties: {
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobListFromJobScheduleNextOptions"] = JobListFromJobScheduleNextOptions;

const JobListPreparationAndReleaseTaskStatusNextOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobListPreparationAndReleaseTaskStatusNextOptions',
        modelProperties: {
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobListPreparationAndReleaseTaskStatusNextOptions"] = JobListPreparationAndReleaseTaskStatusNextOptions;

const CertificateListNextOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'CertificateListNextOptions',
        modelProperties: {
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["CertificateListNextOptions"] = CertificateListNextOptions;

const FileListFromTaskNextOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'FileListFromTaskNextOptions',
        modelProperties: {
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["FileListFromTaskNextOptions"] = FileListFromTaskNextOptions;

const FileListFromComputeNodeNextOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'FileListFromComputeNodeNextOptions',
        modelProperties: {
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["FileListFromComputeNodeNextOptions"] = FileListFromComputeNodeNextOptions;

const JobScheduleListNextOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'JobScheduleListNextOptions',
        modelProperties: {
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["JobScheduleListNextOptions"] = JobScheduleListNextOptions;

const TaskListNextOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'TaskListNextOptions',
        modelProperties: {
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["TaskListNextOptions"] = TaskListNextOptions;

const ComputeNodeListNextOptions = {
    required: false,
    type: {
        name: 'Composite',
        className: 'ComputeNodeListNextOptions',
        modelProperties: {
            clientRequestId: {
                required: false,
                type: {
                    name: 'String'
                }
            },
            returnClientRequestId: {
                required: false,
                defaultValue: false,
                type: {
                    name: 'Boolean'
                }
            },
            ocpDate: {
                required: false,
                type: {
                    name: 'DateTimeRfc1123'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ComputeNodeListNextOptions"] = ComputeNodeListNextOptions;

const ApplicationListResult = {
    required: false,
    serializedName: 'ApplicationListResult',
    type: {
        name: 'Composite',
        className: 'ApplicationListResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ApplicationSummaryElementType',
                        type: {
                            name: 'Composite',
                            className: 'ApplicationSummary'
                        }
                    }
                }
            },
            odatanextLink: {
                required: false,
                serializedName: 'odata\\.nextLink',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ApplicationListResult"] = ApplicationListResult;

const PoolListUsageMetricsResult = {
    required: false,
    serializedName: 'PoolListUsageMetricsResult',
    type: {
        name: 'Composite',
        className: 'PoolListUsageMetricsResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'PoolUsageMetricsElementType',
                        type: {
                            name: 'Composite',
                            className: 'PoolUsageMetrics'
                        }
                    }
                }
            },
            odatanextLink: {
                required: false,
                serializedName: 'odata\\.nextLink',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["PoolListUsageMetricsResult"] = PoolListUsageMetricsResult;

const CloudPoolListResult = {
    required: false,
    serializedName: 'CloudPoolListResult',
    type: {
        name: 'Composite',
        className: 'CloudPoolListResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'CloudPoolElementType',
                        type: {
                            name: 'Composite',
                            className: 'CloudPool'
                        }
                    }
                }
            },
            odatanextLink: {
                required: false,
                serializedName: 'odata\\.nextLink',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["CloudPoolListResult"] = CloudPoolListResult;

const AccountListNodeAgentSkusResult = {
    required: false,
    serializedName: 'AccountListNodeAgentSkusResult',
    type: {
        name: 'Composite',
        className: 'AccountListNodeAgentSkusResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'NodeAgentSkuElementType',
                        type: {
                            name: 'Composite',
                            className: 'NodeAgentSku'
                        }
                    }
                }
            },
            odatanextLink: {
                required: false,
                serializedName: 'odata\\.nextLink',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["AccountListNodeAgentSkusResult"] = AccountListNodeAgentSkusResult;

const CloudJobListResult = {
    required: false,
    serializedName: 'CloudJobListResult',
    type: {
        name: 'Composite',
        className: 'CloudJobListResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'CloudJobElementType',
                        type: {
                            name: 'Composite',
                            className: 'CloudJob'
                        }
                    }
                }
            },
            odatanextLink: {
                required: false,
                serializedName: 'odata\\.nextLink',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["CloudJobListResult"] = CloudJobListResult;

const CloudJobListPreparationAndReleaseTaskStatusResult = {
    required: false,
    serializedName: 'CloudJobListPreparationAndReleaseTaskStatusResult',
    type: {
        name: 'Composite',
        className: 'CloudJobListPreparationAndReleaseTaskStatusResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'JobPreparationAndReleaseTaskExecutionInformationElementType',
                        type: {
                            name: 'Composite',
                            className: 'JobPreparationAndReleaseTaskExecutionInformation'
                        }
                    }
                }
            },
            odatanextLink: {
                required: false,
                serializedName: 'odata\\.nextLink',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["CloudJobListPreparationAndReleaseTaskStatusResult"] = CloudJobListPreparationAndReleaseTaskStatusResult;

const CertificateListResult = {
    required: false,
    serializedName: 'CertificateListResult',
    type: {
        name: 'Composite',
        className: 'CertificateListResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'CertificateElementType',
                        type: {
                            name: 'Composite',
                            className: 'Certificate'
                        }
                    }
                }
            },
            odatanextLink: {
                required: false,
                serializedName: 'odata\\.nextLink',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["CertificateListResult"] = CertificateListResult;

const NodeFileListResult = {
    required: false,
    serializedName: 'NodeFileListResult',
    type: {
        name: 'Composite',
        className: 'NodeFileListResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'NodeFileElementType',
                        type: {
                            name: 'Composite',
                            className: 'NodeFile'
                        }
                    }
                }
            },
            odatanextLink: {
                required: false,
                serializedName: 'odata\\.nextLink',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["NodeFileListResult"] = NodeFileListResult;

const CloudJobScheduleListResult = {
    required: false,
    serializedName: 'CloudJobScheduleListResult',
    type: {
        name: 'Composite',
        className: 'CloudJobScheduleListResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'CloudJobScheduleElementType',
                        type: {
                            name: 'Composite',
                            className: 'CloudJobSchedule'
                        }
                    }
                }
            },
            odatanextLink: {
                required: false,
                serializedName: 'odata\\.nextLink',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["CloudJobScheduleListResult"] = CloudJobScheduleListResult;

const CloudTaskListResult = {
    required: false,
    serializedName: 'CloudTaskListResult',
    type: {
        name: 'Composite',
        className: 'CloudTaskListResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'CloudTaskElementType',
                        type: {
                            name: 'Composite',
                            className: 'CloudTask'
                        }
                    }
                }
            },
            odatanextLink: {
                required: false,
                serializedName: 'odata\\.nextLink',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["CloudTaskListResult"] = CloudTaskListResult;

const ComputeNodeListResult = {
    required: false,
    serializedName: 'ComputeNodeListResult',
    type: {
        name: 'Composite',
        className: 'ComputeNodeListResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ComputeNodeElementType',
                        type: {
                            name: 'Composite',
                            className: 'ComputeNode'
                        }
                    }
                }
            },
            odatanextLink: {
                required: false,
                serializedName: 'odata\\.nextLink',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["ComputeNodeListResult"] = ComputeNodeListResult;



/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const uuid = __webpack_require__(24);
const FormData = __webpack_require__(27);
const webResource_1 = __webpack_require__(5);
const constants_1 = __webpack_require__(4);
const restError_1 = __webpack_require__(12);
const httpOperationResponse_1 = __webpack_require__(13);
const fPF = __webpack_require__(28)({ useCookie: true });
/**
 * Checks if a parsed URL is HTTPS
 *
 * @param {object} urlToCheck The url to check
 * @return {boolean} True if the URL is HTTPS; false otherwise.
 */
function urlIsHTTPS(urlToCheck) {
    return urlToCheck.protocol.toLowerCase() === constants_1.Constants.HTTPS;
}
exports.urlIsHTTPS = urlIsHTTPS;
;
/**
 * Checks if a value is null or undefined.
 *
 * @param {object} value The value to check for null or undefined.
 * @return {boolean} True if the value is null or undefined, false otherwise.
 */
// TODO: Audit the usages of this and remove them.
// Read: https://medium.com/@basarat/null-vs-undefined-in-typescript-land-dc0c7a5f240a
// https://github.com/Microsoft/TypeScript/issues/7426
function objectIsNull(value) {
    return value === null || value === undefined;
}
exports.objectIsNull = objectIsNull;
;
/**
 * Encodes an URI.
 *
 * @param {string} uri The URI to be encoded.
 * @return {string} The encoded URI.
 */
function encodeUri(uri) {
    return encodeURIComponent(uri)
        .replace(/!/g, '%21')
        .replace(/'/g, '%27')
        .replace(/\(/g, '%28')
        .replace(/\)/g, '%29')
        .replace(/\*/g, '%2A');
}
exports.encodeUri = encodeUri;
;
/**
 * Returns a stripped version of the Http Response which only contains body,
 * headers and the status.
 *
 * @param {nodeFetch.Response} response - The Http Response
 *
 * @return {object} strippedResponse - The stripped version of Http Response.
 */
function stripResponse(response) {
    const strippedResponse = {};
    strippedResponse.body = response.body;
    strippedResponse.headers = response.headers;
    strippedResponse.status = response.status;
    return strippedResponse;
}
exports.stripResponse = stripResponse;
/**
 * Returns a stripped version of the Http Request that does not contain the
 * Authorization header.
 *
 * @param {object} request - The Http Request object
 *
 * @return {object} strippedRequest - The stripped version of Http Request.
 */
function stripRequest(request) {
    let strippedRequest = new webResource_1.WebResource();
    try {
        strippedRequest = JSON.parse(JSON.stringify(request));
        if (strippedRequest.headers && strippedRequest.headers.Authorization) {
            delete strippedRequest.headers.Authorization;
        }
        else if (strippedRequest.headers && strippedRequest.headers.authorization) {
            delete strippedRequest.headers.authorization;
        }
    }
    catch (err) {
        const errMsg = err.message;
        err.message = `Error - '${errMsg}' occured while creating a stripped version of the request object - '${request}'.`;
        return err;
    }
    return strippedRequest;
}
exports.stripRequest = stripRequest;
/**
 * Validates the given uuid as a string
 *
 * @param {string} uuid - The uuid as a string that needs to be validated
 *
 * @return {boolean} result - True if the uuid is valid; false otherwise.
 */
function isValidUuid(uuid) {
    const validUuidRegex = new RegExp('^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$', 'ig');
    return validUuidRegex.test(uuid);
}
exports.isValidUuid = isValidUuid;
/**
 * Provides an array of values of an object. For example
 * for a given object { 'a': 'foo', 'b': 'bar' }, the method returns ['foo', 'bar'].
 *
 * @param {object} obj - An object whose properties need to be enumerated so that it's values can be provided as an array
 *
 * @return {array} result - An array of values of the given object.
 */
function objectValues(obj) {
    const result = [];
    if (obj && obj instanceof Object) {
        for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
                result.push(obj[key]);
            }
        }
    }
    else {
        throw new Error(`The provided object ${JSON.stringify(obj, null, 2)} is not a valid object that can be ` +
            `enumerated to provide its values as an array.`);
    }
    return result;
}
exports.objectValues = objectValues;
/**
 * Generated UUID
 *
 * @return {string} RFC4122 v4 UUID.
 */
function generateUuid() {
    return uuid.v4();
}
exports.generateUuid = generateUuid;
/*
 * Executes an array of promises sequentially. Inspiration of this method is here:
 * https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html. An awesome blog on promises!
 *
 * @param {Array} promiseFactories An array of promise factories(A function that return a promise)
 *
 * @param {any} [kickstart] Input to the first promise that is used to kickstart the promise chain.
 * If not provided then the promise chain starts with undefined.
 *
 * @return A chain of resolved or rejected promises
 */
function executePromisesSequentially(promiseFactories, kickstart) {
    let result = Promise.resolve(kickstart);
    promiseFactories.forEach((promiseFactory) => {
        result = result.then(promiseFactory);
    });
    return result;
}
exports.executePromisesSequentially = executePromisesSequentially;
;
/*
 * Merges source object into the target object
 * @param {object} source The object that needs to be merged
 *
 * @param {object} target The object to be merged into
 *
 * @returns {object} target - Returns the merged target object.
 */
function mergeObjects(source, target) {
    Object.keys(source).forEach((key) => {
        target[key] = source[key];
    });
    return target;
}
exports.mergeObjects = mergeObjects;
/**
 * A wrapper for setTimeout that resolves a promise after t milliseconds.
 * @param {number} t - The number of milliseconds to be delayed.
 * @param {T} value - The value to be resolved with after a timeout of t milliseconds.
 * @returns {Promise<T>} - Resolved promise
 */
function delay(t, value) {
    return new Promise((resolve) => setTimeout(() => resolve(value), t));
}
exports.delay = delay;
/**
 * Utility function to create a K:V from a list of strings
 */
function strEnum(o) {
    return o.reduce((res, key) => {
        res[key] = key;
        return res;
    }, Object.create(null)); // TODO: Audit usage of null.
}
exports.strEnum = strEnum;
/**
 * Converts a Promise to a callback.
 * @param {Promise<any>} promise - The Promise to be converted to a callback
 * @returns {Function} fn - A function that takes the callback (cb: Function): void
 */
function promiseToCallback(promise) {
    if (typeof promise.then !== 'function') {
        throw new Error('The provided input is not a Promise.');
    }
    return (cb) => {
        promise.then((data) => {
            process.nextTick(cb, null, data);
        }, (err) => {
            process.nextTick(cb, err);
        });
    };
}
exports.promiseToCallback = promiseToCallback;
/**
 * Converts a Promise to a service callback.
 * @param {Promise<HttpOperationResponse>} promise - The Promise of HttpOperationResponse to be converted to a service callback
 * @returns {Function} fn - A function that takes the service callback (cb: ServiceCallback<T>): void
 */
function promiseToServiceCallback(promise) {
    if (typeof promise.then !== 'function') {
        throw new Error('The provided input is not a Promise.');
    }
    return (cb) => {
        promise.then((data) => {
            process.nextTick(cb, null, data.bodyAsJson, data.request, data.response);
        }, (err) => {
            process.nextTick(cb, err);
        });
    };
}
exports.promiseToServiceCallback = promiseToServiceCallback;
/**
 * Sends the request and returns the received response.
 * @param {WebResource} options - The request to be sent.
 * @returns {Promise<HttpOperationResponse} operationResponse - The response object.
 */
function dispatchRequest(options) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!options) {
            return Promise.reject(new Error('options (WebResource) cannot be null or undefined and must be of type object.'));
        }
        if (options.formData) {
            const formData = options.formData;
            const requestForm = new FormData();
            const appendFormValue = (key, value) => {
                if (value && value.hasOwnProperty('value') && value.hasOwnProperty('options')) {
                    requestForm.append(key, value.value, value.options);
                }
                else {
                    requestForm.append(key, value);
                }
            };
            for (const formKey in formData) {
                if (formData.hasOwnProperty(formKey)) {
                    const formValue = formData[formKey];
                    if (formValue instanceof Array) {
                        for (let j = 0; j < formValue.length; j++) {
                            appendFormValue(formKey, formValue[j]);
                        }
                    }
                    else {
                        appendFormValue(formKey, formValue);
                    }
                }
            }
            options.body = requestForm;
            options.formData = undefined;
            if (options.headers && options.headers['Content-Type'] &&
                options.headers['Content-Type'].indexOf('multipart/form-data') > -1 && typeof requestForm.getBoundary === 'function') {
                options.headers['Content-Type'] = `multipart/form-data; boundary=${requestForm.getBoundary()}`;
            }
        }
        let res;
        try {
            res = yield fPF.fetch(options.url, options);
        }
        catch (err) {
            return Promise.reject(err);
        }
        const operationResponse = new httpOperationResponse_1.HttpOperationResponse(options, res, res.body);
        if (!options.rawResponse) {
            try {
                operationResponse.bodyAsText = yield res.text();
            }
            catch (err) {
                let msg = `Error "${err}" occured while converting the raw response body into string.`;
                let errCode = err.code || 'RAWTEXT_CONVERSION_ERROR';
                let e = new restError_1.RestError(msg, errCode, res.status, options, res, res.body);
                return Promise.reject(e);
            }
            try {
                if (operationResponse.bodyAsText) {
                    operationResponse.bodyAsJson = JSON.parse(operationResponse.bodyAsText);
                }
            }
            catch (err) {
                let msg = `Error "${err}" occured while executing JSON.parse on the response body - ${operationResponse.bodyAsText}.`;
                let errCode = err.code || 'JSON_PARSE_ERROR';
                let e = new restError_1.RestError(msg, errCode, res.status, options, res, operationResponse.bodyAsText);
                return Promise.reject(e);
            }
        }
        return Promise.resolve(operationResponse);
    });
}
exports.dispatchRequest = dispatchRequest;
//# sourceMappingURL=utils.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
class BaseFilter {
    constructor() { }
    before(request) {
        return Promise.resolve(request);
    }
    after(response) {
        return Promise.resolve(response);
    }
}
exports.BaseFilter = BaseFilter;
//# sourceMappingURL=baseFilter.js.map

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Constants = {
    /**
     * The ms-rest version
     * @const
     * @type {string}
     */
    msRestVersion: '3.0.0',
    /**
     * Specifies HTTP.
     *
     * @const
     * @type {string}
     */
    HTTP: 'http:',
    /**
     * Specifies HTTPS.
     *
     * @const
     * @type {string}
     */
    HTTPS: 'https:',
    /**
     * Specifies HTTP Proxy.
     *
     * @const
     * @type {string}
     */
    HTTP_PROXY: 'HTTP_PROXY',
    /**
     * Specifies HTTPS Proxy.
     *
     * @const
     * @type {string}
     */
    HTTPS_PROXY: 'HTTPS_PROXY',
    HttpConstants: {
        /**
         * Http Verbs
         *
         * @const
         * @enum {string}
         */
        HttpVerbs: {
            PUT: 'PUT',
            GET: 'GET',
            DELETE: 'DELETE',
            POST: 'POST',
            MERGE: 'MERGE',
            HEAD: 'HEAD',
            PATCH: 'PATCH'
        },
    },
    /**
     * Defines constants for use with HTTP headers.
     */
    HeaderConstants: {
        /**
         * The Authorization header.
         *
         * @const
         * @type {string}
         */
        AUTHORIZATION: 'authorization',
        AUTHORIZATION_SCHEME: 'Bearer',
        /**
         * The UserAgent header.
         *
         * @const
         * @type {string}
         */
        USER_AGENT: 'User-Agent'
    }
};
//# sourceMappingURL=constants.js.map

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = __webpack_require__(2);
/**
 * Creates a new WebResource object.
 *
 * This class provides an abstraction over a REST call by being library / implementation agnostic and wrapping the necessary
 * properties to initiate a request.
 *
 * @constructor
 */
class WebResource {
    constructor(url, method, body, query, headers = {}, rawResponse = false) {
        this.headers = {};
        this.rawResponse = rawResponse;
        this.url = url || "";
        this.method = method || "GET";
        this.headers = headers || {};
        this.body = body;
        this.query = query;
        this.formData = undefined;
    }
    /**
     * Validates that the required properties such as method, url, headers['Content-Type'],
     * headers['accept-language'] are defined. It will throw an error if one of the above
     * mentioned properties are not defined.
     */
    validateRequestProperties() {
        if (!this.method || !this.url || !this.headers['Content-Type'] || !this.headers['accept-language']) {
            throw new Error('method, url, headers[\'Content-Type\'], headers[\'accept-language\'] are ' +
                'required properties before making a request. Either provide them or use WebResource.prepare() method.');
        }
        return;
    }
    /**
     * Prepares the request.
     * @param {RequestPrepareOptions} options - Options to provide for preparing the request.
     * @returns {object} WebResource Returns the prepared WebResource (HTTP Request) object that needs to be given to the request pipeline.
     */
    prepare(options) {
        if (options === null || options === undefined || typeof options !== 'object') {
            throw new Error('options cannot be null or undefined and must be of type object');
        }
        if (options.method === null || options.method === undefined || typeof options.method.valueOf() !== 'string') {
            throw new Error('options.method cannot be null or undefined and it must be of type string.');
        }
        if (options.url && options.pathTemplate) {
            throw new Error('options.url and options.pathTemplate are mutually exclusive. Please provide either of them.');
        }
        if ((options.pathTemplate === null || options.pathTemplate === undefined || typeof options.pathTemplate.valueOf() !== 'string') && (options.url === null || options.url === undefined || typeof options.url.valueOf() !== 'string')) {
            throw new Error('Please provide either options.pathTemplate or options.url. Currently none of them were provided.');
        }
        // set the url if it is provided.
        if (options.url) {
            if (typeof options.url !== 'string') {
                throw new Error('options.url must be of type \'string\'.');
            }
            this.url = options.url;
        }
        // set the method
        if (options.method) {
            const validMethods = ['GET', 'PUT', 'HEAD', 'DELETE', 'OPTIONS', 'POST', 'PATCH', 'TRACE'];
            if (validMethods.indexOf(options.method.toUpperCase()) === -1) {
                throw new Error('The provided method \'' + options.method + '\' is invalid. Supported HTTP methods are: ' + JSON.stringify(validMethods));
            }
        }
        this.method = options.method.toUpperCase();
        // construct the url if path template is provided
        if (options.pathTemplate) {
            if (typeof options.pathTemplate !== 'string') {
                throw new Error('options.pathTemplate must be of type \'string\'.');
            }
            if (!options.baseUrl) {
                options.baseUrl = 'https://management.azure.com';
            }
            const baseUrl = options.baseUrl;
            let url = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + (options.pathTemplate.startsWith('/') ? options.pathTemplate.slice(1) : options.pathTemplate);
            const segments = url.match(/({\w*\s*\w*})/ig);
            if (segments && segments.length) {
                if (options.pathParameters === null || options.pathParameters === undefined || typeof options.pathParameters !== 'object') {
                    throw new Error(`pathTemplate: ${options.pathTemplate} has been provided. Hence, options.pathParameters ` +
                        `cannot be null or undefined and must be of type "object".`);
                }
                segments.forEach(function (item) {
                    const pathParamName = item.slice(1, -1);
                    const pathParam = options.pathParameters[pathParamName];
                    if (pathParam === null || pathParam === undefined || !(typeof pathParam === 'string' || typeof pathParam === 'object')) {
                        throw new Error(`pathTemplate: ${options.pathTemplate} contains the path parameter ${pathParamName}` +
                            ` however, it is not present in ${options.pathParameters} - ${JSON.stringify(options.pathParameters, null, 2)}.` +
                            `The value of the path parameter can either be a "string" of the form { ${pathParamName}: "some sample value" } or ` +
                            `it can be an "object" of the form { "${pathParamName}": { value: "some sample value", skipUrlEncoding: true } }.`);
                    }
                    if (typeof pathParam.valueOf() === 'string') {
                        url = url.replace(item, encodeURIComponent(pathParam));
                    }
                    if (typeof pathParam.valueOf() === 'object') {
                        if (!pathParam.value) {
                            throw new Error(`options.pathParameters[${pathParamName}] is of type "object" but it does not contain a "value" property.`);
                        }
                        if (pathParam.skipUrlEncoding) {
                            url = url.replace(item, pathParam.value);
                        }
                        else {
                            url = url.replace(item, encodeURIComponent(pathParam.value));
                        }
                    }
                });
            }
            this.url = url;
        }
        // append query parameters to the url if they are provided. They can be provided with pathTemplate or url option.
        if (options.queryParameters) {
            if (typeof options.queryParameters !== 'object') {
                throw new Error(`options.queryParameters must be of type object. It should be a JSON object ` +
                    `of "query-parameter-name" as the key and the "query-parameter-value" as the value. ` +
                    `The "query-parameter-value" may be fo type "string" or an "object" of the form { value: "query-parameter-value", skipUrlEncoding: true }.`);
            }
            // append question mark if it is not present in the url
            if (this.url && this.url.indexOf('?') === -1) {
                this.url += '?';
            }
            // construct queryString
            const queryParams = [];
            const queryParameters = options.queryParameters;
            // We need to populate this.query as a dictionary if the request is being used for Sway's validateRequest().
            this.query = {};
            for (const queryParamName in queryParameters) {
                const queryParam = queryParameters[queryParamName];
                if (queryParam) {
                    if (typeof queryParam === 'string') {
                        queryParams.push(queryParamName + '=' + encodeURIComponent(queryParam));
                        this.query[queryParamName] = encodeURIComponent(queryParam);
                    }
                    else if (typeof queryParam === 'object') {
                        if (!queryParam.value) {
                            throw new Error(`options.queryParameters[${queryParamName}] is of type "object" but it does not contain a "value" property.`);
                        }
                        if (queryParam.skipUrlEncoding) {
                            queryParams.push(queryParamName + '=' + queryParam.value);
                            this.query[queryParamName] = queryParam.value;
                        }
                        else {
                            queryParams.push(queryParamName + '=' + encodeURIComponent(queryParam.value));
                            this.query[queryParamName] = encodeURIComponent(queryParam.value);
                        }
                    }
                }
            } // end-of-for
            // append the queryString
            this.url += queryParams.join('&');
        }
        // add headers to the request if they are provided
        if (options.headers) {
            const headers = options.headers;
            for (const headerName in headers) {
                if (headers.hasOwnProperty(headerName)) {
                    this.headers[headerName] = headers[headerName];
                }
            }
        }
        // ensure accept-language is set correctly
        if (!this.headers['accept-language']) {
            this.headers['accept-language'] = 'en-US';
        }
        // ensure the request-id is set correctly
        if (!this.headers['x-ms-client-request-id'] && !options.disableClientRequestId) {
            this.headers['x-ms-client-request-id'] = utils_1.generateUuid();
        }
        // default
        if (!this.headers['Content-Type']) {
            this.headers['Content-Type'] = 'application/json; charset=utf-8';
        }
        // set the request body. request.js automatically sets the Content-Length request header, so we need not set it explicilty
        this.body = null;
        if (options.body !== null && options.body !== undefined) {
            // body as a stream special case. set the body as-is and check for some special request headers specific to sending a stream.
            if (options.bodyIsStream) {
                this.body = options.body;
                if (!this.headers['Transfer-Encoding']) {
                    this.headers['Transfer-Encoding'] = 'chunked';
                }
                if (this.headers['Content-Type'] !== 'application/octet-stream') {
                    this.headers['Content-Type'] = 'application/octet-stream';
                }
            }
            else {
                // TODO: BUG. we assign this to null and start using it without ever assigning a real value to it.
                let serializedBody = null;
                // if (options.serializationMapper) {
                //   serializedBody = serializer.serialize(options.serializationMapper, options.body, 'requestBody');
                // }
                if (options.disableJsonStringifyOnBody) {
                    this.body = serializedBody || options.body;
                }
                else {
                    this.body = serializedBody ? JSON.stringify(serializedBody) : JSON.stringify(options.body);
                }
            }
        }
        return this;
    }
}
exports.WebResource = WebResource;
//# sourceMappingURL=webResource.js.map

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const Constants = {
    /**
    * Defines constants for long running operation states.
    *
    * @const
    * @type {string}
    */
    LongRunningOperationStates: {
        InProgress: 'InProgress',
        Succeeded: 'Succeeded',
        Failed: 'Failed',
        Canceled: 'Canceled'
    },
    /**
     * The default language in the request header.
     *
     * @const
     * @type {string}
     */
    DEFAULT_LANGUAGE: 'en-us',
    /**
     * The ms-rest-azure version.
     * @const
     * @type {string}
     */
    msRestAzureVersion: '3.0.0'
};
exports.default = Constants;
//# sourceMappingURL=constants.js.map

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const azureServiceClient_1 = __webpack_require__(23);
exports.AzureServiceClient = azureServiceClient_1.AzureServiceClient;
const constants_1 = __webpack_require__(6);
exports.Constants = constants_1.default;
const cloudError_1 = __webpack_require__(42);
exports.CloudErrorMapper = cloudError_1.CloudErrorMapper;
const baseResource_1 = __webpack_require__(43);
exports.BaseResourceMapper = baseResource_1.BaseResourceMapper;
//# sourceMappingURL=msRestAzure.js.map

/***/ }),
/* 8 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection
var rng;

var crypto = global.crypto || global.msCrypto; // for IE 11
if (crypto && crypto.getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef
  rng = function whatwgRNG() {
    crypto.getRandomValues(rnds8);
    return rnds8;
  };
}

if (!rng) {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);
  rng = function() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

module.exports = rng;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 10 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 11 */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  return bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]];
}

module.exports = bytesToUuid;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information. 
Object.defineProperty(exports, "__esModule", { value: true });
class RestError extends Error {
    constructor(message, code, statusCode, request, response, body) {
        super(message);
        this.code = code;
        this.statusCode = statusCode;
        this.request = request;
        this.response = response;
        this.body = body;
    }
}
exports.RestError = RestError;
//# sourceMappingURL=restError.js.map

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Wrapper object for http request and response. Deserialized object is stored in
 * the `body` property.
 * @class
 * Initializes a new instance of the HttpOperationResponse class.
 * @constructor
 */
class HttpOperationResponse {
    constructor(request, response, body) {
        /**
         * Reference to the original request object.
         * [WebResource] object.
         * @type {object}
         */
        this.request = request;
        /**
         * Reference to the original response object.
         * [ServerResponse] object.
         * @type {object}
         */
        this.response = response;
        /**
         * The response object.
         * @type {object}
         */
        this.bodyAsStream = body;
        this.bodyAsText = null;
        this.bodyAsJson = null;
    }
}
exports.HttpOperationResponse = HttpOperationResponse;
//# sourceMappingURL=httpOperationResponse.js.map

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const utils = __webpack_require__(2);
class RequestPipeline {
    constructor(filters, requestOptions) {
        this.filters = filters || [];
        this.requestOptions = requestOptions || {};
    }
    addFilter(f) {
        this.filters.push(f);
        return;
    }
    create() {
        const self = this;
        let pipeline = [];
        if (self.filters && self.filters.length) {
            const beforeFilters = [];
            const afterFilters = [];
            for (let i = 0; i < self.filters.length; i++) {
                const filter = self.filters[i];
                if (filter.before && typeof filter.before === 'function') {
                    beforeFilters.push(filter.before.bind(filter));
                }
                if (filter.after && typeof filter.after === 'function') {
                    afterFilters.push(filter.after.bind(filter));
                }
            } // end-of-for-loop
            // add the request sink
            beforeFilters.push(self.requestSink.bind(self));
            pipeline = beforeFilters.concat(afterFilters);
        }
        else {
            pipeline.push(self.requestSink.bind(self));
        }
        let requestFun = (request) => {
            if (!request.headers)
                request.headers = {};
            return utils.executePromisesSequentially(pipeline, request);
        };
        return requestFun;
    }
    requestSink(options) {
        if (this.requestOptions.method)
            delete this.requestOptions.method;
        return utils.dispatchRequest(options);
    }
}
exports.RequestPipeline = RequestPipeline;
//# sourceMappingURL=requestPipeline.js.map

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const baseFilter_1 = __webpack_require__(3);
const utils = __webpack_require__(2);
/**
 * @class
 * Instantiates a new 'ExponentialRetryPolicyFilter' instance.
 *
 * @constructor
 * @param {number} retryCount        The client retry count.
 * @param {number} retryInterval     The client retry interval, in milliseconds.
 * @param {number} minRetryInterval  The minimum retry interval, in milliseconds.
 * @param {number} maxRetryInterval  The maximum retry interval, in milliseconds.
 */
class ExponentialRetryPolicyFilter extends baseFilter_1.BaseFilter {
    constructor(retryCount, retryInterval, minRetryInterval, maxRetryInterval) {
        super();
        this.DEFAULT_CLIENT_RETRY_INTERVAL = 1000 * 30;
        this.DEFAULT_CLIENT_RETRY_COUNT = 3;
        this.DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 90;
        this.DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 1000 * 3;
        this.retryCount = typeof retryCount === 'number' ? retryCount : this.DEFAULT_CLIENT_RETRY_COUNT;
        this.retryInterval = typeof retryInterval === 'number' ? retryInterval : this.DEFAULT_CLIENT_RETRY_INTERVAL;
        this.minRetryInterval = typeof minRetryInterval === 'number' ? minRetryInterval : this.DEFAULT_CLIENT_MIN_RETRY_INTERVAL;
        this.maxRetryInterval = typeof maxRetryInterval === 'number' ? maxRetryInterval : this.DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
    }
    /**
     * Determines if the operation should be retried and how long to wait until the next retry.
     *
     * @param {number} statusCode The HTTP status code.
     * @param {RetryData} retryData  The retry data.
     * @return {boolean} True if the operation qualifies for a retry; false otherwise.
     */
    shouldRetry(statusCode, retryData) {
        if ((statusCode < 500 && statusCode !== 408) || statusCode === 501 || statusCode === 505) {
            return false;
        }
        let currentCount;
        if (!retryData) {
            throw new Error('retryData for the ExponentialRetryPolicyFilter cannot be null.');
        }
        else {
            currentCount = (retryData && retryData.retryCount);
        }
        return (currentCount < this.retryCount);
    }
    /**
     * Updates the retry data for the next attempt.
     *
     * @param {RetryData} retryData  The retry data.
     * @param {object} err        The operation's error, if any.
     */
    updateRetryData(retryData, err) {
        if (!retryData) {
            retryData = {
                retryCount: 0,
                retryInterval: 0
            };
        }
        if (err) {
            if (retryData.error) {
                err.innerError = retryData.error;
            }
            retryData.error = err;
        }
        // Adjust retry count
        retryData.retryCount++;
        // Adjust retry interval
        let incrementDelta = Math.pow(2, retryData.retryCount) - 1;
        const boundedRandDelta = this.retryInterval * 0.8 +
            Math.floor(Math.random() * (this.retryInterval * 1.2 - this.retryInterval * 0.8));
        incrementDelta *= boundedRandDelta;
        retryData.retryInterval = Math.min(this.minRetryInterval + incrementDelta, this.maxRetryInterval);
        return retryData;
    }
    retry(operationResponse, retryData, err) {
        return __awaiter(this, void 0, void 0, function* () {
            const self = this;
            const response = operationResponse.response;
            retryData = self.updateRetryData(retryData, err);
            if (!utils.objectIsNull(response) && self.shouldRetry(response.status, retryData)) {
                try {
                    yield utils.delay(retryData.retryInterval);
                    let res = yield utils.dispatchRequest(operationResponse.request);
                    return self.retry(res, retryData, err);
                }
                catch (err) {
                    return self.retry(operationResponse, retryData, err);
                }
            }
            else {
                if (!utils.objectIsNull(err)) {
                    // If the operation failed in the end, return all errors instead of just the last one
                    err = retryData.error;
                    return Promise.reject(err);
                }
                return Promise.resolve(operationResponse);
            }
        });
    }
    after(operationResponse) {
        return this.retry(operationResponse);
    }
}
exports.ExponentialRetryPolicyFilter = ExponentialRetryPolicyFilter;
//# sourceMappingURL=exponentialRetryPolicyFilter.js.map

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const baseFilter_1 = __webpack_require__(3);
const utils = __webpack_require__(2);
/**
 * @class
 * Instantiates a new 'ExponentialRetryPolicyFilter' instance.
 *
 * @constructor
 * @param {number} retryCount        The client retry count.
 * @param {number} retryInterval     The client retry interval, in milliseconds.
 * @param {number} minRetryInterval  The minimum retry interval, in milliseconds.
 * @param {number} maxRetryInterval  The maximum retry interval, in milliseconds.
 */
class SystemErrorRetryPolicyFilter extends baseFilter_1.BaseFilter {
    constructor(retryCount, retryInterval, minRetryInterval, maxRetryInterval) {
        super();
        this.DEFAULT_CLIENT_RETRY_INTERVAL = 1000 * 30;
        this.DEFAULT_CLIENT_RETRY_COUNT = 3;
        this.DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 90;
        this.DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 1000 * 3;
        this.retryCount = typeof retryCount === 'number' ? retryCount : this.DEFAULT_CLIENT_RETRY_COUNT;
        this.retryInterval = typeof retryInterval === 'number' ? retryInterval : this.DEFAULT_CLIENT_RETRY_INTERVAL;
        this.minRetryInterval = typeof minRetryInterval === 'number' ? minRetryInterval : this.DEFAULT_CLIENT_MIN_RETRY_INTERVAL;
        this.maxRetryInterval = typeof maxRetryInterval === 'number' ? maxRetryInterval : this.DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
    }
    /**
     * Determines if the operation should be retried and how long to wait until the next retry.
     *
     * @param {number} statusCode The HTTP status code.
     * @param {RetryData} retryData  The retry data.
     * @return {boolean} True if the operation qualifies for a retry; false otherwise.
     */
    shouldRetry(retryData) {
        let currentCount;
        if (!retryData) {
            throw new Error('retryData for the SystemErrorRetryPolicyFilter cannot be null.');
        }
        else {
            currentCount = (retryData && retryData.retryCount);
        }
        return (currentCount < this.retryCount);
    }
    /**
     * Updates the retry data for the next attempt.
     *
     * @param {RetryData} retryData  The retry data.
     * @param {object} err        The operation's error, if any.
     */
    updateRetryData(retryData, err) {
        if (!retryData) {
            retryData = {
                retryCount: 0,
                retryInterval: 0
            };
        }
        if (err) {
            if (retryData.error) {
                err.innerError = retryData.error;
            }
            retryData.error = err;
        }
        // Adjust retry count
        retryData.retryCount++;
        // Adjust retry interval
        let incrementDelta = Math.pow(2, retryData.retryCount) - 1;
        const boundedRandDelta = this.retryInterval * 0.8 +
            Math.floor(Math.random() * (this.retryInterval * 1.2 - this.retryInterval * 0.8));
        incrementDelta *= boundedRandDelta;
        retryData.retryInterval = Math.min(this.minRetryInterval + incrementDelta, this.maxRetryInterval);
        return retryData;
    }
    retry(operationResponse, retryData, err) {
        return __awaiter(this, void 0, void 0, function* () {
            const self = this;
            retryData = self.updateRetryData(retryData, err);
            if (err && err.code && self.shouldRetry(retryData) &&
                (err.code === 'ETIMEDOUT' || err.code === 'ESOCKETTIMEDOUT' || err.code === 'ECONNREFUSED' ||
                    err.code === 'ECONNRESET' || err.code === 'ENOENT')) {
                // If previous operation ended with an error and the policy allows a retry, do that
                try {
                    yield utils.delay(retryData.retryInterval);
                    let res = yield utils.dispatchRequest(operationResponse.request);
                    return self.retry(res, retryData, err);
                }
                catch (err) {
                    return self.retry(operationResponse, retryData, err);
                }
            }
            else {
                if (!utils.objectIsNull(err)) {
                    // If the operation failed in the end, return all errors instead of just the last one
                    err = retryData.error;
                    return Promise.reject(err);
                }
                return Promise.resolve(operationResponse);
            }
        });
    }
    after(operationResponse) {
        return this.retry(operationResponse); //See: https://github.com/Microsoft/TypeScript/issues/7426
    }
}
exports.SystemErrorRetryPolicyFilter = SystemErrorRetryPolicyFilter;
//# sourceMappingURL=systemErrorRetryPolicyFilter.js.map

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
const baseFilter_1 = __webpack_require__(3);
const utils = __webpack_require__(2);
const parse = __webpack_require__(30);
class RedirectFilter extends baseFilter_1.BaseFilter {
    constructor(maximumRetries = 20) {
        super();
        this.maximumRetries = maximumRetries;
    }
    handleRedirect(operationResponse, currentRetries) {
        return __awaiter(this, void 0, void 0, function* () {
            let request = operationResponse.request;
            let response = operationResponse.response;
            if (response && response.headers && response.headers.get('location') &&
                (response.status === 300 || response.status === 307 || (response.status === 303 && request.method === 'POST')) &&
                (!this.maximumRetries || currentRetries < this.maximumRetries)) {
                if (parse(response.headers.get('location')).hostname) {
                    request.url = response.headers.get('location');
                }
                else {
                    let urlObject = parse(request.url);
                    urlObject.set('pathname', response.headers.get('location'));
                    request.url = urlObject.href;
                }
                // POST request with Status code 303 should be converted into a 
                // redirected GET request if the redirect url is present in the location header
                if (response.status === 303) {
                    request.method = 'GET';
                }
                let res;
                try {
                    res = yield utils.dispatchRequest(request);
                    currentRetries++;
                }
                catch (err) {
                    return Promise.reject(err);
                }
                return this.handleRedirect(res, currentRetries);
            }
            return Promise.resolve(operationResponse);
        });
    }
    after(operationResponse) {
        return this.handleRedirect(operationResponse, 0);
    }
}
exports.RedirectFilter = RedirectFilter;
//# sourceMappingURL=redirectFilter.js.map

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const baseFilter_1 = __webpack_require__(3);
class SigningFilter extends baseFilter_1.BaseFilter {
    constructor(authenticationProvider) {
        super();
        this.authenticationProvider = authenticationProvider;
    }
    before(request) {
        const self = this;
        return self.authenticationProvider.signRequest(request);
    }
}
exports.SigningFilter = SigningFilter;
//# sourceMappingURL=signingFilter.js.map

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const baseFilter_1 = __webpack_require__(3);
const constants_1 = __webpack_require__(4);
const os = __webpack_require__(33);
const HeaderConstants = constants_1.Constants.HeaderConstants;
class MsRestUserAgentFilter extends baseFilter_1.BaseFilter {
    constructor(userAgentInfo) {
        super();
        this.userAgentInfo = userAgentInfo;
    }
    tagRequest(request) {
        const osInfo = `(${os.arch()}-${os.type()}-${os.release()})`;
        if (this.userAgentInfo.indexOf(osInfo) === -1) {
            this.userAgentInfo.unshift(osInfo);
        }
        const runtimeInfo = `Node/${process.version}`;
        if (this.userAgentInfo.indexOf(runtimeInfo) === -1) {
            this.userAgentInfo.unshift(runtimeInfo);
        }
        const nodeSDKSignature = `Azure-SDK-For-Node`;
        if (this.userAgentInfo.indexOf(nodeSDKSignature) === -1) {
            const azureRuntime = `ms-rest-azure`;
            let insertIndex = this.userAgentInfo.indexOf(azureRuntime);
            // insert after azureRuntime, otherwise, insert last.
            insertIndex = insertIndex < 0 ? this.userAgentInfo.length : insertIndex + 1;
            this.userAgentInfo.splice(insertIndex, 0, nodeSDKSignature);
        }
        if (!request.headers)
            request.headers = {};
        request.headers[HeaderConstants.USER_AGENT] = this.userAgentInfo.join(' ');
        return Promise.resolve(request);
    }
    before(request) {
        const self = this;
        if (!request.headers)
            request.headers = {};
        if (!request.headers[HeaderConstants.USER_AGENT]) {
            return self.tagRequest(request);
        }
        else {
            return Promise.resolve(request);
        }
    }
}
exports.MsRestUserAgentFilter = MsRestUserAgentFilter;
//# sourceMappingURL=msRestUserAgentFilter.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isStream = module.exports = function (stream) {
	return stream !== null && typeof stream === 'object' && typeof stream.pipe === 'function';
};

isStream.writable = function (stream) {
	return isStream(stream) && stream.writable !== false && typeof stream._write === 'function' && typeof stream._writableState === 'object';
};

isStream.readable = function (stream) {
	return isStream(stream) && stream.readable !== false && typeof stream._read === 'function' && typeof stream._readableState === 'object';
};

isStream.duplex = function (stream) {
	return isStream.writable(stream) && isStream.readable(stream);
};

isStream.transform = function (stream) {
	return isStream.duplex(stream) && typeof stream._transform === 'function' && typeof stream._transformState === 'object';
};


/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BatchServiceClient", function() { return BatchServiceClient; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__models__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__models___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__models__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__models_mappers__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ms_rest_ts__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ms_rest_ts___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_ms_rest_ts__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ms_rest_azure_ts__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ms_rest_azure_ts___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_ms_rest_azure_ts__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__operations__ = __webpack_require__(44);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "BatchServiceModels", function() { return __WEBPACK_IMPORTED_MODULE_0__models__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "BatchServiceMappers", function() { return __WEBPACK_IMPORTED_MODULE_1__models_mappers__; });
/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */





const packageName = 'foo';
const packageVersion = '3.0.0-preview';
class BatchServiceClient extends __WEBPACK_IMPORTED_MODULE_3_ms_rest_azure_ts__["AzureServiceClient"] {
    /**
     * @class
     * Initializes a new instance of the BatchServiceClient class.
     * @constructor
     *
     * @param {msRest.ServiceClientCredentials} credentials - Credentials needed for the client to connect to Azure.
     *
     * @param {string} [baseUri] - The base URI of the service.
     *
     * @param {object} [options] - The parameter options
     *
     * @param {Array} [options.filters] - Filters to be added to the request pipeline
     *
     * @param {object} [options.requestOptions] - The request options. Detailed info can be found at
     * {@link https://github.github.io/fetch/#Request Options doc}
     *
     * @param {boolean} [options.noRetryPolicy] - If set to true, turn off default retry policy
     *
     * @param {string} [options.acceptLanguage] - Gets or sets the preferred language for the response.
     *
     * @param {number} [options.longRunningOperationRetryTimeout] - Gets or sets the retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @param {boolean} [options.generateClientRequestId] - When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     */
    constructor(credentials, baseUri, options) {
        if (credentials === null || credentials === undefined) {
            throw new Error('\'credentials\' cannot be null.');
        }
        if (!options)
            options = {};
        super(credentials, options);
        this.apiVersion = '2017-06-01.5.1';
        this.acceptLanguage = 'en-US';
        this.longRunningOperationRetryTimeout = 30;
        this.generateClientRequestId = true;
        this.baseUri = baseUri;
        if (!this.baseUri) {
            this.baseUri = 'https://batch.core.windows.net';
        }
        this.credentials = credentials;
        this.addUserAgentInfo(`${packageName}/${packageVersion}`);
        if (options.acceptLanguage !== null && options.acceptLanguage !== undefined) {
            this.acceptLanguage = options.acceptLanguage;
        }
        if (options.longRunningOperationRetryTimeout !== null && options.longRunningOperationRetryTimeout !== undefined) {
            this.longRunningOperationRetryTimeout = options.longRunningOperationRetryTimeout;
        }
        if (options.generateClientRequestId !== null && options.generateClientRequestId !== undefined) {
            this.generateClientRequestId = options.generateClientRequestId;
        }
        this.application = new __WEBPACK_IMPORTED_MODULE_4__operations__["b" /* Application */](this);
        this.pool = new __WEBPACK_IMPORTED_MODULE_4__operations__["h" /* Pool */](this);
        this.account = new __WEBPACK_IMPORTED_MODULE_4__operations__["a" /* Account */](this);
        this.job = new __WEBPACK_IMPORTED_MODULE_4__operations__["f" /* Job */](this);
        this.certificateOperations = new __WEBPACK_IMPORTED_MODULE_4__operations__["c" /* CertificateOperations */](this);
        this.file = new __WEBPACK_IMPORTED_MODULE_4__operations__["e" /* File */](this);
        this.jobSchedule = new __WEBPACK_IMPORTED_MODULE_4__operations__["g" /* JobSchedule */](this);
        this.task = new __WEBPACK_IMPORTED_MODULE_4__operations__["i" /* Task */](this);
        this.computeNodeOperations = new __WEBPACK_IMPORTED_MODULE_4__operations__["d" /* ComputeNodeOperations */](this);
        this.serializer = new __WEBPACK_IMPORTED_MODULE_2_ms_rest_ts__["Serializer"](__WEBPACK_IMPORTED_MODULE_1__models_mappers__);
    }
}



/***/ }),
/* 22 */
/***/ (function(module, exports) {

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information. 
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const msRest = __webpack_require__(0);
const constants_1 = __webpack_require__(6);
const pollingState_1 = __webpack_require__(41);
const LroStates = constants_1.default.LongRunningOperationStates;
/**
 * @class
 * Initializes a new instance of the AzureServiceClient class.
 * @constructor
 *
 * @param {msRest.ServiceClientCredentilas} credentials - ApplicationTokenCredentials or
 * UserTokenCredentials object used for authentication.
 * @param {AzureServiceClientOptions} options - The parameter options used by AzureServiceClient
 */
class AzureServiceClient extends msRest.ServiceClient {
    constructor(credentials, options) {
        super(credentials, options);
        this.acceptLanguage = constants_1.default.DEFAULT_LANGUAGE;
        this.generateClientRequestId = true;
        this.longRunningOperationRetryTimeout = 30;
        this.rpRegistrationRetryTimeout = 30;
        this.acceptLanguage = constants_1.default.DEFAULT_LANGUAGE;
        this.generateClientRequestId = true;
        this.longRunningOperationRetryTimeout = 30;
        if (!options)
            options = {};
        if (options.acceptLanguage !== null && options.acceptLanguage !== undefined) {
            this.acceptLanguage = options.acceptLanguage;
        }
        if (options.generateClientRequestId !== null && options.generateClientRequestId !== undefined) {
            this.generateClientRequestId = options.generateClientRequestId;
        }
        if (options.longRunningOperationRetryTimeout !== null && options.longRunningOperationRetryTimeout !== undefined) {
            this.longRunningOperationRetryTimeout = options.longRunningOperationRetryTimeout;
        }
        if (options.rpRegistrationRetryTimeout !== null && options.rpRegistrationRetryTimeout !== undefined) {
            this.rpRegistrationRetryTimeout = options.rpRegistrationRetryTimeout;
        }
        try {
            const moduleName = 'ms-rest-azure';
            const moduleVersion = constants_1.default.msRestAzureVersion;
            this.addUserAgentInfo(`${moduleName}/${moduleVersion}`);
        }
        catch (err) {
            // do nothing
        }
    }
    /**
     * Provides a mechanism to make a request that will poll and provide the final result.
     * @param {msRest.RequestPrepareOptions|msRest.WebResource} request - The request object
     * @param {msRest.RequestOptionsBase} [options] Additional options to be sent while making the request
     * @returns {Promise<msRest.HttpOperationResponse>} The HttpOperationResponse containing the final polling request, response and the responseBody.
     */
    sendLongRunningRequest(request, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let self = this;
            let initialResponse;
            try {
                initialResponse = yield self.sendRequest(request);
            }
            catch (err) {
                return Promise.reject(err);
            }
            let finalResponse;
            try {
                finalResponse = yield self.getLongRunningOperationResult(initialResponse, options);
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(finalResponse);
        });
    }
    /**
     * Verified whether an unexpected polling status code for long running operation was received for the response of the initial request.
     * @param {msRest.HttpOperationResponse} initialResponse - Response to the initial request that was sent as a part of the asynchronous operation.
     */
    checkResponseStatusCodeFailed(initialResponse) {
        let statusCode = initialResponse.response.status;
        let method = initialResponse.request.method;
        if (statusCode === 200 || statusCode === 202 ||
            (statusCode === 201 && method === 'PUT') ||
            (statusCode === 204 && (method === 'DELETE' || method === 'POST'))) {
            return false;
        }
        else {
            return true;
        }
    }
    //goal is to get this working without using the async package and simply using async and Promise.
    /**
     * Poll Azure long running PUT, PATCH, POST or DELETE operations.
     * @param {msRest.HttpOperationResponse} resultOfInitialRequest - result/response of the initial request which is a part of the asynchronous polling operation.
     * @param {msRest.RequestOptionsBase} [options] - custom request options.
     * @returns {Promise<msRest.HttpOperationResponse>} result - The final response after polling is complete.
     */
    getLongRunningOperationResult(resultOfInitialRequest, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let self = this;
            let initialRequestMethod = resultOfInitialRequest.request.method;
            if (self.checkResponseStatusCodeFailed(resultOfInitialRequest)) {
                return Promise.reject(`Unexpected polling status code from long running operation ` +
                    `"${resultOfInitialRequest.response.status}" for method "${initialRequestMethod}".`);
            }
            let pollingState;
            try {
                pollingState = new pollingState_1.default(resultOfInitialRequest, self.longRunningOperationRetryTimeout);
                pollingState.optionsOfInitialRequest = options;
            }
            catch (error) {
                return Promise.reject(error);
            }
            let resourceUrl = resultOfInitialRequest.request.url;
            while (![LroStates.Succeeded, LroStates.Failed, LroStates.Canceled].some((e) => { return e === pollingState.status; })) {
                yield msRest.delay(pollingState.getTimeout());
                if (pollingState.azureAsyncOperationHeaderLink) {
                    yield self.updateStateFromAzureAsyncOperationHeader(pollingState, true);
                }
                else if (pollingState.locationHeaderLink) {
                    yield self.updateStateFromLocationHeader(initialRequestMethod, pollingState);
                }
                else if (initialRequestMethod === 'PUT') {
                    yield self.updateStateFromGetResourceOperation(resourceUrl, pollingState);
                }
                else {
                    return Promise.reject(new Error('Location header is missing from long running operation.'));
                }
            }
            if (pollingState.status === LroStates.Succeeded) {
                if ((pollingState.azureAsyncOperationHeaderLink || !pollingState.resource) &&
                    (initialRequestMethod === 'PUT' || initialRequestMethod === 'PATCH')) {
                    yield self.updateStateFromGetResourceOperation(resourceUrl, pollingState);
                    return Promise.resolve(pollingState.getOperationResponse());
                }
                else {
                    return Promise.resolve(pollingState.getOperationResponse());
                }
            }
            else {
                return Promise.reject(pollingState.getRestError());
            }
        });
    }
    /**
     * Retrieve operation status by polling from 'azure-asyncoperation' header.
     * @param {PollingState} pollingState - The object to persist current operation state.
     * @param {boolean} inPostOrDelete - Invoked by Post Or Delete operation.
     */
    updateStateFromAzureAsyncOperationHeader(pollingState, inPostOrDelete = false) {
        return __awaiter(this, void 0, void 0, function* () {
            let result;
            try {
                result = yield this.getStatus(pollingState.azureAsyncOperationHeaderLink, pollingState.optionsOfInitialRequest);
            }
            catch (err) {
                return Promise.reject(err);
            }
            let parsedResponse = result.bodyAsJson;
            if (!parsedResponse) {
                return Promise.reject(new Error('The response from long running operation does not contain a body.'));
            }
            else if (parsedResponse && !parsedResponse.status) {
                return Promise.reject(new Error(`The response "${result.bodyAsText}" from long running operation does not contain the status property.`));
            }
            pollingState.status = parsedResponse.status;
            pollingState.error = parsedResponse.error;
            pollingState.updateResponse(result.response);
            pollingState.request = result.request;
            pollingState.resource = null;
            if (inPostOrDelete) {
                pollingState.resource = result.bodyAsJson;
            }
            return Promise.resolve();
        });
    }
    /**
     * Retrieve PUT operation status by polling from 'location' header.
     * @param {string} method - The HTTP method.
     * @param {PollingState} pollingState - The object to persist current operation state.
     */
    updateStateFromLocationHeader(method, pollingState) {
        return __awaiter(this, void 0, void 0, function* () {
            let result;
            try {
                result = yield this.getStatus(pollingState.locationHeaderLink, pollingState.optionsOfInitialRequest);
            }
            catch (err) {
                return Promise.reject(err);
            }
            let parsedResponse = result.bodyAsJson;
            pollingState.updateResponse(result.response);
            pollingState.request = result.request;
            let statusCode = result.response.status;
            if (statusCode === 202) {
                pollingState.status = LroStates.InProgress;
            }
            else if (statusCode === 200 ||
                (statusCode === 201 && (method === 'PUT' || method === 'PATCH')) ||
                (statusCode === 204 && (method === 'DELETE' || method === 'POST'))) {
                pollingState.status = LroStates.Succeeded;
                pollingState.resource = parsedResponse;
                //we might not throw an error, but initialize here just in case.
                pollingState.error = new msRest.RestError(`Long running operation failed with status "${pollingState.status}".`);
                pollingState.error.code = pollingState.status;
            }
            else {
                return Promise.reject(new Error(`The response with status code ${statusCode} from polling for ` +
                    `long running operation url "${pollingState.locationHeaderLink}" is not valid.`));
            }
        });
    }
    /**
     * Polling for resource status.
     * @param {string} resourceUrl - The url of resource.
     * @param {PollingState} pollingState - The object to persist current operation state.
     */
    updateStateFromGetResourceOperation(resourceUrl, pollingState) {
        return __awaiter(this, void 0, void 0, function* () {
            let result;
            try {
                result = yield this.getStatus(resourceUrl, pollingState.optionsOfInitialRequest);
            }
            catch (err) {
                return Promise.reject(err);
            }
            if (!result.bodyAsJson) {
                return Promise.reject(new Error('The response from long running operation does not contain a body.'));
            }
            let parsedResponse = result.bodyAsJson;
            pollingState.status = LroStates.Succeeded;
            if (parsedResponse && parsedResponse.properties && parsedResponse.properties.provisioningState) {
                pollingState.status = parsedResponse.properties.provisioningState;
            }
            pollingState.updateResponse(result.response);
            pollingState.request = result.request;
            pollingState.resource = parsedResponse;
            //we might not throw an error, but initialize here just in case.
            pollingState.error = new msRest.RestError(`Long running operation failed with status "${pollingState.status}".`);
            pollingState.error.code = pollingState.status;
            return Promise.resolve();
        });
    }
    /**
     * Retrieves operation status by querying the operation URL.
     * @param {string} operationUrl - URL used to poll operation result.
     * @param {object} options - Options that can be set on the request object
     */
    getStatus(operationUrl, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let self = this;
            // Construct URL
            let requestUrl = operationUrl.replace(' ', '%20');
            // Create HTTP request object
            let httpRequest = {
                method: 'GET',
                url: requestUrl,
                headers: {}
            };
            if (options) {
                let customHeaders = options.customHeaders;
                for (let headerName in customHeaders) {
                    if (customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = customHeaders[headerName];
                    }
                }
            }
            let operationResponse;
            try {
                operationResponse = yield self.sendRequest(httpRequest);
            }
            catch (err) {
                return Promise.reject(err);
            }
            let statusCode = operationResponse.response.status;
            let responseBody = operationResponse.bodyAsJson;
            if (statusCode !== 200 && statusCode !== 201 && statusCode !== 202 && statusCode !== 204) {
                let error = new msRest.RestError(`Invalid status code with response body "${operationResponse.bodyAsText}" occurred ` +
                    `when polling for operation status.`);
                error.statusCode = statusCode;
                error.request = msRest.stripRequest(operationResponse.request);
                error.response = operationResponse.response;
                try {
                    error.body = responseBody;
                }
                catch (badResponse) {
                    error.message += ` Error "${badResponse}" occured while deserializing the response body - "${operationResponse.bodyAsText}".`;
                    error.body = operationResponse.bodyAsText;
                }
                return Promise.reject(error);
            }
            return Promise.resolve(operationResponse);
        });
    }
}
exports.AzureServiceClient = AzureServiceClient;
//# sourceMappingURL=azureServiceClient.js.map

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var v1 = __webpack_require__(25);
var v4 = __webpack_require__(26);

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(9);
var bytesToUuid = __webpack_require__(11);

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

// random #'s we need to init node and clockseq
var _seedBytes = rng();

// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
var _nodeId = [
  _seedBytes[0] | 0x01,
  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
];

// Per 4.2.2, randomize (14 bit) clockseq
var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

// Previous uuid creation time
var _lastMSecs = 0, _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};

  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  var node = options.node || _nodeId;
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(9);
var bytesToUuid = __webpack_require__(11);

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options == 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),
/* 27 */
/***/ (function(module, exports) {

/* eslint-env browser */
module.exports = typeof self == 'object' ? self.FormData : window.FormData;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;(function (self) {
  'use strict';

  function fetchPonyfill(options) {
    var Promise = options && options.Promise || self.Promise;
    var XMLHttpRequest = options && options.XMLHttpRequest || self.XMLHttpRequest;
    var global = self;

    return (function () {
      var self = Object.create(global, {
        fetch: {
          value: undefined,
          writable: true
        }
      });

      (function(self) {
        'use strict';

        if (self.fetch) {
          return
        }

        var support = {
          searchParams: 'URLSearchParams' in self,
          iterable: 'Symbol' in self && 'iterator' in Symbol,
          blob: 'FileReader' in self && 'Blob' in self && (function() {
            try {
              new Blob()
              return true
            } catch(e) {
              return false
            }
          })(),
          formData: 'FormData' in self,
          arrayBuffer: 'ArrayBuffer' in self
        }

        if (support.arrayBuffer) {
          var viewClasses = [
            '[object Int8Array]',
            '[object Uint8Array]',
            '[object Uint8ClampedArray]',
            '[object Int16Array]',
            '[object Uint16Array]',
            '[object Int32Array]',
            '[object Uint32Array]',
            '[object Float32Array]',
            '[object Float64Array]'
          ]

          var isDataView = function(obj) {
            return obj && DataView.prototype.isPrototypeOf(obj)
          }

          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
          }
        }

        function normalizeName(name) {
          if (typeof name !== 'string') {
            name = String(name)
          }
          if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
            throw new TypeError('Invalid character in header field name')
          }
          return name.toLowerCase()
        }

        function normalizeValue(value) {
          if (typeof value !== 'string') {
            value = String(value)
          }
          return value
        }

        // Build a destructive iterator for the value list
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift()
              return {done: value === undefined, value: value}
            }
          }

          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator
            }
          }

          return iterator
        }

        function Headers(headers) {
          this.map = {}

          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value)
            }, this)
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1])
            }, this)
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name])
            }, this)
          }
        }

        Headers.prototype.append = function(name, value) {
          name = normalizeName(name)
          value = normalizeValue(value)
          var oldValue = this.map[name]
          this.map[name] = oldValue ? oldValue+','+value : value
        }

        Headers.prototype['delete'] = function(name) {
          delete this.map[normalizeName(name)]
        }

        Headers.prototype.get = function(name) {
          name = normalizeName(name)
          return this.has(name) ? this.map[name] : null
        }

        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name))
        }

        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value)
        }

        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this)
            }
          }
        }

        Headers.prototype.keys = function() {
          var items = []
          this.forEach(function(value, name) { items.push(name) })
          return iteratorFor(items)
        }

        Headers.prototype.values = function() {
          var items = []
          this.forEach(function(value) { items.push(value) })
          return iteratorFor(items)
        }

        Headers.prototype.entries = function() {
          var items = []
          this.forEach(function(value, name) { items.push([name, value]) })
          return iteratorFor(items)
        }

        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries
        }

        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError('Already read'))
          }
          body.bodyUsed = true
        }

        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result)
            }
            reader.onerror = function() {
              reject(reader.error)
            }
          })
        }

        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader()
          var promise = fileReaderReady(reader)
          reader.readAsArrayBuffer(blob)
          return promise
        }

        function readBlobAsText(blob) {
          var reader = new FileReader()
          var promise = fileReaderReady(reader)
          reader.readAsText(blob)
          return promise
        }

        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf)
          var chars = new Array(view.length)

          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i])
          }
          return chars.join('')
        }

        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0)
          } else {
            var view = new Uint8Array(buf.byteLength)
            view.set(new Uint8Array(buf))
            return view.buffer
          }
        }

        function Body() {
          this.bodyUsed = false

          this._initBody = function(body) {
            this._bodyInit = body
            if (!body) {
              this._bodyText = ''
            } else if (typeof body === 'string') {
              this._bodyText = body
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString()
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer)
              // IE 10-11 can't handle a DataView body.
              this._bodyInit = new Blob([this._bodyArrayBuffer])
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body)
            } else {
              throw new Error('unsupported BodyInit type')
            }

            if (!this.headers.get('content-type')) {
              if (typeof body === 'string') {
                this.headers.set('content-type', 'text/plain;charset=UTF-8')
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set('content-type', this._bodyBlob.type)
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
              }
            }
          }

          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this)
              if (rejected) {
                return rejected
              }

              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob)
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]))
              } else if (this._bodyFormData) {
                throw new Error('could not read FormData body as blob')
              } else {
                return Promise.resolve(new Blob([this._bodyText]))
              }
            }

            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
              } else {
                return this.blob().then(readBlobAsArrayBuffer)
              }
            }
          }

          this.text = function() {
            var rejected = consumed(this)
            if (rejected) {
              return rejected
            }

            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob)
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
            } else if (this._bodyFormData) {
              throw new Error('could not read FormData body as text')
            } else {
              return Promise.resolve(this._bodyText)
            }
          }

          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode)
            }
          }

          this.json = function() {
            return this.text().then(JSON.parse)
          }

          return this
        }

        // HTTP methods whose capitalization should be normalized
        var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

        function normalizeMethod(method) {
          var upcased = method.toUpperCase()
          return (methods.indexOf(upcased) > -1) ? upcased : method
        }

        function Request(input, options) {
          options = options || {}
          var body = options.body

          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError('Already read')
            }
            this.url = input.url
            this.credentials = input.credentials
            if (!options.headers) {
              this.headers = new Headers(input.headers)
            }
            this.method = input.method
            this.mode = input.mode
            if (!body && input._bodyInit != null) {
              body = input._bodyInit
              input.bodyUsed = true
            }
          } else {
            this.url = String(input)
          }

          this.credentials = options.credentials || this.credentials || 'omit'
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers)
          }
          this.method = normalizeMethod(options.method || this.method || 'GET')
          this.mode = options.mode || this.mode || null
          this.referrer = null

          if ((this.method === 'GET' || this.method === 'HEAD') && body) {
            throw new TypeError('Body not allowed for GET or HEAD requests')
          }
          this._initBody(body)
        }

        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit })
        }

        function decode(body) {
          var form = new FormData()
          body.trim().split('&').forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split('=')
              var name = split.shift().replace(/\+/g, ' ')
              var value = split.join('=').replace(/\+/g, ' ')
              form.append(decodeURIComponent(name), decodeURIComponent(value))
            }
          })
          return form
        }

        function parseHeaders(rawHeaders) {
          var headers = new Headers()
          rawHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(':')
            var key = parts.shift().trim()
            if (key) {
              var value = parts.join(':').trim()
              headers.append(key, value)
            }
          })
          return headers
        }

        Body.call(Request.prototype)

        function Response(bodyInit, options) {
          if (!options) {
            options = {}
          }

          this.type = 'default'
          this.status = 'status' in options ? options.status : 200
          this.ok = this.status >= 200 && this.status < 300
          this.statusText = 'statusText' in options ? options.statusText : 'OK'
          this.headers = new Headers(options.headers)
          this.url = options.url || ''
          this._initBody(bodyInit)
        }

        Body.call(Response.prototype)

        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          })
        }

        Response.error = function() {
          var response = new Response(null, {status: 0, statusText: ''})
          response.type = 'error'
          return response
        }

        var redirectStatuses = [301, 302, 303, 307, 308]

        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError('Invalid status code')
          }

          return new Response(null, {status: status, headers: {location: url}})
        }

        self.Headers = Headers
        self.Request = Request
        self.Response = Response

        self.fetch = function(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init)
            var xhr = new XMLHttpRequest()

            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || '')
              }
              options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
              var body = 'response' in xhr ? xhr.response : xhr.responseText
              resolve(new Response(body, options))
            }

            xhr.onerror = function() {
              reject(new TypeError('Network request failed'))
            }

            xhr.ontimeout = function() {
              reject(new TypeError('Network request failed'))
            }

            xhr.open(request.method, request.url, true)

            if (request.credentials === 'include') {
              xhr.withCredentials = true
            }

            if ('responseType' in xhr && support.blob) {
              xhr.responseType = 'blob'
            }

            request.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value)
            })

            xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
          })
        }
        self.fetch.polyfill = true
      })(typeof self !== 'undefined' ? self : this);


      return {
        fetch: self.fetch,
        Headers: self.Headers,
        Request: self.Request,
        Response: self.Response
      };
    }());
  }

  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
      return fetchPonyfill;
    }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports === 'object') {
    module.exports = fetchPonyfill;
  } else {
    self.fetchPonyfill = fetchPonyfill;
  }
}(typeof self === 'undefined' ? this : self));



/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const requestPipeline_1 = __webpack_require__(14);
const exponentialRetryPolicyFilter_1 = __webpack_require__(15);
const systemErrorRetryPolicyFilter_1 = __webpack_require__(16);
const redirectFilter_1 = __webpack_require__(17);
const signingFilter_1 = __webpack_require__(18);
const msRestUserAgentFilter_1 = __webpack_require__(19);
const webResource_1 = __webpack_require__(5);
const constants_1 = __webpack_require__(4);
/**
 * @class
 * Initializes a new instance of the ServiceClient.
 * @constructor
 * @param {ServiceClientCredentials} [credentials]    - BasicAuthenticationCredentials or
 * TokenCredentials object used for authentication.
 *
 * @param {ServiceClientOptions} [options] The service client options that govern the behavior of the client.
 */
class ServiceClient {
    constructor(credentials, options) {
        if (!options) {
            options = {};
        }
        if (!options.requestOptions) {
            options.requestOptions = {};
        }
        if (!options.filters) {
            options.filters = [];
        }
        this.userAgentInfo = { value: [] };
        if (credentials && !credentials.signRequest) {
            throw new Error('credentials argument needs to implement signRequest method');
        }
        try {
            const moduleName = 'ms-rest';
            const moduleVersion = constants_1.Constants.msRestVersion;
            this.addUserAgentInfo(`${moduleName}/${moduleVersion}`);
        }
        catch (err) {
            // do nothing
        }
        if (credentials) {
            options.filters.push(new signingFilter_1.SigningFilter(credentials));
        }
        options.filters.push(new msRestUserAgentFilter_1.MsRestUserAgentFilter(this.userAgentInfo.value));
        options.filters.push(new redirectFilter_1.RedirectFilter());
        if (!options.noRetryPolicy) {
            options.filters.push(new exponentialRetryPolicyFilter_1.ExponentialRetryPolicyFilter());
            options.filters.push(new systemErrorRetryPolicyFilter_1.SystemErrorRetryPolicyFilter());
        }
        this.pipeline = new requestPipeline_1.RequestPipeline(options.filters, options.requestOptions).create();
    }
    /**
     * Adds custom information to user agent header
     * @param {any} additionalUserAgentInfo - information to be added to user agent header, as string.
     */
    addUserAgentInfo(additionalUserAgentInfo) {
        if (this.userAgentInfo.value.indexOf(additionalUserAgentInfo) === -1) {
            this.userAgentInfo.value.push(additionalUserAgentInfo);
        }
        return;
    }
    sendRequest(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (options === null || options === undefined || typeof options !== 'object') {
                throw new Error('options cannot be null or undefined and it must be of type object.');
            }
            let httpRequest;
            try {
                if (options instanceof webResource_1.WebResource) {
                    options.validateRequestProperties();
                    httpRequest = options;
                }
                else {
                    httpRequest = new webResource_1.WebResource();
                    httpRequest = httpRequest.prepare(options);
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // send request
            let operationResponse;
            try {
                operationResponse = yield this.pipeline(httpRequest);
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationResponse);
        });
    }
}
exports.ServiceClient = ServiceClient;
//# sourceMappingURL=serviceClient.js.map

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var required = __webpack_require__(31)
  , qs = __webpack_require__(32)
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @api public
 */
function lolcation(loc) {
  loc = loc || global.location || {};

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new URL(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new URL(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @api private
 */
function extractProtocol(address) {
  var match = protocolre.exec(address);

  return {
    protocol: match[1] ? match[1].toLowerCase() : '',
    slashes: !!match[2],
    rest: match[3]
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @api private
 */
function resolve(relative, base) {
  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} location Location defaults for relative paths.
 * @param {Boolean|Function} parser Parser for the query string.
 * @api public
 */
function URL(address, location, parser) {
  if (!(this instanceof URL)) {
    return new URL(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[2] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];
    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL}
 * @api public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
      url.pathname = value.length && value.charAt(0) !== '/' ? '/' + value : value;

      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String}
 * @api public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

URL.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
URL.extractProtocol = extractProtocol;
URL.location = lolcation;
URL.qs = qs;

module.exports = URL;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String} The decoded string.
 * @api private
 */
function decode(input) {
  return decodeURIComponent(input.replace(/\+/g, ' '));
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?&]+)=?([^&]*)/g
    , result = {}
    , part;

  //
  // Little nifty parsing hack, leverage the fact that RegExp.exec increments
  // the lastIndex property so we can continue executing this loop until we've
  // parsed all results.
  //
  for (;
    part = parser.exec(query);
    result[decode(part[1])] = decode(part[2])
  );

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = [];

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (var key in obj) {
    if (has.call(obj, key)) {
      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;


/***/ }),
/* 33 */
/***/ (function(module, exports) {

exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const baseFilter_1 = __webpack_require__(3);
class LogFilter extends baseFilter_1.BaseFilter {
    constructor(logger = console.log) {
        super();
        this.logger = logger;
    }
    after(operationResponse) {
        const self = this;
        self.logger(`>> Request: ${JSON.stringify(operationResponse.request, undefined, 2)}`);
        self.logger(`>> Response status code: ${operationResponse.response.status}`);
        let responseBody = operationResponse.bodyAsText;
        self.logger(`>> Body: ${responseBody}`);
        return Promise.resolve(operationResponse);
    }
}
exports.LogFilter = LogFilter;
//# sourceMappingURL=logFilter.js.map

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information. 
Object.defineProperty(exports, "__esModule", { value: true });
const utils = __webpack_require__(2);
const moment_1 = __webpack_require__(36);
const isBuffer = __webpack_require__(38);
const isStream = __webpack_require__(20);
class Serializer {
    constructor(mappers) {
        this.modelMappers = mappers;
    }
    validateConstraints(mapper, value, objectName) {
        if (mapper.constraints && (value !== null || value !== undefined)) {
            Object.keys(mapper.constraints).forEach((constraintType) => {
                if (constraintType.match(/^ExclusiveMaximum$/ig) !== null) {
                    if (value >= mapper.constraints.ExclusiveMaximum) {
                        throw new Error(`"${objectName}" with value "${value}" should satify the constraint "ExclusiveMaximum": ${mapper.constraints.ExclusiveMaximum}.`);
                    }
                }
                else if (constraintType.match(/^ExclusiveMinimum$/ig) !== null) {
                    if (value <= mapper.constraints.ExclusiveMinimum) {
                        throw new Error(`${objectName} " with value "${value} " should satify the constraint "ExclusiveMinimum": ${mapper.constraints.ExclusiveMinimum}.`);
                    }
                }
                else if (constraintType.match(/^InclusiveMaximum$/ig) !== null) {
                    if (value > mapper.constraints.InclusiveMaximum) {
                        throw new Error(`${objectName}" with value "${value}" should satify the constraint "InclusiveMaximum": ${mapper.constraints.InclusiveMaximum}.`);
                    }
                }
                else if (constraintType.match(/^InclusiveMinimum$/ig) !== null) {
                    if (value < mapper.constraints.InclusiveMinimum) {
                        throw new Error(`${objectName}" with value "${value}" should satify the constraint "InclusiveMinimum": ${mapper.constraints.InclusiveMinimum}.`);
                    }
                }
                else if (constraintType.match(/^MaxItems$/ig) !== null) {
                    if (value.length > mapper.constraints.MaxItems) {
                        throw new Error(`${objectName}" with value "${value}" should satify the constraint "MaxItems": ${mapper.constraints.MaxItems}.`);
                    }
                }
                else if (constraintType.match(/^MaxLength$/ig) !== null) {
                    if (value.length > mapper.constraints.MaxLength) {
                        throw new Error(`${objectName}" with value "${value}" should satify the constraint "MaxLength": ${mapper.constraints.MaxLength}.`);
                    }
                }
                else if (constraintType.match(/^MinItems$/ig) !== null) {
                    if (value.length < mapper.constraints.MinItems) {
                        throw new Error(`${objectName}" with value "${value}" should satify the constraint "MinItems": ${mapper.constraints.MinItems}.`);
                    }
                }
                else if (constraintType.match(/^MinLength$/ig) !== null) {
                    if (value.length < mapper.constraints.MinLength) {
                        throw new Error(`${objectName}" with value "${value}" should satify the constraint "MinLength": ${mapper.constraints.MinLength}.`);
                    }
                }
                else if (constraintType.match(/^MultipleOf$/ig) !== null) {
                    if (value.length % mapper.constraints.MultipleOf !== 0) {
                        throw new Error(`${objectName}" with value "${value}" should satify the constraint "MultipleOf": ${mapper.constraints.MultipleOf}.`);
                    }
                }
                else if (constraintType.match(/^Pattern$/ig) !== null) {
                    if (value.match(mapper.constraints.Pattern.split('/').join('\/')) === null) {
                        throw new Error(`${objectName}" with value "${value}" should satify the constraint "Pattern": ${mapper.constraints.Pattern}.`);
                    }
                }
                else if (constraintType.match(/^UniqueItems/ig) !== null) {
                    if (mapper.constraints.UniqueItems) {
                        if (value.length !== value.filter((item, i, ar) => { {
                            return ar.indexOf(item) === i;
                        } }).length) {
                            throw new Error(`${objectName}" with value "${value}" should satify the constraint "UniqueItems": ${mapper.constraints.UniqueItems}`);
                        }
                    }
                }
            });
        }
    }
    trimEnd(str, ch) {
        let len = str.length;
        while ((len - 1) >= 0 && str[len - 1] === ch) {
            --len;
        }
        return str.substr(0, len);
    }
    bufferToBase64Url(buffer) {
        if (!buffer) {
            return null;
        }
        if (!isBuffer(buffer)) {
            throw new Error(`Please provide an input of type Buffer for converting to Base64Url.`);
        }
        // Buffer to Base64.
        let str = buffer.toString('base64');
        // Base64 to Base64Url.
        return this.trimEnd(str, '=').replace(/\+/g, '-').replace(/\//g, '_');
    }
    base64UrlToBuffer(str) {
        if (!str) {
            return null;
        }
        if (str && typeof str.valueOf() !== 'string') {
            throw new Error('Please provide an input of type string for converting to Buffer');
        }
        // Base64Url to Base64.
        str = str.replace(/\-/g, '+').replace(/\_/g, '/');
        // Base64 to Buffer.
        return Buffer.from(str, 'base64');
    }
    splitSerializeName(prop) {
        let classes = [];
        let partialclass = '';
        let subwords = prop.split('.');
        subwords.forEach((item) => {
            if (item.charAt(item.length - 1) === '\\') {
                partialclass += item.substr(0, item.length - 1) + '.';
            }
            else {
                partialclass += item;
                classes.push(partialclass);
                partialclass = '';
            }
        });
        return classes;
    }
    dateToUnixTime(d) {
        if (!d) {
            return null;
        }
        if (typeof d.valueOf() === 'string') {
            d = new Date(d);
        }
        return Math.floor(d.getTime() / 1000);
    }
    unixTimeToDate(n) {
        if (!n) {
            return null;
        }
        return new Date(n * 1000);
    }
    serializeBasicTypes(typeName, objectName, value) {
        if (value !== null && value !== undefined) {
            if (typeName.match(/^Number$/ig) !== null) {
                if (typeof value !== 'number') {
                    throw new Error(`${objectName} with value ${value} must be of type number.`);
                }
            }
            else if (typeName.match(/^String$/ig) !== null) {
                if (typeof value.valueOf() !== 'string') {
                    throw new Error(`${objectName} with value "${value}" must be of type string.`);
                }
            }
            else if (typeName.match(/^Uuid$/ig) !== null) {
                if (!(typeof value.valueOf() === 'string' && utils.isValidUuid(value))) {
                    throw new Error(`${objectName} with value "${value}" must be of type string and a valid uuid.`);
                }
            }
            else if (typeName.match(/^Boolean$/ig) !== null) {
                if (typeof value !== 'boolean') {
                    throw new Error(`${objectName} with value ${value} must be of type boolean.`);
                }
            }
            else if (typeName.match(/^Object$/ig) !== null) {
                if (typeof value !== 'object') {
                    throw new Error(`${objectName} must be of type object.`);
                }
            }
            else if (typeName.match(/^Stream$/ig) !== null) {
                if (!isStream(value)) {
                    throw new Error(`${objectName} must be of type stream.`);
                }
            }
        }
        return value;
    }
    serializeEnumType(objectName, allowedValues, value) {
        if (!allowedValues) {
            throw new Error(`Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`);
        }
        let isPresent = allowedValues.some((item) => {
            if (typeof item.valueOf() === 'string') {
                return item.toLowerCase() === value.toLowerCase();
            }
            return item === value;
        });
        if (!isPresent) {
            throw new Error(`${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(allowedValues)}.`);
        }
        return value;
    }
    serializeBufferType(objectName, value) {
        if (value !== null && value !== undefined) {
            if (!isBuffer(value)) {
                throw new Error(`${objectName} must be of type Buffer.`);
            }
            value = value.toString('base64');
        }
        return value;
    }
    serializeBase64UrlType(objectName, value) {
        if (value !== null && value !== undefined) {
            if (!isBuffer(value)) {
                throw new Error(`${objectName} must be of type Buffer.`);
            }
            value = this.bufferToBase64Url(value);
        }
        return value;
    }
    serializeDateTypes(typeName, value, objectName) {
        if (value !== null && value !== undefined) {
            if (typeName.match(/^Date$/ig) !== null) {
                if (!(value instanceof Date ||
                    (typeof value.valueOf() === 'string' && !isNaN(Date.parse(value))))) {
                    throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
                }
                value = (value instanceof Date) ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);
            }
            else if (typeName.match(/^DateTime$/ig) !== null) {
                if (!(value instanceof Date ||
                    (typeof value.valueOf() === 'string' && !isNaN(Date.parse(value))))) {
                    throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
                }
                value = (value instanceof Date) ? value.toISOString() : new Date(value).toISOString();
            }
            else if (typeName.match(/^DateTimeRfc1123$/ig) !== null) {
                if (!(value instanceof Date ||
                    (typeof value.valueOf() === 'string' && !isNaN(Date.parse(value))))) {
                    throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);
                }
                value = (value instanceof Date) ? value.toUTCString() : new Date(value).toUTCString();
            }
            else if (typeName.match(/^UnixTime$/ig) !== null) {
                if (!(value instanceof Date ||
                    (typeof value.valueOf() === 'string' && !isNaN(Date.parse(value))))) {
                    throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format ` +
                        `for it to be serialized in UnixTime/Epoch format.`);
                }
                value = this.dateToUnixTime(value);
            }
            else if (typeName.match(/^TimeSpan$/ig) !== null) {
                if (!moment_1.isDuration(value)) {
                    throw new Error(`${objectName} must be a TimeSpan/Duration.`);
                }
                value = value.toISOString();
            }
        }
        return value;
    }
    serializeSequenceType(mapper, object, objectName) {
        if (!Array.isArray(object)) {
            throw new Error(`${objectName} must be of type Array.`);
        }
        if (!mapper.type.element || typeof mapper.type.element !== 'object') {
            throw new Error(`element" metadata for an Array must be defined in the ` +
                `mapper and it must of type "object" in ${objectName}.`);
        }
        let tempArray = [];
        for (let i = 0; i < object.length; i++) {
            tempArray[i] = this.serialize(mapper.type.element, object[i], objectName);
        }
        return tempArray;
    }
    serializeDictionaryType(mapper, object, objectName) {
        if (typeof object !== 'object') {
            throw new Error(`${objectName} must be of type object.`);
        }
        if (!mapper.type.value || typeof mapper.type.value !== 'object') {
            throw new Error(`"value" metadata for a Dictionary must be defined in the ` +
                `mapper and it must of type "object" in ${objectName}.`);
        }
        let tempDictionary = {};
        for (let key in object) {
            if (object.hasOwnProperty(key)) {
                tempDictionary[key] = this.serialize(mapper.type.value, object[key], objectName);
            }
        }
        return tempDictionary;
    }
    serializeCompositeType(mapper, object, objectName) {
        //check for polymorphic discriminator
        if (mapper.type.polymorphicDiscriminator) {
            mapper = this.getPolymorphicMapper(mapper, object, objectName, 'serialize');
        }
        let payload = {};
        let modelMapper = {
            required: false,
            serializedName: 'serializedName',
            type: {
                name: 'Composite',
                className: 'className',
                modelProperties: {}
            }
        };
        if (object !== null && object !== undefined) {
            let modelProps = mapper.type.modelProperties;
            if (!modelProps) {
                if (!mapper.type.className) {
                    throw new Error(`Class name for model "${objectName}" is not provided in the mapper "${JSON.stringify(mapper, null, 2)}".`);
                }
                //get the mapper if modelProperties of the CompositeType is not present and 
                //then get the modelProperties from it.
                modelMapper = this.modelMappers[mapper.type.className];
                if (!modelMapper) {
                    throw new Error(`mapper() cannot be null or undefined for model "${mapper.type.className}".`);
                }
                modelProps = modelMapper.type.modelProperties;
                if (!modelProps) {
                    throw new Error(`modelProperties cannot be null or undefined in the ` +
                        `mapper "${JSON.stringify(modelMapper)}" of type "${mapper.type.className}" for object "${objectName}".`);
                }
            }
            for (let key in modelProps) {
                if (modelProps.hasOwnProperty(key)) {
                    let paths = this.splitSerializeName(modelProps[key].serializedName);
                    let propName = paths.pop();
                    let parentObject = payload;
                    paths.forEach((pathName) => {
                        let childObject = parentObject[pathName];
                        if ((childObject === null || childObject === undefined) && (object[key] !== null && object[key] !== undefined)) {
                            parentObject[pathName] = {};
                        }
                        parentObject = parentObject[pathName];
                    });
                    //make sure required properties of the CompositeType are present
                    if (modelProps[key].required && !modelProps[key].isConstant) {
                        if (object[key] === null || object[key] === undefined) {
                            throw new Error(`${key}" cannot be null or undefined in "${objectName}".`);
                        }
                    }
                    //make sure that readOnly properties are not sent on the wire
                    if (modelProps[key].readOnly) {
                        continue;
                    }
                    //serialize the property if it is present in the provided object instance
                    if (((parentObject !== null && parentObject !== undefined) && (modelProps[key].defaultValue !== null && modelProps[key].defaultValue !== undefined)) ||
                        (object[key] !== null && object[key] !== undefined)) {
                        let propertyObjectName = objectName;
                        if (modelProps[key].serializedName !== '')
                            propertyObjectName = objectName + '.' + modelProps[key].serializedName;
                        let propertyMapper = modelProps[key];
                        let serializedValue = this.serialize(propertyMapper, object[key], propertyObjectName);
                        if (propName !== null && propName !== undefined)
                            parentObject[propName] = serializedValue;
                    }
                }
            }
            return payload;
        }
        return object;
    }
    /**
     * Serialize the given object based on its metadata defined in the mapper
     *
     * @param {Mapper} mapper The mapper which defines the metadata of the serializable object
     *
     * @param {object|string|Array|number|boolean|Date|stream} object A valid Javascript object to be serialized
     *
     * @param {string} objectName Name of the serialized object
     *
     * @returns {object|string|Array|number|boolean|Date|stream} A valid serialized Javascript object
     */
    serialize(mapper, object, objectName) {
        let payload = {};
        let mapperType = mapper.type.name;
        if (!objectName)
            objectName = mapper.serializedName;
        if (mapperType.match(/^Sequence$/ig) !== null)
            payload = [];
        //Throw if required and object is null or undefined
        if (mapper.required && (object === null || object === undefined) && !mapper.isConstant) {
            throw new Error(`${objectName} cannot be null or undefined.`);
        }
        //Set Defaults
        if ((mapper.defaultValue !== null && mapper.defaultValue !== undefined) &&
            (object === null || object === undefined)) {
            object = mapper.defaultValue;
        }
        if (mapper.isConstant)
            object = mapper.defaultValue;
        //Validate Constraints if any
        this.validateConstraints(mapper, object, objectName);
        if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/ig) !== null) {
            payload = this.serializeBasicTypes(mapperType, objectName, object);
        }
        else if (mapperType.match(/^Enum$/ig) !== null) {
            let enumMapper = mapper;
            payload = this.serializeEnumType(objectName, enumMapper.type.allowedValues, object);
        }
        else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/ig) !== null) {
            payload = this.serializeDateTypes(mapperType, object, objectName);
        }
        else if (mapperType.match(/^ByteArray$/ig) !== null) {
            payload = this.serializeBufferType(objectName, object);
        }
        else if (mapperType.match(/^Base64Url$/ig) !== null) {
            payload = this.serializeBase64UrlType(objectName, object);
        }
        else if (mapperType.match(/^Sequence$/ig) !== null) {
            payload = this.serializeSequenceType(mapper, object, objectName);
        }
        else if (mapperType.match(/^Dictionary$/ig) !== null) {
            payload = this.serializeDictionaryType(mapper, object, objectName);
        }
        else if (mapperType.match(/^Composite$/ig) !== null) {
            payload = this.serializeCompositeType(mapper, object, objectName);
        }
        return payload;
    }
    deserializeCompositeType(mapper, responseBody, objectName) {
        /*jshint validthis: true */
        //check for polymorphic discriminator
        if (mapper.type.polymorphicDiscriminator) {
            mapper = this.getPolymorphicMapper(mapper, responseBody, objectName, 'deserialize');
        }
        let instance = {};
        let modelMapper = {
            required: false,
            serializedName: 'serializedName',
            type: {
                name: 'Composite'
            }
        };
        if (responseBody !== null && responseBody !== undefined) {
            let modelProps = mapper.type.modelProperties;
            if (!modelProps) {
                if (!mapper.type.className) {
                    throw new Error(`Class name for model "${objectName}" is not provided in the mapper "${JSON.stringify(mapper)}"`);
                }
                //get the mapper if modelProperties of the CompositeType is not present and 
                //then get the modelProperties from it.
                modelMapper = this.modelMappers[mapper.type.className];
                if (!modelMapper) {
                    throw new Error(`mapper() cannot be null or undefined for model "${mapper.type.className}"`);
                }
                modelProps = modelMapper.type.modelProperties;
                if (!modelProps) {
                    throw new Error(`modelProperties cannot be null or undefined in the ` +
                        `mapper "${JSON.stringify(modelMapper)}" of type "${mapper.type.className}" for responseBody "${objectName}".`);
                }
            }
            for (let key in modelProps) {
                if (modelProps.hasOwnProperty(key)) {
                    let jpath = ['responseBody'];
                    let paths = this.splitSerializeName(modelProps[key].serializedName);
                    paths.forEach((item) => {
                        jpath.push(`["${item}"]`);
                    });
                    //deserialize the property if it is present in the provided responseBody instance
                    let propertyInstance;
                    try {
                        /*jslint evil: true */
                        propertyInstance = eval(jpath.join(''));
                    }
                    catch (err) {
                        continue;
                    }
                    let propertyObjectName = objectName;
                    if (modelProps[key].serializedName !== '')
                        propertyObjectName = objectName + '.' + modelProps[key].serializedName;
                    let propertyMapper = modelProps[key];
                    let serializedValue;
                    //paging
                    if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === '') {
                        propertyInstance = responseBody[key];
                        instance = this.deserialize(propertyMapper, propertyInstance, propertyObjectName);
                    }
                    else if (propertyInstance !== null && propertyInstance !== undefined) {
                        serializedValue = this.deserialize(propertyMapper, propertyInstance, propertyObjectName);
                        instance[key] = serializedValue;
                    }
                }
            }
            return instance;
        }
        return responseBody;
    }
    deserializeDictionaryType(mapper, responseBody, objectName) {
        /*jshint validthis: true */
        if (!mapper.type.value || typeof mapper.type.value !== 'object') {
            throw new Error(`"value" metadata for a Dictionary must be defined in the ` +
                `mapper and it must of type "object" in ${objectName}`);
        }
        if (responseBody) {
            let tempDictionary = {};
            for (let key in responseBody) {
                if (responseBody.hasOwnProperty(key)) {
                    tempDictionary[key] = this.deserialize(mapper.type.value, responseBody[key], objectName);
                }
            }
            return tempDictionary;
        }
        return responseBody;
    }
    deserializeSequenceType(mapper, responseBody, objectName) {
        /*jshint validthis: true */
        if (!mapper.type.element || typeof mapper.type.element !== 'object') {
            throw new Error(`element" metadata for an Array must be defined in the ` +
                `mapper and it must of type "object" in ${objectName}`);
        }
        if (responseBody) {
            let tempArray = [];
            for (let i = 0; i < responseBody.length; i++) {
                tempArray[i] = this.deserialize(mapper.type.element, responseBody[i], objectName);
            }
            return tempArray;
        }
        return responseBody;
    }
    /**
     * Deserialize the given object based on its metadata defined in the mapper
     *
     * @param {object} mapper The mapper which defines the metadata of the serializable object
     *
     * @param {object|string|Array|number|boolean|Date|stream} responseBody A valid Javascript entity to be deserialized
     *
     * @param {string} objectName Name of the deserialized object
     *
     * @returns {object|string|Array|number|boolean|Date|stream} A valid deserialized Javascript object
     */
    deserialize(mapper, responseBody, objectName) {
        if (responseBody === null || responseBody === undefined)
            return responseBody;
        let payload;
        let mapperType = mapper.type.name;
        if (!objectName)
            objectName = mapper.serializedName;
        if (mapperType.match(/^Sequence$/ig) !== null)
            payload = [];
        if (mapperType.match(/^(Number|String|Boolean|Enum|Object|Stream|Uuid)$/ig) !== null) {
            payload = responseBody;
        }
        else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/ig) !== null) {
            payload = new Date(responseBody);
        }
        else if (mapperType.match(/^TimeSpan$/ig) !== null) {
            payload = moment_1.duration(responseBody);
        }
        else if (mapperType.match(/^UnixTime$/ig) !== null) {
            payload = this.unixTimeToDate(responseBody);
        }
        else if (mapperType.match(/^ByteArray$/ig) !== null) {
            payload = Buffer.from(responseBody, 'base64');
        }
        else if (mapperType.match(/^Base64Url$/ig) !== null) {
            payload = this.base64UrlToBuffer(responseBody);
        }
        else if (mapperType.match(/^Sequence$/ig) !== null) {
            payload = this.deserializeSequenceType(mapper, responseBody, objectName);
        }
        else if (mapperType.match(/^Dictionary$/ig) !== null) {
            payload = this.deserializeDictionaryType(mapper, responseBody, objectName);
        }
        else if (mapperType.match(/^Composite$/ig) !== null) {
            payload = this.deserializeCompositeType(mapper, responseBody, objectName);
        }
        if (mapper.isConstant)
            payload = mapper.defaultValue;
        return payload;
    }
    getPolymorphicMapper(mapper, object, objectName, mode) {
        //check for polymorphic discriminator
        //Until version 1.15.1, 'polymorphicDiscriminator' in the mapper was a string. This method was not effective when the 
        //polymorphicDiscriminator property had a dot in it's name. So we have comeup with a desgin where polymorphicDiscriminator  
        //will be an object that contains the clientName (normalized property name, ex: 'odatatype') and 
        //the serializedName (ex: 'odata.type') (We do not escape the dots with double backslash in this case as it is not required). 
        //Thus when serializing, the user will give us an object which will contain the normalizedProperty hence we will lookup
        //the clientName of the polmorphicDiscriminator in the mapper and during deserialization from the responseBody we will 
        //lookup the serializedName of the polmorphicDiscriminator in the mapper. This will help us in selecting the correct mapper
        //for the model that needs to be serializes or deserialized. 
        //We need this routing for backwards compatibility. This will absorb the breaking change in the mapper and allow new versions
        //of the runtime to work seamlessly with older version (>= 0.17.0-Nightly20161008) of Autorest generated node.js clients.
        if (mapper.type.polymorphicDiscriminator) {
            if (typeof mapper.type.polymorphicDiscriminator.valueOf() === 'string') {
                return this.getPolymorphicMapperStringVersion(mapper, object, objectName);
            }
            else if (mapper.type.polymorphicDiscriminator instanceof Object) {
                return this.getPolymorphicMapperObjectVersion(mapper, object, objectName, mode);
            }
            else {
                throw new Error(`The polymorphicDiscriminator for "${objectName}" is neither a string nor an object.`);
            }
        }
        return mapper;
    }
    //processes new version of the polymorphicDiscriminator in the mapper.
    getPolymorphicMapperObjectVersion(mapper, object, objectName, mode) {
        //check for polymorphic discriminator
        let polymorphicPropertyName = '';
        if (mode === 'serialize') {
            polymorphicPropertyName = 'clientName';
        }
        else if (mode === 'deserialize') {
            polymorphicPropertyName = 'serializedName';
        }
        else {
            throw new Error(`The given mode "${mode}" for getting the polymorphic mapper for "${objectName}" is inavlid.`);
        }
        let discriminatorAsObject = mapper.type.polymorphicDiscriminator;
        if (discriminatorAsObject &&
            discriminatorAsObject[polymorphicPropertyName] !== null &&
            discriminatorAsObject[polymorphicPropertyName] !== undefined) {
            if (object === null || object === undefined) {
                throw new Error(`${objectName}" cannot be null or undefined. ` +
                    `"${discriminatorAsObject[polymorphicPropertyName]}" is the ` +
                    `polmorphicDiscriminator and is a required property.`);
            }
            if (object[discriminatorAsObject[polymorphicPropertyName]] === null ||
                object[discriminatorAsObject[polymorphicPropertyName]] === undefined) {
                throw new Error(`No discriminator field "${discriminatorAsObject[polymorphicPropertyName]}" was found in "${objectName}".`);
            }
            let indexDiscriminator = null;
            if (object[discriminatorAsObject[polymorphicPropertyName]] === mapper.type.uberParent) {
                indexDiscriminator = object[discriminatorAsObject[polymorphicPropertyName]];
            }
            else {
                indexDiscriminator = mapper.type.uberParent + '.' + object[discriminatorAsObject[polymorphicPropertyName]];
            }
            if (!this.modelMappers.discriminators[indexDiscriminator]) {
                throw new Error(`${discriminatorAsObject[polymorphicPropertyName]}": ` +
                    `"${object[discriminatorAsObject[polymorphicPropertyName]]}" in "${objectName}" is not a valid ` +
                    `discriminator as a corresponding model class for the disciminator "${indexDiscriminator}" ` +
                    `was not found in this.modelMappers.discriminators object.`);
            }
            mapper = this.modelMappers.discriminators[indexDiscriminator];
        }
        return mapper;
    }
    //processes old version of the polymorphicDiscriminator in the mapper.
    getPolymorphicMapperStringVersion(mapper, object, objectName) {
        //check for polymorphic discriminator
        let discriminatorAsString = mapper.type.polymorphicDiscriminator;
        if (discriminatorAsString !== null && discriminatorAsString !== undefined) {
            if (object === null || object === undefined) {
                throw new Error(`${objectName}" cannot be null or undefined. "${discriminatorAsString}" is the ` +
                    `polmorphicDiscriminator and is a required property.`);
            }
            if (object[discriminatorAsString] === null || object[discriminatorAsString] === undefined) {
                throw new Error(`No discriminator field "${discriminatorAsString}" was found in "${objectName}".`);
            }
            let indexDiscriminator = null;
            if (object[discriminatorAsString] === mapper.type.uberParent) {
                indexDiscriminator = object[discriminatorAsString];
            }
            else {
                indexDiscriminator = mapper.type.uberParent + '.' + object[discriminatorAsString];
            }
            if (!this.modelMappers.discriminators[indexDiscriminator]) {
                throw new Error(`${discriminatorAsString}": ` +
                    `"${object[discriminatorAsString]}"  in "${objectName}" is not a valid ` +
                    `discriminator as a corresponding model class for the disciminator "${indexDiscriminator}" ` +
                    `was not found in this.models.discriminators object.`);
            }
            mapper = this.modelMappers.discriminators[indexDiscriminator];
        }
        return mapper;
    }
}
exports.Serializer = Serializer;
function serializeObject(toSerialize) {
    if (toSerialize === null || toSerialize === undefined)
        return null;
    if (isBuffer(toSerialize)) {
        toSerialize = toSerialize.toString('base64');
        return toSerialize;
    }
    else if (toSerialize instanceof Date) {
        return toSerialize.toISOString();
    }
    else if (Array.isArray(toSerialize)) {
        let array = [];
        for (let i = 0; i < toSerialize.length; i++) {
            array.push(serializeObject(toSerialize[i]));
        }
        return array;
    }
    else if (typeof toSerialize === 'object') {
        let dictionary = {};
        for (let property in toSerialize) {
            dictionary[property] = serializeObject(toSerialize[property]);
        }
        return dictionary;
    }
    return toSerialize;
}
exports.serializeObject = serializeObject;
exports.MapperType = utils.strEnum([
    'Base64Url',
    'Boolean',
    'ByteArray',
    'Composite',
    'Date',
    'DateTime',
    'DateTimeRfc1123',
    'Dictionary',
    'Enum',
    'Number',
    'Object',
    'Sequence',
    'String',
    'Stream',
    'TimeSpan',
    'UnixTime'
]);
//# sourceMappingURL=serializer.js.map

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {//! moment.js
//! version : 2.18.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
     true ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

var hookCallback;

function hooks () {
    return hookCallback.apply(null, arguments);
}

// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback (callback) {
    hookCallback = callback;
}

function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}

function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

function isObjectEmpty(obj) {
    var k;
    for (k in obj) {
        // even if its not own property I'd still call it non-empty
        return false;
    }
    return true;
}

function isUndefined(input) {
    return input === void 0;
}

function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}

function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}

function map(arr, fn) {
    var res = [], i;
    for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
    }
    return res;
}

function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
}

function extend(a, b) {
    for (var i in b) {
        if (hasOwnProp(b, i)) {
            a[i] = b[i];
        }
    }

    if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
    }

    return a;
}

function createUTC (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
}

function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
        empty           : false,
        unusedTokens    : [],
        unusedInput     : [],
        overflow        : -2,
        charsLeftOver   : 0,
        nullInput       : false,
        invalidMonth    : null,
        invalidFormat   : false,
        userInvalidated : false,
        iso             : false,
        parsedDateParts : [],
        meridiem        : null,
        rfc2822         : false,
        weekdayMismatch : false
    };
}

function getParsingFlags(m) {
    if (m._pf == null) {
        m._pf = defaultParsingFlags();
    }
    return m._pf;
}

var some;
if (Array.prototype.some) {
    some = Array.prototype.some;
} else {
    some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
                return true;
            }
        }

        return false;
    };
}

var some$1 = some;

function isValid(m) {
    if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some$1.call(flags.parsedDateParts, function (i) {
            return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) &&
            flags.overflow < 0 &&
            !flags.empty &&
            !flags.invalidMonth &&
            !flags.invalidWeekday &&
            !flags.nullInput &&
            !flags.invalidFormat &&
            !flags.userInvalidated &&
            (!flags.meridiem || (flags.meridiem && parsedParts));

        if (m._strict) {
            isNowValid = isNowValid &&
                flags.charsLeftOver === 0 &&
                flags.unusedTokens.length === 0 &&
                flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        }
        else {
            return isNowValid;
        }
    }
    return m._isValid;
}

function createInvalid (flags) {
    var m = createUTC(NaN);
    if (flags != null) {
        extend(getParsingFlags(m), flags);
    }
    else {
        getParsingFlags(m).userInvalidated = true;
    }

    return m;
}

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties = hooks.momentProperties = [];

function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
        to._i = from._i;
    }
    if (!isUndefined(from._f)) {
        to._f = from._f;
    }
    if (!isUndefined(from._l)) {
        to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
        to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
        to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
        to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
                to[prop] = val;
            }
        }
    }

    return to;
}

var updateInProgress = false;

// Moment prototype object
function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
        this._d = new Date(NaN);
    }
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
    }
}

function isMoment (obj) {
    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
}

function absFloor (number) {
    if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
    } else {
        return Math.floor(number);
    }
}

function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
    }

    return value;
}

// compare two arrays, return the number of differences
function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
        if ((dontConvert && array1[i] !== array2[i]) ||
            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
            diffs++;
        }
    }
    return diffs + lengthDiff;
}

function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false &&
            (typeof console !==  'undefined') && console.warn) {
        console.warn('Deprecation warning: ' + msg);
    }
}

function deprecate(msg, fn) {
    var firstTime = true;

    return extend(function () {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
            var args = [];
            var arg;
            for (var i = 0; i < arguments.length; i++) {
                arg = '';
                if (typeof arguments[i] === 'object') {
                    arg += '\n[' + i + '] ';
                    for (var key in arguments[0]) {
                        arg += key + ': ' + arguments[0][key] + ', ';
                    }
                    arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                    arg = arguments[i];
                }
                args.push(arg);
            }
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
            firstTime = false;
        }
        return fn.apply(this, arguments);
    }, fn);
}

var deprecations = {};

function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
    }
}

hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}

function set (config) {
    var prop, i;
    for (i in config) {
        prop = config[i];
        if (isFunction(prop)) {
            this[i] = prop;
        } else {
            this['_' + i] = prop;
        }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in next major release.
    this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
            '|' + (/\d{1,2}/).source);
}

function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig), prop;
    for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
            } else {
                delete res[prop];
            }
        }
    }
    for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend({}, res[prop]);
        }
    }
    return res;
}

function Locale(config) {
    if (config != null) {
        this.set(config);
    }
}

var keys;

if (Object.keys) {
    keys = Object.keys;
} else {
    keys = function (obj) {
        var i, res = [];
        for (i in obj) {
            if (hasOwnProp(obj, i)) {
                res.push(i);
            }
        }
        return res;
    };
}

var keys$1 = keys;

var defaultCalendar = {
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    nextWeek : 'dddd [at] LT',
    lastDay : '[Yesterday at] LT',
    lastWeek : '[Last] dddd [at] LT',
    sameElse : 'L'
};

function calendar (key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
}

var defaultLongDateFormat = {
    LTS  : 'h:mm:ss A',
    LT   : 'h:mm A',
    L    : 'MM/DD/YYYY',
    LL   : 'MMMM D, YYYY',
    LLL  : 'MMMM D, YYYY h:mm A',
    LLLL : 'dddd, MMMM D, YYYY h:mm A'
};

function longDateFormat (key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
        return format;
    }

    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
    });

    return this._longDateFormat[key];
}

var defaultInvalidDate = 'Invalid date';

function invalidDate () {
    return this._invalidDate;
}

var defaultOrdinal = '%d';
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

function ordinal (number) {
    return this._ordinal.replace('%d', number);
}

var defaultRelativeTime = {
    future : 'in %s',
    past   : '%s ago',
    s  : 'a few seconds',
    ss : '%d seconds',
    m  : 'a minute',
    mm : '%d minutes',
    h  : 'an hour',
    hh : '%d hours',
    d  : 'a day',
    dd : '%d days',
    M  : 'a month',
    MM : '%d months',
    y  : 'a year',
    yy : '%d years'
};

function relativeTime (number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return (isFunction(output)) ?
        output(number, withoutSuffix, string, isFuture) :
        output.replace(/%d/i, number);
}

function pastFuture (diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}

var aliases = {};

function addUnitAlias (unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}

function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
            }
        }
    }

    return normalizedInput;
}

var priorities = {};

function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
}

function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
        units.push({unit: u, priority: priorities[u]});
    }
    units.sort(function (a, b) {
        return a.priority - b.priority;
    });
    return units;
}

function makeGetSet (unit, keepTime) {
    return function (value) {
        if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
        } else {
            return get(this, unit);
        }
    };
}

function get (mom, unit) {
    return mom.isValid() ?
        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
}

function set$1 (mom, unit, value) {
    if (mom.isValid()) {
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }
}

// MOMENTS

function stringGet (units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
        return this[units]();
    }
    return this;
}


function stringSet (units, value) {
    if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);
        for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
        }
    } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units](value);
        }
    }
    return this;
}

function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? (forceSign ? '+' : '') : '-') +
        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}

var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

var formatFunctions = {};

var formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken (token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
        func = function () {
            return this[callback]();
        };
    }
    if (token) {
        formatTokenFunctions[token] = func;
    }
    if (padded) {
        formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
    }
    if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        };
    }
}

function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
}

function makeFormatFunction(format) {
    var array = format.match(formattingTokens), i, length;

    for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
        } else {
            array[i] = removeFormattingTokens(array[i]);
        }
    }

    return function (mom) {
        var output = '', i;
        for (i = 0; i < length; i++) {
            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }
        return output;
    };
}

// format date using native date object
function formatMoment(m, format) {
    if (!m.isValid()) {
        return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

    return formatFunctions[format](m);
}

function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
    }

    return format;
}

var match1         = /\d/;            //       0 - 9
var match2         = /\d\d/;          //      00 - 99
var match3         = /\d{3}/;         //     000 - 999
var match4         = /\d{4}/;         //    0000 - 9999
var match6         = /[+-]?\d{6}/;    // -999999 - 999999
var match1to2      = /\d\d?/;         //       0 - 99
var match3to4      = /\d\d\d\d?/;     //     999 - 9999
var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3      = /\d{1,3}/;       //       0 - 999
var match1to4      = /\d{1,4}/;       //       0 - 9999
var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

var matchUnsigned  = /\d+/;           //       0 - inf
var matchSigned    = /[+-]?\d+/;      //    -inf - inf

var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


var regexes = {};

function addRegexToken (token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return (isStrict && strictRegex) ? strictRegex : regex;
    };
}

function getParseRegexForToken (token, config) {
    if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
}

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
    }));
}

function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

var tokens = {};

function addParseToken (token, callback) {
    var i, func = callback;
    if (typeof token === 'string') {
        token = [token];
    }
    if (isNumber(callback)) {
        func = function (input, array) {
            array[callback] = toInt(input);
        };
    }
    for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
    }
}

function addWeekParseToken (token, callback) {
    addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
    });
}

function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
    }
}

var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;

var indexOf;

if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
} else {
    indexOf = function (o) {
        // I know
        var i;
        for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
                return i;
            }
        }
        return -1;
    };
}

var indexOf$1 = indexOf;

function daysInMonth(year, month) {
    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
}

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
});

addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
});

addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
});

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M',    match1to2);
addRegexToken('MM',   match1to2, match2);
addRegexToken('MMM',  function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
});
addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
});

addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
});

addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
        array[MONTH] = month;
    } else {
        getParsingFlags(config).invalidMonth = input;
    }
});

// LOCALES

var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths (m, format) {
    if (!m) {
        return isArray(this._months) ? this._months :
            this._months['standalone'];
    }
    return isArray(this._months) ? this._months[m.month()] :
        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}

var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort (m, format) {
    if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort :
            this._monthsShort['standalone'];
    }
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}

function handleStrictParse(monthName, format, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeMonthsParse (monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
        }
    }
}

// MOMENTS

function setMonth (mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
        // No op
        return mom;
    }

    if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
            value = toInt(value);
        } else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber(value)) {
                return mom;
            }
        }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
}

function getSetMonth (value) {
    if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
    } else {
        return get(this, 'Month');
    }
}

function getDaysInMonth () {
    return daysInMonth(this.year(), this.month());
}

var defaultMonthsShortRegex = matchWord;
function monthsShortRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsShortStrictRegex;
        } else {
            return this._monthsShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ?
            this._monthsShortStrictRegex : this._monthsShortRegex;
    }
}

var defaultMonthsRegex = matchWord;
function monthsRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsStrictRegex;
        } else {
            return this._monthsRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ?
            this._monthsStrictRegex : this._monthsRegex;
    }
}

function computeMonthsParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom;
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
}

// FORMATTING

addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
});

addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
});

addFormatToken(0, ['YYYY',   4],       0, 'year');
addFormatToken(0, ['YYYYY',  5],       0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

addUnitAlias('year', 'y');

// PRIORITIES

addUnitPriority('year', 1);

// PARSING

addRegexToken('Y',      matchSigned);
addRegexToken('YY',     match1to2, match2);
addRegexToken('YYYY',   match1to4, match4);
addRegexToken('YYYYY',  match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);

addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
});

// HELPERS

function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
}

function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}

// HOOKS

hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};

// MOMENTS

var getSetYear = makeGetSet('FullYear', true);

function getIsLeapYear () {
    return isLeapYear(this.year());
}

function createDate (y, m, d, h, M, s, ms) {
    // can't just apply() to create a date:
    // https://stackoverflow.com/q/181348
    var date = new Date(y, m, d, h, M, s, ms);

    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
        date.setFullYear(y);
    }
    return date;
}

function createUTCDate (y) {
    var date = new Date(Date.UTC.apply(null, arguments));

    // the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
    }
    return date;
}

// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy,
        // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

    return -fwdlw + fwd - 1;
}

// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear, resDayOfYear;

    if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
    } else {
        resYear = year;
        resDayOfYear = dayOfYear;
    }

    return {
        year: resYear,
        dayOfYear: resDayOfYear
    };
}

function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek, resYear;

    if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
    } else {
        resYear = mom.year();
        resWeek = week;
    }

    return {
        week: resWeek,
        year: resYear
    };
}

function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// FORMATTING

addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');

// PRIORITIES

addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);

// PARSING

addRegexToken('w',  match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W',  match1to2);
addRegexToken('WW', match1to2, match2);

addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
});

// HELPERS

// LOCALES

function localeWeek (mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
}

var defaultLocaleWeek = {
    dow : 0, // Sunday is the first day of the week.
    doy : 6  // The week that contains Jan 1st is the first week of the year.
};

function localeFirstDayOfWeek () {
    return this._week.dow;
}

function localeFirstDayOfYear () {
    return this._week.doy;
}

// MOMENTS

function getSetWeek (input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
}

function getSetISOWeek (input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
}

// FORMATTING

addFormatToken('d', 0, 'do', 'day');

addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
});

addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
});

addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
});

addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');

// PRIORITY
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);

// PARSING

addRegexToken('d',    match1to2);
addRegexToken('e',    match1to2);
addRegexToken('E',    match1to2);
addRegexToken('dd',   function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
});
addRegexToken('ddd',   function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
});
addRegexToken('dddd',   function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
});

addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
        week.d = weekday;
    } else {
        getParsingFlags(config).invalidWeekday = input;
    }
});

addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
});

// HELPERS

function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
        return input;
    }

    if (!isNaN(input)) {
        return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
        return input;
    }

    return null;
}

function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
}

// LOCALES

var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays (m, format) {
    if (!m) {
        return isArray(this._weekdays) ? this._weekdays :
            this._weekdays['standalone'];
    }
    return isArray(this._weekdays) ? this._weekdays[m.day()] :
        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
}

var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort (m) {
    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}

var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin (m) {
    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}

function handleStrictParse$1(weekdayName, format, strict) {
    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeWeekdaysParse (weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already

        mom = createUTC([2000, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
        }
        if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
        }
    }
}

// MOMENTS

function getSetDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
    } else {
        return day;
    }
}

function getSetLocaleDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
}

function getSetISODayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
        return this.day() || 7;
    }
}

var defaultWeekdaysRegex = matchWord;
function weekdaysRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysStrictRegex;
        } else {
            return this._weekdaysRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ?
            this._weekdaysStrictRegex : this._weekdaysRegex;
    }
}

var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysShortStrictRegex;
        } else {
            return this._weekdaysShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ?
            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
}

var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysMinStrictRegex;
        } else {
            return this._weekdaysMinRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ?
            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
}


function computeWeekdaysParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom, minp, shortp, longp;
    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;

    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
}

// FORMATTING

function hFormat() {
    return this.hours() % 12 || 12;
}

function kFormat() {
    return this.hours() || 24;
}

addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);

addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});

addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
});

addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

function meridiem (token, lowercase) {
    addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
}

meridiem('a', true);
meridiem('A', false);

// ALIASES

addUnitAlias('hour', 'h');

// PRIORITY
addUnitPriority('hour', 13);

// PARSING

function matchMeridiem (isStrict, locale) {
    return locale._meridiemParse;
}

addRegexToken('a',  matchMeridiem);
addRegexToken('A',  matchMeridiem);
addRegexToken('H',  match1to2);
addRegexToken('h',  match1to2);
addRegexToken('k',  match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);
addRegexToken('kk', match1to2, match2);

addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);

addParseToken(['H', 'HH'], HOUR);
addParseToken(['k', 'kk'], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
});
addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
});

// LOCALES

function localeIsPM (input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return ((input + '').toLowerCase().charAt(0) === 'p');
}

var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours, minutes, isLower) {
    if (hours > 11) {
        return isLower ? 'pm' : 'PM';
    } else {
        return isLower ? 'am' : 'AM';
    }
}


// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour = makeGetSet('Hours', true);

// months
// week
// weekdays
// meridiem
var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,

    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,

    week: defaultLocaleWeek,

    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,

    meridiemParse: defaultLocaleMeridiemParse
};

// internal storage for locale config files
var locales = {};
var localeFamilies = {};
var globalLocale;

function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0, j, next, locale, split;

    while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
                return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
            }
            j--;
        }
        i++;
    }
    return null;
}

function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] && (typeof module !== 'undefined') &&
            module && module.exports) {
        try {
            oldLocale = globalLocale._abbr;
            !(function webpackMissingModule() { var e = new Error("Cannot find module \"./locale\""); e.code = 'MODULE_NOT_FOUND'; throw e; }());
            // because defineLocale currently also sets the global locale, we
            // want to undo that for lazy loaded locales
            getSetGlobalLocale(oldLocale);
        } catch (e) { }
    }
    return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function getSetGlobalLocale (key, values) {
    var data;
    if (key) {
        if (isUndefined(values)) {
            data = getLocale(key);
        }
        else {
            data = defineLocale(key, values);
        }

        if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
        }
    }

    return globalLocale._abbr;
}

function defineLocale (name, config) {
    if (config !== null) {
        var parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                });
                return null;
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);


        return locales[name];
    } else {
        // useful for testing
        delete locales[name];
        return null;
    }
}

function updateLocale(name, config) {
    if (config != null) {
        var locale, parentConfig = baseConfig;
        // MERGE
        if (locales[name] != null) {
            parentConfig = locales[name]._config;
        }
        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;

        // backwards compat for now: also set the locale
        getSetGlobalLocale(name);
    } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
                delete locales[name];
            }
        }
    }
    return locales[name];
}

// returns locale data
function getLocale (key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
    }

    if (!key) {
        return globalLocale;
    }

    if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);
        if (locale) {
            return locale;
        }
        key = [key];
    }

    return chooseLocale(key);
}

function listLocales() {
    return keys$1(locales);
}

function checkOverflow (m) {
    var overflow;
    var a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
        overflow =
            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
            -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
    }

    return m;
}

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

var isoDates = [
    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
    ['YYYY-DDD', /\d{4}-\d{3}/],
    ['YYYY-MM', /\d{4}-\d\d/, false],
    ['YYYYYYMMDD', /[+-]\d{10}/],
    ['YYYYMMDD', /\d{8}/],
    // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/],
    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
    ['YYYYDDD', /\d{7}/]
];

// iso time formats and regexes
var isoTimes = [
    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
    ['HH:mm', /\d\d:\d\d/],
    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
    ['HHmmss', /\d\d\d\d\d\d/],
    ['HHmm', /\d\d\d\d/],
    ['HH', /\d\d/]
];

var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
function configFromISO(config) {
    var i, l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime, dateFormat, timeFormat, tzFormat;

    if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
            }
        }
        if (dateFormat == null) {
            config._isValid = false;
            return;
        }
        if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                    // match[2] should be 'T' or space
                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (timeFormat == null) {
                config._isValid = false;
                return;
            }
        }
        if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
        }
        if (match[4]) {
            if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
            } else {
                config._isValid = false;
                return;
            }
        }
        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
    } else {
        config._isValid = false;
    }
}

// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
var basicRfcRegex = /^((?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d?\d\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(?:\d\d)?\d\d\s)(\d\d:\d\d)(\:\d\d)?(\s(?:UT|GMT|[ECMP][SD]T|[A-IK-Za-ik-z]|[+-]\d{4}))$/;

// date and time from ref 2822 format
function configFromRFC2822(config) {
    var string, match, dayFormat,
        dateFormat, timeFormat, tzFormat;
    var timezones = {
        ' GMT': ' +0000',
        ' EDT': ' -0400',
        ' EST': ' -0500',
        ' CDT': ' -0500',
        ' CST': ' -0600',
        ' MDT': ' -0600',
        ' MST': ' -0700',
        ' PDT': ' -0700',
        ' PST': ' -0800'
    };
    var military = 'YXWVUTSRQPONZABCDEFGHIKLM';
    var timezone, timezoneIndex;

    string = config._i
        .replace(/\([^\)]*\)|[\n\t]/g, ' ') // Remove comments and folding whitespace
        .replace(/(\s\s+)/g, ' ') // Replace multiple-spaces with a single space
        .replace(/^\s|\s$/g, ''); // Remove leading and trailing spaces
    match = basicRfcRegex.exec(string);

    if (match) {
        dayFormat = match[1] ? 'ddd' + ((match[1].length === 5) ? ', ' : ' ') : '';
        dateFormat = 'D MMM ' + ((match[2].length > 10) ? 'YYYY ' : 'YY ');
        timeFormat = 'HH:mm' + (match[4] ? ':ss' : '');

        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        if (match[1]) { // day of week given
            var momentDate = new Date(match[2]);
            var momentDay = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][momentDate.getDay()];

            if (match[1].substr(0,3) !== momentDay) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return;
            }
        }

        switch (match[5].length) {
            case 2: // military
                if (timezoneIndex === 0) {
                    timezone = ' +0000';
                } else {
                    timezoneIndex = military.indexOf(match[5][1].toUpperCase()) - 12;
                    timezone = ((timezoneIndex < 0) ? ' -' : ' +') +
                        (('' + timezoneIndex).replace(/^-?/, '0')).match(/..$/)[0] + '00';
                }
                break;
            case 4: // Zone
                timezone = timezones[match[5]];
                break;
            default: // UT or +/-9999
                timezone = timezones[' GMT'];
        }
        match[5] = timezone;
        config._i = match.splice(1).join('');
        tzFormat = ' ZZ';
        config._f = dayFormat + dateFormat + timeFormat + tzFormat;
        configFromStringAndFormat(config);
        getParsingFlags(config).rfc2822 = true;
    } else {
        config._isValid = false;
    }
}

// date from iso format or fallback
function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
    }

    configFromISO(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    configFromRFC2822(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    // Final attempt, use Input Fallback
    hooks.createFromInputFallback(config);
}

hooks.createFromInputFallback = deprecate(
    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
    'discouraged and will be removed in an upcoming major release. Please refer to ' +
    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
    function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }
);

// Pick the first defined of two or three arguments.
function defaults(a, b, c) {
    if (a != null) {
        return a;
    }
    if (b != null) {
        return b;
    }
    return c;
}

function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray (config) {
    var i, date, input = [], currentDate, yearToUse;

    if (config._d) {
        return;
    }

    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }

    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
        config._a[HOUR] = 24;
    }
}

function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;

        // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
        }
    } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;

        var curWeek = weekOfYear(createLocal(), dow, doy);

        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

        // Default to current week.
        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
            }
        } else if (w.e != null) {
            // local weekday -- counting starts from begining of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
            }
        } else {
            // default to begining of week
            weekday = dow;
        }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
    } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
}

// constant that refers to the ISO standard
hooks.ISO_8601 = function () {};

// constant that refers to the RFC 2822 form
hooks.RFC_2822 = function () {};

// date from string and format string
function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
    }
    if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
        i, parsedInput, tokens, token, skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;

    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));
        if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
        }
        // don't parse if it's not a known token
        if (formatTokenFunctions[token]) {
            if (parsedInput) {
                getParsingFlags(config).empty = false;
            }
            else {
                getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
        }
        else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
        }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 &&
        getParsingFlags(config).bigHour === true &&
        config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

    configFromArray(config);
    checkOverflow(config);
}


function meridiemFixWrap (locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
        // nothing to do
        return hour;
    }
    if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
            hour += 12;
        }
        if (!isPm && hour === 12) {
            hour = 0;
        }
        return hour;
    } else {
        // this is not supposed to happen
        return hour;
    }
}

// date from string and array of format strings
function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,

        scoreToBeat,
        i,
        currentScore;

    if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
    }

    for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
            continue;
        }

        // if there is any input that was not parsed add a penalty for that format
        currentScore += getParsingFlags(tempConfig).charsLeftOver;

        //or tokens
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
        }
    }

    extend(config, bestMoment || tempConfig);
}

function configFromObject(config) {
    if (config._d) {
        return;
    }

    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
    });

    configFromArray(config);
}

function createFromConfig (config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
    }

    return res;
}

function prepareConfig (config) {
    var input = config._i,
        format = config._f;

    config._locale = config._locale || getLocale(config._l);

    if (input === null || (format === undefined && input === '')) {
        return createInvalid({nullInput: true});
    }

    if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
        return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
        config._d = input;
    } else if (isArray(format)) {
        configFromStringAndArray(config);
    } else if (format) {
        configFromStringAndFormat(config);
    }  else {
        configFromInput(config);
    }

    if (!isValid(config)) {
        config._d = null;
    }

    return config;
}

function configFromInput(config) {
    var input = config._i;
    if (isUndefined(input)) {
        config._d = new Date(hooks.now());
    } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
        configFromString(config);
    } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10);
        });
        configFromArray(config);
    } else if (isObject(input)) {
        configFromObject(config);
    } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
    } else {
        hooks.createFromInputFallback(config);
    }
}

function createLocalOrUTC (input, format, locale, strict, isUTC) {
    var c = {};

    if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
    }

    if ((isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)) {
        input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;

    return createFromConfig(c);
}

function createLocal (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
}

var prototypeMin = deprecate(
    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

var prototypeMax = deprecate(
    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
    }
    if (!moments.length) {
        return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
        }
    }
    return res;
}

// TODO: Use [].sort instead?
function min () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isBefore', args);
}

function max () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isAfter', args);
}

var now = function () {
    return Date.now ? Date.now() : +(new Date());
};

var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

function isDurationValid(m) {
    for (var key in m) {
        if (!(ordering.indexOf(key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
        }
    }

    var unitHasDecimal = false;
    for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
            if (unitHasDecimal) {
                return false; // only allow non-integers for smallest unit
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
            }
        }
    }

    return true;
}

function isValid$1() {
    return this._isValid;
}

function createInvalid$1() {
    return createDuration(NaN);
}

function Duration (duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;

    this._isValid = isDurationValid(normalizedInput);

    // representation for dateAddRemove
    this._milliseconds = +milliseconds +
        seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days +
        weeks * 7;
    // It is impossible translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months +
        quarters * 3 +
        years * 12;

    this._data = {};

    this._locale = getLocale();

    this._bubble();
}

function isDuration (obj) {
    return obj instanceof Duration;
}

function absRound (number) {
    if (number < 0) {
        return Math.round(-1 * number) * -1;
    } else {
        return Math.round(number);
    }
}

// FORMATTING

function offset (token, separator) {
    addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
            offset = -offset;
            sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
    });
}

offset('Z', ':');
offset('ZZ', '');

// PARSING

addRegexToken('Z',  matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
});

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher);

    if (matches === null) {
        return null;
    }

    var chunk   = matches[matches.length - 1] || [];
    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);

    return minutes === 0 ?
      0 :
      parts[0] === '+' ? minutes : -minutes;
}

// Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        // Use low-level api, because this fn is low-level api.
        res._d.setTime(res._d.valueOf() + diff);
        hooks.updateOffset(res, false);
        return res;
    } else {
        return createLocal(input).local();
    }
}

function getDateOffset (m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
hooks.updateOffset = function () {};

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset (input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    if (input != null) {
        if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
                return this;
            }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
            this.add(localAdjust, 'm');
        }
        if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
            }
        }
        return this;
    } else {
        return this._isUTC ? offset : getDateOffset(this);
    }
}

function getSetZone (input, keepLocalTime) {
    if (input != null) {
        if (typeof input !== 'string') {
            input = -input;
        }

        this.utcOffset(input, keepLocalTime);

        return this;
    } else {
        return -this.utcOffset();
    }
}

function setOffsetToUTC (keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
}

function setOffsetToLocal (keepLocalTime) {
    if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
        }
    }
    return this;
}

function setOffsetToParsedOffset () {
    if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
            this.utcOffset(tZone);
        }
        else {
            this.utcOffset(0, true);
        }
    }
    return this;
}

function hasAlignedHourOffset (input) {
    if (!this.isValid()) {
        return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;

    return (this.utcOffset() - input) % 60 === 0;
}

function isDaylightSavingTime () {
    return (
        this.utcOffset() > this.clone().month(0).utcOffset() ||
        this.utcOffset() > this.clone().month(5).utcOffset()
    );
}

function isDaylightSavingTimeShifted () {
    if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
    }

    var c = {};

    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() &&
            compareArrays(c._a, other.toArray()) > 0;
    } else {
        this._isDSTShifted = false;
    }

    return this._isDSTShifted;
}

function isLocal () {
    return this.isValid() ? !this._isUTC : false;
}

function isUtcOffset () {
    return this.isValid() ? this._isUTC : false;
}

function isUtc () {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
}

// ASP.NET json date format regex
var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

function createDuration (input, key) {
    var duration = input,
        // matching against regexp is expensive, do it on demand
        match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
        duration = {
            ms : input._milliseconds,
            d  : input._days,
            M  : input._months
        };
    } else if (isNumber(input)) {
        duration = {};
        if (key) {
            duration[key] = input;
        } else {
            duration.milliseconds = input;
        }
    } else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y  : 0,
            d  : toInt(match[DATE])                         * sign,
            h  : toInt(match[HOUR])                         * sign,
            m  : toInt(match[MINUTE])                       * sign,
            s  : toInt(match[SECOND])                       * sign,
            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
        };
    } else if (!!(match = isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y : parseIso(match[2], sign),
            M : parseIso(match[3], sign),
            w : parseIso(match[4], sign),
            d : parseIso(match[5], sign),
            h : parseIso(match[6], sign),
            m : parseIso(match[7], sign),
            s : parseIso(match[8], sign)
        };
    } else if (duration == null) {// checks for null or undefined
        duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
    }

    return ret;
}

createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;

function parseIso (inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
}

function positiveMomentsDifference(base, other) {
    var res = {milliseconds: 0, months: 0};

    res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
    }

    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

    return res;
}

function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
        return {milliseconds: 0, months: 0};
    }

    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
    } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
    }

    return res;
}

// TODO: remove 'name' arg after deprecation is removed
function createAdder(direction, name) {
    return function (val, period) {
        var dur, tmp;
        //invert the arguments, but complain about it
        if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val; val = period; period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
    };
}

function addSubtract (mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
        // No op
        return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }
    if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
    }
    if (updateOffset) {
        hooks.updateOffset(mom, days || months);
    }
}

var add      = createAdder(1, 'add');
var subtract = createAdder(-1, 'subtract');

function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' :
            diff < -1 ? 'lastWeek' :
            diff < 0 ? 'lastDay' :
            diff < 1 ? 'sameDay' :
            diff < 2 ? 'nextDay' :
            diff < 7 ? 'nextWeek' : 'sameElse';
}

function calendar$1 (time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse';

    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
}

function clone () {
    return new Moment(this);
}

function isAfter (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
    } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
}

function isBefore (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
    } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
}

function isBetween (from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
}

function isSame (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
    } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
}

function isSameOrAfter (input, units) {
    return this.isSame(input, units) || this.isAfter(input,units);
}

function isSameOrBefore (input, units) {
    return this.isSame(input, units) || this.isBefore(input,units);
}

function diff (input, units, asFloat) {
    var that,
        zoneDelta,
        delta, output;

    if (!this.isValid()) {
        return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
        return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

    units = normalizeUnits(units);

    if (units === 'year' || units === 'month' || units === 'quarter') {
        output = monthDiff(this, that);
        if (units === 'quarter') {
            output = output / 3;
        } else if (units === 'year') {
            output = output / 12;
        }
    } else {
        delta = this - that;
        output = units === 'second' ? delta / 1e3 : // 1000
            units === 'minute' ? delta / 6e4 : // 1000 * 60
            units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
            units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
            units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
            delta;
    }
    return asFloat ? output : absFloor(output);
}

function monthDiff (a, b) {
    // difference in months
    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2, adjust;

    if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor - anchor2);
    } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
}

hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

function toString () {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
}

function toISOString() {
    if (!this.isValid()) {
        return null;
    }
    var m = this.clone().utc();
    if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
    }
    if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        return this.toDate().toISOString();
    }
    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
}

/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function inspect () {
    if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
    }
    var func = 'moment';
    var zone = '';
    if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
    }
    var prefix = '[' + func + '("]';
    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
    var suffix = zone + '[")]';

    return this.format(prefix + year + datetime + suffix);
}

function format (inputString) {
    if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
}

function from (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function fromNow (withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
}

function to (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function toNow (withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
}

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale (key) {
    var newLocaleData;

    if (key === undefined) {
        return this._locale._abbr;
    } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
            this._locale = newLocaleData;
        }
        return this;
    }
}

var lang = deprecate(
    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
    function (key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    }
);

function localeData () {
    return this._locale;
}

function startOf (units) {
    units = normalizeUnits(units);
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
    }

    // weeks are a special case
    if (units === 'week') {
        this.weekday(0);
    }
    if (units === 'isoWeek') {
        this.isoWeekday(1);
    }

    // quarters are also special
    if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
    }

    return this;
}

function endOf (units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
        return this;
    }

    // 'date' is an alias for 'day', so it should be considered as such.
    if (units === 'date') {
        units = 'day';
    }

    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
}

function valueOf () {
    return this._d.valueOf() - ((this._offset || 0) * 60000);
}

function unix () {
    return Math.floor(this.valueOf() / 1000);
}

function toDate () {
    return new Date(this.valueOf());
}

function toArray () {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}

function toObject () {
    var m = this;
    return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
    };
}

function toJSON () {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
}

function isValid$2 () {
    return isValid(this);
}

function parsingFlags () {
    return extend({}, getParsingFlags(this));
}

function invalidAt () {
    return getParsingFlags(this).overflow;
}

function creationData() {
    return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
    };
}

// FORMATTING

addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
});

addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
});

function addWeekYearFormatToken (token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
}

addWeekYearFormatToken('gggg',     'weekYear');
addWeekYearFormatToken('ggggg',    'weekYear');
addWeekYearFormatToken('GGGG',  'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);


// PARSING

addRegexToken('G',      matchSigned);
addRegexToken('g',      matchSigned);
addRegexToken('GG',     match1to2, match2);
addRegexToken('gg',     match1to2, match2);
addRegexToken('GGGG',   match1to4, match4);
addRegexToken('gggg',   match1to4, match4);
addRegexToken('GGGGG',  match1to6, match6);
addRegexToken('ggggg',  match1to6, match6);

addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
});

addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
});

// MOMENTS

function getSetWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy);
}

function getSetISOWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input, this.isoWeek(), this.isoWeekday(), 1, 4);
}

function getISOWeeksInYear () {
    return weeksInYear(this.year(), 1, 4);
}

function getWeeksInYear () {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}

function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
        return weekOfYear(this, dow, doy).year;
    } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
            week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
}

function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
}

// FORMATTING

addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

addUnitAlias('quarter', 'Q');

// PRIORITY

addUnitPriority('quarter', 7);

// PARSING

addRegexToken('Q', match1);
addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
});

// MOMENTS

function getSetQuarter (input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}

// FORMATTING

addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

addUnitAlias('date', 'D');

// PRIOROITY
addUnitPriority('date', 9);

// PARSING

addRegexToken('D',  match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ?
      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
      locale._dayOfMonthOrdinalParseLenient;
});

addParseToken(['D', 'DD'], DATE);
addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0], 10);
});

// MOMENTS

var getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
addUnitPriority('dayOfYear', 4);

// PARSING

addRegexToken('DDD',  match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
});

// HELPERS

// MOMENTS

function getSetDayOfYear (input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
}

// FORMATTING

addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

addUnitAlias('minute', 'm');

// PRIORITY

addUnitPriority('minute', 14);

// PARSING

addRegexToken('m',  match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

var getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

addUnitAlias('second', 's');

// PRIORITY

addUnitPriority('second', 15);

// PARSING

addRegexToken('s',  match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);

// MOMENTS

var getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
});

addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
});

addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
});


// ALIASES

addUnitAlias('millisecond', 'ms');

// PRIORITY

addUnitPriority('millisecond', 16);

// PARSING

addRegexToken('S',    match1to3, match1);
addRegexToken('SS',   match1to3, match2);
addRegexToken('SSS',  match1to3, match3);

var token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
}

function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
}

for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
}
// MOMENTS

var getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

addFormatToken('z',  0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

function getZoneAbbr () {
    return this._isUTC ? 'UTC' : '';
}

function getZoneName () {
    return this._isUTC ? 'Coordinated Universal Time' : '';
}

var proto = Moment.prototype;

proto.add               = add;
proto.calendar          = calendar$1;
proto.clone             = clone;
proto.diff              = diff;
proto.endOf             = endOf;
proto.format            = format;
proto.from              = from;
proto.fromNow           = fromNow;
proto.to                = to;
proto.toNow             = toNow;
proto.get               = stringGet;
proto.invalidAt         = invalidAt;
proto.isAfter           = isAfter;
proto.isBefore          = isBefore;
proto.isBetween         = isBetween;
proto.isSame            = isSame;
proto.isSameOrAfter     = isSameOrAfter;
proto.isSameOrBefore    = isSameOrBefore;
proto.isValid           = isValid$2;
proto.lang              = lang;
proto.locale            = locale;
proto.localeData        = localeData;
proto.max               = prototypeMax;
proto.min               = prototypeMin;
proto.parsingFlags      = parsingFlags;
proto.set               = stringSet;
proto.startOf           = startOf;
proto.subtract          = subtract;
proto.toArray           = toArray;
proto.toObject          = toObject;
proto.toDate            = toDate;
proto.toISOString       = toISOString;
proto.inspect           = inspect;
proto.toJSON            = toJSON;
proto.toString          = toString;
proto.unix              = unix;
proto.valueOf           = valueOf;
proto.creationData      = creationData;

// Year
proto.year       = getSetYear;
proto.isLeapYear = getIsLeapYear;

// Week Year
proto.weekYear    = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;

// Quarter
proto.quarter = proto.quarters = getSetQuarter;

// Month
proto.month       = getSetMonth;
proto.daysInMonth = getDaysInMonth;

// Week
proto.week           = proto.weeks        = getSetWeek;
proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
proto.weeksInYear    = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;

// Day
proto.date       = getSetDayOfMonth;
proto.day        = proto.days             = getSetDayOfWeek;
proto.weekday    = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear  = getSetDayOfYear;

// Hour
proto.hour = proto.hours = getSetHour;

// Minute
proto.minute = proto.minutes = getSetMinute;

// Second
proto.second = proto.seconds = getSetSecond;

// Millisecond
proto.millisecond = proto.milliseconds = getSetMillisecond;

// Offset
proto.utcOffset            = getSetOffset;
proto.utc                  = setOffsetToUTC;
proto.local                = setOffsetToLocal;
proto.parseZone            = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST                = isDaylightSavingTime;
proto.isLocal              = isLocal;
proto.isUtcOffset          = isUtcOffset;
proto.isUtc                = isUtc;
proto.isUTC                = isUtc;

// Timezone
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;

// Deprecations
proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

function createUnix (input) {
    return createLocal(input * 1000);
}

function createInZone () {
    return createLocal.apply(null, arguments).parseZone();
}

function preParsePostFormat (string) {
    return string;
}

var proto$1 = Locale.prototype;

proto$1.calendar        = calendar;
proto$1.longDateFormat  = longDateFormat;
proto$1.invalidDate     = invalidDate;
proto$1.ordinal         = ordinal;
proto$1.preparse        = preParsePostFormat;
proto$1.postformat      = preParsePostFormat;
proto$1.relativeTime    = relativeTime;
proto$1.pastFuture      = pastFuture;
proto$1.set             = set;

// Month
proto$1.months            =        localeMonths;
proto$1.monthsShort       =        localeMonthsShort;
proto$1.monthsParse       =        localeMonthsParse;
proto$1.monthsRegex       = monthsRegex;
proto$1.monthsShortRegex  = monthsShortRegex;

// Week
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;

// Day of Week
proto$1.weekdays       =        localeWeekdays;
proto$1.weekdaysMin    =        localeWeekdaysMin;
proto$1.weekdaysShort  =        localeWeekdaysShort;
proto$1.weekdaysParse  =        localeWeekdaysParse;

proto$1.weekdaysRegex       =        weekdaysRegex;
proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

// Hours
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$1 (format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
}

function listMonthsImpl (format, index, field) {
    if (isNumber(format)) {
        index = format;
        format = undefined;
    }

    format = format || '';

    if (index != null) {
        return get$1(format, index, field, 'month');
    }

    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
    }
    return out;
}

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function listWeekdaysImpl (localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0;

    if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
    }

    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }
    return out;
}

function listMonths (format, index) {
    return listMonthsImpl(format, index, 'months');
}

function listMonthsShort (format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
}

function listWeekdays (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
}

function listWeekdaysShort (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
}

function listWeekdaysMin (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
}

getSetGlobalLocale('en', {
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

// Side effect imports
hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

var mathAbs = Math.abs;

function abs () {
    var data           = this._data;

    this._milliseconds = mathAbs(this._milliseconds);
    this._days         = mathAbs(this._days);
    this._months       = mathAbs(this._months);

    data.milliseconds  = mathAbs(data.milliseconds);
    data.seconds       = mathAbs(data.seconds);
    data.minutes       = mathAbs(data.minutes);
    data.hours         = mathAbs(data.hours);
    data.months        = mathAbs(data.months);
    data.years         = mathAbs(data.years);

    return this;
}

function addSubtract$1 (duration, input, value, direction) {
    var other = createDuration(input, value);

    duration._milliseconds += direction * other._milliseconds;
    duration._days         += direction * other._days;
    duration._months       += direction * other._months;

    return duration._bubble();
}

// supports only 2.0-style add(1, 's') or add(duration)
function add$1 (input, value) {
    return addSubtract$1(this, input, value, 1);
}

// supports only 2.0-style subtract(1, 's') or subtract(duration)
function subtract$1 (input, value) {
    return addSubtract$1(this, input, value, -1);
}

function absCeil (number) {
    if (number < 0) {
        return Math.floor(number);
    } else {
        return Math.ceil(number);
    }
}

function bubble () {
    var milliseconds = this._milliseconds;
    var days         = this._days;
    var months       = this._months;
    var data         = this._data;
    var seconds, minutes, hours, years, monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
            (milliseconds <= 0 && days <= 0 && months <= 0))) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;

    seconds           = absFloor(milliseconds / 1000);
    data.seconds      = seconds % 60;

    minutes           = absFloor(seconds / 60);
    data.minutes      = minutes % 60;

    hours             = absFloor(minutes / 60);
    data.hours        = hours % 24;

    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    data.days   = days;
    data.months = months;
    data.years  = years;

    return this;
}

function daysToMonths (days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
}

function monthsToDays (months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
}

function as (units) {
    if (!this.isValid()) {
        return NaN;
    }
    var days;
    var months;
    var milliseconds = this._milliseconds;

    units = normalizeUnits(units);

    if (units === 'month' || units === 'year') {
        days   = this._days   + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        return units === 'month' ? months : months / 12;
    } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
            case 'week'   : return days / 7     + milliseconds / 6048e5;
            case 'day'    : return days         + milliseconds / 864e5;
            case 'hour'   : return days * 24    + milliseconds / 36e5;
            case 'minute' : return days * 1440  + milliseconds / 6e4;
            case 'second' : return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
            default: throw new Error('Unknown unit ' + units);
        }
    }
}

// TODO: Use this.as('ms')?
function valueOf$1 () {
    if (!this.isValid()) {
        return NaN;
    }
    return (
        this._milliseconds +
        this._days * 864e5 +
        (this._months % 12) * 2592e6 +
        toInt(this._months / 12) * 31536e6
    );
}

function makeAs (alias) {
    return function () {
        return this.as(alias);
    };
}

var asMilliseconds = makeAs('ms');
var asSeconds      = makeAs('s');
var asMinutes      = makeAs('m');
var asHours        = makeAs('h');
var asDays         = makeAs('d');
var asWeeks        = makeAs('w');
var asMonths       = makeAs('M');
var asYears        = makeAs('y');

function get$2 (units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + 's']() : NaN;
}

function makeGetter(name) {
    return function () {
        return this.isValid() ? this._data[name] : NaN;
    };
}

var milliseconds = makeGetter('milliseconds');
var seconds      = makeGetter('seconds');
var minutes      = makeGetter('minutes');
var hours        = makeGetter('hours');
var days         = makeGetter('days');
var months       = makeGetter('months');
var years        = makeGetter('years');

function weeks () {
    return absFloor(this.days() / 7);
}

var round = Math.round;
var thresholds = {
    ss: 44,         // a few seconds to seconds
    s : 45,         // seconds to minute
    m : 45,         // minutes to hour
    h : 22,         // hours to day
    d : 26,         // days to month
    M : 11          // months to year
};

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}

function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds  = round(duration.as('s'));
    var minutes  = round(duration.as('m'));
    var hours    = round(duration.as('h'));
    var days     = round(duration.as('d'));
    var months   = round(duration.as('M'));
    var years    = round(duration.as('y'));

    var a = seconds <= thresholds.ss && ['s', seconds]  ||
            seconds < thresholds.s   && ['ss', seconds] ||
            minutes <= 1             && ['m']           ||
            minutes < thresholds.m   && ['mm', minutes] ||
            hours   <= 1             && ['h']           ||
            hours   < thresholds.h   && ['hh', hours]   ||
            days    <= 1             && ['d']           ||
            days    < thresholds.d   && ['dd', days]    ||
            months  <= 1             && ['M']           ||
            months  < thresholds.M   && ['MM', months]  ||
            years   <= 1             && ['y']           || ['yy', years];

    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
}

// This function allows you to set the rounding function for relative time strings
function getSetRelativeTimeRounding (roundingFunction) {
    if (roundingFunction === undefined) {
        return round;
    }
    if (typeof(roundingFunction) === 'function') {
        round = roundingFunction;
        return true;
    }
    return false;
}

// This function allows you to set a threshold for relative time strings
function getSetRelativeTimeThreshold (threshold, limit) {
    if (thresholds[threshold] === undefined) {
        return false;
    }
    if (limit === undefined) {
        return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    if (threshold === 's') {
        thresholds.ss = limit - 1;
    }
    return true;
}

function humanize (withSuffix) {
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);

    if (withSuffix) {
        output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
}

var abs$1 = Math.abs;

function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var seconds = abs$1(this._milliseconds) / 1000;
    var days         = abs$1(this._days);
    var months       = abs$1(this._months);
    var minutes, hours, years;

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes           = absFloor(seconds / 60);
    hours             = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years  = absFloor(months / 12);
    months %= 12;


    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds;
    var total = this.asSeconds();

    if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
    }

    return (total < 0 ? '-' : '') +
        'P' +
        (Y ? Y + 'Y' : '') +
        (M ? M + 'M' : '') +
        (D ? D + 'D' : '') +
        ((h || m || s) ? 'T' : '') +
        (h ? h + 'H' : '') +
        (m ? m + 'M' : '') +
        (s ? s + 'S' : '');
}

var proto$2 = Duration.prototype;

proto$2.isValid        = isValid$1;
proto$2.abs            = abs;
proto$2.add            = add$1;
proto$2.subtract       = subtract$1;
proto$2.as             = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds      = asSeconds;
proto$2.asMinutes      = asMinutes;
proto$2.asHours        = asHours;
proto$2.asDays         = asDays;
proto$2.asWeeks        = asWeeks;
proto$2.asMonths       = asMonths;
proto$2.asYears        = asYears;
proto$2.valueOf        = valueOf$1;
proto$2._bubble        = bubble;
proto$2.get            = get$2;
proto$2.milliseconds   = milliseconds;
proto$2.seconds        = seconds;
proto$2.minutes        = minutes;
proto$2.hours          = hours;
proto$2.days           = days;
proto$2.weeks          = weeks;
proto$2.months         = months;
proto$2.years          = years;
proto$2.humanize       = humanize;
proto$2.toISOString    = toISOString$1;
proto$2.toString       = toISOString$1;
proto$2.toJSON         = toISOString$1;
proto$2.locale         = locale;
proto$2.localeData     = localeData;

// Deprecations
proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;

// Side effect imports

// FORMATTING

addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');

// PARSING

addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
});

// Side effect imports


hooks.version = '2.18.1';

setHookCallback(createLocal);

hooks.fn                    = proto;
hooks.min                   = min;
hooks.max                   = max;
hooks.now                   = now;
hooks.utc                   = createUTC;
hooks.unix                  = createUnix;
hooks.months                = listMonths;
hooks.isDate                = isDate;
hooks.locale                = getSetGlobalLocale;
hooks.invalid               = createInvalid;
hooks.duration              = createDuration;
hooks.isMoment              = isMoment;
hooks.weekdays              = listWeekdays;
hooks.parseZone             = createInZone;
hooks.localeData            = getLocale;
hooks.isDuration            = isDuration;
hooks.monthsShort           = listMonthsShort;
hooks.weekdaysMin           = listWeekdaysMin;
hooks.defineLocale          = defineLocale;
hooks.updateLocale          = updateLocale;
hooks.locales               = listLocales;
hooks.weekdaysShort         = listWeekdaysShort;
hooks.normalizeUnits        = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat        = getCalendarFormat;
hooks.prototype             = proto;

return hooks;

})));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(37)(module)))

/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 38 */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = __webpack_require__(4);
const HeaderConstants = constants_1.Constants.HeaderConstants;
const DEFAULT_AUTHORIZATION_SCHEME = 'Bearer';
/**
 * Creates a new TokenCredentials object.
 *
 * @constructor
 * @param {string} token               The token.
 * @param {string} authorizationScheme The authorization scheme.
 */
class TokenCredentials {
    constructor(token, authorizationScheme = DEFAULT_AUTHORIZATION_SCHEME) {
        this.authorizationScheme = DEFAULT_AUTHORIZATION_SCHEME;
        if (!token) {
            throw new Error('token cannot be null or undefined.');
        }
        this.token = token;
        this.authorizationScheme = authorizationScheme;
    }
    /**
     * Signs a request with the Authentication header.
     *
     * @param {WebResource} The WebResource to be signed.
     * @return {Promise<WebResource>} The signed request object.
     */
    signRequest(webResource) {
        if (!webResource.headers)
            webResource.headers = {};
        webResource.headers[HeaderConstants.AUTHORIZATION] = `${this.authorizationScheme} ${this.token}`;
        return Promise.resolve(webResource);
    }
}
exports.TokenCredentials = TokenCredentials;
//# sourceMappingURL=tokenCredentials.js.map

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = __webpack_require__(4);
const HeaderConstants = constants_1.Constants.HeaderConstants;
const DEFAULT_AUTHORIZATION_SCHEME = 'Basic';
/**
 * Creates a new BasicAuthenticationCredentials object.
 *
 * @constructor
 * @param {string} userName                 User name.
 * @param {string} password                 Password.
 * @param {string} [authorizationScheme]    The authorization scheme.
 */
class BasicAuthenticationCredentials {
    constructor(userName, password, authorizationScheme = DEFAULT_AUTHORIZATION_SCHEME) {
        this.authorizationScheme = DEFAULT_AUTHORIZATION_SCHEME;
        if (userName === null || userName === undefined || typeof userName.valueOf() !== 'string') {
            throw new Error('userName cannot be null or undefined and must be of type string.');
        }
        if (password === null || password === undefined || typeof password.valueOf() !== 'string') {
            throw new Error('password cannot be null or undefined and must be of type string.');
        }
        this.userName = userName;
        this.password = password;
        this.authorizationScheme = authorizationScheme;
    }
    /**
     * Signs a request with the Authentication header.
     *
     * @param {WebResource} The WebResource to be signed.
     * @returns {Promise<WebResource>} - The signed request object.
     */
    signRequest(webResource) {
        const credentials = `${this.userName}:${this.password}`;
        const encodedCredentials = `${this.authorizationScheme} ${Buffer.from(credentials).toString('base64')}`;
        if (!webResource.headers)
            webResource.headers = {};
        webResource.headers[HeaderConstants.AUTHORIZATION] = encodedCredentials;
        return Promise.resolve(webResource);
    }
}
exports.BasicAuthenticationCredentials = BasicAuthenticationCredentials;
//# sourceMappingURL=basicAuthenticationCredentials.js.map

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information. 
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = __webpack_require__(6);
const msRest = __webpack_require__(0);
const LroStates = constants_1.default.LongRunningOperationStates;
/**
 * @class
 * Initializes a new instance of the PollingState class.
 */
class PollingState {
    constructor(resultOfInitialRequest, retryTimeout = 30) {
        /**
         * @param {number} [retryTimeout] - The timeout in seconds to retry on intermediate operation results. Default Value is 30.
         */
        this.retryTimeout = 30;
        this.resultOfInitialRequest = resultOfInitialRequest;
        this.retryTimeout = retryTimeout;
        this.updateResponse(resultOfInitialRequest.response);
        this.request = resultOfInitialRequest.request;
        //Parse response.body & assign it as the resource
        try {
            if (resultOfInitialRequest.bodyAsText && resultOfInitialRequest.bodyAsText.length > 0) {
                this.resource = JSON.parse(resultOfInitialRequest.bodyAsText);
            }
            else {
                this.resource = resultOfInitialRequest.bodyAsJson;
            }
        }
        catch (error) {
            let deserializationError = new msRest.RestError(`Error "${error}" occurred in parsing the responseBody ' +
        'while creating the PollingState for Long Running Operation- "${resultOfInitialRequest.bodyAsText}"`);
            deserializationError.request = resultOfInitialRequest.request;
            deserializationError.response = resultOfInitialRequest.response;
            throw deserializationError;
        }
        switch (this.response.status) {
            case 202:
                this.status = LroStates.InProgress;
                break;
            case 204:
                this.status = LroStates.Succeeded;
                break;
            case 201:
                if (this.resource && this.resource.properties && this.resource.properties.provisioningState) {
                    this.status = this.resource.properties.provisioningState;
                }
                else {
                    this.status = LroStates.InProgress;
                }
                break;
            case 200:
                if (this.resource && this.resource.properties && this.resource.properties.provisioningState) {
                    this.status = this.resource.properties.provisioningState;
                }
                else {
                    this.status = LroStates.Succeeded;
                }
                break;
            default:
                this.status = LroStates.Failed;
                break;
        }
    }
    /**
     * Update cached data using the provided response object
     * @param {Response} [response] - provider response object.
     */
    updateResponse(response) {
        this.response = response;
        if (response && response.headers) {
            let asyncOperationHeader = response.headers.get('azure-asyncoperation');
            let locationHeader = response.headers.get('location');
            if (asyncOperationHeader) {
                this.azureAsyncOperationHeaderLink = asyncOperationHeader;
            }
            if (locationHeader) {
                this.locationHeaderLink = locationHeader;
            }
        }
    }
    /**
     * Gets timeout in milliseconds.
     * @returns {number} timeout
     */
    getTimeout() {
        if (this.retryTimeout || this.retryTimeout === 0) {
            return this.retryTimeout * 1000;
        }
        if (this.response) {
            let retryAfter = this.response.headers.get('retry-after');
            if (retryAfter) {
                return parseInt(retryAfter) * 1000;
            }
        }
        return 30 * 1000;
    }
    /**
     * Returns long running operation result.
     * @returns {msRest.HttpOperationResponse} HttpOperationResponse
     */
    getOperationResponse() {
        let result = new msRest.HttpOperationResponse(this.request, this.response, this.response.body);
        if (this.resource && typeof this.resource.valueOf() === 'string') {
            result.bodyAsText = this.resource;
            result.bodyAsJson = JSON.parse(this.resource);
        }
        else {
            result.bodyAsJson = this.resource;
            result.bodyAsText = JSON.stringify(this.resource);
        }
        return result;
    }
    /**
     * Returns an Error on operation failure.
     * @param {Error} err - The error object.
     * @returns {msRest.RestError} The RestError defined in the runtime.
     */
    getRestError(err) {
        let errMsg;
        let errCode = null;
        let error = new msRest.RestError('');
        error.request = msRest.stripRequest(this.request);
        error.response = this.response;
        let parsedResponse = this.resource;
        if (err && err.message) {
            errMsg = `Long running operation failed with error: "${err.message}".`;
        }
        else {
            errMsg = `Long running operation failed with status: "${this.status}".`;
        }
        if (parsedResponse) {
            if (parsedResponse.error && parsedResponse.error.message) {
                errMsg = `Long running operation failed with error: "${parsedResponse.error.message}".`;
            }
            if (parsedResponse.error && parsedResponse.error.code) {
                errCode = parsedResponse.error.code;
            }
        }
        error.message = errMsg;
        if (errCode)
            error.code = errCode;
        error.body = parsedResponse;
        return error;
    }
}
exports.default = PollingState;
//# sourceMappingURL=pollingState.js.map

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.CloudErrorMapper = {
    required: false,
    serializedName: 'CloudError',
    type: {
        name: 'Composite',
        className: 'CloudError',
        modelProperties: {
            code: {
                required: true,
                serializedName: 'code',
                type: {
                    name: 'String'
                }
            },
            message: {
                required: true,
                serializedName: 'message',
                type: {
                    name: 'String'
                }
            },
            target: {
                required: false,
                serializedName: 'target',
                type: {
                    name: 'String'
                }
            },
            details: {
                required: false,
                serializedName: 'details',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'CloudErrorElementType',
                        type: {
                            name: 'Composite',
                            className: 'CloudError'
                        }
                    }
                }
            }
        }
    }
};
//# sourceMappingURL=cloudError.js.map

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseResourceMapper = {
    required: false,
    serializedName: 'BaseResource',
    type: {
        name: 'Composite',
        className: 'BaseResource',
        modelProperties: {}
    }
};
//# sourceMappingURL=baseResource.js.map

/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__application__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__pool__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__account__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__job__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__certificateOperations__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__file__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__jobSchedule__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__task__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__computeNodeOperations__ = __webpack_require__(53);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_0__application__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return __WEBPACK_IMPORTED_MODULE_1__pool__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_2__account__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_3__job__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_4__certificateOperations__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_5__file__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return __WEBPACK_IMPORTED_MODULE_6__jobSchedule__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return __WEBPACK_IMPORTED_MODULE_7__task__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_8__computeNodeOperations__["a"]; });
/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */












/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__models_mappers__ = __webpack_require__(1);
/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


const WebResource = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["WebResource"];
/** Class representing a Application. */
class Application {
    /**
     * Create a Application.
     * @param {BatchServiceClient} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Lists all of the applications available in the specified account.
     *
     * This operation returns only applications and versions that are available for
     * use on compute nodes; that is, that can be used in an application package
     * reference. For administrator information about applications and versions
     * that are not yet available to compute nodes, use the Azure portal or the
     * Azure Resource Manager API.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.applicationListOptions] Additional parameters for
     * the operation
     *
     * @param {number} [options.applicationListOptions.maxResults] The maximum
     * number of items to return in the response. A maximum of 1000 applications
     * can be returned.
     *
     * @param {number} [options.applicationListOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.applicationListOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.applicationListOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.applicationListOptions.ocpDate] The time the request
     * was issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<ApplicationListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let applicationListOptions = (options && options.applicationListOptions !== undefined) ? options.applicationListOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (applicationListOptions !== null && applicationListOptions !== undefined) {
                    maxResults = applicationListOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (applicationListOptions !== null && applicationListOptions !== undefined) {
                    timeout = applicationListOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (applicationListOptions !== null && applicationListOptions !== undefined) {
                    clientRequestId = applicationListOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (applicationListOptions !== null && applicationListOptions !== undefined) {
                    returnClientRequestId = applicationListOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (applicationListOptions !== null && applicationListOptions !== undefined) {
                    ocpDate = applicationListOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'applications';
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (maxResults !== null && maxResults !== undefined) {
                queryParameters.push('maxresults=' + encodeURIComponent(maxResults.toString()));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["ApplicationListResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets information about the specified application.
     *
     * This operation returns only applications and versions that are available for
     * use on compute nodes; that is, that can be used in an application package
     * reference. For administrator information about applications and versions
     * that are not yet available to compute nodes, use the Azure portal or the
     * Azure Resource Manager API.
     *
     * @param {string} applicationId The ID of the application.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.applicationGetOptions] Additional parameters for
     * the operation
     *
     * @param {number} [options.applicationGetOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.applicationGetOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.applicationGetOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.applicationGetOptions.ocpDate] The time the request
     * was issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<ApplicationSummary>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(applicationId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let applicationGetOptions = (options && options.applicationGetOptions !== undefined) ? options.applicationGetOptions : undefined;
            // Validate
            try {
                if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
                    throw new Error('applicationId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (applicationGetOptions !== null && applicationGetOptions !== undefined) {
                    timeout = applicationGetOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (applicationGetOptions !== null && applicationGetOptions !== undefined) {
                    clientRequestId = applicationGetOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (applicationGetOptions !== null && applicationGetOptions !== undefined) {
                    returnClientRequestId = applicationGetOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (applicationGetOptions !== null && applicationGetOptions !== undefined) {
                    ocpDate = applicationGetOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'applications/{applicationId}';
            requestUrl = requestUrl.replace('{applicationId}', encodeURIComponent(applicationId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["ApplicationSummary"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the applications available in the specified account.
     *
     * This operation returns only applications and versions that are available for
     * use on compute nodes; that is, that can be used in an application package
     * reference. For administrator information about applications and versions
     * that are not yet available to compute nodes, use the Azure portal or the
     * Azure Resource Manager API.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.applicationListNextOptions] Additional parameters
     * for the operation
     *
     * @param {string} [options.applicationListNextOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.applicationListNextOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.applicationListNextOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<ApplicationListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let applicationListNextOptions = (options && options.applicationListNextOptions !== undefined) ? options.applicationListNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (applicationListNextOptions !== null && applicationListNextOptions !== undefined) {
                    clientRequestId = applicationListNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (applicationListNextOptions !== null && applicationListNextOptions !== undefined) {
                    returnClientRequestId = applicationListNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (applicationListNextOptions !== null && applicationListNextOptions !== undefined) {
                    ocpDate = applicationListNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["ApplicationListResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    list(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.listWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    get(applicationId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(applicationId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.getWithHttpOperationResponse(applicationId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.listNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Application;



/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__models_mappers__ = __webpack_require__(1);
/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


const WebResource = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["WebResource"];
/** Class representing a Pool. */
class Pool {
    /**
     * Create a Pool.
     * @param {BatchServiceClient} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Lists the usage metrics, aggregated by pool across individual time
     * intervals, for the specified account.
     *
     * If you do not specify a $filter clause including a poolId, the response
     * includes all pools that existed in the account in the time range of the
     * returned aggregation intervals. If you do not specify a $filter clause
     * including a startTime or endTime these filters default to the start and end
     * times of the last aggregation interval currently available; that is, only
     * the last aggregation interval is returned.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolListUsageMetricsOptions] Additional parameters
     * for the operation
     *
     * @param {date} [options.poolListUsageMetricsOptions.startTime] The earliest
     * time from which to include metrics. This must be at least two and a half
     * hours before the current time. If not specified this defaults to the start
     * time of the last aggregation interval currently available.
     *
     * @param {date} [options.poolListUsageMetricsOptions.endTime] The latest time
     * from which to include metrics. This must be at least two hours before the
     * current time. If not specified this defaults to the end time of the last
     * aggregation interval currently available.
     *
     * @param {string} [options.poolListUsageMetricsOptions.filter] An OData
     * $filter clause. If this is not specified the response includes all pools
     * that existed in the account in the time range of the returned aggregation
     * intervals.
     *
     * @param {number} [options.poolListUsageMetricsOptions.maxResults] The maximum
     * number of items to return in the response. A maximum of 1000 results will be
     * returned.
     *
     * @param {number} [options.poolListUsageMetricsOptions.timeout] The maximum
     * time that the server can spend processing the request, in seconds. The
     * default is 30 seconds.
     *
     * @param {string} [options.poolListUsageMetricsOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolListUsageMetricsOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.poolListUsageMetricsOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<PoolListUsageMetricsResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listUsageMetricsWithHttpOperationResponse(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolListUsageMetricsOptions = (options && options.poolListUsageMetricsOptions !== undefined) ? options.poolListUsageMetricsOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let startTime;
            let endTime;
            let filter;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    startTime = poolListUsageMetricsOptions.startTime;
                    if (startTime && !(startTime instanceof Date ||
                        (typeof startTime.valueOf() === 'string' && !isNaN(Date.parse(startTime))))) {
                        throw new Error('startTime must be of type date.');
                    }
                }
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    endTime = poolListUsageMetricsOptions.endTime;
                    if (endTime && !(endTime instanceof Date ||
                        (typeof endTime.valueOf() === 'string' && !isNaN(Date.parse(endTime))))) {
                        throw new Error('endTime must be of type date.');
                    }
                }
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    filter = poolListUsageMetricsOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    maxResults = poolListUsageMetricsOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    timeout = poolListUsageMetricsOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    clientRequestId = poolListUsageMetricsOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    returnClientRequestId = poolListUsageMetricsOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined) {
                    ocpDate = poolListUsageMetricsOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'poolusagemetrics';
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (startTime !== null && startTime !== undefined) {
                queryParameters.push('starttime=' + encodeURIComponent(__WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["serializeObject"](startTime)));
            }
            if (endTime !== null && endTime !== undefined) {
                queryParameters.push('endtime=' + encodeURIComponent(__WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["serializeObject"](endTime)));
            }
            if (filter !== null && filter !== undefined) {
                queryParameters.push('$filter=' + encodeURIComponent(filter));
            }
            if (maxResults !== null && maxResults !== undefined) {
                queryParameters.push('maxresults=' + encodeURIComponent(maxResults.toString()));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["PoolListUsageMetricsResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets lifetime summary statistics for all of the pools in the
     * specified account.
     *
     * Statistics are aggregated across all pools that have ever existed in the
     * account, from account creation to the last update time of the statistics.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolGetAllLifetimeStatisticsOptions] Additional
     * parameters for the operation
     *
     * @param {number} [options.poolGetAllLifetimeStatisticsOptions.timeout] The
     * maximum time that the server can spend processing the request, in seconds.
     * The default is 30 seconds.
     *
     * @param {string}
     * [options.poolGetAllLifetimeStatisticsOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean}
     * [options.poolGetAllLifetimeStatisticsOptions.returnClientRequestId] Whether
     * the server should return the client-request-id in the response.
     *
     * @param {date} [options.poolGetAllLifetimeStatisticsOptions.ocpDate] The time
     * the request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<PoolStatistics>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getAllLifetimeStatisticsWithHttpOperationResponse(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolGetAllLifetimeStatisticsOptions = (options && options.poolGetAllLifetimeStatisticsOptions !== undefined) ? options.poolGetAllLifetimeStatisticsOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolGetAllLifetimeStatisticsOptions !== null && poolGetAllLifetimeStatisticsOptions !== undefined) {
                    timeout = poolGetAllLifetimeStatisticsOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolGetAllLifetimeStatisticsOptions !== null && poolGetAllLifetimeStatisticsOptions !== undefined) {
                    clientRequestId = poolGetAllLifetimeStatisticsOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolGetAllLifetimeStatisticsOptions !== null && poolGetAllLifetimeStatisticsOptions !== undefined) {
                    returnClientRequestId = poolGetAllLifetimeStatisticsOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolGetAllLifetimeStatisticsOptions !== null && poolGetAllLifetimeStatisticsOptions !== undefined) {
                    ocpDate = poolGetAllLifetimeStatisticsOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'lifetimepoolstats';
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["PoolStatistics"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Adds a pool to the specified account.
     *
     * When naming pools, avoid including sensitive information such as user names
     * or secret project names. This information may appear in telemetry logs
     * accessible to Microsoft Support engineers.
     *
     * @param {object} pool The pool to be added.
     *
     * @param {string} pool.id A string that uniquely identifies the pool within
     * the account. The ID can contain any combination of alphanumeric characters
     * including hyphens and underscores, and cannot contain more than 64
     * characters. The ID is case-preserving and case-insensitive (that is, you may
     * not have two pool IDs within an account that differ only by case).
     *
     * @param {string} [pool.displayName] The display name for the pool. The
     * display name need not be unique and can contain any Unicode characters up to
     * a maximum length of 1024.
     *
     * @param {string} pool.vmSize The size of virtual machines in the pool. All
     * virtual machines in a pool are the same size. For information about
     * available sizes of virtual machines for Cloud Services pools (pools created
     * with cloudServiceConfiguration), see Sizes for Cloud Services
     * (http://azure.microsoft.com/documentation/articles/cloud-services-sizes-specs/).
     * Batch supports all Cloud Services VM sizes except ExtraSmall, A1V2 and A2V2.
     * For information about available VM sizes for pools using images from the
     * Virtual Machines Marketplace (pools created with
     * virtualMachineConfiguration) see Sizes for Virtual Machines (Linux)
     * (https://azure.microsoft.com/documentation/articles/virtual-machines-linux-sizes/)
     * or Sizes for Virtual Machines (Windows)
     * (https://azure.microsoft.com/documentation/articles/virtual-machines-windows-sizes/).
     * Batch supports all Azure VM sizes except STANDARD_A0 and those with premium
     * storage (STANDARD_GS, STANDARD_DS, and STANDARD_DSV2 series).
     *
     * @param {object} [pool.cloudServiceConfiguration] The cloud service
     * configuration for the pool. This property and virtualMachineConfiguration
     * are mutually exclusive and one of the properties must be specified. This
     * property cannot be specified if the Batch account was created with its
     * poolAllocationMode property set to 'UserSubscription'.
     *
     * @param {string} pool.cloudServiceConfiguration.osFamily The Azure Guest OS
     * family to be installed on the virtual machines in the pool. Possible values
     * are: 2 - OS Family 2, equivalent to Windows Server 2008 R2 SP1. 3 - OS
     * Family 3, equivalent to Windows Server 2012. 4 - OS Family 4, equivalent to
     * Windows Server 2012 R2. 5 - OS Family 5, equivalent to Windows Server 2016.
     * For more information, see Azure Guest OS Releases
     * (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
     *
     * @param {string} [pool.cloudServiceConfiguration.targetOSVersion] The Azure
     * Guest OS version to be installed on the virtual machines in the pool. The
     * default value is * which specifies the latest operating system version for
     * the specified OS family.
     *
     * @param {string} [pool.cloudServiceConfiguration.currentOSVersion] The Azure
     * Guest OS Version currently installed on the virtual machines in the pool.
     * This may differ from targetOSVersion if the pool state is Upgrading. In this
     * case some virtual machines may be on the targetOSVersion and some may be on
     * the currentOSVersion during the upgrade process. Once all virtual machines
     * have upgraded, currentOSVersion is updated to be the same as
     * targetOSVersion.
     *
     * @param {object} [pool.virtualMachineConfiguration] The virtual machine
     * configuration for the pool. This property and cloudServiceConfiguration are
     * mutually exclusive and one of the properties must be specified.
     *
     * @param {object} [pool.virtualMachineConfiguration.imageReference] A
     * reference to the Azure Virtual Machines Marketplace image to use. This
     * property and osDisk are mutually exclusive and one of the properties must be
     * specified.
     *
     * @param {string} pool.virtualMachineConfiguration.imageReference.publisher
     * The publisher of the Azure Virtual Machines Marketplace image. For example,
     * Canonical or MicrosoftWindowsServer.
     *
     * @param {string} pool.virtualMachineConfiguration.imageReference.offer The
     * offer type of the Azure Virtual Machines Marketplace image. For example,
     * UbuntuServer or WindowsServer.
     *
     * @param {string} pool.virtualMachineConfiguration.imageReference.sku The SKU
     * of the Azure Virtual Machines Marketplace image. For example, 14.04.0-LTS or
     * 2012-R2-Datacenter.
     *
     * @param {string} [pool.virtualMachineConfiguration.imageReference.version]
     * The version of the Azure Virtual Machines Marketplace image. A value of
     * 'latest' can be specified to select the latest version of an image. If
     * omitted, the default is 'latest'.
     *
     * @param {object} [pool.virtualMachineConfiguration.osDisk] A reference to the
     * OS disk image to use. This property can be specified only if the Batch
     * account was created with its poolAllocationMode property set to
     * 'UserSubscription'. This property and imageReference are mutually exclusive
     * and one of the properties must be specified.
     *
     * @param {array} pool.virtualMachineConfiguration.osDisk.imageUris The
     * collection of Virtual Hard Disk (VHD) URIs. All the VHDs must be identical
     * and must reside in an Azure Storage account within the same subscription and
     * same region as the Batch account. For best performance, it is recommended
     * that each VHD resides in a separate Azure Storage account. Each VHD can
     * serve upto 20 Windows compute nodes or 40 Linux compute nodes. You must
     * supply enough VHD URIs to satisfy the 'targetDedicated' property of the
     * pool. If you do not supply enough VHD URIs, the pool will partially allocate
     * compute nodes, and a resize error will occur.
     *
     * @param {string} [pool.virtualMachineConfiguration.osDisk.caching] The type
     * of caching to enable for the OS disk. Values are:
     *
     * none - The caching mode for the disk is not enabled.
     * readOnly - The caching mode for the disk is read only.
     * readWrite - The caching mode for the disk is read and write.
     *
     * The default value for caching is none. For information about the caching
     * options see:
     * https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/27/exploring-windows-azure-drives-disks-and-images/.
     * Possible values include: 'none', 'readOnly', 'readWrite'
     *
     * @param {string} pool.virtualMachineConfiguration.nodeAgentSKUId The SKU of
     * the Batch node agent to be provisioned on compute nodes in the pool. The
     * Batch node agent is a program that runs on each node in the pool, and
     * provides the command-and-control interface between the node and the Batch
     * service. There are different implementations of the node agent, known as
     * SKUs, for different operating systems. You must specify a node agent SKU
     * which matches the selected image reference. To get the list of supported
     * node agent SKUs along with their list of verified image references, see the
     * 'List supported node agent SKUs' operation.
     *
     * @param {object} [pool.virtualMachineConfiguration.windowsConfiguration]
     * Windows operating system settings on the virtual machine. This property must
     * not be specified if the imageReference or osDisk property specifies a Linux
     * OS image.
     *
     * @param {boolean}
     * [pool.virtualMachineConfiguration.windowsConfiguration.enableAutomaticUpdates]
     * Whether automatic updates are enabled on the virtual machine. If omitted,
     * the default value is true.
     *
     * @param {moment.duration} [pool.resizeTimeout] The timeout for allocation of
     * compute nodes to the pool. This timeout applies only to manual scaling; it
     * has no effect when enableAutoScale is set to true. The default value is 15
     * minutes. The minimum value is 5 minutes. If you specify a value less than 5
     * minutes, the Batch service returns an error; if you are calling the REST API
     * directly, the HTTP status code is 400 (Bad Request).
     *
     * @param {number} [pool.targetDedicatedNodes] The desired number of dedicated
     * compute nodes in the pool. This property must not be specified if
     * enableAutoScale is set to true. If enableAutoScale is set to false, then you
     * must set either targetDedicatedNodes, targetLowPriorityNodes, or both.
     *
     * @param {number} [pool.targetLowPriorityNodes] The desired number of
     * low-priority compute nodes in the pool. This property must not be specified
     * if enableAutoScale is set to true. If enableAutoScale is set to false, then
     * you must set either targetDedicatedNodes, targetLowPriorityNodes, or both.
     *
     * @param {boolean} [pool.enableAutoScale] Whether the pool size should
     * automatically adjust over time. If false, at least one of
     * targetDedicateNodes and targetLowPriorityNodes must be specified. If true,
     * the autoScaleFormula property is required and the pool automatically resizes
     * according to the formula. The default value is false.
     *
     * @param {string} [pool.autoScaleFormula] A formula for the desired number of
     * compute nodes in the pool. This property must not be specified if
     * enableAutoScale is set to false. It is required if enableAutoScale is set to
     * true. The formula is checked for validity before the pool is created. If the
     * formula is not valid, the Batch service rejects the request with detailed
     * error information. For more information about specifying this formula, see
     * 'Automatically scale compute nodes in an Azure Batch pool'
     * (https://azure.microsoft.com/documentation/articles/batch-automatic-scaling/).
     *
     * @param {moment.duration} [pool.autoScaleEvaluationInterval] The time
     * interval at which to automatically adjust the pool size according to the
     * autoscale formula. The default value is 15 minutes. The minimum and maximum
     * value are 5 minutes and 168 hours respectively. If you specify a value less
     * than 5 minutes or greater than 168 hours, the Batch service returns an
     * error; if you are calling the REST API directly, the HTTP status code is 400
     * (Bad Request).
     *
     * @param {boolean} [pool.enableInterNodeCommunication] Whether the pool
     * permits direct communication between nodes. Enabling inter-node
     * communication limits the maximum size of the pool due to deployment
     * restrictions on the nodes of the pool. This may result in the pool not
     * reaching its desired size. The default value is false.
     *
     * @param {object} [pool.networkConfiguration] The network configuration for
     * the pool.
     *
     * @param {string} [pool.networkConfiguration.subnetId] The ARM resource
     * identifier of the virtual network subnet which the compute nodes of the pool
     * will join. This is of the form
     * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
     * The virtual network must be in the same region and subscription as the Azure
     * Batch account. The specified subnet should have enough free IP addresses to
     * accommodate the number of nodes in the pool. If the subnet doesn't have
     * enough free IP addresses, the pool will partially allocate compute nodes,
     * and a resize error will occur. The 'MicrosoftAzureBatch' service principal
     * must have the 'Classic Virtual Machine Contributor' Role-Based Access
     * Control (RBAC) role for the specified VNet. The specified subnet must allow
     * communication from the Azure Batch service to be able to schedule tasks on
     * the compute nodes. This can be verified by checking if the specified VNet
     * has any associated Network Security Groups (NSG). If communication to the
     * compute nodes in the specified subnet is denied by an NSG, then the Batch
     * service will set the state of the compute nodes to unusable. For pools
     * created via virtualMachineConfiguration the Batch account must have
     * poolAllocationMode userSubscription in order to use a VNet. If the specified
     * VNet has any associated Network Security Groups (NSG), then a few reserved
     * system ports must be enabled for inbound communication. For pools created
     * with a virtual machine configuration, enable ports 29876 and 29877, as well
     * as port 22 for Linux and port 3389 for Windows. For pools created with a
     * cloud service configuration, enable ports 10100, 20100, and 30100. Also
     * enable outbound connections to Azure Storage on port 443. For more details
     * see:
     * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration
     *
     * @param {object} [pool.networkConfiguration.endpointConfiguration] The
     * configuration for endpoints on compute nodes in the Batch pool. Pool
     * endpoint configuration is only supported on pools with the
     * virtualMachineConfiguration property.
     *
     * @param {array}
     * pool.networkConfiguration.endpointConfiguration.inboundNATPools A list of
     * inbound NAT pools that can be used to address specific ports on an
     * individual compute node externally. The maximum number of inbound NAT pools
     * per Batch pool is 5. If the maximum number of inbound NAT pools is exceeded
     * the request fails with HTTP status code 400.
     *
     * @param {object} [pool.startTask] A task specified to run on each compute
     * node as it joins the pool. The task runs when the node is added to the pool
     * or when the node is restarted.
     *
     * @param {string} pool.startTask.commandLine The command line of the start
     * task. The command line does not run under a shell, and therefore cannot take
     * advantage of shell features such as environment variable expansion. If you
     * want to take advantage of such features, you should invoke the shell in the
     * command line, for example using "cmd /c MyCommand" in Windows or "/bin/sh -c
     * MyCommand" in Linux.
     *
     * @param {array} [pool.startTask.resourceFiles] A list of files that the Batch
     * service will download to the compute node before running the command line.
     * Files listed under this element are located in the task's working directory.
     *
     * @param {array} [pool.startTask.environmentSettings] A list of environment
     * variable settings for the start task.
     *
     * @param {object} [pool.startTask.userIdentity] The user identity under which
     * the start task runs. If omitted, the task runs as a non-administrative user
     * unique to the task.
     *
     * @param {string} [pool.startTask.userIdentity.userName] The name of the user
     * identity under which the task is run. The userName and autoUser properties
     * are mutually exclusive; you must specify one but not both.
     *
     * @param {object} [pool.startTask.userIdentity.autoUser] The auto user under
     * which the task is run. The userName and autoUser properties are mutually
     * exclusive; you must specify one but not both.
     *
     * @param {string} [pool.startTask.userIdentity.autoUser.scope] The scope for
     * the auto user Values are:
     *
     * pool - specifies that the task runs as the common auto user account which is
     * created on every node in a pool.
     * task - specifies that the service should create a new user for the task.
     * The default value is task. Possible values include: 'task', 'pool'
     *
     * @param {string} [pool.startTask.userIdentity.autoUser.elevationLevel] The
     * elevation level of the auto user. nonAdmin - The auto user is a standard
     * user without elevated access. admin - The auto user is a user with elevated
     * access and operates with full Administrator permissions. The default value
     * is nonAdmin. Possible values include: 'nonAdmin', 'admin'
     *
     * @param {number} [pool.startTask.maxTaskRetryCount] The maximum number of
     * times the task may be retried. The Batch service retries a task if its exit
     * code is nonzero. Note that this value specifically controls the number of
     * retries. The Batch service will try the task once, and may then retry up to
     * this limit. For example, if the maximum retry count is 3, Batch tries the
     * task up to 4 times (one initial try and 3 retries). If the maximum retry
     * count is 0, the Batch service does not retry the task. If the maximum retry
     * count is -1, the Batch service retries the task without limit.
     *
     * @param {boolean} [pool.startTask.waitForSuccess] Whether the Batch service
     * should wait for the start task to complete successfully (that is, to exit
     * with exit code 0) before scheduling any tasks on the compute node. If true
     * and the start task fails on a compute node, the Batch service retries the
     * start task up to its maximum retry count (maxTaskRetryCount). If the task
     * has still not completed successfully after all retries, then the Batch
     * service marks the compute node unusable, and will not schedule tasks to it.
     * This condition can be detected via the node state and failure info details.
     * If false, the Batch service will not wait for the start task to complete. In
     * this case, other tasks can start executing on the compute node while the
     * start task is still running; and even if the start task fails, new tasks
     * will continue to be scheduled on the node. The default is false.
     *
     * @param {array} [pool.certificateReferences] The list of certificates to be
     * installed on each compute node in the pool. For Windows compute nodes, the
     * Batch service installs the certificates to the specified certificate store
     * and location. For Linux compute nodes, the certificates are stored in a
     * directory inside the task working directory and an environment variable
     * AZ_BATCH_CERTIFICATES_DIR is supplied to the task to query for this
     * location. For certificates with visibility of 'remoteUser', a 'certs'
     * directory is created in the user's home directory (e.g.,
     * /home/{user-name}/certs) and certificates are placed in that directory.
     *
     * @param {array} [pool.applicationPackageReferences] The list of application
     * packages to be installed on each compute node in the pool.
     *
     * @param {array} [pool.applicationLicenses] The list of application licenses
     * the Batch service will make available on each compute node in the pool. The
     * list of application licenses must be a subset of available Batch service
     * application licenses. If a license is requested which is not supported, pool
     * creation will fail.
     *
     * @param {number} [pool.maxTasksPerNode] The maximum number of tasks that can
     * run concurrently on a single compute node in the pool. The default value is
     * 1. The maximum value of this setting depends on the size of the compute
     * nodes in the pool (the vmSize setting).
     *
     * @param {object} [pool.taskSchedulingPolicy] How tasks are distributed across
     * compute nodes in a pool.
     *
     * @param {string} pool.taskSchedulingPolicy.nodeFillType How tasks are
     * distributed across compute nodes in a pool. Values are:
     *
     * pack - As many tasks as possible (maxTasksPerNode) should be assigned to
     * each node in the pool before any tasks are assigned to the next node in the
     * pool.
     * spread - Tasks should be assigned evenly across all nodes in the pool.
     * Possible values include: 'spread', 'pack'
     *
     * @param {array} [pool.userAccounts] The list of user accounts to be created
     * on each node in the pool.
     *
     * @param {array} [pool.metadata] A list of name-value pairs associated with
     * the pool as metadata. The Batch service does not assign any meaning to
     * metadata; it is solely for the use of user code.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolAddOptions] Additional parameters for the
     * operation
     *
     * @param {number} [options.poolAddOptions.timeout] The maximum time that the
     * server can spend processing the request, in seconds. The default is 30
     * seconds.
     *
     * @param {string} [options.poolAddOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolAddOptions.returnClientRequestId] Whether the
     * server should return the client-request-id in the response.
     *
     * @param {date} [options.poolAddOptions.ocpDate] The time the request was
     * issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addWithHttpOperationResponse(pool, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolAddOptions = (options && options.poolAddOptions !== undefined) ? options.poolAddOptions : undefined;
            // Validate
            try {
                if (pool === null || pool === undefined) {
                    throw new Error('pool cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolAddOptions !== null && poolAddOptions !== undefined) {
                    timeout = poolAddOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolAddOptions !== null && poolAddOptions !== undefined) {
                    clientRequestId = poolAddOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolAddOptions !== null && poolAddOptions !== undefined) {
                    returnClientRequestId = poolAddOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolAddOptions !== null && poolAddOptions !== undefined) {
                    ocpDate = poolAddOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools';
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (pool !== null && pool !== undefined) {
                    let requestModelMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["PoolAddParameter"];
                    requestModel = client.serializer.serialize(requestModelMapper, pool, 'pool');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(pool, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 201) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the pools in the specified account.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolListOptions] Additional parameters for the
     * operation
     *
     * @param {string} [options.poolListOptions.filter] An OData $filter clause.
     *
     * @param {string} [options.poolListOptions.select] An OData $select clause.
     *
     * @param {string} [options.poolListOptions.expand] An OData $expand clause.
     *
     * @param {number} [options.poolListOptions.maxResults] The maximum number of
     * items to return in the response. A maximum of 1000 pools can be returned.
     *
     * @param {number} [options.poolListOptions.timeout] The maximum time that the
     * server can spend processing the request, in seconds. The default is 30
     * seconds.
     *
     * @param {string} [options.poolListOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolListOptions.returnClientRequestId] Whether the
     * server should return the client-request-id in the response.
     *
     * @param {date} [options.poolListOptions.ocpDate] The time the request was
     * issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<CloudPoolListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolListOptions = (options && options.poolListOptions !== undefined) ? options.poolListOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let select;
            let expand;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    filter = poolListOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    select = poolListOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    expand = poolListOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    maxResults = poolListOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    timeout = poolListOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    clientRequestId = poolListOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    returnClientRequestId = poolListOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolListOptions !== null && poolListOptions !== undefined) {
                    ocpDate = poolListOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools';
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (filter !== null && filter !== undefined) {
                queryParameters.push('$filter=' + encodeURIComponent(filter));
            }
            if (select !== null && select !== undefined) {
                queryParameters.push('$select=' + encodeURIComponent(select));
            }
            if (expand !== null && expand !== undefined) {
                queryParameters.push('$expand=' + encodeURIComponent(expand));
            }
            if (maxResults !== null && maxResults !== undefined) {
                queryParameters.push('maxresults=' + encodeURIComponent(maxResults.toString()));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["CloudPoolListResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Deletes a pool from the specified account.
     *
     * When you request that a pool be deleted, the following actions occur: the
     * pool state is set to deleting; any ongoing resize operation on the pool are
     * stopped; the Batch service starts resizing the pool to zero nodes; any tasks
     * running on existing nodes are terminated and requeued (as if a resize pool
     * operation had been requested with the default requeue option); finally, the
     * pool is removed from the system. Because running tasks are requeued, the
     * user can rerun these tasks by updating their job to target a different pool.
     * The tasks can then run on the new pool. If you want to override the requeue
     * behavior, then you should call resize pool explicitly to shrink the pool to
     * zero size before deleting the pool. If you call an Update, Patch or Delete
     * API on a pool in the deleting state, it will fail with HTTP status code 409
     * with error code PoolBeingDeleted.
     *
     * @param {string} poolId The ID of the pool to delete.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolDeleteMethodOptions] Additional parameters for
     * the operation
     *
     * @param {number} [options.poolDeleteMethodOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.poolDeleteMethodOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolDeleteMethodOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.poolDeleteMethodOptions.ocpDate] The time the request
     * was issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.poolDeleteMethodOptions.ifMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.
     *
     * @param {string} [options.poolDeleteMethodOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.poolDeleteMethodOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.poolDeleteMethodOptions.ifUnmodifiedSince] A
     * timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service
     * has not been modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(poolId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolDeleteMethodOptions = (options && options.poolDeleteMethodOptions !== undefined) ? options.poolDeleteMethodOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    timeout = poolDeleteMethodOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    clientRequestId = poolDeleteMethodOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    returnClientRequestId = poolDeleteMethodOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    ocpDate = poolDeleteMethodOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    ifMatch = poolDeleteMethodOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    ifNoneMatch = poolDeleteMethodOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    ifModifiedSince = poolDeleteMethodOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined) {
                    ifUnmodifiedSince = poolDeleteMethodOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'DELETE';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets basic properties of a pool.
     *
     * @param {string} poolId The ID of the pool to get.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolExistsOptions] Additional parameters for the
     * operation
     *
     * @param {number} [options.poolExistsOptions.timeout] The maximum time that
     * the server can spend processing the request, in seconds. The default is 30
     * seconds.
     *
     * @param {string} [options.poolExistsOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolExistsOptions.returnClientRequestId] Whether
     * the server should return the client-request-id in the response.
     *
     * @param {date} [options.poolExistsOptions.ocpDate] The time the request was
     * issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.poolExistsOptions.ifMatch] An ETag value associated
     * with the version of the resource known to the client. The operation will be
     * performed only if the resource's current ETag on the service exactly matches
     * the value specified by the client.
     *
     * @param {string} [options.poolExistsOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.poolExistsOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.poolExistsOptions.ifUnmodifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has not been
     * modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<boolean>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    existsWithHttpOperationResponse(poolId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolExistsOptions = (options && options.poolExistsOptions !== undefined) ? options.poolExistsOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    timeout = poolExistsOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    clientRequestId = poolExistsOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    returnClientRequestId = poolExistsOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    ocpDate = poolExistsOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    ifMatch = poolExistsOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    ifNoneMatch = poolExistsOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    ifModifiedSince = poolExistsOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolExistsOptions !== null && poolExistsOptions !== undefined) {
                    ifUnmodifiedSince = poolExistsOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'HEAD';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200 && statusCode !== 404) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                operationRes.bodyAsJson = (statusCode === 200);
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets information about the specified pool.
     *
     * @param {string} poolId The ID of the pool to get.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolGetOptions] Additional parameters for the
     * operation
     *
     * @param {string} [options.poolGetOptions.select] An OData $select clause.
     *
     * @param {string} [options.poolGetOptions.expand] An OData $expand clause.
     *
     * @param {number} [options.poolGetOptions.timeout] The maximum time that the
     * server can spend processing the request, in seconds. The default is 30
     * seconds.
     *
     * @param {string} [options.poolGetOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolGetOptions.returnClientRequestId] Whether the
     * server should return the client-request-id in the response.
     *
     * @param {date} [options.poolGetOptions.ocpDate] The time the request was
     * issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.poolGetOptions.ifMatch] An ETag value associated
     * with the version of the resource known to the client. The operation will be
     * performed only if the resource's current ETag on the service exactly matches
     * the value specified by the client.
     *
     * @param {string} [options.poolGetOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.poolGetOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.poolGetOptions.ifUnmodifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has not been
     * modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<CloudPool>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(poolId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolGetOptions = (options && options.poolGetOptions !== undefined) ? options.poolGetOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let select;
            let expand;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    select = poolGetOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    expand = poolGetOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    timeout = poolGetOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    clientRequestId = poolGetOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    returnClientRequestId = poolGetOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    ocpDate = poolGetOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    ifMatch = poolGetOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    ifNoneMatch = poolGetOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    ifModifiedSince = poolGetOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolGetOptions !== null && poolGetOptions !== undefined) {
                    ifUnmodifiedSince = poolGetOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (select !== null && select !== undefined) {
                queryParameters.push('$select=' + encodeURIComponent(select));
            }
            if (expand !== null && expand !== undefined) {
                queryParameters.push('$expand=' + encodeURIComponent(expand));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["CloudPool"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Updates the properties of the specified pool.
     *
     * This only replaces the pool properties specified in the request. For
     * example, if the pool has a start task associated with it, and a request does
     * not specify a start task element, then the pool keeps the existing start
     * task.
     *
     * @param {string} poolId The ID of the pool to update.
     *
     * @param {object} poolPatchParameter The parameters for the request.
     *
     * @param {object} [poolPatchParameter.startTask] A task to run on each compute
     * node as it joins the pool. The task runs when the node is added to the pool
     * or when the node is restarted. If this element is present, it overwrites any
     * existing start task. If omitted, any existing start task is left unchanged.
     *
     * @param {string} poolPatchParameter.startTask.commandLine The command line of
     * the start task. The command line does not run under a shell, and therefore
     * cannot take advantage of shell features such as environment variable
     * expansion. If you want to take advantage of such features, you should invoke
     * the shell in the command line, for example using "cmd /c MyCommand" in
     * Windows or "/bin/sh -c MyCommand" in Linux.
     *
     * @param {array} [poolPatchParameter.startTask.resourceFiles] A list of files
     * that the Batch service will download to the compute node before running the
     * command line. Files listed under this element are located in the task's
     * working directory.
     *
     * @param {array} [poolPatchParameter.startTask.environmentSettings] A list of
     * environment variable settings for the start task.
     *
     * @param {object} [poolPatchParameter.startTask.userIdentity] The user
     * identity under which the start task runs. If omitted, the task runs as a
     * non-administrative user unique to the task.
     *
     * @param {string} [poolPatchParameter.startTask.userIdentity.userName] The
     * name of the user identity under which the task is run. The userName and
     * autoUser properties are mutually exclusive; you must specify one but not
     * both.
     *
     * @param {object} [poolPatchParameter.startTask.userIdentity.autoUser] The
     * auto user under which the task is run. The userName and autoUser properties
     * are mutually exclusive; you must specify one but not both.
     *
     * @param {string} [poolPatchParameter.startTask.userIdentity.autoUser.scope]
     * The scope for the auto user Values are:
     *
     * pool - specifies that the task runs as the common auto user account which is
     * created on every node in a pool.
     * task - specifies that the service should create a new user for the task.
     * The default value is task. Possible values include: 'task', 'pool'
     *
     * @param {string}
     * [poolPatchParameter.startTask.userIdentity.autoUser.elevationLevel] The
     * elevation level of the auto user. nonAdmin - The auto user is a standard
     * user without elevated access. admin - The auto user is a user with elevated
     * access and operates with full Administrator permissions. The default value
     * is nonAdmin. Possible values include: 'nonAdmin', 'admin'
     *
     * @param {number} [poolPatchParameter.startTask.maxTaskRetryCount] The maximum
     * number of times the task may be retried. The Batch service retries a task if
     * its exit code is nonzero. Note that this value specifically controls the
     * number of retries. The Batch service will try the task once, and may then
     * retry up to this limit. For example, if the maximum retry count is 3, Batch
     * tries the task up to 4 times (one initial try and 3 retries). If the maximum
     * retry count is 0, the Batch service does not retry the task. If the maximum
     * retry count is -1, the Batch service retries the task without limit.
     *
     * @param {boolean} [poolPatchParameter.startTask.waitForSuccess] Whether the
     * Batch service should wait for the start task to complete successfully (that
     * is, to exit with exit code 0) before scheduling any tasks on the compute
     * node. If true and the start task fails on a compute node, the Batch service
     * retries the start task up to its maximum retry count (maxTaskRetryCount). If
     * the task has still not completed successfully after all retries, then the
     * Batch service marks the compute node unusable, and will not schedule tasks
     * to it. This condition can be detected via the node state and failure info
     * details. If false, the Batch service will not wait for the start task to
     * complete. In this case, other tasks can start executing on the compute node
     * while the start task is still running; and even if the start task fails, new
     * tasks will continue to be scheduled on the node. The default is false.
     *
     * @param {array} [poolPatchParameter.certificateReferences] A list of
     * certificates to be installed on each compute node in the pool. If this
     * element is present, it replaces any existing certificate references
     * configured on the pool. If omitted, any existing certificate references are
     * left unchanged. For Windows compute nodes, the Batch service installs the
     * certificates to the specified certificate store and location. For Linux
     * compute nodes, the certificates are stored in a directory inside the task
     * working directory and an environment variable AZ_BATCH_CERTIFICATES_DIR is
     * supplied to the task to query for this location. For certificates with
     * visibility of 'remoteUser', a 'certs' directory is created in the user's
     * home directory (e.g., /home/{user-name}/certs) and certificates are placed
     * in that directory.
     *
     * @param {array} [poolPatchParameter.applicationPackageReferences] A list of
     * application packages to be installed on each compute node in the pool.
     * Changes to application package references affect all new compute nodes
     * joining the pool, but do not affect compute nodes that are already in the
     * pool until they are rebooted or reimaged. If this element is present, it
     * replaces any existing application package references. If you specify an
     * empty collection, then all application package references are removed from
     * the pool. If omitted, any existing application package references are left
     * unchanged.
     *
     * @param {array} [poolPatchParameter.metadata] A list of name-value pairs
     * associated with the pool as metadata. If this element is present, it
     * replaces any existing metadata configured on the pool. If you specify an
     * empty collection, any metadata is removed from the pool. If omitted, any
     * existing metadata is left unchanged.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolPatchOptions] Additional parameters for the
     * operation
     *
     * @param {number} [options.poolPatchOptions.timeout] The maximum time that the
     * server can spend processing the request, in seconds. The default is 30
     * seconds.
     *
     * @param {string} [options.poolPatchOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolPatchOptions.returnClientRequestId] Whether
     * the server should return the client-request-id in the response.
     *
     * @param {date} [options.poolPatchOptions.ocpDate] The time the request was
     * issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.poolPatchOptions.ifMatch] An ETag value associated
     * with the version of the resource known to the client. The operation will be
     * performed only if the resource's current ETag on the service exactly matches
     * the value specified by the client.
     *
     * @param {string} [options.poolPatchOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.poolPatchOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.poolPatchOptions.ifUnmodifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has not been
     * modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    patchWithHttpOperationResponse(poolId, poolPatchParameter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolPatchOptions = (options && options.poolPatchOptions !== undefined) ? options.poolPatchOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (poolPatchParameter === null || poolPatchParameter === undefined) {
                    throw new Error('poolPatchParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    timeout = poolPatchOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    clientRequestId = poolPatchOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    returnClientRequestId = poolPatchOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    ocpDate = poolPatchOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    ifMatch = poolPatchOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    ifNoneMatch = poolPatchOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    ifModifiedSince = poolPatchOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolPatchOptions !== null && poolPatchOptions !== undefined) {
                    ifUnmodifiedSince = poolPatchOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'PATCH';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (poolPatchParameter !== null && poolPatchParameter !== undefined) {
                    let requestModelMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["PoolPatchParameter"];
                    requestModel = client.serializer.serialize(requestModelMapper, poolPatchParameter, 'poolPatchParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(poolPatchParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Disables automatic scaling for a pool.
     *
     * @param {string} poolId The ID of the pool on which to disable automatic
     * scaling.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolDisableAutoScaleOptions] Additional parameters
     * for the operation
     *
     * @param {number} [options.poolDisableAutoScaleOptions.timeout] The maximum
     * time that the server can spend processing the request, in seconds. The
     * default is 30 seconds.
     *
     * @param {string} [options.poolDisableAutoScaleOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolDisableAutoScaleOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.poolDisableAutoScaleOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    disableAutoScaleWithHttpOperationResponse(poolId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolDisableAutoScaleOptions = (options && options.poolDisableAutoScaleOptions !== undefined) ? options.poolDisableAutoScaleOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolDisableAutoScaleOptions !== null && poolDisableAutoScaleOptions !== undefined) {
                    timeout = poolDisableAutoScaleOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolDisableAutoScaleOptions !== null && poolDisableAutoScaleOptions !== undefined) {
                    clientRequestId = poolDisableAutoScaleOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolDisableAutoScaleOptions !== null && poolDisableAutoScaleOptions !== undefined) {
                    returnClientRequestId = poolDisableAutoScaleOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolDisableAutoScaleOptions !== null && poolDisableAutoScaleOptions !== undefined) {
                    ocpDate = poolDisableAutoScaleOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/disableautoscale';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Enables automatic scaling for a pool.
     *
     * You cannot enable automatic scaling on a pool if a resize operation is in
     * progress on the pool. If automatic scaling of the pool is currently
     * disabled, you must specify a valid autoscale formula as part of the request.
     * If automatic scaling of the pool is already enabled, you may specify a new
     * autoscale formula and/or a new evaluation interval. You cannot call this API
     * for the same pool more than once every 30 seconds.
     *
     * @param {string} poolId The ID of the pool on which to enable automatic
     * scaling.
     *
     * @param {object} poolEnableAutoScaleParameter The parameters for the request.
     *
     * @param {string} [poolEnableAutoScaleParameter.autoScaleFormula] The formula
     * for the desired number of compute nodes in the pool. The formula is checked
     * for validity before it is applied to the pool. If the formula is not valid,
     * the Batch service rejects the request with detailed error information. For
     * more information about specifying this formula, see Automatically scale
     * compute nodes in an Azure Batch pool
     * (https://azure.microsoft.com/en-us/documentation/articles/batch-automatic-scaling).
     *
     * @param {moment.duration}
     * [poolEnableAutoScaleParameter.autoScaleEvaluationInterval] The time interval
     * at which to automatically adjust the pool size according to the autoscale
     * formula. The default value is 15 minutes. The minimum and maximum value are
     * 5 minutes and 168 hours respectively. If you specify a value less than 5
     * minutes or greater than 168 hours, the Batch service rejects the request
     * with an invalid property value error; if you are calling the REST API
     * directly, the HTTP status code is 400 (Bad Request). If you specify a new
     * interval, then the existing autoscale evaluation schedule will be stopped
     * and a new autoscale evaluation schedule will be started, with its starting
     * time being the time when this request was issued.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolEnableAutoScaleOptions] Additional parameters
     * for the operation
     *
     * @param {number} [options.poolEnableAutoScaleOptions.timeout] The maximum
     * time that the server can spend processing the request, in seconds. The
     * default is 30 seconds.
     *
     * @param {string} [options.poolEnableAutoScaleOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolEnableAutoScaleOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.poolEnableAutoScaleOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {string} [options.poolEnableAutoScaleOptions.ifMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.
     *
     * @param {string} [options.poolEnableAutoScaleOptions.ifNoneMatch] An ETag
     * value associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.poolEnableAutoScaleOptions.ifModifiedSince] A
     * timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service
     * has been modified since the specified time.
     *
     * @param {date} [options.poolEnableAutoScaleOptions.ifUnmodifiedSince] A
     * timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service
     * has not been modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    enableAutoScaleWithHttpOperationResponse(poolId, poolEnableAutoScaleParameter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolEnableAutoScaleOptions = (options && options.poolEnableAutoScaleOptions !== undefined) ? options.poolEnableAutoScaleOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (poolEnableAutoScaleParameter === null || poolEnableAutoScaleParameter === undefined) {
                    throw new Error('poolEnableAutoScaleParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    timeout = poolEnableAutoScaleOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    clientRequestId = poolEnableAutoScaleOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    returnClientRequestId = poolEnableAutoScaleOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    ocpDate = poolEnableAutoScaleOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    ifMatch = poolEnableAutoScaleOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    ifNoneMatch = poolEnableAutoScaleOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    ifModifiedSince = poolEnableAutoScaleOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined) {
                    ifUnmodifiedSince = poolEnableAutoScaleOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/enableautoscale';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (poolEnableAutoScaleParameter !== null && poolEnableAutoScaleParameter !== undefined) {
                    let requestModelMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["PoolEnableAutoScaleParameter"];
                    requestModel = client.serializer.serialize(requestModelMapper, poolEnableAutoScaleParameter, 'poolEnableAutoScaleParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(poolEnableAutoScaleParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets the result of evaluating an automatic scaling formula on the
     * pool.
     *
     * This API is primarily for validating an autoscale formula, as it simply
     * returns the result without applying the formula to the pool. The pool must
     * have auto scaling enabled in order to evaluate a formula.
     *
     * @param {string} poolId The ID of the pool on which to evaluate the automatic
     * scaling formula.
     *
     * @param {string} autoScaleFormula The formula for the desired number of
     * compute nodes in the pool. The formula is validated and its results
     * calculated, but it is not applied to the pool. To apply the formula to the
     * pool, 'Enable automatic scaling on a pool'. For more information about
     * specifying this formula, see Automatically scale compute nodes in an Azure
     * Batch pool
     * (https://azure.microsoft.com/en-us/documentation/articles/batch-automatic-scaling).
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolEvaluateAutoScaleOptions] Additional parameters
     * for the operation
     *
     * @param {number} [options.poolEvaluateAutoScaleOptions.timeout] The maximum
     * time that the server can spend processing the request, in seconds. The
     * default is 30 seconds.
     *
     * @param {string} [options.poolEvaluateAutoScaleOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean}
     * [options.poolEvaluateAutoScaleOptions.returnClientRequestId] Whether the
     * server should return the client-request-id in the response.
     *
     * @param {date} [options.poolEvaluateAutoScaleOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<AutoScaleRun>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    evaluateAutoScaleWithHttpOperationResponse(poolId, autoScaleFormula, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolEvaluateAutoScaleOptions = (options && options.poolEvaluateAutoScaleOptions !== undefined) ? options.poolEvaluateAutoScaleOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (autoScaleFormula === null || autoScaleFormula === undefined || typeof autoScaleFormula.valueOf() !== 'string') {
                    throw new Error('autoScaleFormula cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let poolEvaluateAutoScaleParameter = {};
            try {
                if (poolEvaluateAutoScaleOptions !== null && poolEvaluateAutoScaleOptions !== undefined) {
                    timeout = poolEvaluateAutoScaleOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolEvaluateAutoScaleOptions !== null && poolEvaluateAutoScaleOptions !== undefined) {
                    clientRequestId = poolEvaluateAutoScaleOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolEvaluateAutoScaleOptions !== null && poolEvaluateAutoScaleOptions !== undefined) {
                    returnClientRequestId = poolEvaluateAutoScaleOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolEvaluateAutoScaleOptions !== null && poolEvaluateAutoScaleOptions !== undefined) {
                    ocpDate = poolEvaluateAutoScaleOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (autoScaleFormula !== null && autoScaleFormula !== undefined) {
                    poolEvaluateAutoScaleParameter.autoScaleFormula = autoScaleFormula;
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/evaluateautoscale';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (poolEvaluateAutoScaleParameter !== null && poolEvaluateAutoScaleParameter !== undefined) {
                    let requestModelMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["PoolEvaluateAutoScaleParameter"];
                    requestModel = client.serializer.serialize(requestModelMapper, poolEvaluateAutoScaleParameter, 'poolEvaluateAutoScaleParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(poolEvaluateAutoScaleParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["AutoScaleRun"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Changes the number of compute nodes that are assigned to a pool.
     *
     * You can only resize a pool when its allocation state is steady. If the pool
     * is already resizing, the request fails with status code 409. When you resize
     * a pool, the pool's allocation state changes from steady to resizing. You
     * cannot resize pools which are configured for automatic scaling. If you try
     * to do this, the Batch service returns an error 409. If you resize a pool
     * downwards, the Batch service chooses which nodes to remove. To remove
     * specific nodes, use the pool remove nodes API instead.
     *
     * @param {string} poolId The ID of the pool to resize.
     *
     * @param {object} poolResizeParameter The parameters for the request.
     *
     * @param {number} [poolResizeParameter.targetDedicatedNodes] The desired
     * number of dedicated compute nodes in the pool.
     *
     * @param {number} [poolResizeParameter.targetLowPriorityNodes] The desired
     * number of low-priority compute nodes in the pool.
     *
     * @param {moment.duration} [poolResizeParameter.resizeTimeout] The timeout for
     * allocation of compute nodes to the pool or removal of compute nodes from the
     * pool. The default value is 15 minutes. The minimum value is 5 minutes. If
     * you specify a value less than 5 minutes, the Batch service returns an error;
     * if you are calling the REST API directly, the HTTP status code is 400 (Bad
     * Request).
     *
     * @param {string} [poolResizeParameter.nodeDeallocationOption] Determines what
     * to do with a node and its running task(s) if the pool size is decreasing.
     * The default value is requeue. Possible values include: 'requeue',
     * 'terminate', 'taskCompletion', 'retainedData'
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolResizeOptions] Additional parameters for the
     * operation
     *
     * @param {number} [options.poolResizeOptions.timeout] The maximum time that
     * the server can spend processing the request, in seconds. The default is 30
     * seconds.
     *
     * @param {string} [options.poolResizeOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolResizeOptions.returnClientRequestId] Whether
     * the server should return the client-request-id in the response.
     *
     * @param {date} [options.poolResizeOptions.ocpDate] The time the request was
     * issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.poolResizeOptions.ifMatch] An ETag value associated
     * with the version of the resource known to the client. The operation will be
     * performed only if the resource's current ETag on the service exactly matches
     * the value specified by the client.
     *
     * @param {string} [options.poolResizeOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.poolResizeOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.poolResizeOptions.ifUnmodifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has not been
     * modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    resizeWithHttpOperationResponse(poolId, poolResizeParameter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolResizeOptions = (options && options.poolResizeOptions !== undefined) ? options.poolResizeOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (poolResizeParameter === null || poolResizeParameter === undefined) {
                    throw new Error('poolResizeParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    timeout = poolResizeOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    clientRequestId = poolResizeOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    returnClientRequestId = poolResizeOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    ocpDate = poolResizeOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    ifMatch = poolResizeOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    ifNoneMatch = poolResizeOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    ifModifiedSince = poolResizeOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolResizeOptions !== null && poolResizeOptions !== undefined) {
                    ifUnmodifiedSince = poolResizeOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/resize';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (poolResizeParameter !== null && poolResizeParameter !== undefined) {
                    let requestModelMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["PoolResizeParameter"];
                    requestModel = client.serializer.serialize(requestModelMapper, poolResizeParameter, 'poolResizeParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(poolResizeParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Stops an ongoing resize operation on the pool.
     *
     * This does not restore the pool to its previous state before the resize
     * operation: it only stops any further changes being made, and the pool
     * maintains its current state. After stopping, the pool stabilizes at the
     * number of nodes it was at when the stop operation was done. During the stop
     * operation, the pool allocation state changes first to stopping and then to
     * steady. A resize operation need not be an explicit resize pool request; this
     * API can also be used to halt the initial sizing of the pool when it is
     * created.
     *
     * @param {string} poolId The ID of the pool whose resizing you want to stop.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolStopResizeOptions] Additional parameters for
     * the operation
     *
     * @param {number} [options.poolStopResizeOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.poolStopResizeOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolStopResizeOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.poolStopResizeOptions.ocpDate] The time the request
     * was issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.poolStopResizeOptions.ifMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.
     *
     * @param {string} [options.poolStopResizeOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.poolStopResizeOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.poolStopResizeOptions.ifUnmodifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has not been
     * modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    stopResizeWithHttpOperationResponse(poolId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolStopResizeOptions = (options && options.poolStopResizeOptions !== undefined) ? options.poolStopResizeOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    timeout = poolStopResizeOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    clientRequestId = poolStopResizeOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    returnClientRequestId = poolStopResizeOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    ocpDate = poolStopResizeOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    ifMatch = poolStopResizeOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    ifNoneMatch = poolStopResizeOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    ifModifiedSince = poolStopResizeOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined) {
                    ifUnmodifiedSince = poolStopResizeOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/stopresize';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Updates the properties of the specified pool.
     *
     * This fully replaces all the updateable properties of the pool. For example,
     * if the pool has a start task associated with it and if start task is not
     * specified with this request, then the Batch service will remove the existing
     * start task.
     *
     * @param {string} poolId The ID of the pool to update.
     *
     * @param {object} poolUpdatePropertiesParameter The parameters for the
     * request.
     *
     * @param {object} [poolUpdatePropertiesParameter.startTask] A task to run on
     * each compute node as it joins the pool. The task runs when the node is added
     * to the pool or when the node is restarted. If this element is present, it
     * overwrites any existing start task. If omitted, any existing start task is
     * removed from the pool.
     *
     * @param {string} poolUpdatePropertiesParameter.startTask.commandLine The
     * command line of the start task. The command line does not run under a shell,
     * and therefore cannot take advantage of shell features such as environment
     * variable expansion. If you want to take advantage of such features, you
     * should invoke the shell in the command line, for example using "cmd /c
     * MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux.
     *
     * @param {array} [poolUpdatePropertiesParameter.startTask.resourceFiles] A
     * list of files that the Batch service will download to the compute node
     * before running the command line. Files listed under this element are located
     * in the task's working directory.
     *
     * @param {array} [poolUpdatePropertiesParameter.startTask.environmentSettings]
     * A list of environment variable settings for the start task.
     *
     * @param {object} [poolUpdatePropertiesParameter.startTask.userIdentity] The
     * user identity under which the start task runs. If omitted, the task runs as
     * a non-administrative user unique to the task.
     *
     * @param {string}
     * [poolUpdatePropertiesParameter.startTask.userIdentity.userName] The name of
     * the user identity under which the task is run. The userName and autoUser
     * properties are mutually exclusive; you must specify one but not both.
     *
     * @param {object}
     * [poolUpdatePropertiesParameter.startTask.userIdentity.autoUser] The auto
     * user under which the task is run. The userName and autoUser properties are
     * mutually exclusive; you must specify one but not both.
     *
     * @param {string}
     * [poolUpdatePropertiesParameter.startTask.userIdentity.autoUser.scope] The
     * scope for the auto user Values are:
     *
     * pool - specifies that the task runs as the common auto user account which is
     * created on every node in a pool.
     * task - specifies that the service should create a new user for the task.
     * The default value is task. Possible values include: 'task', 'pool'
     *
     * @param {string}
     * [poolUpdatePropertiesParameter.startTask.userIdentity.autoUser.elevationLevel]
     * The elevation level of the auto user. nonAdmin - The auto user is a standard
     * user without elevated access. admin - The auto user is a user with elevated
     * access and operates with full Administrator permissions. The default value
     * is nonAdmin. Possible values include: 'nonAdmin', 'admin'
     *
     * @param {number} [poolUpdatePropertiesParameter.startTask.maxTaskRetryCount]
     * The maximum number of times the task may be retried. The Batch service
     * retries a task if its exit code is nonzero. Note that this value
     * specifically controls the number of retries. The Batch service will try the
     * task once, and may then retry up to this limit. For example, if the maximum
     * retry count is 3, Batch tries the task up to 4 times (one initial try and 3
     * retries). If the maximum retry count is 0, the Batch service does not retry
     * the task. If the maximum retry count is -1, the Batch service retries the
     * task without limit.
     *
     * @param {boolean} [poolUpdatePropertiesParameter.startTask.waitForSuccess]
     * Whether the Batch service should wait for the start task to complete
     * successfully (that is, to exit with exit code 0) before scheduling any tasks
     * on the compute node. If true and the start task fails on a compute node, the
     * Batch service retries the start task up to its maximum retry count
     * (maxTaskRetryCount). If the task has still not completed successfully after
     * all retries, then the Batch service marks the compute node unusable, and
     * will not schedule tasks to it. This condition can be detected via the node
     * state and failure info details. If false, the Batch service will not wait
     * for the start task to complete. In this case, other tasks can start
     * executing on the compute node while the start task is still running; and
     * even if the start task fails, new tasks will continue to be scheduled on the
     * node. The default is false.
     *
     * @param {array} poolUpdatePropertiesParameter.certificateReferences A list of
     * certificates to be installed on each compute node in the pool. This list
     * replaces any existing certificate references configured on the pool. If you
     * specify an empty collection, any existing certificate references are removed
     * from the pool. For Windows compute nodes, the Batch service installs the
     * certificates to the specified certificate store and location. For Linux
     * compute nodes, the certificates are stored in a directory inside the task
     * working directory and an environment variable AZ_BATCH_CERTIFICATES_DIR is
     * supplied to the task to query for this location. For certificates with
     * visibility of 'remoteUser', a 'certs' directory is created in the user's
     * home directory (e.g., /home/{user-name}/certs) and certificates are placed
     * in that directory.
     *
     * @param {array} poolUpdatePropertiesParameter.applicationPackageReferences A
     * list of application packages to be installed on each compute node in the
     * pool. The list replaces any existing application package references on the
     * pool. Changes to application package references affect all new compute nodes
     * joining the pool, but do not affect compute nodes that are already in the
     * pool until they are rebooted or reimaged. If omitted, or if you specify an
     * empty collection, any existing application packages references are removed
     * from the pool.
     *
     * @param {array} poolUpdatePropertiesParameter.metadata A list of name-value
     * pairs associated with the pool as metadata. This list replaces any existing
     * metadata configured on the pool. If omitted, or if you specify an empty
     * collection, any existing metadata is removed from the pool.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolUpdatePropertiesOptions] Additional parameters
     * for the operation
     *
     * @param {number} [options.poolUpdatePropertiesOptions.timeout] The maximum
     * time that the server can spend processing the request, in seconds. The
     * default is 30 seconds.
     *
     * @param {string} [options.poolUpdatePropertiesOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolUpdatePropertiesOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.poolUpdatePropertiesOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updatePropertiesWithHttpOperationResponse(poolId, poolUpdatePropertiesParameter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolUpdatePropertiesOptions = (options && options.poolUpdatePropertiesOptions !== undefined) ? options.poolUpdatePropertiesOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (poolUpdatePropertiesParameter === null || poolUpdatePropertiesParameter === undefined) {
                    throw new Error('poolUpdatePropertiesParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolUpdatePropertiesOptions !== null && poolUpdatePropertiesOptions !== undefined) {
                    timeout = poolUpdatePropertiesOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolUpdatePropertiesOptions !== null && poolUpdatePropertiesOptions !== undefined) {
                    clientRequestId = poolUpdatePropertiesOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolUpdatePropertiesOptions !== null && poolUpdatePropertiesOptions !== undefined) {
                    returnClientRequestId = poolUpdatePropertiesOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolUpdatePropertiesOptions !== null && poolUpdatePropertiesOptions !== undefined) {
                    ocpDate = poolUpdatePropertiesOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/updateproperties';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (poolUpdatePropertiesParameter !== null && poolUpdatePropertiesParameter !== undefined) {
                    let requestModelMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["PoolUpdatePropertiesParameter"];
                    requestModel = client.serializer.serialize(requestModelMapper, poolUpdatePropertiesParameter, 'poolUpdatePropertiesParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(poolUpdatePropertiesParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 204) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Upgrades the operating system of the specified pool.
     *
     * During an upgrade, the Batch service upgrades each compute node in the pool.
     * When a compute node is chosen for upgrade, any tasks running on that node
     * are removed from the node and returned to the queue to be rerun later (or on
     * a different compute node). The node will be unavailable until the upgrade is
     * complete. This operation results in temporarily reduced pool capacity as
     * nodes are taken out of service to be upgraded. Although the Batch service
     * tries to avoid upgrading all compute nodes at the same time, it does not
     * guarantee to do this (particularly on small pools); therefore, the pool may
     * be temporarily unavailable to run tasks. When this operation runs, the pool
     * state changes to upgrading. When all compute nodes have finished upgrading,
     * the pool state returns to active. While the upgrade is in progress, the
     * pool's currentOSVersion reflects the OS version that nodes are upgrading
     * from, and targetOSVersion reflects the OS version that nodes are upgrading
     * to. Once the upgrade is complete, currentOSVersion is updated to reflect the
     * OS version now running on all nodes. This operation can only be invoked on
     * pools created with the cloudServiceConfiguration property.
     *
     * @param {string} poolId The ID of the pool to upgrade.
     *
     * @param {string} targetOSVersion The Azure Guest OS version to be installed
     * on the virtual machines in the pool.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolUpgradeOSOptions] Additional parameters for the
     * operation
     *
     * @param {number} [options.poolUpgradeOSOptions.timeout] The maximum time that
     * the server can spend processing the request, in seconds. The default is 30
     * seconds.
     *
     * @param {string} [options.poolUpgradeOSOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolUpgradeOSOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.poolUpgradeOSOptions.ocpDate] The time the request
     * was issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.poolUpgradeOSOptions.ifMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.
     *
     * @param {string} [options.poolUpgradeOSOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.poolUpgradeOSOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.poolUpgradeOSOptions.ifUnmodifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has not been
     * modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    upgradeOSWithHttpOperationResponse(poolId, targetOSVersion, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolUpgradeOSOptions = (options && options.poolUpgradeOSOptions !== undefined) ? options.poolUpgradeOSOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (targetOSVersion === null || targetOSVersion === undefined || typeof targetOSVersion.valueOf() !== 'string') {
                    throw new Error('targetOSVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            let poolUpgradeOSParameter = {};
            try {
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    timeout = poolUpgradeOSOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    clientRequestId = poolUpgradeOSOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    returnClientRequestId = poolUpgradeOSOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    ocpDate = poolUpgradeOSOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    ifMatch = poolUpgradeOSOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    ifNoneMatch = poolUpgradeOSOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    ifModifiedSince = poolUpgradeOSOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined) {
                    ifUnmodifiedSince = poolUpgradeOSOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
                if (targetOSVersion !== null && targetOSVersion !== undefined) {
                    poolUpgradeOSParameter.targetOSVersion = targetOSVersion;
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/upgradeos';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (poolUpgradeOSParameter !== null && poolUpgradeOSParameter !== undefined) {
                    let requestModelMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["PoolUpgradeOSParameter"];
                    requestModel = client.serializer.serialize(requestModelMapper, poolUpgradeOSParameter, 'poolUpgradeOSParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(poolUpgradeOSParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Removes compute nodes from the specified pool.
     *
     * This operation can only run when the allocation state of the pool is steady.
     * When this operation runs, the allocation state changes from steady to
     * resizing.
     *
     * @param {string} poolId The ID of the pool from which you want to remove
     * nodes.
     *
     * @param {object} nodeRemoveParameter The parameters for the request.
     *
     * @param {array} nodeRemoveParameter.nodeList A list containing the IDs of the
     * compute nodes to be removed from the specified pool.
     *
     * @param {moment.duration} [nodeRemoveParameter.resizeTimeout] The timeout for
     * removal of compute nodes to the pool. The default value is 15 minutes. The
     * minimum value is 5 minutes. If you specify a value less than 5 minutes, the
     * Batch service returns an error; if you are calling the REST API directly,
     * the HTTP status code is 400 (Bad Request).
     *
     * @param {string} [nodeRemoveParameter.nodeDeallocationOption] Determines what
     * to do with a node and its running task(s) after it has been selected for
     * deallocation. The default value is requeue. Possible values include:
     * 'requeue', 'terminate', 'taskCompletion', 'retainedData'
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolRemoveNodesOptions] Additional parameters for
     * the operation
     *
     * @param {number} [options.poolRemoveNodesOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.poolRemoveNodesOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolRemoveNodesOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.poolRemoveNodesOptions.ocpDate] The time the request
     * was issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.poolRemoveNodesOptions.ifMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.
     *
     * @param {string} [options.poolRemoveNodesOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.poolRemoveNodesOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.poolRemoveNodesOptions.ifUnmodifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has not been
     * modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    removeNodesWithHttpOperationResponse(poolId, nodeRemoveParameter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolRemoveNodesOptions = (options && options.poolRemoveNodesOptions !== undefined) ? options.poolRemoveNodesOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeRemoveParameter === null || nodeRemoveParameter === undefined) {
                    throw new Error('nodeRemoveParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    timeout = poolRemoveNodesOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    clientRequestId = poolRemoveNodesOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    returnClientRequestId = poolRemoveNodesOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    ocpDate = poolRemoveNodesOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    ifMatch = poolRemoveNodesOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    ifNoneMatch = poolRemoveNodesOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    ifModifiedSince = poolRemoveNodesOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined) {
                    ifUnmodifiedSince = poolRemoveNodesOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/removenodes';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (nodeRemoveParameter !== null && nodeRemoveParameter !== undefined) {
                    let requestModelMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["NodeRemoveParameter"];
                    requestModel = client.serializer.serialize(requestModelMapper, nodeRemoveParameter, 'nodeRemoveParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(nodeRemoveParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the usage metrics, aggregated by pool across individual time
     * intervals, for the specified account.
     *
     * If you do not specify a $filter clause including a poolId, the response
     * includes all pools that existed in the account in the time range of the
     * returned aggregation intervals. If you do not specify a $filter clause
     * including a startTime or endTime these filters default to the start and end
     * times of the last aggregation interval currently available; that is, only
     * the last aggregation interval is returned.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolListUsageMetricsNextOptions] Additional
     * parameters for the operation
     *
     * @param {string} [options.poolListUsageMetricsNextOptions.clientRequestId]
     * The caller-generated request identity, in the form of a GUID with no
     * decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean}
     * [options.poolListUsageMetricsNextOptions.returnClientRequestId] Whether the
     * server should return the client-request-id in the response.
     *
     * @param {date} [options.poolListUsageMetricsNextOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<PoolListUsageMetricsResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listUsageMetricsNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolListUsageMetricsNextOptions = (options && options.poolListUsageMetricsNextOptions !== undefined) ? options.poolListUsageMetricsNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolListUsageMetricsNextOptions !== null && poolListUsageMetricsNextOptions !== undefined) {
                    clientRequestId = poolListUsageMetricsNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolListUsageMetricsNextOptions !== null && poolListUsageMetricsNextOptions !== undefined) {
                    returnClientRequestId = poolListUsageMetricsNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolListUsageMetricsNextOptions !== null && poolListUsageMetricsNextOptions !== undefined) {
                    ocpDate = poolListUsageMetricsNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["PoolListUsageMetricsResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the pools in the specified account.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.poolListNextOptions] Additional parameters for the
     * operation
     *
     * @param {string} [options.poolListNextOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.poolListNextOptions.returnClientRequestId] Whether
     * the server should return the client-request-id in the response.
     *
     * @param {date} [options.poolListNextOptions.ocpDate] The time the request was
     * issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<CloudPoolListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let poolListNextOptions = (options && options.poolListNextOptions !== undefined) ? options.poolListNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (poolListNextOptions !== null && poolListNextOptions !== undefined) {
                    clientRequestId = poolListNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (poolListNextOptions !== null && poolListNextOptions !== undefined) {
                    returnClientRequestId = poolListNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (poolListNextOptions !== null && poolListNextOptions !== undefined) {
                    ocpDate = poolListNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["CloudPoolListResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    listUsageMetrics(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listUsageMetricsWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.listUsageMetricsWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    getAllLifetimeStatistics(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getAllLifetimeStatisticsWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.getAllLifetimeStatisticsWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    add(pool, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.addWithHttpOperationResponse(pool, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.addWithHttpOperationResponse(pool, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    list(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.listWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    deleteMethod(poolId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteMethodWithHttpOperationResponse(poolId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.deleteMethodWithHttpOperationResponse(poolId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    exists(poolId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.existsWithHttpOperationResponse(poolId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.existsWithHttpOperationResponse(poolId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    get(poolId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(poolId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.getWithHttpOperationResponse(poolId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    patch(poolId, poolPatchParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.patchWithHttpOperationResponse(poolId, poolPatchParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.patchWithHttpOperationResponse(poolId, poolPatchParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    disableAutoScale(poolId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.disableAutoScaleWithHttpOperationResponse(poolId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.disableAutoScaleWithHttpOperationResponse(poolId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    enableAutoScale(poolId, poolEnableAutoScaleParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.enableAutoScaleWithHttpOperationResponse(poolId, poolEnableAutoScaleParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.enableAutoScaleWithHttpOperationResponse(poolId, poolEnableAutoScaleParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    evaluateAutoScale(poolId, autoScaleFormula, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.evaluateAutoScaleWithHttpOperationResponse(poolId, autoScaleFormula, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.evaluateAutoScaleWithHttpOperationResponse(poolId, autoScaleFormula, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    resize(poolId, poolResizeParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.resizeWithHttpOperationResponse(poolId, poolResizeParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.resizeWithHttpOperationResponse(poolId, poolResizeParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    stopResize(poolId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.stopResizeWithHttpOperationResponse(poolId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.stopResizeWithHttpOperationResponse(poolId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    updateProperties(poolId, poolUpdatePropertiesParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.updatePropertiesWithHttpOperationResponse(poolId, poolUpdatePropertiesParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.updatePropertiesWithHttpOperationResponse(poolId, poolUpdatePropertiesParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    upgradeOS(poolId, targetOSVersion, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.upgradeOSWithHttpOperationResponse(poolId, targetOSVersion, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.upgradeOSWithHttpOperationResponse(poolId, targetOSVersion, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    removeNodes(poolId, nodeRemoveParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.removeNodesWithHttpOperationResponse(poolId, nodeRemoveParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.removeNodesWithHttpOperationResponse(poolId, nodeRemoveParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listUsageMetricsNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listUsageMetricsNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.listUsageMetricsNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.listNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Pool;



/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__models_mappers__ = __webpack_require__(1);
/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


const WebResource = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["WebResource"];
/** Class representing a Account. */
class Account {
    /**
     * Create a Account.
     * @param {BatchServiceClient} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Lists all node agent SKUs supported by the Azure Batch service.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.accountListNodeAgentSkusOptions] Additional
     * parameters for the operation
     *
     * @param {string} [options.accountListNodeAgentSkusOptions.filter] An OData
     * $filter clause.
     *
     * @param {number} [options.accountListNodeAgentSkusOptions.maxResults] The
     * maximum number of items to return in the response. A maximum of 1000 results
     * will be returned.
     *
     * @param {number} [options.accountListNodeAgentSkusOptions.timeout] The
     * maximum time that the server can spend processing the request, in seconds.
     * The default is 30 seconds.
     *
     * @param {string} [options.accountListNodeAgentSkusOptions.clientRequestId]
     * The caller-generated request identity, in the form of a GUID with no
     * decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean}
     * [options.accountListNodeAgentSkusOptions.returnClientRequestId] Whether the
     * server should return the client-request-id in the response.
     *
     * @param {date} [options.accountListNodeAgentSkusOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<AccountListNodeAgentSkusResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNodeAgentSkusWithHttpOperationResponse(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let accountListNodeAgentSkusOptions = (options && options.accountListNodeAgentSkusOptions !== undefined) ? options.accountListNodeAgentSkusOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (accountListNodeAgentSkusOptions !== null && accountListNodeAgentSkusOptions !== undefined) {
                    filter = accountListNodeAgentSkusOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (accountListNodeAgentSkusOptions !== null && accountListNodeAgentSkusOptions !== undefined) {
                    maxResults = accountListNodeAgentSkusOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (accountListNodeAgentSkusOptions !== null && accountListNodeAgentSkusOptions !== undefined) {
                    timeout = accountListNodeAgentSkusOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (accountListNodeAgentSkusOptions !== null && accountListNodeAgentSkusOptions !== undefined) {
                    clientRequestId = accountListNodeAgentSkusOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (accountListNodeAgentSkusOptions !== null && accountListNodeAgentSkusOptions !== undefined) {
                    returnClientRequestId = accountListNodeAgentSkusOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (accountListNodeAgentSkusOptions !== null && accountListNodeAgentSkusOptions !== undefined) {
                    ocpDate = accountListNodeAgentSkusOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'nodeagentskus';
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (filter !== null && filter !== undefined) {
                queryParameters.push('$filter=' + encodeURIComponent(filter));
            }
            if (maxResults !== null && maxResults !== undefined) {
                queryParameters.push('maxresults=' + encodeURIComponent(maxResults.toString()));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["AccountListNodeAgentSkusResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all node agent SKUs supported by the Azure Batch service.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.accountListNodeAgentSkusNextOptions] Additional
     * parameters for the operation
     *
     * @param {string}
     * [options.accountListNodeAgentSkusNextOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean}
     * [options.accountListNodeAgentSkusNextOptions.returnClientRequestId] Whether
     * the server should return the client-request-id in the response.
     *
     * @param {date} [options.accountListNodeAgentSkusNextOptions.ocpDate] The time
     * the request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<AccountListNodeAgentSkusResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNodeAgentSkusNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let accountListNodeAgentSkusNextOptions = (options && options.accountListNodeAgentSkusNextOptions !== undefined) ? options.accountListNodeAgentSkusNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (accountListNodeAgentSkusNextOptions !== null && accountListNodeAgentSkusNextOptions !== undefined) {
                    clientRequestId = accountListNodeAgentSkusNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (accountListNodeAgentSkusNextOptions !== null && accountListNodeAgentSkusNextOptions !== undefined) {
                    returnClientRequestId = accountListNodeAgentSkusNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (accountListNodeAgentSkusNextOptions !== null && accountListNodeAgentSkusNextOptions !== undefined) {
                    ocpDate = accountListNodeAgentSkusNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["AccountListNodeAgentSkusResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    listNodeAgentSkus(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNodeAgentSkusWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.listNodeAgentSkusWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listNodeAgentSkusNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNodeAgentSkusNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.listNodeAgentSkusNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Account;



/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__models_mappers__ = __webpack_require__(1);
/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


const WebResource = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["WebResource"];
/** Class representing a Job. */
class Job {
    /**
     * Create a Job.
     * @param {BatchServiceClient} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Gets lifetime summary statistics for all of the jobs in the
     * specified account.
     *
     * Statistics are aggregated across all jobs that have ever existed in the
     * account, from account creation to the last update time of the statistics.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.jobGetAllLifetimeStatisticsOptions] Additional
     * parameters for the operation
     *
     * @param {number} [options.jobGetAllLifetimeStatisticsOptions.timeout] The
     * maximum time that the server can spend processing the request, in seconds.
     * The default is 30 seconds.
     *
     * @param {string} [options.jobGetAllLifetimeStatisticsOptions.clientRequestId]
     * The caller-generated request identity, in the form of a GUID with no
     * decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean}
     * [options.jobGetAllLifetimeStatisticsOptions.returnClientRequestId] Whether
     * the server should return the client-request-id in the response.
     *
     * @param {date} [options.jobGetAllLifetimeStatisticsOptions.ocpDate] The time
     * the request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<JobStatistics>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getAllLifetimeStatisticsWithHttpOperationResponse(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobGetAllLifetimeStatisticsOptions = (options && options.jobGetAllLifetimeStatisticsOptions !== undefined) ? options.jobGetAllLifetimeStatisticsOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobGetAllLifetimeStatisticsOptions !== null && jobGetAllLifetimeStatisticsOptions !== undefined) {
                    timeout = jobGetAllLifetimeStatisticsOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobGetAllLifetimeStatisticsOptions !== null && jobGetAllLifetimeStatisticsOptions !== undefined) {
                    clientRequestId = jobGetAllLifetimeStatisticsOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobGetAllLifetimeStatisticsOptions !== null && jobGetAllLifetimeStatisticsOptions !== undefined) {
                    returnClientRequestId = jobGetAllLifetimeStatisticsOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobGetAllLifetimeStatisticsOptions !== null && jobGetAllLifetimeStatisticsOptions !== undefined) {
                    ocpDate = jobGetAllLifetimeStatisticsOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'lifetimejobstats';
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["JobStatistics"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Deletes a job.
     *
     * Deleting a job also deletes all tasks that are part of that job, and all job
     * statistics. This also overrides the retention period for task data; that is,
     * if the job contains tasks which are still retained on compute nodes, the
     * Batch services deletes those tasks' working directories and all their
     * contents.  When a Delete Job request is received, the Batch service sets the
     * job to the deleting state. All update operations on a job that is in
     * deleting state will fail with status code 409 (Conflict), with additional
     * information indicating that the job is being deleted.
     *
     * @param {string} jobId The ID of the job to delete.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.jobDeleteMethodOptions] Additional parameters for
     * the operation
     *
     * @param {number} [options.jobDeleteMethodOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.jobDeleteMethodOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.jobDeleteMethodOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.jobDeleteMethodOptions.ocpDate] The time the request
     * was issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.jobDeleteMethodOptions.ifMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.
     *
     * @param {string} [options.jobDeleteMethodOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.jobDeleteMethodOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.jobDeleteMethodOptions.ifUnmodifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has not been
     * modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(jobId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobDeleteMethodOptions = (options && options.jobDeleteMethodOptions !== undefined) ? options.jobDeleteMethodOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    timeout = jobDeleteMethodOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    clientRequestId = jobDeleteMethodOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    returnClientRequestId = jobDeleteMethodOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    ocpDate = jobDeleteMethodOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    ifMatch = jobDeleteMethodOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    ifNoneMatch = jobDeleteMethodOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    ifModifiedSince = jobDeleteMethodOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
                    ifUnmodifiedSince = jobDeleteMethodOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'DELETE';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets information about the specified job.
     *
     * @param {string} jobId The ID of the job.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.jobGetOptions] Additional parameters for the
     * operation
     *
     * @param {string} [options.jobGetOptions.select] An OData $select clause.
     *
     * @param {string} [options.jobGetOptions.expand] An OData $expand clause.
     *
     * @param {number} [options.jobGetOptions.timeout] The maximum time that the
     * server can spend processing the request, in seconds. The default is 30
     * seconds.
     *
     * @param {string} [options.jobGetOptions.clientRequestId] The caller-generated
     * request identity, in the form of a GUID with no decoration such as curly
     * braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.jobGetOptions.returnClientRequestId] Whether the
     * server should return the client-request-id in the response.
     *
     * @param {date} [options.jobGetOptions.ocpDate] The time the request was
     * issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.jobGetOptions.ifMatch] An ETag value associated
     * with the version of the resource known to the client. The operation will be
     * performed only if the resource's current ETag on the service exactly matches
     * the value specified by the client.
     *
     * @param {string} [options.jobGetOptions.ifNoneMatch] An ETag value associated
     * with the version of the resource known to the client. The operation will be
     * performed only if the resource's current ETag on the service does not match
     * the value specified by the client.
     *
     * @param {date} [options.jobGetOptions.ifModifiedSince] A timestamp indicating
     * the last modified time of the resource known to the client. The operation
     * will be performed only if the resource on the service has been modified
     * since the specified time.
     *
     * @param {date} [options.jobGetOptions.ifUnmodifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has not been
     * modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<CloudJob>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(jobId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobGetOptions = (options && options.jobGetOptions !== undefined) ? options.jobGetOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let select;
            let expand;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    select = jobGetOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    expand = jobGetOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    timeout = jobGetOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    clientRequestId = jobGetOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    returnClientRequestId = jobGetOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    ocpDate = jobGetOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    ifMatch = jobGetOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    ifNoneMatch = jobGetOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    ifModifiedSince = jobGetOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobGetOptions !== null && jobGetOptions !== undefined) {
                    ifUnmodifiedSince = jobGetOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (select !== null && select !== undefined) {
                queryParameters.push('$select=' + encodeURIComponent(select));
            }
            if (expand !== null && expand !== undefined) {
                queryParameters.push('$expand=' + encodeURIComponent(expand));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["CloudJob"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Updates the properties of the specified job.
     *
     * This replaces only the job properties specified in the request. For example,
     * if the job has constraints, and a request does not specify the constraints
     * element, then the job keeps the existing constraints.
     *
     * @param {string} jobId The ID of the job whose properties you want to update.
     *
     * @param {object} jobPatchParameter The parameters for the request.
     *
     * @param {number} [jobPatchParameter.priority] The priority of the job.
     * Priority values can range from -1000 to 1000, with -1000 being the lowest
     * priority and 1000 being the highest priority. If omitted, the priority of
     * the job is left unchanged.
     *
     * @param {string} [jobPatchParameter.onAllTasksComplete] The action the Batch
     * service should take when all tasks in the job are in the completed state. If
     * omitted, the completion behavior is left unchanged. You may not change the
     * value from terminateJob to noAction - that is, once you have engaged
     * automatic job termination, you cannot turn it off again. If you try to do
     * this, the request fails with an 'invalid property value' error response; if
     * you are calling the REST API directly, the HTTP status code is 400 (Bad
     * Request). Possible values include: 'noAction', 'terminateJob'
     *
     * @param {object} [jobPatchParameter.constraints] The execution constraints
     * for the job. If omitted, the existing execution constraints are left
     * unchanged.
     *
     * @param {moment.duration} [jobPatchParameter.constraints.maxWallClockTime]
     * The maximum elapsed time that the job may run, measured from the time the
     * job is created. If the job does not complete within the time limit, the
     * Batch service terminates it and any tasks that are still running. In this
     * case, the termination reason will be MaxWallClockTimeExpiry. If this
     * property is not specified, there is no time limit on how long the job may
     * run.
     *
     * @param {number} [jobPatchParameter.constraints.maxTaskRetryCount] The
     * maximum number of times each task may be retried. The Batch service retries
     * a task if its exit code is nonzero. Note that this value specifically
     * controls the number of retries. The Batch service will try each task once,
     * and may then retry up to this limit. For example, if the maximum retry count
     * is 3, Batch tries a task up to 4 times (one initial try and 3 retries). If
     * the maximum retry count is 0, the Batch service does not retry tasks. If the
     * maximum retry count is -1, the Batch service retries tasks without limit.
     * The default value is 0 (no retries).
     *
     * @param {object} [jobPatchParameter.poolInfo] The pool on which the Batch
     * service runs the job's tasks. You may change the pool for a job only when
     * the job is disabled. The Patch Job call will fail if you include the
     * poolInfo element and the job is not disabled. If you specify an
     * autoPoolSpecification specification in the poolInfo, only the keepAlive
     * property can be updated, and then only if the auto pool has a
     * poolLifetimeOption of job. If omitted, the job continues to run on its
     * current pool.
     *
     * @param {string} [jobPatchParameter.poolInfo.poolId] The ID of an existing
     * pool. All the tasks of the job will run on the specified pool. You must
     * ensure that the pool referenced by this property exists. If the pool does
     * not exist at the time the Batch service tries to schedule a job, no tasks
     * for the job will run until you create a pool with that id. Note that the
     * Batch service will not reject the job request; it will simply not run tasks
     * until the pool exists. You must specify either the pool ID or the auto pool
     * specification, but not both.
     *
     * @param {object} [jobPatchParameter.poolInfo.autoPoolSpecification]
     * Characteristics for a temporary 'auto pool'. The Batch service will create
     * this auto pool when the job is submitted. If auto pool creation fails, the
     * Batch service moves the job to a completed state, and the pool creation
     * error is set in the job's scheduling error property. The Batch service
     * manages the lifetime (both creation and, unless keepAlive is specified,
     * deletion) of the auto pool. Any user actions that affect the lifetime of the
     * auto pool while the job is active will result in unexpected behavior. You
     * must specify either the pool ID or the auto pool specification, but not
     * both.
     *
     * @param {string}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.autoPoolIdPrefix] A prefix
     * to be added to the unique identifier when a pool is automatically created.
     * The Batch service assigns each auto pool a unique identifier on creation. To
     * distinguish between pools created for different purposes, you can specify
     * this element to add a prefix to the ID that is assigned. The prefix can be
     * up to 20 characters long.
     *
     * @param {string}
     * jobPatchParameter.poolInfo.autoPoolSpecification.poolLifetimeOption The
     * minimum lifetime of created auto pools, and how multiple jobs on a schedule
     * are assigned to pools. When the pool lifetime is jobSchedule the pool exists
     * for the lifetime of the job schedule. The Batch Service creates the pool
     * when it creates the first job on the schedule. You may apply this option
     * only to job schedules, not to jobs. When the pool lifetime is job the pool
     * exists for the lifetime of the job to which it is dedicated. The Batch
     * service creates the pool when it creates the job. If the 'job' option is
     * applied to a job schedule, the Batch service creates a new auto pool for
     * every job created on the schedule. Possible values include: 'jobSchedule',
     * 'job'
     *
     * @param {boolean}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.keepAlive] Whether to keep
     * an auto pool alive after its lifetime expires. If false, the Batch service
     * deletes the pool once its lifetime (as determined by the poolLifetimeOption
     * setting) expires; that is, when the job or job schedule completes. If true,
     * the Batch service does not delete the pool automatically. It is up to the
     * user to delete auto pools created with this option.
     *
     * @param {object} [jobPatchParameter.poolInfo.autoPoolSpecification.pool] The
     * pool specification for the auto pool.
     *
     * @param {string}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.displayName] The
     * display name for the pool. The display name need not be unique and can
     * contain any Unicode characters up to a maximum length of 1024.
     *
     * @param {string} jobPatchParameter.poolInfo.autoPoolSpecification.pool.vmSize
     * The size of the virtual machines in the pool. All virtual machines in a pool
     * are the same size. For information about available sizes of virtual machines
     * for Cloud Services pools (pools created with cloudServiceConfiguration), see
     * Sizes for Cloud Services
     * (http://azure.microsoft.com/documentation/articles/cloud-services-sizes-specs/).
     * Batch supports all Cloud Services VM sizes except ExtraSmall, A1V2 and A2V2.
     * For information about available VM sizes for pools using images from the
     * Virtual Machines Marketplace (pools created with
     * virtualMachineConfiguration) see Sizes for Virtual Machines (Linux)
     * (https://azure.microsoft.com/documentation/articles/virtual-machines-linux-sizes/)
     * or Sizes for Virtual Machines (Windows)
     * (https://azure.microsoft.com/documentation/articles/virtual-machines-windows-sizes/).
     * Batch supports all Azure VM sizes except STANDARD_A0 and those with premium
     * storage (STANDARD_GS, STANDARD_DS, and STANDARD_DSV2 series).
     *
     * @param {object}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration]
     * The cloud service configuration for the pool. This property must be
     * specified if the pool needs to be created with Azure PaaS VMs. This property
     * and virtualMachineConfiguration are mutually exclusive and one of the
     * properties must be specified. If neither is specified then the Batch service
     * returns an error; if you are calling the REST API directly, the HTTP status
     * code is 400 (Bad Request). This property cannot be specified if the Batch
     * account was created with its poolAllocationMode property set to
     * 'UserSubscription'.
     *
     * @param {string}
     * jobPatchParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.osFamily
     * The Azure Guest OS family to be installed on the virtual machines in the
     * pool. Possible values are: 2 - OS Family 2, equivalent to Windows Server
     * 2008 R2 SP1. 3 - OS Family 3, equivalent to Windows Server 2012. 4 - OS
     * Family 4, equivalent to Windows Server 2012 R2. 5 - OS Family 5, equivalent
     * to Windows Server 2016. For more information, see Azure Guest OS Releases
     * (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
     *
     * @param {string}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.targetOSVersion]
     * The Azure Guest OS version to be installed on the virtual machines in the
     * pool. The default value is * which specifies the latest operating system
     * version for the specified OS family.
     *
     * @param {string}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.currentOSVersion]
     * The Azure Guest OS Version currently installed on the virtual machines in
     * the pool. This may differ from targetOSVersion if the pool state is
     * Upgrading. In this case some virtual machines may be on the targetOSVersion
     * and some may be on the currentOSVersion during the upgrade process. Once all
     * virtual machines have upgraded, currentOSVersion is updated to be the same
     * as targetOSVersion.
     *
     * @param {object}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration]
     * The virtual machine configuration for the pool. This property must be
     * specified if the pool needs to be created with Azure IaaS VMs. This property
     * and cloudServiceConfiguration are mutually exclusive and one of the
     * properties must be specified. If neither is specified then the Batch service
     * returns an error; if you are calling the REST API directly, the HTTP status
     * code is 400 (Bad Request).
     *
     * @param {object}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference]
     * A reference to the Azure Virtual Machines Marketplace image to use. This
     * property and osDisk are mutually exclusive and one of the properties must be
     * specified.
     *
     * @param {string}
     * jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.publisher
     * The publisher of the Azure Virtual Machines Marketplace image. For example,
     * Canonical or MicrosoftWindowsServer.
     *
     * @param {string}
     * jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.offer
     * The offer type of the Azure Virtual Machines Marketplace image. For example,
     * UbuntuServer or WindowsServer.
     *
     * @param {string}
     * jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.sku
     * The SKU of the Azure Virtual Machines Marketplace image. For example,
     * 14.04.0-LTS or 2012-R2-Datacenter.
     *
     * @param {string}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.version]
     * The version of the Azure Virtual Machines Marketplace image. A value of
     * 'latest' can be specified to select the latest version of an image. If
     * omitted, the default is 'latest'.
     *
     * @param {object}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.osDisk]
     * A reference to the OS disk image to use. This property can be specified only
     * if the Batch account was created with its poolAllocationMode property set to
     * 'UserSubscription'. This property and imageReference are mutually exclusive
     * and one of the properties must be specified.
     *
     * @param {array}
     * jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.osDisk.imageUris
     * The collection of Virtual Hard Disk (VHD) URIs. All the VHDs must be
     * identical and must reside in an Azure Storage account within the same
     * subscription and same region as the Batch account. For best performance, it
     * is recommended that each VHD resides in a separate Azure Storage account.
     * Each VHD can serve upto 20 Windows compute nodes or 40 Linux compute nodes.
     * You must supply enough VHD URIs to satisfy the 'targetDedicated' property of
     * the pool. If you do not supply enough VHD URIs, the pool will partially
     * allocate compute nodes, and a resize error will occur.
     *
     * @param {string}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.osDisk.caching]
     * The type of caching to enable for the OS disk. Values are:
     *
     * none - The caching mode for the disk is not enabled.
     * readOnly - The caching mode for the disk is read only.
     * readWrite - The caching mode for the disk is read and write.
     *
     * The default value for caching is none. For information about the caching
     * options see:
     * https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/27/exploring-windows-azure-drives-disks-and-images/.
     * Possible values include: 'none', 'readOnly', 'readWrite'
     *
     * @param {string}
     * jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.nodeAgentSKUId
     * The SKU of the Batch node agent to be provisioned on compute nodes in the
     * pool. The Batch node agent is a program that runs on each node in the pool,
     * and provides the command-and-control interface between the node and the
     * Batch service. There are different implementations of the node agent, known
     * as SKUs, for different operating systems. You must specify a node agent SKU
     * which matches the selected image reference. To get the list of supported
     * node agent SKUs along with their list of verified image references, see the
     * 'List supported node agent SKUs' operation.
     *
     * @param {object}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration]
     * Windows operating system settings on the virtual machine. This property must
     * not be specified if the imageReference or osDisk property specifies a Linux
     * OS image.
     *
     * @param {boolean}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration.enableAutomaticUpdates]
     * Whether automatic updates are enabled on the virtual machine. If omitted,
     * the default value is true.
     *
     * @param {number}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.maxTasksPerNode] The
     * maximum number of tasks that can run concurrently on a single compute node
     * in the pool. The default value is 1. The maximum value of this setting
     * depends on the size of the compute nodes in the pool (the vmSize setting).
     *
     * @param {object}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy]
     * How tasks are distributed across compute nodes in a pool.
     *
     * @param {string}
     * jobPatchParameter.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy.nodeFillType
     * How tasks are distributed across compute nodes in a pool. Values are:
     *
     * pack - As many tasks as possible (maxTasksPerNode) should be assigned to
     * each node in the pool before any tasks are assigned to the next node in the
     * pool.
     * spread - Tasks should be assigned evenly across all nodes in the pool.
     * Possible values include: 'spread', 'pack'
     *
     * @param {moment.duration}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.resizeTimeout] The
     * timeout for allocation of compute nodes to the pool. This timeout applies
     * only to manual scaling; it has no effect when enableAutoScale is set to
     * true. The default value is 15 minutes. The minimum value is 5 minutes. If
     * you specify a value less than 5 minutes, the Batch service rejects the
     * request with an error; if you are calling the REST API directly, the HTTP
     * status code is 400 (Bad Request).
     *
     * @param {number}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.targetDedicatedNodes]
     * The desired number of dedicated compute nodes in the pool. This property
     * must not be specified if enableAutoScale is set to true. If enableAutoScale
     * is set to false, then you must set either targetDedicatedNodes,
     * targetLowPriorityNodes, or both.
     *
     * @param {number}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.targetLowPriorityNodes]
     * The desired number of low-priority compute nodes in the pool. This property
     * must not be specified if enableAutoScale is set to true. If enableAutoScale
     * is set to false, then you must set either targetDedicatedNodes,
     * targetLowPriorityNodes, or both.
     *
     * @param {boolean}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.enableAutoScale]
     * Whether the pool size should automatically adjust over time. If false, at
     * least one of targetDedicateNodes and targetLowPriorityNodes must be
     * specified. If true, the autoScaleFormula element is required. The pool
     * automatically resizes according to the formula. The default value is false.
     *
     * @param {string}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.autoScaleFormula] The
     * formula for the desired number of compute nodes in the pool. This property
     * must not be specified if enableAutoScale is set to false. It is required if
     * enableAutoScale is set to true. The formula is checked for validity before
     * the pool is created. If the formula is not valid, the Batch service rejects
     * the request with detailed error information.
     *
     * @param {moment.duration}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.autoScaleEvaluationInterval]
     * The time interval at which to automatically adjust the pool size according
     * to the autoscale formula. The default value is 15 minutes. The minimum and
     * maximum value are 5 minutes and 168 hours respectively. If you specify a
     * value less than 5 minutes or greater than 168 hours, the Batch service
     * rejects the request with an invalid property value error; if you are calling
     * the REST API directly, the HTTP status code is 400 (Bad Request).
     *
     * @param {boolean}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.enableInterNodeCommunication]
     * Whether the pool permits direct communication between nodes. Enabling
     * inter-node communication limits the maximum size of the pool due to
     * deployment restrictions on the nodes of the pool. This may result in the
     * pool not reaching its desired size. The default value is false.
     *
     * @param {object}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration]
     * The network configuration for the pool.
     *
     * @param {string}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.subnetId]
     * The ARM resource identifier of the virtual network subnet which the compute
     * nodes of the pool will join. This is of the form
     * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
     * The virtual network must be in the same region and subscription as the Azure
     * Batch account. The specified subnet should have enough free IP addresses to
     * accommodate the number of nodes in the pool. If the subnet doesn't have
     * enough free IP addresses, the pool will partially allocate compute nodes,
     * and a resize error will occur. The 'MicrosoftAzureBatch' service principal
     * must have the 'Classic Virtual Machine Contributor' Role-Based Access
     * Control (RBAC) role for the specified VNet. The specified subnet must allow
     * communication from the Azure Batch service to be able to schedule tasks on
     * the compute nodes. This can be verified by checking if the specified VNet
     * has any associated Network Security Groups (NSG). If communication to the
     * compute nodes in the specified subnet is denied by an NSG, then the Batch
     * service will set the state of the compute nodes to unusable. For pools
     * created via virtualMachineConfiguration the Batch account must have
     * poolAllocationMode userSubscription in order to use a VNet. If the specified
     * VNet has any associated Network Security Groups (NSG), then a few reserved
     * system ports must be enabled for inbound communication. For pools created
     * with a virtual machine configuration, enable ports 29876 and 29877, as well
     * as port 22 for Linux and port 3389 for Windows. For pools created with a
     * cloud service configuration, enable ports 10100, 20100, and 30100. Also
     * enable outbound connections to Azure Storage on port 443. For more details
     * see:
     * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration
     *
     * @param {object}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration]
     * The configuration for endpoints on compute nodes in the Batch pool. Pool
     * endpoint configuration is only supported on pools with the
     * virtualMachineConfiguration property.
     *
     * @param {array}
     * jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration.inboundNATPools
     * A list of inbound NAT pools that can be used to address specific ports on an
     * individual compute node externally. The maximum number of inbound NAT pools
     * per Batch pool is 5. If the maximum number of inbound NAT pools is exceeded
     * the request fails with HTTP status code 400.
     *
     * @param {object}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask] A task to
     * run on each compute node as it joins the pool. The task runs when the node
     * is added to the pool or when the node is restarted.
     *
     * @param {string}
     * jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.commandLine
     * The command line of the start task. The command line does not run under a
     * shell, and therefore cannot take advantage of shell features such as
     * environment variable expansion. If you want to take advantage of such
     * features, you should invoke the shell in the command line, for example using
     * "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux.
     *
     * @param {array}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.resourceFiles]
     * A list of files that the Batch service will download to the compute node
     * before running the command line. Files listed under this element are located
     * in the task's working directory.
     *
     * @param {array}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.environmentSettings]
     * A list of environment variable settings for the start task.
     *
     * @param {object}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity]
     * The user identity under which the start task runs. If omitted, the task runs
     * as a non-administrative user unique to the task.
     *
     * @param {string}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.userName]
     * The name of the user identity under which the task is run. The userName and
     * autoUser properties are mutually exclusive; you must specify one but not
     * both.
     *
     * @param {object}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser]
     * The auto user under which the task is run. The userName and autoUser
     * properties are mutually exclusive; you must specify one but not both.
     *
     * @param {string}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.scope]
     * The scope for the auto user Values are:
     *
     * pool - specifies that the task runs as the common auto user account which is
     * created on every node in a pool.
     * task - specifies that the service should create a new user for the task.
     * The default value is task. Possible values include: 'task', 'pool'
     *
     * @param {string}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.elevationLevel]
     * The elevation level of the auto user. nonAdmin - The auto user is a standard
     * user without elevated access. admin - The auto user is a user with elevated
     * access and operates with full Administrator permissions. The default value
     * is nonAdmin. Possible values include: 'nonAdmin', 'admin'
     *
     * @param {number}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.maxTaskRetryCount]
     * The maximum number of times the task may be retried. The Batch service
     * retries a task if its exit code is nonzero. Note that this value
     * specifically controls the number of retries. The Batch service will try the
     * task once, and may then retry up to this limit. For example, if the maximum
     * retry count is 3, Batch tries the task up to 4 times (one initial try and 3
     * retries). If the maximum retry count is 0, the Batch service does not retry
     * the task. If the maximum retry count is -1, the Batch service retries the
     * task without limit.
     *
     * @param {boolean}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.waitForSuccess]
     * Whether the Batch service should wait for the start task to complete
     * successfully (that is, to exit with exit code 0) before scheduling any tasks
     * on the compute node. If true and the start task fails on a compute node, the
     * Batch service retries the start task up to its maximum retry count
     * (maxTaskRetryCount). If the task has still not completed successfully after
     * all retries, then the Batch service marks the compute node unusable, and
     * will not schedule tasks to it. This condition can be detected via the node
     * state and failure info details. If false, the Batch service will not wait
     * for the start task to complete. In this case, other tasks can start
     * executing on the compute node while the start task is still running; and
     * even if the start task fails, new tasks will continue to be scheduled on the
     * node. The default is false.
     *
     * @param {array}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.certificateReferences]
     * A list of certificates to be installed on each compute node in the pool. For
     * Windows compute nodes, the Batch service installs the certificates to the
     * specified certificate store and location. For Linux compute nodes, the
     * certificates are stored in a directory inside the task working directory and
     * an environment variable AZ_BATCH_CERTIFICATES_DIR is supplied to the task to
     * query for this location. For certificates with visibility of 'remoteUser', a
     * 'certs' directory is created in the user's home directory (e.g.,
     * /home/{user-name}/certs) and certificates are placed in that directory.
     *
     * @param {array}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.applicationPackageReferences]
     * The list of application packages to be installed on each compute node in the
     * pool.
     *
     * @param {array}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.applicationLicenses]
     * The list of application licenses the Batch service will make available on
     * each compute node in the pool. The list of application licenses must be a
     * subset of available Batch service application licenses. If a license is
     * requested which is not supported, pool creation will fail.
     *
     * @param {array}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.userAccounts] The
     * list of user accounts to be created on each node in the pool.
     *
     * @param {array}
     * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.metadata] A list of
     * name-value pairs associated with the pool as metadata. The Batch service
     * does not assign any meaning to metadata; it is solely for the use of user
     * code.
     *
     * @param {array} [jobPatchParameter.metadata] A list of name-value pairs
     * associated with the job as metadata. If omitted, the existing job metadata
     * is left unchanged.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.jobPatchOptions] Additional parameters for the
     * operation
     *
     * @param {number} [options.jobPatchOptions.timeout] The maximum time that the
     * server can spend processing the request, in seconds. The default is 30
     * seconds.
     *
     * @param {string} [options.jobPatchOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.jobPatchOptions.returnClientRequestId] Whether the
     * server should return the client-request-id in the response.
     *
     * @param {date} [options.jobPatchOptions.ocpDate] The time the request was
     * issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.jobPatchOptions.ifMatch] An ETag value associated
     * with the version of the resource known to the client. The operation will be
     * performed only if the resource's current ETag on the service exactly matches
     * the value specified by the client.
     *
     * @param {string} [options.jobPatchOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.jobPatchOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.jobPatchOptions.ifUnmodifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has not been
     * modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    patchWithHttpOperationResponse(jobId, jobPatchParameter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobPatchOptions = (options && options.jobPatchOptions !== undefined) ? options.jobPatchOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (jobPatchParameter === null || jobPatchParameter === undefined) {
                    throw new Error('jobPatchParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    timeout = jobPatchOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    clientRequestId = jobPatchOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    returnClientRequestId = jobPatchOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    ocpDate = jobPatchOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    ifMatch = jobPatchOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    ifNoneMatch = jobPatchOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    ifModifiedSince = jobPatchOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
                    ifUnmodifiedSince = jobPatchOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'PATCH';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (jobPatchParameter !== null && jobPatchParameter !== undefined) {
                    let requestModelMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["JobPatchParameter"];
                    requestModel = client.serializer.serialize(requestModelMapper, jobPatchParameter, 'jobPatchParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(jobPatchParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Updates the properties of the specified job.
     *
     * This fully replaces all the updateable properties of the job. For example,
     * if the job has constraints associated with it and if constraints is not
     * specified with this request, then the Batch service will remove the existing
     * constraints.
     *
     * @param {string} jobId The ID of the job whose properties you want to update.
     *
     * @param {object} jobUpdateParameter The parameters for the request.
     *
     * @param {number} [jobUpdateParameter.priority] The priority of the job.
     * Priority values can range from -1000 to 1000, with -1000 being the lowest
     * priority and 1000 being the highest priority. If omitted, it is set to the
     * default value 0.
     *
     * @param {object} [jobUpdateParameter.constraints] The execution constraints
     * for the job. If omitted, the constraints are cleared.
     *
     * @param {moment.duration} [jobUpdateParameter.constraints.maxWallClockTime]
     * The maximum elapsed time that the job may run, measured from the time the
     * job is created. If the job does not complete within the time limit, the
     * Batch service terminates it and any tasks that are still running. In this
     * case, the termination reason will be MaxWallClockTimeExpiry. If this
     * property is not specified, there is no time limit on how long the job may
     * run.
     *
     * @param {number} [jobUpdateParameter.constraints.maxTaskRetryCount] The
     * maximum number of times each task may be retried. The Batch service retries
     * a task if its exit code is nonzero. Note that this value specifically
     * controls the number of retries. The Batch service will try each task once,
     * and may then retry up to this limit. For example, if the maximum retry count
     * is 3, Batch tries a task up to 4 times (one initial try and 3 retries). If
     * the maximum retry count is 0, the Batch service does not retry tasks. If the
     * maximum retry count is -1, the Batch service retries tasks without limit.
     * The default value is 0 (no retries).
     *
     * @param {object} jobUpdateParameter.poolInfo The pool on which the Batch
     * service runs the job's tasks. You may change the pool for a job only when
     * the job is disabled. The Update Job call will fail if you include the
     * poolInfo element and the job is not disabled. If you specify an
     * autoPoolSpecification specification in the poolInfo, only the keepAlive
     * property can be updated, and then only if the auto pool has a
     * poolLifetimeOption of job.
     *
     * @param {string} [jobUpdateParameter.poolInfo.poolId] The ID of an existing
     * pool. All the tasks of the job will run on the specified pool. You must
     * ensure that the pool referenced by this property exists. If the pool does
     * not exist at the time the Batch service tries to schedule a job, no tasks
     * for the job will run until you create a pool with that id. Note that the
     * Batch service will not reject the job request; it will simply not run tasks
     * until the pool exists. You must specify either the pool ID or the auto pool
     * specification, but not both.
     *
     * @param {object} [jobUpdateParameter.poolInfo.autoPoolSpecification]
     * Characteristics for a temporary 'auto pool'. The Batch service will create
     * this auto pool when the job is submitted. If auto pool creation fails, the
     * Batch service moves the job to a completed state, and the pool creation
     * error is set in the job's scheduling error property. The Batch service
     * manages the lifetime (both creation and, unless keepAlive is specified,
     * deletion) of the auto pool. Any user actions that affect the lifetime of the
     * auto pool while the job is active will result in unexpected behavior. You
     * must specify either the pool ID or the auto pool specification, but not
     * both.
     *
     * @param {string}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.autoPoolIdPrefix] A
     * prefix to be added to the unique identifier when a pool is automatically
     * created. The Batch service assigns each auto pool a unique identifier on
     * creation. To distinguish between pools created for different purposes, you
     * can specify this element to add a prefix to the ID that is assigned. The
     * prefix can be up to 20 characters long.
     *
     * @param {string}
     * jobUpdateParameter.poolInfo.autoPoolSpecification.poolLifetimeOption The
     * minimum lifetime of created auto pools, and how multiple jobs on a schedule
     * are assigned to pools. When the pool lifetime is jobSchedule the pool exists
     * for the lifetime of the job schedule. The Batch Service creates the pool
     * when it creates the first job on the schedule. You may apply this option
     * only to job schedules, not to jobs. When the pool lifetime is job the pool
     * exists for the lifetime of the job to which it is dedicated. The Batch
     * service creates the pool when it creates the job. If the 'job' option is
     * applied to a job schedule, the Batch service creates a new auto pool for
     * every job created on the schedule. Possible values include: 'jobSchedule',
     * 'job'
     *
     * @param {boolean}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.keepAlive] Whether to
     * keep an auto pool alive after its lifetime expires. If false, the Batch
     * service deletes the pool once its lifetime (as determined by the
     * poolLifetimeOption setting) expires; that is, when the job or job schedule
     * completes. If true, the Batch service does not delete the pool
     * automatically. It is up to the user to delete auto pools created with this
     * option.
     *
     * @param {object} [jobUpdateParameter.poolInfo.autoPoolSpecification.pool] The
     * pool specification for the auto pool.
     *
     * @param {string}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.displayName] The
     * display name for the pool. The display name need not be unique and can
     * contain any Unicode characters up to a maximum length of 1024.
     *
     * @param {string}
     * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.vmSize The size of
     * the virtual machines in the pool. All virtual machines in a pool are the
     * same size. For information about available sizes of virtual machines for
     * Cloud Services pools (pools created with cloudServiceConfiguration), see
     * Sizes for Cloud Services
     * (http://azure.microsoft.com/documentation/articles/cloud-services-sizes-specs/).
     * Batch supports all Cloud Services VM sizes except ExtraSmall, A1V2 and A2V2.
     * For information about available VM sizes for pools using images from the
     * Virtual Machines Marketplace (pools created with
     * virtualMachineConfiguration) see Sizes for Virtual Machines (Linux)
     * (https://azure.microsoft.com/documentation/articles/virtual-machines-linux-sizes/)
     * or Sizes for Virtual Machines (Windows)
     * (https://azure.microsoft.com/documentation/articles/virtual-machines-windows-sizes/).
     * Batch supports all Azure VM sizes except STANDARD_A0 and those with premium
     * storage (STANDARD_GS, STANDARD_DS, and STANDARD_DSV2 series).
     *
     * @param {object}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration]
     * The cloud service configuration for the pool. This property must be
     * specified if the pool needs to be created with Azure PaaS VMs. This property
     * and virtualMachineConfiguration are mutually exclusive and one of the
     * properties must be specified. If neither is specified then the Batch service
     * returns an error; if you are calling the REST API directly, the HTTP status
     * code is 400 (Bad Request). This property cannot be specified if the Batch
     * account was created with its poolAllocationMode property set to
     * 'UserSubscription'.
     *
     * @param {string}
     * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.osFamily
     * The Azure Guest OS family to be installed on the virtual machines in the
     * pool. Possible values are: 2 - OS Family 2, equivalent to Windows Server
     * 2008 R2 SP1. 3 - OS Family 3, equivalent to Windows Server 2012. 4 - OS
     * Family 4, equivalent to Windows Server 2012 R2. 5 - OS Family 5, equivalent
     * to Windows Server 2016. For more information, see Azure Guest OS Releases
     * (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
     *
     * @param {string}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.targetOSVersion]
     * The Azure Guest OS version to be installed on the virtual machines in the
     * pool. The default value is * which specifies the latest operating system
     * version for the specified OS family.
     *
     * @param {string}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.currentOSVersion]
     * The Azure Guest OS Version currently installed on the virtual machines in
     * the pool. This may differ from targetOSVersion if the pool state is
     * Upgrading. In this case some virtual machines may be on the targetOSVersion
     * and some may be on the currentOSVersion during the upgrade process. Once all
     * virtual machines have upgraded, currentOSVersion is updated to be the same
     * as targetOSVersion.
     *
     * @param {object}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration]
     * The virtual machine configuration for the pool. This property must be
     * specified if the pool needs to be created with Azure IaaS VMs. This property
     * and cloudServiceConfiguration are mutually exclusive and one of the
     * properties must be specified. If neither is specified then the Batch service
     * returns an error; if you are calling the REST API directly, the HTTP status
     * code is 400 (Bad Request).
     *
     * @param {object}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference]
     * A reference to the Azure Virtual Machines Marketplace image to use. This
     * property and osDisk are mutually exclusive and one of the properties must be
     * specified.
     *
     * @param {string}
     * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.publisher
     * The publisher of the Azure Virtual Machines Marketplace image. For example,
     * Canonical or MicrosoftWindowsServer.
     *
     * @param {string}
     * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.offer
     * The offer type of the Azure Virtual Machines Marketplace image. For example,
     * UbuntuServer or WindowsServer.
     *
     * @param {string}
     * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.sku
     * The SKU of the Azure Virtual Machines Marketplace image. For example,
     * 14.04.0-LTS or 2012-R2-Datacenter.
     *
     * @param {string}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.version]
     * The version of the Azure Virtual Machines Marketplace image. A value of
     * 'latest' can be specified to select the latest version of an image. If
     * omitted, the default is 'latest'.
     *
     * @param {object}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.osDisk]
     * A reference to the OS disk image to use. This property can be specified only
     * if the Batch account was created with its poolAllocationMode property set to
     * 'UserSubscription'. This property and imageReference are mutually exclusive
     * and one of the properties must be specified.
     *
     * @param {array}
     * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.osDisk.imageUris
     * The collection of Virtual Hard Disk (VHD) URIs. All the VHDs must be
     * identical and must reside in an Azure Storage account within the same
     * subscription and same region as the Batch account. For best performance, it
     * is recommended that each VHD resides in a separate Azure Storage account.
     * Each VHD can serve upto 20 Windows compute nodes or 40 Linux compute nodes.
     * You must supply enough VHD URIs to satisfy the 'targetDedicated' property of
     * the pool. If you do not supply enough VHD URIs, the pool will partially
     * allocate compute nodes, and a resize error will occur.
     *
     * @param {string}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.osDisk.caching]
     * The type of caching to enable for the OS disk. Values are:
     *
     * none - The caching mode for the disk is not enabled.
     * readOnly - The caching mode for the disk is read only.
     * readWrite - The caching mode for the disk is read and write.
     *
     * The default value for caching is none. For information about the caching
     * options see:
     * https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/27/exploring-windows-azure-drives-disks-and-images/.
     * Possible values include: 'none', 'readOnly', 'readWrite'
     *
     * @param {string}
     * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.nodeAgentSKUId
     * The SKU of the Batch node agent to be provisioned on compute nodes in the
     * pool. The Batch node agent is a program that runs on each node in the pool,
     * and provides the command-and-control interface between the node and the
     * Batch service. There are different implementations of the node agent, known
     * as SKUs, for different operating systems. You must specify a node agent SKU
     * which matches the selected image reference. To get the list of supported
     * node agent SKUs along with their list of verified image references, see the
     * 'List supported node agent SKUs' operation.
     *
     * @param {object}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration]
     * Windows operating system settings on the virtual machine. This property must
     * not be specified if the imageReference or osDisk property specifies a Linux
     * OS image.
     *
     * @param {boolean}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration.enableAutomaticUpdates]
     * Whether automatic updates are enabled on the virtual machine. If omitted,
     * the default value is true.
     *
     * @param {number}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.maxTasksPerNode] The
     * maximum number of tasks that can run concurrently on a single compute node
     * in the pool. The default value is 1. The maximum value of this setting
     * depends on the size of the compute nodes in the pool (the vmSize setting).
     *
     * @param {object}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy]
     * How tasks are distributed across compute nodes in a pool.
     *
     * @param {string}
     * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy.nodeFillType
     * How tasks are distributed across compute nodes in a pool. Values are:
     *
     * pack - As many tasks as possible (maxTasksPerNode) should be assigned to
     * each node in the pool before any tasks are assigned to the next node in the
     * pool.
     * spread - Tasks should be assigned evenly across all nodes in the pool.
     * Possible values include: 'spread', 'pack'
     *
     * @param {moment.duration}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.resizeTimeout] The
     * timeout for allocation of compute nodes to the pool. This timeout applies
     * only to manual scaling; it has no effect when enableAutoScale is set to
     * true. The default value is 15 minutes. The minimum value is 5 minutes. If
     * you specify a value less than 5 minutes, the Batch service rejects the
     * request with an error; if you are calling the REST API directly, the HTTP
     * status code is 400 (Bad Request).
     *
     * @param {number}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.targetDedicatedNodes]
     * The desired number of dedicated compute nodes in the pool. This property
     * must not be specified if enableAutoScale is set to true. If enableAutoScale
     * is set to false, then you must set either targetDedicatedNodes,
     * targetLowPriorityNodes, or both.
     *
     * @param {number}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.targetLowPriorityNodes]
     * The desired number of low-priority compute nodes in the pool. This property
     * must not be specified if enableAutoScale is set to true. If enableAutoScale
     * is set to false, then you must set either targetDedicatedNodes,
     * targetLowPriorityNodes, or both.
     *
     * @param {boolean}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.enableAutoScale]
     * Whether the pool size should automatically adjust over time. If false, at
     * least one of targetDedicateNodes and targetLowPriorityNodes must be
     * specified. If true, the autoScaleFormula element is required. The pool
     * automatically resizes according to the formula. The default value is false.
     *
     * @param {string}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.autoScaleFormula]
     * The formula for the desired number of compute nodes in the pool. This
     * property must not be specified if enableAutoScale is set to false. It is
     * required if enableAutoScale is set to true. The formula is checked for
     * validity before the pool is created. If the formula is not valid, the Batch
     * service rejects the request with detailed error information.
     *
     * @param {moment.duration}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.autoScaleEvaluationInterval]
     * The time interval at which to automatically adjust the pool size according
     * to the autoscale formula. The default value is 15 minutes. The minimum and
     * maximum value are 5 minutes and 168 hours respectively. If you specify a
     * value less than 5 minutes or greater than 168 hours, the Batch service
     * rejects the request with an invalid property value error; if you are calling
     * the REST API directly, the HTTP status code is 400 (Bad Request).
     *
     * @param {boolean}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.enableInterNodeCommunication]
     * Whether the pool permits direct communication between nodes. Enabling
     * inter-node communication limits the maximum size of the pool due to
     * deployment restrictions on the nodes of the pool. This may result in the
     * pool not reaching its desired size. The default value is false.
     *
     * @param {object}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration]
     * The network configuration for the pool.
     *
     * @param {string}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.subnetId]
     * The ARM resource identifier of the virtual network subnet which the compute
     * nodes of the pool will join. This is of the form
     * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
     * The virtual network must be in the same region and subscription as the Azure
     * Batch account. The specified subnet should have enough free IP addresses to
     * accommodate the number of nodes in the pool. If the subnet doesn't have
     * enough free IP addresses, the pool will partially allocate compute nodes,
     * and a resize error will occur. The 'MicrosoftAzureBatch' service principal
     * must have the 'Classic Virtual Machine Contributor' Role-Based Access
     * Control (RBAC) role for the specified VNet. The specified subnet must allow
     * communication from the Azure Batch service to be able to schedule tasks on
     * the compute nodes. This can be verified by checking if the specified VNet
     * has any associated Network Security Groups (NSG). If communication to the
     * compute nodes in the specified subnet is denied by an NSG, then the Batch
     * service will set the state of the compute nodes to unusable. For pools
     * created via virtualMachineConfiguration the Batch account must have
     * poolAllocationMode userSubscription in order to use a VNet. If the specified
     * VNet has any associated Network Security Groups (NSG), then a few reserved
     * system ports must be enabled for inbound communication. For pools created
     * with a virtual machine configuration, enable ports 29876 and 29877, as well
     * as port 22 for Linux and port 3389 for Windows. For pools created with a
     * cloud service configuration, enable ports 10100, 20100, and 30100. Also
     * enable outbound connections to Azure Storage on port 443. For more details
     * see:
     * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration
     *
     * @param {object}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration]
     * The configuration for endpoints on compute nodes in the Batch pool. Pool
     * endpoint configuration is only supported on pools with the
     * virtualMachineConfiguration property.
     *
     * @param {array}
     * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration.inboundNATPools
     * A list of inbound NAT pools that can be used to address specific ports on an
     * individual compute node externally. The maximum number of inbound NAT pools
     * per Batch pool is 5. If the maximum number of inbound NAT pools is exceeded
     * the request fails with HTTP status code 400.
     *
     * @param {object}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask] A task to
     * run on each compute node as it joins the pool. The task runs when the node
     * is added to the pool or when the node is restarted.
     *
     * @param {string}
     * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.commandLine
     * The command line of the start task. The command line does not run under a
     * shell, and therefore cannot take advantage of shell features such as
     * environment variable expansion. If you want to take advantage of such
     * features, you should invoke the shell in the command line, for example using
     * "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux.
     *
     * @param {array}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.resourceFiles]
     * A list of files that the Batch service will download to the compute node
     * before running the command line. Files listed under this element are located
     * in the task's working directory.
     *
     * @param {array}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.environmentSettings]
     * A list of environment variable settings for the start task.
     *
     * @param {object}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity]
     * The user identity under which the start task runs. If omitted, the task runs
     * as a non-administrative user unique to the task.
     *
     * @param {string}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.userName]
     * The name of the user identity under which the task is run. The userName and
     * autoUser properties are mutually exclusive; you must specify one but not
     * both.
     *
     * @param {object}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser]
     * The auto user under which the task is run. The userName and autoUser
     * properties are mutually exclusive; you must specify one but not both.
     *
     * @param {string}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.scope]
     * The scope for the auto user Values are:
     *
     * pool - specifies that the task runs as the common auto user account which is
     * created on every node in a pool.
     * task - specifies that the service should create a new user for the task.
     * The default value is task. Possible values include: 'task', 'pool'
     *
     * @param {string}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.elevationLevel]
     * The elevation level of the auto user. nonAdmin - The auto user is a standard
     * user without elevated access. admin - The auto user is a user with elevated
     * access and operates with full Administrator permissions. The default value
     * is nonAdmin. Possible values include: 'nonAdmin', 'admin'
     *
     * @param {number}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.maxTaskRetryCount]
     * The maximum number of times the task may be retried. The Batch service
     * retries a task if its exit code is nonzero. Note that this value
     * specifically controls the number of retries. The Batch service will try the
     * task once, and may then retry up to this limit. For example, if the maximum
     * retry count is 3, Batch tries the task up to 4 times (one initial try and 3
     * retries). If the maximum retry count is 0, the Batch service does not retry
     * the task. If the maximum retry count is -1, the Batch service retries the
     * task without limit.
     *
     * @param {boolean}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.waitForSuccess]
     * Whether the Batch service should wait for the start task to complete
     * successfully (that is, to exit with exit code 0) before scheduling any tasks
     * on the compute node. If true and the start task fails on a compute node, the
     * Batch service retries the start task up to its maximum retry count
     * (maxTaskRetryCount). If the task has still not completed successfully after
     * all retries, then the Batch service marks the compute node unusable, and
     * will not schedule tasks to it. This condition can be detected via the node
     * state and failure info details. If false, the Batch service will not wait
     * for the start task to complete. In this case, other tasks can start
     * executing on the compute node while the start task is still running; and
     * even if the start task fails, new tasks will continue to be scheduled on the
     * node. The default is false.
     *
     * @param {array}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.certificateReferences]
     * A list of certificates to be installed on each compute node in the pool. For
     * Windows compute nodes, the Batch service installs the certificates to the
     * specified certificate store and location. For Linux compute nodes, the
     * certificates are stored in a directory inside the task working directory and
     * an environment variable AZ_BATCH_CERTIFICATES_DIR is supplied to the task to
     * query for this location. For certificates with visibility of 'remoteUser', a
     * 'certs' directory is created in the user's home directory (e.g.,
     * /home/{user-name}/certs) and certificates are placed in that directory.
     *
     * @param {array}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.applicationPackageReferences]
     * The list of application packages to be installed on each compute node in the
     * pool.
     *
     * @param {array}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.applicationLicenses]
     * The list of application licenses the Batch service will make available on
     * each compute node in the pool. The list of application licenses must be a
     * subset of available Batch service application licenses. If a license is
     * requested which is not supported, pool creation will fail.
     *
     * @param {array}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.userAccounts] The
     * list of user accounts to be created on each node in the pool.
     *
     * @param {array}
     * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.metadata] A list of
     * name-value pairs associated with the pool as metadata. The Batch service
     * does not assign any meaning to metadata; it is solely for the use of user
     * code.
     *
     * @param {array} [jobUpdateParameter.metadata] A list of name-value pairs
     * associated with the job as metadata. If omitted, it takes the default value
     * of an empty list; in effect, any existing metadata is deleted.
     *
     * @param {string} [jobUpdateParameter.onAllTasksComplete] The action the Batch
     * service should take when all tasks in the job are in the completed state. If
     * omitted, the completion behavior is set to noAction. If the current value is
     * terminateJob, this is an error because a job's completion behavior may not
     * be changed from terminateJob to noAction. You may not change the value from
     * terminatejob to noaction - that is, once you have engaged automatic job
     * termination, you cannot turn it off again. If you try to do this, the
     * request fails and Batch returns status code 400 (Bad Request) and an
     * 'invalid property value' error response. If you do not specify this element
     * in a PUT request, it is equivalent to passing noaction. This is an error if
     * the current value is terminatejob. Possible values include: 'noAction',
     * 'terminateJob'
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.jobUpdateOptions] Additional parameters for the
     * operation
     *
     * @param {number} [options.jobUpdateOptions.timeout] The maximum time that the
     * server can spend processing the request, in seconds. The default is 30
     * seconds.
     *
     * @param {string} [options.jobUpdateOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.jobUpdateOptions.returnClientRequestId] Whether
     * the server should return the client-request-id in the response.
     *
     * @param {date} [options.jobUpdateOptions.ocpDate] The time the request was
     * issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.jobUpdateOptions.ifMatch] An ETag value associated
     * with the version of the resource known to the client. The operation will be
     * performed only if the resource's current ETag on the service exactly matches
     * the value specified by the client.
     *
     * @param {string} [options.jobUpdateOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.jobUpdateOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.jobUpdateOptions.ifUnmodifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has not been
     * modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updateWithHttpOperationResponse(jobId, jobUpdateParameter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobUpdateOptions = (options && options.jobUpdateOptions !== undefined) ? options.jobUpdateOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (jobUpdateParameter === null || jobUpdateParameter === undefined) {
                    throw new Error('jobUpdateParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    timeout = jobUpdateOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    clientRequestId = jobUpdateOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    returnClientRequestId = jobUpdateOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    ocpDate = jobUpdateOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    ifMatch = jobUpdateOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    ifNoneMatch = jobUpdateOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    ifModifiedSince = jobUpdateOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
                    ifUnmodifiedSince = jobUpdateOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'PUT';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (jobUpdateParameter !== null && jobUpdateParameter !== undefined) {
                    let requestModelMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["JobUpdateParameter"];
                    requestModel = client.serializer.serialize(requestModelMapper, jobUpdateParameter, 'jobUpdateParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(jobUpdateParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Disables the specified job, preventing new tasks from running.
     *
     * The Batch Service immediately moves the job to the disabling state. Batch
     * then uses the disableTasks parameter to determine what to do with the
     * currently running tasks of the job. The job remains in the disabling state
     * until the disable operation is completed and all tasks have been dealt with
     * according to the disableTasks option; the job then moves to the disabled
     * state. No new tasks are started under the job until it moves back to active
     * state. If you try to disable a job that is in any state other than active,
     * disabling, or disabled, the request fails with status code 409.
     *
     * @param {string} jobId The ID of the job to disable.
     *
     * @param {string} disableTasks What to do with active tasks associated with
     * the job. Values are:
     *
     * requeue - Terminate running tasks and requeue them. The tasks will run again
     * when the job is enabled.
     * terminate - Terminate running tasks. The tasks will not run again.
     * wait - Allow currently running tasks to complete. Possible values include:
     * 'requeue', 'terminate', 'wait'
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.jobDisableOptions] Additional parameters for the
     * operation
     *
     * @param {number} [options.jobDisableOptions.timeout] The maximum time that
     * the server can spend processing the request, in seconds. The default is 30
     * seconds.
     *
     * @param {string} [options.jobDisableOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.jobDisableOptions.returnClientRequestId] Whether
     * the server should return the client-request-id in the response.
     *
     * @param {date} [options.jobDisableOptions.ocpDate] The time the request was
     * issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.jobDisableOptions.ifMatch] An ETag value associated
     * with the version of the resource known to the client. The operation will be
     * performed only if the resource's current ETag on the service exactly matches
     * the value specified by the client.
     *
     * @param {string} [options.jobDisableOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.jobDisableOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.jobDisableOptions.ifUnmodifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has not been
     * modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    disableWithHttpOperationResponse(jobId, disableTasks, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobDisableOptions = (options && options.jobDisableOptions !== undefined) ? options.jobDisableOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (disableTasks) {
                    let allowedValues = ['requeue', 'terminate', 'wait'];
                    if (!allowedValues.some(function (item) { return item === disableTasks; })) {
                        throw new Error(disableTasks + ' is not a valid value. The valid values are: ' + allowedValues);
                    }
                }
                else {
                    throw new Error('disableTasks cannot be null or undefined.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            let jobDisableParameter = {};
            try {
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    timeout = jobDisableOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    clientRequestId = jobDisableOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    returnClientRequestId = jobDisableOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    ocpDate = jobDisableOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    ifMatch = jobDisableOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    ifNoneMatch = jobDisableOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    ifModifiedSince = jobDisableOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
                    ifUnmodifiedSince = jobDisableOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
                if (disableTasks !== null && disableTasks !== undefined) {
                    jobDisableParameter.disableTasks = disableTasks;
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/disable';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (jobDisableParameter !== null && jobDisableParameter !== undefined) {
                    let requestModelMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["JobDisableParameter"];
                    requestModel = client.serializer.serialize(requestModelMapper, jobDisableParameter, 'jobDisableParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(jobDisableParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Enables the specified job, allowing new tasks to run.
     *
     * When you call this API, the Batch service sets a disabled job to the
     * enabling state. After the this operation is completed, the job moves to the
     * active state, and scheduling of new tasks under the job resumes. The Batch
     * service does not allow a task to remain in the active state for more than 7
     * days. Therefore, if you enable a job containing active tasks which were
     * added more than 7 days ago, those tasks will not run.
     *
     * @param {string} jobId The ID of the job to enable.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.jobEnableOptions] Additional parameters for the
     * operation
     *
     * @param {number} [options.jobEnableOptions.timeout] The maximum time that the
     * server can spend processing the request, in seconds. The default is 30
     * seconds.
     *
     * @param {string} [options.jobEnableOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.jobEnableOptions.returnClientRequestId] Whether
     * the server should return the client-request-id in the response.
     *
     * @param {date} [options.jobEnableOptions.ocpDate] The time the request was
     * issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.jobEnableOptions.ifMatch] An ETag value associated
     * with the version of the resource known to the client. The operation will be
     * performed only if the resource's current ETag on the service exactly matches
     * the value specified by the client.
     *
     * @param {string} [options.jobEnableOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.jobEnableOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.jobEnableOptions.ifUnmodifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has not been
     * modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    enableWithHttpOperationResponse(jobId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobEnableOptions = (options && options.jobEnableOptions !== undefined) ? options.jobEnableOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    timeout = jobEnableOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    clientRequestId = jobEnableOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    returnClientRequestId = jobEnableOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    ocpDate = jobEnableOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    ifMatch = jobEnableOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    ifNoneMatch = jobEnableOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    ifModifiedSince = jobEnableOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
                    ifUnmodifiedSince = jobEnableOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/enable';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Terminates the specified job, marking it as completed.
     *
     * When a Terminate Job request is received, the Batch service sets the job to
     * the terminating state. The Batch service then terminates any active or
     * running tasks associated with the job, and runs any required Job Release
     * tasks. The job then moves into the completed state.
     *
     * @param {string} jobId The ID of the job to terminate.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.terminateReason] The text you want to appear as the
     * job's TerminateReason. The default is 'UserTerminate'.
     *
     * @param {object} [options.jobTerminateOptions] Additional parameters for the
     * operation
     *
     * @param {number} [options.jobTerminateOptions.timeout] The maximum time that
     * the server can spend processing the request, in seconds. The default is 30
     * seconds.
     *
     * @param {string} [options.jobTerminateOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.jobTerminateOptions.returnClientRequestId] Whether
     * the server should return the client-request-id in the response.
     *
     * @param {date} [options.jobTerminateOptions.ocpDate] The time the request was
     * issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.jobTerminateOptions.ifMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.
     *
     * @param {string} [options.jobTerminateOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.jobTerminateOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.jobTerminateOptions.ifUnmodifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has not been
     * modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    terminateWithHttpOperationResponse(jobId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let terminateReason = (options && options.terminateReason !== undefined) ? options.terminateReason : undefined;
            let jobTerminateOptions = (options && options.jobTerminateOptions !== undefined) ? options.jobTerminateOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (terminateReason !== null && terminateReason !== undefined && typeof terminateReason.valueOf() !== 'string') {
                    throw new Error('terminateReason must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            let jobTerminateParameter;
            try {
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    timeout = jobTerminateOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    clientRequestId = jobTerminateOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    returnClientRequestId = jobTerminateOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    ocpDate = jobTerminateOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    ifMatch = jobTerminateOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    ifNoneMatch = jobTerminateOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    ifModifiedSince = jobTerminateOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
                    ifUnmodifiedSince = jobTerminateOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
                if (terminateReason !== null && terminateReason !== undefined) {
                    jobTerminateParameter = {};
                    jobTerminateParameter.terminateReason = terminateReason;
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/terminate';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (jobTerminateParameter !== null && jobTerminateParameter !== undefined) {
                    let requestModelMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["JobTerminateParameter"];
                    requestModel = client.serializer.serialize(requestModelMapper, jobTerminateParameter, 'jobTerminateParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(jobTerminateParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Adds a job to the specified account.
     *
     * The Batch service supports two ways to control the work done as part of a
     * job. In the first approach, the user specifies a Job Manager task. The Batch
     * service launches this task when it is ready to start the job. The Job
     * Manager task controls all other tasks that run under this job, by using the
     * Task APIs. In the second approach, the user directly controls the execution
     * of tasks under an active job, by using the Task APIs. Also note: when naming
     * jobs, avoid including sensitive information such as user names or secret
     * project names. This information may appear in telemetry logs accessible to
     * Microsoft Support engineers.
     *
     * @param {object} job The job to be added.
     *
     * @param {string} job.id A string that uniquely identifies the job within the
     * account. The ID can contain any combination of alphanumeric characters
     * including hyphens and underscores, and cannot contain more than 64
     * characters. The ID is case-preserving and case-insensitive (that is, you may
     * not have two IDs within an account that differ only by case).
     *
     * @param {string} [job.displayName] The display name for the job. The display
     * name need not be unique and can contain any Unicode characters up to a
     * maximum length of 1024.
     *
     * @param {number} [job.priority] The priority of the job. Priority values can
     * range from -1000 to 1000, with -1000 being the lowest priority and 1000
     * being the highest priority. The default value is 0.
     *
     * @param {object} [job.constraints] The execution constraints for the job.
     *
     * @param {moment.duration} [job.constraints.maxWallClockTime] The maximum
     * elapsed time that the job may run, measured from the time the job is
     * created. If the job does not complete within the time limit, the Batch
     * service terminates it and any tasks that are still running. In this case,
     * the termination reason will be MaxWallClockTimeExpiry. If this property is
     * not specified, there is no time limit on how long the job may run.
     *
     * @param {number} [job.constraints.maxTaskRetryCount] The maximum number of
     * times each task may be retried. The Batch service retries a task if its exit
     * code is nonzero. Note that this value specifically controls the number of
     * retries. The Batch service will try each task once, and may then retry up to
     * this limit. For example, if the maximum retry count is 3, Batch tries a task
     * up to 4 times (one initial try and 3 retries). If the maximum retry count is
     * 0, the Batch service does not retry tasks. If the maximum retry count is -1,
     * the Batch service retries tasks without limit. The default value is 0 (no
     * retries).
     *
     * @param {object} [job.jobManagerTask] Details of a Job Manager task to be
     * launched when the job is started. If the job does not specify a Job Manager
     * task, the user must explicitly add tasks to the job. If the job does specify
     * a Job Manager task, the Batch service creates the Job Manager task when the
     * job is created, and will try to schedule the Job Manager task before
     * scheduling other tasks in the job. The Job Manager task's typical purpose is
     * to control and/or monitor job execution, for example by deciding what
     * additional tasks to run, determining when the work is complete, etc.
     * (However, a Job Manager task is not restricted to these activities - it is a
     * fully-fledged task in the system and perform whatever actions are required
     * for the job.) For example, a Job Manager task might download a file
     * specified as a parameter, analyze the contents of that file and submit
     * additional tasks based on those contents.
     *
     * @param {string} job.jobManagerTask.id A string that uniquely identifies the
     * Job Manager task within the job. The ID can contain any combination of
     * alphanumeric characters including hyphens and underscores and cannot contain
     * more than 64 characters.
     *
     * @param {string} [job.jobManagerTask.displayName] The display name of the Job
     * Manager task. It need not be unique and can contain any Unicode characters
     * up to a maximum length of 1024.
     *
     * @param {string} job.jobManagerTask.commandLine The command line of the Job
     * Manager task. The command line does not run under a shell, and therefore
     * cannot take advantage of shell features such as environment variable
     * expansion. If you want to take advantage of such features, you should invoke
     * the shell in the command line, for example using "cmd /c MyCommand" in
     * Windows or "/bin/sh -c MyCommand" in Linux.
     *
     * @param {array} [job.jobManagerTask.resourceFiles] A list of files that the
     * Batch service will download to the compute node before running the command
     * line. Files listed under this element are located in the task's working
     * directory.
     *
     * @param {array} [job.jobManagerTask.outputFiles] A list of files that the
     * Batch service will upload from the compute node after running the command
     * line. For multi-instance tasks, the files will only be uploaded from the
     * compute node on which the primary task is executed.
     *
     * @param {array} [job.jobManagerTask.environmentSettings] A list of
     * environment variable settings for the Job Manager task.
     *
     * @param {object} [job.jobManagerTask.constraints] Constraints that apply to
     * the Job Manager task.
     *
     * @param {boolean} [job.jobManagerTask.killJobOnCompletion] Whether completion
     * of the Job Manager task signifies completion of the entire job. If true,
     * when the Job Manager task completes, the Batch service marks the job as
     * complete. If any tasks are still running at this time (other than Job
     * Release), those tasks are terminated. If false, the completion of the Job
     * Manager task does not affect the job status. In this case, you should either
     * use the onAllTasksComplete attribute to terminate the job, or have a client
     * or user terminate the job explicitly. An example of this is if the Job
     * Manager creates a set of tasks but then takes no further role in their
     * execution. The default value is true. If you are using the
     * onAllTasksComplete and onTaskFailure attributes to control job lifetime, and
     * using the Job Manager task only to create the tasks for the job (not to
     * monitor progress), then it is important to set killJobOnCompletion to false.
     *
     * @param {object} [job.jobManagerTask.userIdentity] The user identity under
     * which the Job Manager task runs. If omitted, the task runs as a
     * non-administrative user unique to the task.
     *
     * @param {boolean} [job.jobManagerTask.runExclusive] Whether the Job Manager
     * task requires exclusive use of the compute node where it runs. If true, no
     * other tasks will run on the same compute node for as long as the Job Manager
     * is running. If false, other tasks can run simultaneously with the Job
     * Manager on a compute node. The Job Manager task counts normally against the
     * node's concurrent task limit, so this is only relevant if the node allows
     * multiple concurrent tasks. The default value is true.
     *
     * @param {array} [job.jobManagerTask.applicationPackageReferences] A list of
     * application packages that the Batch service will deploy to the compute node
     * before running the command line. Application packages are downloaded and
     * deployed to a shared directory, not the task working directory. Therefore,
     * if a referenced package is already on the compute node, and is up to date,
     * then it is not re-downloaded; the existing copy on the compute node is used.
     * If a referenced application package cannot be installed, for example because
     * the package has been deleted or because download failed, the task fails.
     *
     * @param {object} [job.jobManagerTask.authenticationTokenSettings] The
     * settings for an authentication token that the task can use to perform Batch
     * service operations. If this property is set, the Batch service provides the
     * task with an authentication token which can be used to authenticate Batch
     * service operations without requiring an account access key. The token is
     * provided via the AZ_BATCH_AUTHENTICATION_TOKEN environment variable. The
     * operations that the task can carry out using the token depend on the
     * settings. For example, a task can request job permissions in order to add
     * other tasks to the job, or check the status of the job or of other tasks
     * under the job.
     *
     * @param {array} [job.jobManagerTask.authenticationTokenSettings.access] The
     * Batch resources to which the token grants access. The authentication token
     * grants access to a limited set of Batch service operations. Currently the
     * only supported value for the access property is 'job', which grants access
     * to all operations related to the job which contains the task.
     *
     * @param {boolean} [job.jobManagerTask.allowLowPriorityNode] Whether the Job
     * Manager task may run on a low-priority compute node. The default value is
     * false.
     *
     * @param {object} [job.jobPreparationTask] The Job Preparation task. If a job
     * has a Job Preparation task, the Batch service will run the Job Preparation
     * task on a compute node before starting any tasks of that job on that compute
     * node.
     *
     * @param {string} [job.jobPreparationTask.id] A string that uniquely
     * identifies the Job Preparation task within the job. The ID can contain any
     * combination of alphanumeric characters including hyphens and underscores and
     * cannot contain more than 64 characters. If you do not specify this property,
     * the Batch service assigns a default value of 'jobpreparation'. No other task
     * in the job can have the same ID as the Job Preparation task. If you try to
     * submit a task with the same id, the Batch service rejects the request with
     * error code TaskIdSameAsJobPreparationTask; if you are calling the REST API
     * directly, the HTTP status code is 409 (Conflict).
     *
     * @param {string} job.jobPreparationTask.commandLine The command line of the
     * Job Preparation task. The command line does not run under a shell, and
     * therefore cannot take advantage of shell features such as environment
     * variable expansion. If you want to take advantage of such features, you
     * should invoke the shell in the command line, for example using "cmd /c
     * MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux.
     *
     * @param {array} [job.jobPreparationTask.resourceFiles] A list of files that
     * the Batch service will download to the compute node before running the
     * command line. Files listed under this element are located in the task's
     * working directory.
     *
     * @param {array} [job.jobPreparationTask.environmentSettings] A list of
     * environment variable settings for the Job Preparation task.
     *
     * @param {object} [job.jobPreparationTask.constraints] Constraints that apply
     * to the Job Preparation task.
     *
     * @param {moment.duration}
     * [job.jobPreparationTask.constraints.maxWallClockTime] The maximum elapsed
     * time that the task may run, measured from the time the task starts. If the
     * task does not complete within the time limit, the Batch service terminates
     * it. If this is not specified, there is no time limit on how long the task
     * may run.
     *
     * @param {moment.duration} [job.jobPreparationTask.constraints.retentionTime]
     * The minimum time to retain the task directory on the compute node where it
     * ran, from the time it completes execution. After this time, the Batch
     * service may delete the task directory and all its contents. The default is
     * infinite, i.e. the task directory will be retained until the compute node is
     * removed or reimaged.
     *
     * @param {number} [job.jobPreparationTask.constraints.maxTaskRetryCount] The
     * maximum number of times the task may be retried. The Batch service retries a
     * task if its exit code is nonzero. Note that this value specifically controls
     * the number of retries. The Batch service will try the task once, and may
     * then retry up to this limit. For example, if the maximum retry count is 3,
     * Batch tries the task up to 4 times (one initial try and 3 retries). If the
     * maximum retry count is 0, the Batch service does not retry the task. If the
     * maximum retry count is -1, the Batch service retries the task without limit.
     *
     * @param {boolean} [job.jobPreparationTask.waitForSuccess] Whether the Batch
     * service should wait for the Job Preparation task to complete successfully
     * before scheduling any other tasks of the job on the compute node. A Job
     * Preparation task has completed successfully if it exits with exit code 0. If
     * true and the Job Preparation task fails on a compute node, the Batch service
     * retries the Job Preparation task up to its maximum retry count (as specified
     * in the constraints element). If the task has still not completed
     * successfully after all retries, then the Batch service will not schedule
     * tasks of the job to the compute node. The compute node remains active and
     * eligible to run tasks of other jobs. If false, the Batch service will not
     * wait for the Job Preparation task to complete. In this case, other tasks of
     * the job can start executing on the compute node while the Job Preparation
     * task is still running; and even if the Job Preparation task fails, new tasks
     * will continue to be scheduled on the node. The default value is true.
     *
     * @param {object} [job.jobPreparationTask.userIdentity] The user identity
     * under which the Job Preparation task runs. If omitted, the task runs as a
     * non-administrative user unique to the task on Windows nodes, or a a
     * non-administrative user unique to the pool on Linux nodes.
     *
     * @param {boolean} [job.jobPreparationTask.rerunOnNodeRebootAfterSuccess]
     * Whether the Batch service should rerun the Job Preparation task after a
     * compute node reboots. The Job Preparation task is always rerun if a compute
     * node is reimaged, or if the Job Preparation task did not complete (e.g.
     * because the reboot occurred while the task was running). Therefore, you
     * should always write a Job Preparation task to be idempotent and to behave
     * correctly if run multiple times. The default value is true.
     *
     * @param {object} [job.jobReleaseTask] The Job Release task. A Job Release
     * task cannot be specified without also specifying a Job Preparation task for
     * the job. The Batch service runs the Job Release task on the compute nodes
     * that have run the Job Preparation task. The primary purpose of the Job
     * Release task is to undo changes to compute nodes made by the Job Preparation
     * task. Example activities include deleting local files, or shutting down
     * services that were started as part of job preparation.
     *
     * @param {string} [job.jobReleaseTask.id] A string that uniquely identifies
     * the Job Release task within the job. The ID can contain any combination of
     * alphanumeric characters including hyphens and underscores and cannot contain
     * more than 64 characters. If you do not specify this property, the Batch
     * service assigns a default value of 'jobrelease'. No other task in the job
     * can have the same ID as the Job Release task. If you try to submit a task
     * with the same id, the Batch service rejects the request with error code
     * TaskIdSameAsJobReleaseTask; if you are calling the REST API directly, the
     * HTTP status code is 409 (Conflict).
     *
     * @param {string} job.jobReleaseTask.commandLine The command line of the Job
     * Release task. The command line does not run under a shell, and therefore
     * cannot take advantage of shell features such as environment variable
     * expansion. If you want to take advantage of such features, you should invoke
     * the shell in the command line, for example using "cmd /c MyCommand" in
     * Windows or "/bin/sh -c MyCommand" in Linux.
     *
     * @param {array} [job.jobReleaseTask.resourceFiles] A list of files that the
     * Batch service will download to the compute node before running the command
     * line. Files listed under this element are located in the task's working
     * directory.
     *
     * @param {array} [job.jobReleaseTask.environmentSettings] A list of
     * environment variable settings for the Job Release task.
     *
     * @param {moment.duration} [job.jobReleaseTask.maxWallClockTime] The maximum
     * elapsed time that the Job Release task may run on a given compute node,
     * measured from the time the task starts. If the task does not complete within
     * the time limit, the Batch service terminates it. The default value is 15
     * minutes. You may not specify a timeout longer than 15 minutes. If you do,
     * the Batch service rejects it with an error; if you are calling the REST API
     * directly, the HTTP status code is 400 (Bad Request).
     *
     * @param {moment.duration} [job.jobReleaseTask.retentionTime] The minimum time
     * to retain the task directory for the Job Release task on the compute node.
     * After this time, the Batch service may delete the task directory and all its
     * contents. The default is infinite, i.e. the task directory will be retained
     * until the compute node is removed or reimaged.
     *
     * @param {object} [job.jobReleaseTask.userIdentity] The user identity under
     * which the Job Release task runs. If omitted, the task runs as a
     * non-administrative user unique to the task.
     *
     * @param {array} [job.commonEnvironmentSettings] The list of common
     * environment variable settings. These environment variables are set for all
     * tasks in the job (including the Job Manager, Job Preparation and Job Release
     * tasks). Individual tasks can override an environment setting specified here
     * by specifying the same setting name with a different value.
     *
     * @param {object} job.poolInfo The pool on which the Batch service runs the
     * job's tasks.
     *
     * @param {string} [job.poolInfo.poolId] The ID of an existing pool. All the
     * tasks of the job will run on the specified pool. You must ensure that the
     * pool referenced by this property exists. If the pool does not exist at the
     * time the Batch service tries to schedule a job, no tasks for the job will
     * run until you create a pool with that id. Note that the Batch service will
     * not reject the job request; it will simply not run tasks until the pool
     * exists. You must specify either the pool ID or the auto pool specification,
     * but not both.
     *
     * @param {object} [job.poolInfo.autoPoolSpecification] Characteristics for a
     * temporary 'auto pool'. The Batch service will create this auto pool when the
     * job is submitted. If auto pool creation fails, the Batch service moves the
     * job to a completed state, and the pool creation error is set in the job's
     * scheduling error property. The Batch service manages the lifetime (both
     * creation and, unless keepAlive is specified, deletion) of the auto pool. Any
     * user actions that affect the lifetime of the auto pool while the job is
     * active will result in unexpected behavior. You must specify either the pool
     * ID or the auto pool specification, but not both.
     *
     * @param {string} [job.poolInfo.autoPoolSpecification.autoPoolIdPrefix] A
     * prefix to be added to the unique identifier when a pool is automatically
     * created. The Batch service assigns each auto pool a unique identifier on
     * creation. To distinguish between pools created for different purposes, you
     * can specify this element to add a prefix to the ID that is assigned. The
     * prefix can be up to 20 characters long.
     *
     * @param {string} job.poolInfo.autoPoolSpecification.poolLifetimeOption The
     * minimum lifetime of created auto pools, and how multiple jobs on a schedule
     * are assigned to pools. When the pool lifetime is jobSchedule the pool exists
     * for the lifetime of the job schedule. The Batch Service creates the pool
     * when it creates the first job on the schedule. You may apply this option
     * only to job schedules, not to jobs. When the pool lifetime is job the pool
     * exists for the lifetime of the job to which it is dedicated. The Batch
     * service creates the pool when it creates the job. If the 'job' option is
     * applied to a job schedule, the Batch service creates a new auto pool for
     * every job created on the schedule. Possible values include: 'jobSchedule',
     * 'job'
     *
     * @param {boolean} [job.poolInfo.autoPoolSpecification.keepAlive] Whether to
     * keep an auto pool alive after its lifetime expires. If false, the Batch
     * service deletes the pool once its lifetime (as determined by the
     * poolLifetimeOption setting) expires; that is, when the job or job schedule
     * completes. If true, the Batch service does not delete the pool
     * automatically. It is up to the user to delete auto pools created with this
     * option.
     *
     * @param {object} [job.poolInfo.autoPoolSpecification.pool] The pool
     * specification for the auto pool.
     *
     * @param {string} [job.poolInfo.autoPoolSpecification.pool.displayName] The
     * display name for the pool. The display name need not be unique and can
     * contain any Unicode characters up to a maximum length of 1024.
     *
     * @param {string} job.poolInfo.autoPoolSpecification.pool.vmSize The size of
     * the virtual machines in the pool. All virtual machines in a pool are the
     * same size. For information about available sizes of virtual machines for
     * Cloud Services pools (pools created with cloudServiceConfiguration), see
     * Sizes for Cloud Services
     * (http://azure.microsoft.com/documentation/articles/cloud-services-sizes-specs/).
     * Batch supports all Cloud Services VM sizes except ExtraSmall, A1V2 and A2V2.
     * For information about available VM sizes for pools using images from the
     * Virtual Machines Marketplace (pools created with
     * virtualMachineConfiguration) see Sizes for Virtual Machines (Linux)
     * (https://azure.microsoft.com/documentation/articles/virtual-machines-linux-sizes/)
     * or Sizes for Virtual Machines (Windows)
     * (https://azure.microsoft.com/documentation/articles/virtual-machines-windows-sizes/).
     * Batch supports all Azure VM sizes except STANDARD_A0 and those with premium
     * storage (STANDARD_GS, STANDARD_DS, and STANDARD_DSV2 series).
     *
     * @param {object}
     * [job.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration] The
     * cloud service configuration for the pool. This property must be specified if
     * the pool needs to be created with Azure PaaS VMs. This property and
     * virtualMachineConfiguration are mutually exclusive and one of the properties
     * must be specified. If neither is specified then the Batch service returns an
     * error; if you are calling the REST API directly, the HTTP status code is 400
     * (Bad Request). This property cannot be specified if the Batch account was
     * created with its poolAllocationMode property set to 'UserSubscription'.
     *
     * @param {string}
     * job.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.osFamily
     * The Azure Guest OS family to be installed on the virtual machines in the
     * pool. Possible values are: 2 - OS Family 2, equivalent to Windows Server
     * 2008 R2 SP1. 3 - OS Family 3, equivalent to Windows Server 2012. 4 - OS
     * Family 4, equivalent to Windows Server 2012 R2. 5 - OS Family 5, equivalent
     * to Windows Server 2016. For more information, see Azure Guest OS Releases
     * (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
     *
     * @param {string}
     * [job.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.targetOSVersion]
     * The Azure Guest OS version to be installed on the virtual machines in the
     * pool. The default value is * which specifies the latest operating system
     * version for the specified OS family.
     *
     * @param {string}
     * [job.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.currentOSVersion]
     * The Azure Guest OS Version currently installed on the virtual machines in
     * the pool. This may differ from targetOSVersion if the pool state is
     * Upgrading. In this case some virtual machines may be on the targetOSVersion
     * and some may be on the currentOSVersion during the upgrade process. Once all
     * virtual machines have upgraded, currentOSVersion is updated to be the same
     * as targetOSVersion.
     *
     * @param {object}
     * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration] The
     * virtual machine configuration for the pool. This property must be specified
     * if the pool needs to be created with Azure IaaS VMs. This property and
     * cloudServiceConfiguration are mutually exclusive and one of the properties
     * must be specified. If neither is specified then the Batch service returns an
     * error; if you are calling the REST API directly, the HTTP status code is 400
     * (Bad Request).
     *
     * @param {object}
     * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference]
     * A reference to the Azure Virtual Machines Marketplace image to use. This
     * property and osDisk are mutually exclusive and one of the properties must be
     * specified.
     *
     * @param {string}
     * job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.publisher
     * The publisher of the Azure Virtual Machines Marketplace image. For example,
     * Canonical or MicrosoftWindowsServer.
     *
     * @param {string}
     * job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.offer
     * The offer type of the Azure Virtual Machines Marketplace image. For example,
     * UbuntuServer or WindowsServer.
     *
     * @param {string}
     * job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.sku
     * The SKU of the Azure Virtual Machines Marketplace image. For example,
     * 14.04.0-LTS or 2012-R2-Datacenter.
     *
     * @param {string}
     * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.version]
     * The version of the Azure Virtual Machines Marketplace image. A value of
     * 'latest' can be specified to select the latest version of an image. If
     * omitted, the default is 'latest'.
     *
     * @param {object}
     * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.osDisk]
     * A reference to the OS disk image to use. This property can be specified only
     * if the Batch account was created with its poolAllocationMode property set to
     * 'UserSubscription'. This property and imageReference are mutually exclusive
     * and one of the properties must be specified.
     *
     * @param {array}
     * job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.osDisk.imageUris
     * The collection of Virtual Hard Disk (VHD) URIs. All the VHDs must be
     * identical and must reside in an Azure Storage account within the same
     * subscription and same region as the Batch account. For best performance, it
     * is recommended that each VHD resides in a separate Azure Storage account.
     * Each VHD can serve upto 20 Windows compute nodes or 40 Linux compute nodes.
     * You must supply enough VHD URIs to satisfy the 'targetDedicated' property of
     * the pool. If you do not supply enough VHD URIs, the pool will partially
     * allocate compute nodes, and a resize error will occur.
     *
     * @param {string}
     * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.osDisk.caching]
     * The type of caching to enable for the OS disk. Values are:
     *
     * none - The caching mode for the disk is not enabled.
     * readOnly - The caching mode for the disk is read only.
     * readWrite - The caching mode for the disk is read and write.
     *
     * The default value for caching is none. For information about the caching
     * options see:
     * https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/27/exploring-windows-azure-drives-disks-and-images/.
     * Possible values include: 'none', 'readOnly', 'readWrite'
     *
     * @param {string}
     * job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.nodeAgentSKUId
     * The SKU of the Batch node agent to be provisioned on compute nodes in the
     * pool. The Batch node agent is a program that runs on each node in the pool,
     * and provides the command-and-control interface between the node and the
     * Batch service. There are different implementations of the node agent, known
     * as SKUs, for different operating systems. You must specify a node agent SKU
     * which matches the selected image reference. To get the list of supported
     * node agent SKUs along with their list of verified image references, see the
     * 'List supported node agent SKUs' operation.
     *
     * @param {object}
     * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration]
     * Windows operating system settings on the virtual machine. This property must
     * not be specified if the imageReference or osDisk property specifies a Linux
     * OS image.
     *
     * @param {boolean}
     * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration.enableAutomaticUpdates]
     * Whether automatic updates are enabled on the virtual machine. If omitted,
     * the default value is true.
     *
     * @param {number} [job.poolInfo.autoPoolSpecification.pool.maxTasksPerNode]
     * The maximum number of tasks that can run concurrently on a single compute
     * node in the pool. The default value is 1. The maximum value of this setting
     * depends on the size of the compute nodes in the pool (the vmSize setting).
     *
     * @param {object}
     * [job.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy] How tasks are
     * distributed across compute nodes in a pool.
     *
     * @param {string}
     * job.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy.nodeFillType
     * How tasks are distributed across compute nodes in a pool. Values are:
     *
     * pack - As many tasks as possible (maxTasksPerNode) should be assigned to
     * each node in the pool before any tasks are assigned to the next node in the
     * pool.
     * spread - Tasks should be assigned evenly across all nodes in the pool.
     * Possible values include: 'spread', 'pack'
     *
     * @param {moment.duration}
     * [job.poolInfo.autoPoolSpecification.pool.resizeTimeout] The timeout for
     * allocation of compute nodes to the pool. This timeout applies only to manual
     * scaling; it has no effect when enableAutoScale is set to true. The default
     * value is 15 minutes. The minimum value is 5 minutes. If you specify a value
     * less than 5 minutes, the Batch service rejects the request with an error; if
     * you are calling the REST API directly, the HTTP status code is 400 (Bad
     * Request).
     *
     * @param {number}
     * [job.poolInfo.autoPoolSpecification.pool.targetDedicatedNodes] The desired
     * number of dedicated compute nodes in the pool. This property must not be
     * specified if enableAutoScale is set to true. If enableAutoScale is set to
     * false, then you must set either targetDedicatedNodes,
     * targetLowPriorityNodes, or both.
     *
     * @param {number}
     * [job.poolInfo.autoPoolSpecification.pool.targetLowPriorityNodes] The desired
     * number of low-priority compute nodes in the pool. This property must not be
     * specified if enableAutoScale is set to true. If enableAutoScale is set to
     * false, then you must set either targetDedicatedNodes,
     * targetLowPriorityNodes, or both.
     *
     * @param {boolean} [job.poolInfo.autoPoolSpecification.pool.enableAutoScale]
     * Whether the pool size should automatically adjust over time. If false, at
     * least one of targetDedicateNodes and targetLowPriorityNodes must be
     * specified. If true, the autoScaleFormula element is required. The pool
     * automatically resizes according to the formula. The default value is false.
     *
     * @param {string} [job.poolInfo.autoPoolSpecification.pool.autoScaleFormula]
     * The formula for the desired number of compute nodes in the pool. This
     * property must not be specified if enableAutoScale is set to false. It is
     * required if enableAutoScale is set to true. The formula is checked for
     * validity before the pool is created. If the formula is not valid, the Batch
     * service rejects the request with detailed error information.
     *
     * @param {moment.duration}
     * [job.poolInfo.autoPoolSpecification.pool.autoScaleEvaluationInterval] The
     * time interval at which to automatically adjust the pool size according to
     * the autoscale formula. The default value is 15 minutes. The minimum and
     * maximum value are 5 minutes and 168 hours respectively. If you specify a
     * value less than 5 minutes or greater than 168 hours, the Batch service
     * rejects the request with an invalid property value error; if you are calling
     * the REST API directly, the HTTP status code is 400 (Bad Request).
     *
     * @param {boolean}
     * [job.poolInfo.autoPoolSpecification.pool.enableInterNodeCommunication]
     * Whether the pool permits direct communication between nodes. Enabling
     * inter-node communication limits the maximum size of the pool due to
     * deployment restrictions on the nodes of the pool. This may result in the
     * pool not reaching its desired size. The default value is false.
     *
     * @param {object}
     * [job.poolInfo.autoPoolSpecification.pool.networkConfiguration] The network
     * configuration for the pool.
     *
     * @param {string}
     * [job.poolInfo.autoPoolSpecification.pool.networkConfiguration.subnetId] The
     * ARM resource identifier of the virtual network subnet which the compute
     * nodes of the pool will join. This is of the form
     * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
     * The virtual network must be in the same region and subscription as the Azure
     * Batch account. The specified subnet should have enough free IP addresses to
     * accommodate the number of nodes in the pool. If the subnet doesn't have
     * enough free IP addresses, the pool will partially allocate compute nodes,
     * and a resize error will occur. The 'MicrosoftAzureBatch' service principal
     * must have the 'Classic Virtual Machine Contributor' Role-Based Access
     * Control (RBAC) role for the specified VNet. The specified subnet must allow
     * communication from the Azure Batch service to be able to schedule tasks on
     * the compute nodes. This can be verified by checking if the specified VNet
     * has any associated Network Security Groups (NSG). If communication to the
     * compute nodes in the specified subnet is denied by an NSG, then the Batch
     * service will set the state of the compute nodes to unusable. For pools
     * created via virtualMachineConfiguration the Batch account must have
     * poolAllocationMode userSubscription in order to use a VNet. If the specified
     * VNet has any associated Network Security Groups (NSG), then a few reserved
     * system ports must be enabled for inbound communication. For pools created
     * with a virtual machine configuration, enable ports 29876 and 29877, as well
     * as port 22 for Linux and port 3389 for Windows. For pools created with a
     * cloud service configuration, enable ports 10100, 20100, and 30100. Also
     * enable outbound connections to Azure Storage on port 443. For more details
     * see:
     * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration
     *
     * @param {object}
     * [job.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration]
     * The configuration for endpoints on compute nodes in the Batch pool. Pool
     * endpoint configuration is only supported on pools with the
     * virtualMachineConfiguration property.
     *
     * @param {array}
     * job.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration.inboundNATPools
     * A list of inbound NAT pools that can be used to address specific ports on an
     * individual compute node externally. The maximum number of inbound NAT pools
     * per Batch pool is 5. If the maximum number of inbound NAT pools is exceeded
     * the request fails with HTTP status code 400.
     *
     * @param {object} [job.poolInfo.autoPoolSpecification.pool.startTask] A task
     * to run on each compute node as it joins the pool. The task runs when the
     * node is added to the pool or when the node is restarted.
     *
     * @param {string}
     * job.poolInfo.autoPoolSpecification.pool.startTask.commandLine The command
     * line of the start task. The command line does not run under a shell, and
     * therefore cannot take advantage of shell features such as environment
     * variable expansion. If you want to take advantage of such features, you
     * should invoke the shell in the command line, for example using "cmd /c
     * MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux.
     *
     * @param {array}
     * [job.poolInfo.autoPoolSpecification.pool.startTask.resourceFiles] A list of
     * files that the Batch service will download to the compute node before
     * running the command line. Files listed under this element are located in the
     * task's working directory.
     *
     * @param {array}
     * [job.poolInfo.autoPoolSpecification.pool.startTask.environmentSettings] A
     * list of environment variable settings for the start task.
     *
     * @param {object}
     * [job.poolInfo.autoPoolSpecification.pool.startTask.userIdentity] The user
     * identity under which the start task runs. If omitted, the task runs as a
     * non-administrative user unique to the task.
     *
     * @param {string}
     * [job.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.userName]
     * The name of the user identity under which the task is run. The userName and
     * autoUser properties are mutually exclusive; you must specify one but not
     * both.
     *
     * @param {object}
     * [job.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser]
     * The auto user under which the task is run. The userName and autoUser
     * properties are mutually exclusive; you must specify one but not both.
     *
     * @param {string}
     * [job.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.scope]
     * The scope for the auto user Values are:
     *
     * pool - specifies that the task runs as the common auto user account which is
     * created on every node in a pool.
     * task - specifies that the service should create a new user for the task.
     * The default value is task. Possible values include: 'task', 'pool'
     *
     * @param {string}
     * [job.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.elevationLevel]
     * The elevation level of the auto user. nonAdmin - The auto user is a standard
     * user without elevated access. admin - The auto user is a user with elevated
     * access and operates with full Administrator permissions. The default value
     * is nonAdmin. Possible values include: 'nonAdmin', 'admin'
     *
     * @param {number}
     * [job.poolInfo.autoPoolSpecification.pool.startTask.maxTaskRetryCount] The
     * maximum number of times the task may be retried. The Batch service retries a
     * task if its exit code is nonzero. Note that this value specifically controls
     * the number of retries. The Batch service will try the task once, and may
     * then retry up to this limit. For example, if the maximum retry count is 3,
     * Batch tries the task up to 4 times (one initial try and 3 retries). If the
     * maximum retry count is 0, the Batch service does not retry the task. If the
     * maximum retry count is -1, the Batch service retries the task without limit.
     *
     * @param {boolean}
     * [job.poolInfo.autoPoolSpecification.pool.startTask.waitForSuccess] Whether
     * the Batch service should wait for the start task to complete successfully
     * (that is, to exit with exit code 0) before scheduling any tasks on the
     * compute node. If true and the start task fails on a compute node, the Batch
     * service retries the start task up to its maximum retry count
     * (maxTaskRetryCount). If the task has still not completed successfully after
     * all retries, then the Batch service marks the compute node unusable, and
     * will not schedule tasks to it. This condition can be detected via the node
     * state and failure info details. If false, the Batch service will not wait
     * for the start task to complete. In this case, other tasks can start
     * executing on the compute node while the start task is still running; and
     * even if the start task fails, new tasks will continue to be scheduled on the
     * node. The default is false.
     *
     * @param {array}
     * [job.poolInfo.autoPoolSpecification.pool.certificateReferences] A list of
     * certificates to be installed on each compute node in the pool. For Windows
     * compute nodes, the Batch service installs the certificates to the specified
     * certificate store and location. For Linux compute nodes, the certificates
     * are stored in a directory inside the task working directory and an
     * environment variable AZ_BATCH_CERTIFICATES_DIR is supplied to the task to
     * query for this location. For certificates with visibility of 'remoteUser', a
     * 'certs' directory is created in the user's home directory (e.g.,
     * /home/{user-name}/certs) and certificates are placed in that directory.
     *
     * @param {array}
     * [job.poolInfo.autoPoolSpecification.pool.applicationPackageReferences] The
     * list of application packages to be installed on each compute node in the
     * pool.
     *
     * @param {array} [job.poolInfo.autoPoolSpecification.pool.applicationLicenses]
     * The list of application licenses the Batch service will make available on
     * each compute node in the pool. The list of application licenses must be a
     * subset of available Batch service application licenses. If a license is
     * requested which is not supported, pool creation will fail.
     *
     * @param {array} [job.poolInfo.autoPoolSpecification.pool.userAccounts] The
     * list of user accounts to be created on each node in the pool.
     *
     * @param {array} [job.poolInfo.autoPoolSpecification.pool.metadata] A list of
     * name-value pairs associated with the pool as metadata. The Batch service
     * does not assign any meaning to metadata; it is solely for the use of user
     * code.
     *
     * @param {string} [job.onAllTasksComplete] The action the Batch service should
     * take when all tasks in the job are in the completed state. Note that if a
     * job contains no tasks, then all tasks are considered complete. This option
     * is therefore most commonly used with a Job Manager task; if you want to use
     * automatic job termination without a Job Manager, you should initially set
     * onAllTasksComplete to noAction and update the job properties to set
     * onAllTasksComplete to terminateJob once you have finished adding tasks.
     * Permitted values are: noAction - do nothing. The job remains active unless
     * terminated or disabled by some other means. terminateJob - terminate the
     * job. The job's terminateReason is set to 'AllTasksComplete'. The default is
     * noAction. Possible values include: 'noAction', 'terminateJob'
     *
     * @param {string} [job.onTaskFailure] The action the Batch service should take
     * when any task in the job fails. A task is considered to have failed if has a
     * failureInfo. A failureInfo is set if the task completes with a non-zero exit
     * code after exhausting its retry count, or if there was an error starting the
     * task, for example due to a resource file download error. noAction - do
     * nothing. performExitOptionsJobAction - take the action associated with the
     * task exit condition in the task's exitConditions collection. (This may still
     * result in no action being taken, if that is what the task specifies.) The
     * default is noAction. Possible values include: 'noAction',
     * 'performExitOptionsJobAction'
     *
     * @param {array} [job.metadata] A list of name-value pairs associated with the
     * job as metadata. The Batch service does not assign any meaning to metadata;
     * it is solely for the use of user code.
     *
     * @param {boolean} [job.usesTaskDependencies] Whether tasks in the job can
     * define dependencies on each other. The default is false.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.jobAddOptions] Additional parameters for the
     * operation
     *
     * @param {number} [options.jobAddOptions.timeout] The maximum time that the
     * server can spend processing the request, in seconds. The default is 30
     * seconds.
     *
     * @param {string} [options.jobAddOptions.clientRequestId] The caller-generated
     * request identity, in the form of a GUID with no decoration such as curly
     * braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.jobAddOptions.returnClientRequestId] Whether the
     * server should return the client-request-id in the response.
     *
     * @param {date} [options.jobAddOptions.ocpDate] The time the request was
     * issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addWithHttpOperationResponse(job, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobAddOptions = (options && options.jobAddOptions !== undefined) ? options.jobAddOptions : undefined;
            // Validate
            try {
                if (job === null || job === undefined) {
                    throw new Error('job cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobAddOptions !== null && jobAddOptions !== undefined) {
                    timeout = jobAddOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobAddOptions !== null && jobAddOptions !== undefined) {
                    clientRequestId = jobAddOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobAddOptions !== null && jobAddOptions !== undefined) {
                    returnClientRequestId = jobAddOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobAddOptions !== null && jobAddOptions !== undefined) {
                    ocpDate = jobAddOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs';
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (job !== null && job !== undefined) {
                    let requestModelMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["JobAddParameter"];
                    requestModel = client.serializer.serialize(requestModelMapper, job, 'job');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(job, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 201) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the jobs in the specified account.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.jobListOptions] Additional parameters for the
     * operation
     *
     * @param {string} [options.jobListOptions.filter] An OData $filter clause.
     *
     * @param {string} [options.jobListOptions.select] An OData $select clause.
     *
     * @param {string} [options.jobListOptions.expand] An OData $expand clause.
     *
     * @param {number} [options.jobListOptions.maxResults] The maximum number of
     * items to return in the response. A maximum of 1000 jobs can be returned.
     *
     * @param {number} [options.jobListOptions.timeout] The maximum time that the
     * server can spend processing the request, in seconds. The default is 30
     * seconds.
     *
     * @param {string} [options.jobListOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.jobListOptions.returnClientRequestId] Whether the
     * server should return the client-request-id in the response.
     *
     * @param {date} [options.jobListOptions.ocpDate] The time the request was
     * issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<CloudJobListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobListOptions = (options && options.jobListOptions !== undefined) ? options.jobListOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let select;
            let expand;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    filter = jobListOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    select = jobListOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    expand = jobListOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    maxResults = jobListOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    timeout = jobListOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    clientRequestId = jobListOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    returnClientRequestId = jobListOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobListOptions !== null && jobListOptions !== undefined) {
                    ocpDate = jobListOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs';
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (filter !== null && filter !== undefined) {
                queryParameters.push('$filter=' + encodeURIComponent(filter));
            }
            if (select !== null && select !== undefined) {
                queryParameters.push('$select=' + encodeURIComponent(select));
            }
            if (expand !== null && expand !== undefined) {
                queryParameters.push('$expand=' + encodeURIComponent(expand));
            }
            if (maxResults !== null && maxResults !== undefined) {
                queryParameters.push('maxresults=' + encodeURIComponent(maxResults.toString()));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["CloudJobListResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the jobs that have been created under the specified job
     * schedule.
     *
     * @param {string} jobScheduleId The ID of the job schedule from which you want
     * to get a list of jobs.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.jobListFromJobScheduleOptions] Additional
     * parameters for the operation
     *
     * @param {string} [options.jobListFromJobScheduleOptions.filter] An OData
     * $filter clause.
     *
     * @param {string} [options.jobListFromJobScheduleOptions.select] An OData
     * $select clause.
     *
     * @param {string} [options.jobListFromJobScheduleOptions.expand] An OData
     * $expand clause.
     *
     * @param {number} [options.jobListFromJobScheduleOptions.maxResults] The
     * maximum number of items to return in the response. A maximum of 1000 jobs
     * can be returned.
     *
     * @param {number} [options.jobListFromJobScheduleOptions.timeout] The maximum
     * time that the server can spend processing the request, in seconds. The
     * default is 30 seconds.
     *
     * @param {string} [options.jobListFromJobScheduleOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean}
     * [options.jobListFromJobScheduleOptions.returnClientRequestId] Whether the
     * server should return the client-request-id in the response.
     *
     * @param {date} [options.jobListFromJobScheduleOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<CloudJobListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listFromJobScheduleWithHttpOperationResponse(jobScheduleId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobListFromJobScheduleOptions = (options && options.jobListFromJobScheduleOptions !== undefined) ? options.jobListFromJobScheduleOptions : undefined;
            // Validate
            try {
                if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
                    throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let select;
            let expand;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    filter = jobListFromJobScheduleOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    select = jobListFromJobScheduleOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    expand = jobListFromJobScheduleOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    maxResults = jobListFromJobScheduleOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    timeout = jobListFromJobScheduleOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    clientRequestId = jobListFromJobScheduleOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    returnClientRequestId = jobListFromJobScheduleOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
                    ocpDate = jobListFromJobScheduleOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobschedules/{jobScheduleId}/jobs';
            requestUrl = requestUrl.replace('{jobScheduleId}', encodeURIComponent(jobScheduleId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (filter !== null && filter !== undefined) {
                queryParameters.push('$filter=' + encodeURIComponent(filter));
            }
            if (select !== null && select !== undefined) {
                queryParameters.push('$select=' + encodeURIComponent(select));
            }
            if (expand !== null && expand !== undefined) {
                queryParameters.push('$expand=' + encodeURIComponent(expand));
            }
            if (maxResults !== null && maxResults !== undefined) {
                queryParameters.push('maxresults=' + encodeURIComponent(maxResults.toString()));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["CloudJobListResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the execution status of the Job Preparation and Job Release
     * task for the specified job across the compute nodes where the job has run.
     *
     * This API returns the Job Preparation and Job Release task status on all
     * compute nodes that have run the Job Preparation or Job Release task. This
     * includes nodes which have since been removed from the pool. If this API is
     * invoked on a job which has no Job Preparation or Job Release task, the Batch
     * service returns HTTP status code 409 (Conflict) with an error code of
     * JobPreparationTaskNotSpecified.
     *
     * @param {string} jobId The ID of the job.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.jobListPreparationAndReleaseTaskStatusOptions]
     * Additional parameters for the operation
     *
     * @param {string}
     * [options.jobListPreparationAndReleaseTaskStatusOptions.filter] An OData
     * $filter clause. To get the status of the Job Preparation and Job Release
     * tasks on a specific compute node, use "nodeId eq '{desired-node-id}'"
     *
     * @param {string}
     * [options.jobListPreparationAndReleaseTaskStatusOptions.select] An OData
     * $select clause.
     *
     * @param {number}
     * [options.jobListPreparationAndReleaseTaskStatusOptions.maxResults] The
     * maximum number of items to return in the response. A maximum of 1000 tasks
     * can be returned.
     *
     * @param {number}
     * [options.jobListPreparationAndReleaseTaskStatusOptions.timeout] The maximum
     * time that the server can spend processing the request, in seconds. The
     * default is 30 seconds.
     *
     * @param {string}
     * [options.jobListPreparationAndReleaseTaskStatusOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean}
     * [options.jobListPreparationAndReleaseTaskStatusOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date}
     * [options.jobListPreparationAndReleaseTaskStatusOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<CloudJobListPreparationAndReleaseTaskStatusResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listPreparationAndReleaseTaskStatusWithHttpOperationResponse(jobId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobListPreparationAndReleaseTaskStatusOptions = (options && options.jobListPreparationAndReleaseTaskStatusOptions !== undefined) ? options.jobListPreparationAndReleaseTaskStatusOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let select;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
                    filter = jobListPreparationAndReleaseTaskStatusOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
                    select = jobListPreparationAndReleaseTaskStatusOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
                    maxResults = jobListPreparationAndReleaseTaskStatusOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
                    timeout = jobListPreparationAndReleaseTaskStatusOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
                    clientRequestId = jobListPreparationAndReleaseTaskStatusOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
                    returnClientRequestId = jobListPreparationAndReleaseTaskStatusOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
                    ocpDate = jobListPreparationAndReleaseTaskStatusOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/jobpreparationandreleasetaskstatus';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (filter !== null && filter !== undefined) {
                queryParameters.push('$filter=' + encodeURIComponent(filter));
            }
            if (select !== null && select !== undefined) {
                queryParameters.push('$select=' + encodeURIComponent(select));
            }
            if (maxResults !== null && maxResults !== undefined) {
                queryParameters.push('maxresults=' + encodeURIComponent(maxResults.toString()));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["CloudJobListPreparationAndReleaseTaskStatusResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets the task counts for the specified job.
     *
     * Task counts provide a count of the tasks by active, running or completed
     * task state, and a count of tasks which succeeded or failed. Tasks in the
     * preparing state are counted as running. If the validationStatus is
     * unvalidated, then the Batch service has not been able to check state counts
     * against the task states as reported in the List Tasks API. The
     * validationStatus may be unvalidated if the job contains more than 200,000
     * tasks.
     *
     * @param {string} jobId The ID of the job.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.jobGetTaskCountsOptions] Additional parameters for
     * the operation
     *
     * @param {number} [options.jobGetTaskCountsOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.jobGetTaskCountsOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.jobGetTaskCountsOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.jobGetTaskCountsOptions.ocpDate] The time the request
     * was issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<TaskCounts>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getTaskCountsWithHttpOperationResponse(jobId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobGetTaskCountsOptions = (options && options.jobGetTaskCountsOptions !== undefined) ? options.jobGetTaskCountsOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobGetTaskCountsOptions !== null && jobGetTaskCountsOptions !== undefined) {
                    timeout = jobGetTaskCountsOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobGetTaskCountsOptions !== null && jobGetTaskCountsOptions !== undefined) {
                    clientRequestId = jobGetTaskCountsOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobGetTaskCountsOptions !== null && jobGetTaskCountsOptions !== undefined) {
                    returnClientRequestId = jobGetTaskCountsOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobGetTaskCountsOptions !== null && jobGetTaskCountsOptions !== undefined) {
                    ocpDate = jobGetTaskCountsOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/taskcounts';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["TaskCounts"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the jobs in the specified account.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.jobListNextOptions] Additional parameters for the
     * operation
     *
     * @param {string} [options.jobListNextOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.jobListNextOptions.returnClientRequestId] Whether
     * the server should return the client-request-id in the response.
     *
     * @param {date} [options.jobListNextOptions.ocpDate] The time the request was
     * issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<CloudJobListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobListNextOptions = (options && options.jobListNextOptions !== undefined) ? options.jobListNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobListNextOptions !== null && jobListNextOptions !== undefined) {
                    clientRequestId = jobListNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobListNextOptions !== null && jobListNextOptions !== undefined) {
                    returnClientRequestId = jobListNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobListNextOptions !== null && jobListNextOptions !== undefined) {
                    ocpDate = jobListNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["CloudJobListResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the jobs that have been created under the specified job
     * schedule.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.jobListFromJobScheduleNextOptions] Additional
     * parameters for the operation
     *
     * @param {string} [options.jobListFromJobScheduleNextOptions.clientRequestId]
     * The caller-generated request identity, in the form of a GUID with no
     * decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean}
     * [options.jobListFromJobScheduleNextOptions.returnClientRequestId] Whether
     * the server should return the client-request-id in the response.
     *
     * @param {date} [options.jobListFromJobScheduleNextOptions.ocpDate] The time
     * the request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<CloudJobListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listFromJobScheduleNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobListFromJobScheduleNextOptions = (options && options.jobListFromJobScheduleNextOptions !== undefined) ? options.jobListFromJobScheduleNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobListFromJobScheduleNextOptions !== null && jobListFromJobScheduleNextOptions !== undefined) {
                    clientRequestId = jobListFromJobScheduleNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobListFromJobScheduleNextOptions !== null && jobListFromJobScheduleNextOptions !== undefined) {
                    returnClientRequestId = jobListFromJobScheduleNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobListFromJobScheduleNextOptions !== null && jobListFromJobScheduleNextOptions !== undefined) {
                    ocpDate = jobListFromJobScheduleNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["CloudJobListResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the execution status of the Job Preparation and Job Release
     * task for the specified job across the compute nodes where the job has run.
     *
     * This API returns the Job Preparation and Job Release task status on all
     * compute nodes that have run the Job Preparation or Job Release task. This
     * includes nodes which have since been removed from the pool. If this API is
     * invoked on a job which has no Job Preparation or Job Release task, the Batch
     * service returns HTTP status code 409 (Conflict) with an error code of
     * JobPreparationTaskNotSpecified.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.jobListPreparationAndReleaseTaskStatusNextOptions]
     * Additional parameters for the operation
     *
     * @param {string}
     * [options.jobListPreparationAndReleaseTaskStatusNextOptions.clientRequestId]
     * The caller-generated request identity, in the form of a GUID with no
     * decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean}
     * [options.jobListPreparationAndReleaseTaskStatusNextOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date}
     * [options.jobListPreparationAndReleaseTaskStatusNextOptions.ocpDate] The time
     * the request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<CloudJobListPreparationAndReleaseTaskStatusResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listPreparationAndReleaseTaskStatusNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobListPreparationAndReleaseTaskStatusNextOptions = (options && options.jobListPreparationAndReleaseTaskStatusNextOptions !== undefined) ? options.jobListPreparationAndReleaseTaskStatusNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobListPreparationAndReleaseTaskStatusNextOptions !== null && jobListPreparationAndReleaseTaskStatusNextOptions !== undefined) {
                    clientRequestId = jobListPreparationAndReleaseTaskStatusNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusNextOptions !== null && jobListPreparationAndReleaseTaskStatusNextOptions !== undefined) {
                    returnClientRequestId = jobListPreparationAndReleaseTaskStatusNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobListPreparationAndReleaseTaskStatusNextOptions !== null && jobListPreparationAndReleaseTaskStatusNextOptions !== undefined) {
                    ocpDate = jobListPreparationAndReleaseTaskStatusNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["CloudJobListPreparationAndReleaseTaskStatusResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    getAllLifetimeStatistics(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getAllLifetimeStatisticsWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.getAllLifetimeStatisticsWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    deleteMethod(jobId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteMethodWithHttpOperationResponse(jobId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.deleteMethodWithHttpOperationResponse(jobId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    get(jobId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(jobId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.getWithHttpOperationResponse(jobId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    patch(jobId, jobPatchParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.patchWithHttpOperationResponse(jobId, jobPatchParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.patchWithHttpOperationResponse(jobId, jobPatchParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    update(jobId, jobUpdateParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.updateWithHttpOperationResponse(jobId, jobUpdateParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.updateWithHttpOperationResponse(jobId, jobUpdateParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    disable(jobId, disableTasks, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.disableWithHttpOperationResponse(jobId, disableTasks, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.disableWithHttpOperationResponse(jobId, disableTasks, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    enable(jobId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.enableWithHttpOperationResponse(jobId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.enableWithHttpOperationResponse(jobId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    terminate(jobId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.terminateWithHttpOperationResponse(jobId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.terminateWithHttpOperationResponse(jobId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    add(job, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.addWithHttpOperationResponse(job, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.addWithHttpOperationResponse(job, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    list(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.listWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listFromJobSchedule(jobScheduleId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listFromJobScheduleWithHttpOperationResponse(jobScheduleId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.listFromJobScheduleWithHttpOperationResponse(jobScheduleId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listPreparationAndReleaseTaskStatus(jobId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listPreparationAndReleaseTaskStatusWithHttpOperationResponse(jobId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.listPreparationAndReleaseTaskStatusWithHttpOperationResponse(jobId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    getTaskCounts(jobId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getTaskCountsWithHttpOperationResponse(jobId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.getTaskCountsWithHttpOperationResponse(jobId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.listNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listFromJobScheduleNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listFromJobScheduleNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.listFromJobScheduleNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listPreparationAndReleaseTaskStatusNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listPreparationAndReleaseTaskStatusNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.listPreparationAndReleaseTaskStatusNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Job;



/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__models_mappers__ = __webpack_require__(1);
/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


const WebResource = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["WebResource"];
/** Class representing a CertificateOperations. */
class CertificateOperations {
    /**
     * Create a CertificateOperations.
     * @param {BatchServiceClient} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Adds a certificate to the specified account.
     *
     * @param {object} certificate The certificate to be added.
     *
     * @param {string} certificate.thumbprint The X.509 thumbprint of the
     * certificate. This is a sequence of up to 40 hex digits (it may include
     * spaces but these are removed).
     *
     * @param {string} certificate.thumbprintAlgorithm The algorithm used to derive
     * the thumbprint. This must be sha1.
     *
     * @param {string} certificate.data The base64-encoded contents of the
     * certificate. The maximum size is 10KB.
     *
     * @param {string} [certificate.certificateFormat] The format of the
     * certificate data. Possible values include: 'pfx', 'cer'
     *
     * @param {string} [certificate.password] The password to access the
     * certificate's private key. This is required if the certificate format is
     * pfx. It should be omitted if the certificate format is cer.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.certificateAddOptions] Additional parameters for
     * the operation
     *
     * @param {number} [options.certificateAddOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.certificateAddOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.certificateAddOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.certificateAddOptions.ocpDate] The time the request
     * was issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addWithHttpOperationResponse(certificate, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let certificateAddOptions = (options && options.certificateAddOptions !== undefined) ? options.certificateAddOptions : undefined;
            // Validate
            try {
                if (certificate === null || certificate === undefined) {
                    throw new Error('certificate cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (certificateAddOptions !== null && certificateAddOptions !== undefined) {
                    timeout = certificateAddOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (certificateAddOptions !== null && certificateAddOptions !== undefined) {
                    clientRequestId = certificateAddOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (certificateAddOptions !== null && certificateAddOptions !== undefined) {
                    returnClientRequestId = certificateAddOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (certificateAddOptions !== null && certificateAddOptions !== undefined) {
                    ocpDate = certificateAddOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates';
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (certificate !== null && certificate !== undefined) {
                    let requestModelMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["CertificateAddParameter"];
                    requestModel = client.serializer.serialize(requestModelMapper, certificate, 'certificate');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(certificate, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 201) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the certificates that have been added to the specified
     * account.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.certificateListOptions] Additional parameters for
     * the operation
     *
     * @param {string} [options.certificateListOptions.filter] An OData $filter
     * clause.
     *
     * @param {string} [options.certificateListOptions.select] An OData $select
     * clause.
     *
     * @param {number} [options.certificateListOptions.maxResults] The maximum
     * number of items to return in the response. A maximum of 1000 certificates
     * can be returned.
     *
     * @param {number} [options.certificateListOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.certificateListOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.certificateListOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.certificateListOptions.ocpDate] The time the request
     * was issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<CertificateListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let certificateListOptions = (options && options.certificateListOptions !== undefined) ? options.certificateListOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let select;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (certificateListOptions !== null && certificateListOptions !== undefined) {
                    filter = certificateListOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (certificateListOptions !== null && certificateListOptions !== undefined) {
                    select = certificateListOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (certificateListOptions !== null && certificateListOptions !== undefined) {
                    maxResults = certificateListOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (certificateListOptions !== null && certificateListOptions !== undefined) {
                    timeout = certificateListOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (certificateListOptions !== null && certificateListOptions !== undefined) {
                    clientRequestId = certificateListOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (certificateListOptions !== null && certificateListOptions !== undefined) {
                    returnClientRequestId = certificateListOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (certificateListOptions !== null && certificateListOptions !== undefined) {
                    ocpDate = certificateListOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates';
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (filter !== null && filter !== undefined) {
                queryParameters.push('$filter=' + encodeURIComponent(filter));
            }
            if (select !== null && select !== undefined) {
                queryParameters.push('$select=' + encodeURIComponent(select));
            }
            if (maxResults !== null && maxResults !== undefined) {
                queryParameters.push('maxresults=' + encodeURIComponent(maxResults.toString()));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["CertificateListResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Cancels a failed deletion of a certificate from the specified
     * account.
     *
     * If you try to delete a certificate that is being used by a pool or compute
     * node, the status of the certificate changes to deleteFailed. If you decide
     * that you want to continue using the certificate, you can use this operation
     * to set the status of the certificate back to active. If you intend to delete
     * the certificate, you do not need to run this operation after the deletion
     * failed. You must make sure that the certificate is not being used by any
     * resources, and then you can try again to delete the certificate.
     *
     * @param {string} thumbprintAlgorithm The algorithm used to derive the
     * thumbprint parameter. This must be sha1.
     *
     * @param {string} thumbprint The thumbprint of the certificate being deleted.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.certificateCancelDeletionOptions] Additional
     * parameters for the operation
     *
     * @param {number} [options.certificateCancelDeletionOptions.timeout] The
     * maximum time that the server can spend processing the request, in seconds.
     * The default is 30 seconds.
     *
     * @param {string} [options.certificateCancelDeletionOptions.clientRequestId]
     * The caller-generated request identity, in the form of a GUID with no
     * decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean}
     * [options.certificateCancelDeletionOptions.returnClientRequestId] Whether the
     * server should return the client-request-id in the response.
     *
     * @param {date} [options.certificateCancelDeletionOptions.ocpDate] The time
     * the request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    cancelDeletionWithHttpOperationResponse(thumbprintAlgorithm, thumbprint, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let certificateCancelDeletionOptions = (options && options.certificateCancelDeletionOptions !== undefined) ? options.certificateCancelDeletionOptions : undefined;
            // Validate
            try {
                if (thumbprintAlgorithm === null || thumbprintAlgorithm === undefined || typeof thumbprintAlgorithm.valueOf() !== 'string') {
                    throw new Error('thumbprintAlgorithm cannot be null or undefined and it must be of type string.');
                }
                if (thumbprint === null || thumbprint === undefined || typeof thumbprint.valueOf() !== 'string') {
                    throw new Error('thumbprint cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (certificateCancelDeletionOptions !== null && certificateCancelDeletionOptions !== undefined) {
                    timeout = certificateCancelDeletionOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (certificateCancelDeletionOptions !== null && certificateCancelDeletionOptions !== undefined) {
                    clientRequestId = certificateCancelDeletionOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (certificateCancelDeletionOptions !== null && certificateCancelDeletionOptions !== undefined) {
                    returnClientRequestId = certificateCancelDeletionOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (certificateCancelDeletionOptions !== null && certificateCancelDeletionOptions !== undefined) {
                    ocpDate = certificateCancelDeletionOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates(thumbprintAlgorithm={thumbprintAlgorithm},thumbprint={thumbprint})/canceldelete';
            requestUrl = requestUrl.replace('{thumbprintAlgorithm}', encodeURIComponent(thumbprintAlgorithm));
            requestUrl = requestUrl.replace('{thumbprint}', encodeURIComponent(thumbprint));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 204) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Deletes a certificate from the specified account.
     *
     * You cannot delete a certificate if a resource (pool or compute node) is
     * using it. Before you can delete a certificate, you must therefore make sure
     * that the certificate is not associated with any existing pools, the
     * certificate is not installed on any compute nodes (even if you remove a
     * certificate from a pool, it is not removed from existing compute nodes in
     * that pool until they restart), and no running tasks depend on the
     * certificate. If you try to delete a certificate that is in use, the deletion
     * fails. The certificate status changes to deleteFailed. You can use Cancel
     * Delete Certificate to set the status back to active if you decide that you
     * want to continue using the certificate.
     *
     * @param {string} thumbprintAlgorithm The algorithm used to derive the
     * thumbprint parameter. This must be sha1.
     *
     * @param {string} thumbprint The thumbprint of the certificate to be deleted.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.certificateDeleteMethodOptions] Additional
     * parameters for the operation
     *
     * @param {number} [options.certificateDeleteMethodOptions.timeout] The maximum
     * time that the server can spend processing the request, in seconds. The
     * default is 30 seconds.
     *
     * @param {string} [options.certificateDeleteMethodOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean}
     * [options.certificateDeleteMethodOptions.returnClientRequestId] Whether the
     * server should return the client-request-id in the response.
     *
     * @param {date} [options.certificateDeleteMethodOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(thumbprintAlgorithm, thumbprint, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let certificateDeleteMethodOptions = (options && options.certificateDeleteMethodOptions !== undefined) ? options.certificateDeleteMethodOptions : undefined;
            // Validate
            try {
                if (thumbprintAlgorithm === null || thumbprintAlgorithm === undefined || typeof thumbprintAlgorithm.valueOf() !== 'string') {
                    throw new Error('thumbprintAlgorithm cannot be null or undefined and it must be of type string.');
                }
                if (thumbprint === null || thumbprint === undefined || typeof thumbprint.valueOf() !== 'string') {
                    throw new Error('thumbprint cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (certificateDeleteMethodOptions !== null && certificateDeleteMethodOptions !== undefined) {
                    timeout = certificateDeleteMethodOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (certificateDeleteMethodOptions !== null && certificateDeleteMethodOptions !== undefined) {
                    clientRequestId = certificateDeleteMethodOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (certificateDeleteMethodOptions !== null && certificateDeleteMethodOptions !== undefined) {
                    returnClientRequestId = certificateDeleteMethodOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (certificateDeleteMethodOptions !== null && certificateDeleteMethodOptions !== undefined) {
                    ocpDate = certificateDeleteMethodOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates(thumbprintAlgorithm={thumbprintAlgorithm},thumbprint={thumbprint})';
            requestUrl = requestUrl.replace('{thumbprintAlgorithm}', encodeURIComponent(thumbprintAlgorithm));
            requestUrl = requestUrl.replace('{thumbprint}', encodeURIComponent(thumbprint));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'DELETE';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets information about the specified certificate.
     *
     * @param {string} thumbprintAlgorithm The algorithm used to derive the
     * thumbprint parameter. This must be sha1.
     *
     * @param {string} thumbprint The thumbprint of the certificate to get.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.certificateGetOptions] Additional parameters for
     * the operation
     *
     * @param {string} [options.certificateGetOptions.select] An OData $select
     * clause.
     *
     * @param {number} [options.certificateGetOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.certificateGetOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.certificateGetOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.certificateGetOptions.ocpDate] The time the request
     * was issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<Certificate>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(thumbprintAlgorithm, thumbprint, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let certificateGetOptions = (options && options.certificateGetOptions !== undefined) ? options.certificateGetOptions : undefined;
            // Validate
            try {
                if (thumbprintAlgorithm === null || thumbprintAlgorithm === undefined || typeof thumbprintAlgorithm.valueOf() !== 'string') {
                    throw new Error('thumbprintAlgorithm cannot be null or undefined and it must be of type string.');
                }
                if (thumbprint === null || thumbprint === undefined || typeof thumbprint.valueOf() !== 'string') {
                    throw new Error('thumbprint cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let select;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (certificateGetOptions !== null && certificateGetOptions !== undefined) {
                    select = certificateGetOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (certificateGetOptions !== null && certificateGetOptions !== undefined) {
                    timeout = certificateGetOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (certificateGetOptions !== null && certificateGetOptions !== undefined) {
                    clientRequestId = certificateGetOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (certificateGetOptions !== null && certificateGetOptions !== undefined) {
                    returnClientRequestId = certificateGetOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (certificateGetOptions !== null && certificateGetOptions !== undefined) {
                    ocpDate = certificateGetOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'certificates(thumbprintAlgorithm={thumbprintAlgorithm},thumbprint={thumbprint})';
            requestUrl = requestUrl.replace('{thumbprintAlgorithm}', encodeURIComponent(thumbprintAlgorithm));
            requestUrl = requestUrl.replace('{thumbprint}', encodeURIComponent(thumbprint));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (select !== null && select !== undefined) {
                queryParameters.push('$select=' + encodeURIComponent(select));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["Certificate"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the certificates that have been added to the specified
     * account.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.certificateListNextOptions] Additional parameters
     * for the operation
     *
     * @param {string} [options.certificateListNextOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.certificateListNextOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.certificateListNextOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<CertificateListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let certificateListNextOptions = (options && options.certificateListNextOptions !== undefined) ? options.certificateListNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (certificateListNextOptions !== null && certificateListNextOptions !== undefined) {
                    clientRequestId = certificateListNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (certificateListNextOptions !== null && certificateListNextOptions !== undefined) {
                    returnClientRequestId = certificateListNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (certificateListNextOptions !== null && certificateListNextOptions !== undefined) {
                    ocpDate = certificateListNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["CertificateListResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    add(certificate, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.addWithHttpOperationResponse(certificate, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.addWithHttpOperationResponse(certificate, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    list(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.listWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    cancelDeletion(thumbprintAlgorithm, thumbprint, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.cancelDeletionWithHttpOperationResponse(thumbprintAlgorithm, thumbprint, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.cancelDeletionWithHttpOperationResponse(thumbprintAlgorithm, thumbprint, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    deleteMethod(thumbprintAlgorithm, thumbprint, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteMethodWithHttpOperationResponse(thumbprintAlgorithm, thumbprint, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.deleteMethodWithHttpOperationResponse(thumbprintAlgorithm, thumbprint, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    get(thumbprintAlgorithm, thumbprint, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(thumbprintAlgorithm, thumbprint, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.getWithHttpOperationResponse(thumbprintAlgorithm, thumbprint, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.listNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = CertificateOperations;



/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__models_mappers__ = __webpack_require__(1);
/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


const WebResource = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["WebResource"];
/** Class representing a File. */
class File {
    /**
     * Create a File.
     * @param {BatchServiceClient} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Deletes the specified task file from the compute node where the
     * task ran.
     *
     * @param {string} jobId The ID of the job that contains the task.
     *
     * @param {string} taskId The ID of the task whose file you want to delete.
     *
     * @param {string} filePath The path to the task file or directory that you
     * want to delete.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {boolean} [options.recursive] Whether to delete children of a
     * directory. If the filePath parameter represents a directory instead of a
     * file, you can set recursive to true to delete the directory and all of the
     * files and subdirectories in it. If recursive is false then the directory
     * must be empty or deletion will fail.
     *
     * @param {object} [options.fileDeleteFromTaskOptions] Additional parameters
     * for the operation
     *
     * @param {number} [options.fileDeleteFromTaskOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.fileDeleteFromTaskOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.fileDeleteFromTaskOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.fileDeleteFromTaskOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteFromTaskWithHttpOperationResponse(jobId, taskId, filePath, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let recursive = (options && options.recursive !== undefined) ? options.recursive : undefined;
            let fileDeleteFromTaskOptions = (options && options.fileDeleteFromTaskOptions !== undefined) ? options.fileDeleteFromTaskOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (filePath === null || filePath === undefined || typeof filePath.valueOf() !== 'string') {
                    throw new Error('filePath cannot be null or undefined and it must be of type string.');
                }
                if (recursive !== null && recursive !== undefined && typeof recursive !== 'boolean') {
                    throw new Error('recursive must be of type boolean.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (fileDeleteFromTaskOptions !== null && fileDeleteFromTaskOptions !== undefined) {
                    timeout = fileDeleteFromTaskOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (fileDeleteFromTaskOptions !== null && fileDeleteFromTaskOptions !== undefined) {
                    clientRequestId = fileDeleteFromTaskOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileDeleteFromTaskOptions !== null && fileDeleteFromTaskOptions !== undefined) {
                    returnClientRequestId = fileDeleteFromTaskOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileDeleteFromTaskOptions !== null && fileDeleteFromTaskOptions !== undefined) {
                    ocpDate = fileDeleteFromTaskOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/tasks/{taskId}/files/{filePath}';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            requestUrl = requestUrl.replace('{taskId}', encodeURIComponent(taskId));
            requestUrl = requestUrl.replace('{filePath}', encodeURIComponent(filePath));
            let queryParameters = [];
            if (recursive !== null && recursive !== undefined) {
                queryParameters.push('recursive=' + encodeURIComponent(recursive.toString()));
            }
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'DELETE';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Returns the content of the specified task file.
     *
     * @param {string} jobId The ID of the job that contains the task.
     *
     * @param {string} taskId The ID of the task whose file you want to retrieve.
     *
     * @param {string} filePath The path to the task file that you want to get the
     * content of.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.fileGetFromTaskOptions] Additional parameters for
     * the operation
     *
     * @param {number} [options.fileGetFromTaskOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.fileGetFromTaskOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.fileGetFromTaskOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.fileGetFromTaskOptions.ocpDate] The time the request
     * was issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.fileGetFromTaskOptions.ocpRange] The byte range to
     * be retrieved. The default is to retrieve the entire file. The format is
     * bytes=startRange-endRange.
     *
     * @param {date} [options.fileGetFromTaskOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.fileGetFromTaskOptions.ifUnmodifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has not been
     * modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<ReadableStream>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getFromTaskWithHttpOperationResponse(jobId, taskId, filePath, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let fileGetFromTaskOptions = (options && options.fileGetFromTaskOptions !== undefined) ? options.fileGetFromTaskOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (filePath === null || filePath === undefined || typeof filePath.valueOf() !== 'string') {
                    throw new Error('filePath cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ocpRange;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (fileGetFromTaskOptions !== null && fileGetFromTaskOptions !== undefined) {
                    timeout = fileGetFromTaskOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (fileGetFromTaskOptions !== null && fileGetFromTaskOptions !== undefined) {
                    clientRequestId = fileGetFromTaskOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileGetFromTaskOptions !== null && fileGetFromTaskOptions !== undefined) {
                    returnClientRequestId = fileGetFromTaskOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileGetFromTaskOptions !== null && fileGetFromTaskOptions !== undefined) {
                    ocpDate = fileGetFromTaskOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (fileGetFromTaskOptions !== null && fileGetFromTaskOptions !== undefined) {
                    ocpRange = fileGetFromTaskOptions.ocpRange;
                    if (ocpRange !== null && ocpRange !== undefined && typeof ocpRange.valueOf() !== 'string') {
                        throw new Error('ocpRange must be of type string.');
                    }
                }
                if (fileGetFromTaskOptions !== null && fileGetFromTaskOptions !== undefined) {
                    ifModifiedSince = fileGetFromTaskOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (fileGetFromTaskOptions !== null && fileGetFromTaskOptions !== undefined) {
                    ifUnmodifiedSince = fileGetFromTaskOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/tasks/{taskId}/files/{filePath}';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            requestUrl = requestUrl.replace('{taskId}', encodeURIComponent(taskId));
            requestUrl = requestUrl.replace('{filePath}', encodeURIComponent(filePath));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ocpRange !== undefined && ocpRange !== null) {
                httpRequest.headers['ocp-range'] = ocpRange;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            httpRequest.rawResponse = true;
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Unexpected status code: ${statusCode}`);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets the properties of the specified task file.
     *
     * @param {string} jobId The ID of the job that contains the task.
     *
     * @param {string} taskId The ID of the task whose file you want to get the
     * properties of.
     *
     * @param {string} filePath The path to the task file that you want to get the
     * properties of.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.fileGetPropertiesFromTaskOptions] Additional
     * parameters for the operation
     *
     * @param {number} [options.fileGetPropertiesFromTaskOptions.timeout] The
     * maximum time that the server can spend processing the request, in seconds.
     * The default is 30 seconds.
     *
     * @param {string} [options.fileGetPropertiesFromTaskOptions.clientRequestId]
     * The caller-generated request identity, in the form of a GUID with no
     * decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean}
     * [options.fileGetPropertiesFromTaskOptions.returnClientRequestId] Whether the
     * server should return the client-request-id in the response.
     *
     * @param {date} [options.fileGetPropertiesFromTaskOptions.ocpDate] The time
     * the request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {date} [options.fileGetPropertiesFromTaskOptions.ifModifiedSince] A
     * timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service
     * has been modified since the specified time.
     *
     * @param {date} [options.fileGetPropertiesFromTaskOptions.ifUnmodifiedSince] A
     * timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service
     * has not been modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getPropertiesFromTaskWithHttpOperationResponse(jobId, taskId, filePath, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let fileGetPropertiesFromTaskOptions = (options && options.fileGetPropertiesFromTaskOptions !== undefined) ? options.fileGetPropertiesFromTaskOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (filePath === null || filePath === undefined || typeof filePath.valueOf() !== 'string') {
                    throw new Error('filePath cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (fileGetPropertiesFromTaskOptions !== null && fileGetPropertiesFromTaskOptions !== undefined) {
                    timeout = fileGetPropertiesFromTaskOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (fileGetPropertiesFromTaskOptions !== null && fileGetPropertiesFromTaskOptions !== undefined) {
                    clientRequestId = fileGetPropertiesFromTaskOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileGetPropertiesFromTaskOptions !== null && fileGetPropertiesFromTaskOptions !== undefined) {
                    returnClientRequestId = fileGetPropertiesFromTaskOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileGetPropertiesFromTaskOptions !== null && fileGetPropertiesFromTaskOptions !== undefined) {
                    ocpDate = fileGetPropertiesFromTaskOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (fileGetPropertiesFromTaskOptions !== null && fileGetPropertiesFromTaskOptions !== undefined) {
                    ifModifiedSince = fileGetPropertiesFromTaskOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (fileGetPropertiesFromTaskOptions !== null && fileGetPropertiesFromTaskOptions !== undefined) {
                    ifUnmodifiedSince = fileGetPropertiesFromTaskOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/tasks/{taskId}/files/{filePath}';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            requestUrl = requestUrl.replace('{taskId}', encodeURIComponent(taskId));
            requestUrl = requestUrl.replace('{filePath}', encodeURIComponent(filePath));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'HEAD';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Deletes the specified file from the compute node.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node from which you want to
     * delete the file.
     *
     * @param {string} filePath The path to the file or directory that you want to
     * delete.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {boolean} [options.recursive] Whether to delete children of a
     * directory. If the filePath parameter represents a directory instead of a
     * file, you can set recursive to true to delete the directory and all of the
     * files and subdirectories in it. If recursive is false then the directory
     * must be empty or deletion will fail.
     *
     * @param {object} [options.fileDeleteFromComputeNodeOptions] Additional
     * parameters for the operation
     *
     * @param {number} [options.fileDeleteFromComputeNodeOptions.timeout] The
     * maximum time that the server can spend processing the request, in seconds.
     * The default is 30 seconds.
     *
     * @param {string} [options.fileDeleteFromComputeNodeOptions.clientRequestId]
     * The caller-generated request identity, in the form of a GUID with no
     * decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean}
     * [options.fileDeleteFromComputeNodeOptions.returnClientRequestId] Whether the
     * server should return the client-request-id in the response.
     *
     * @param {date} [options.fileDeleteFromComputeNodeOptions.ocpDate] The time
     * the request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteFromComputeNodeWithHttpOperationResponse(poolId, nodeId, filePath, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let recursive = (options && options.recursive !== undefined) ? options.recursive : undefined;
            let fileDeleteFromComputeNodeOptions = (options && options.fileDeleteFromComputeNodeOptions !== undefined) ? options.fileDeleteFromComputeNodeOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (filePath === null || filePath === undefined || typeof filePath.valueOf() !== 'string') {
                    throw new Error('filePath cannot be null or undefined and it must be of type string.');
                }
                if (recursive !== null && recursive !== undefined && typeof recursive !== 'boolean') {
                    throw new Error('recursive must be of type boolean.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (fileDeleteFromComputeNodeOptions !== null && fileDeleteFromComputeNodeOptions !== undefined) {
                    timeout = fileDeleteFromComputeNodeOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (fileDeleteFromComputeNodeOptions !== null && fileDeleteFromComputeNodeOptions !== undefined) {
                    clientRequestId = fileDeleteFromComputeNodeOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileDeleteFromComputeNodeOptions !== null && fileDeleteFromComputeNodeOptions !== undefined) {
                    returnClientRequestId = fileDeleteFromComputeNodeOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileDeleteFromComputeNodeOptions !== null && fileDeleteFromComputeNodeOptions !== undefined) {
                    ocpDate = fileDeleteFromComputeNodeOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes/{nodeId}/files/{filePath}';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            requestUrl = requestUrl.replace('{nodeId}', encodeURIComponent(nodeId));
            requestUrl = requestUrl.replace('{filePath}', encodeURIComponent(filePath));
            let queryParameters = [];
            if (recursive !== null && recursive !== undefined) {
                queryParameters.push('recursive=' + encodeURIComponent(recursive.toString()));
            }
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'DELETE';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Returns the content of the specified compute node file.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node that contains the file.
     *
     * @param {string} filePath The path to the compute node file that you want to
     * get the content of.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.fileGetFromComputeNodeOptions] Additional
     * parameters for the operation
     *
     * @param {number} [options.fileGetFromComputeNodeOptions.timeout] The maximum
     * time that the server can spend processing the request, in seconds. The
     * default is 30 seconds.
     *
     * @param {string} [options.fileGetFromComputeNodeOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean}
     * [options.fileGetFromComputeNodeOptions.returnClientRequestId] Whether the
     * server should return the client-request-id in the response.
     *
     * @param {date} [options.fileGetFromComputeNodeOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {string} [options.fileGetFromComputeNodeOptions.ocpRange] The byte
     * range to be retrieved. The default is to retrieve the entire file. The
     * format is bytes=startRange-endRange.
     *
     * @param {date} [options.fileGetFromComputeNodeOptions.ifModifiedSince] A
     * timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service
     * has been modified since the specified time.
     *
     * @param {date} [options.fileGetFromComputeNodeOptions.ifUnmodifiedSince] A
     * timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service
     * has not been modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<ReadableStream>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getFromComputeNodeWithHttpOperationResponse(poolId, nodeId, filePath, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let fileGetFromComputeNodeOptions = (options && options.fileGetFromComputeNodeOptions !== undefined) ? options.fileGetFromComputeNodeOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (filePath === null || filePath === undefined || typeof filePath.valueOf() !== 'string') {
                    throw new Error('filePath cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ocpRange;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (fileGetFromComputeNodeOptions !== null && fileGetFromComputeNodeOptions !== undefined) {
                    timeout = fileGetFromComputeNodeOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (fileGetFromComputeNodeOptions !== null && fileGetFromComputeNodeOptions !== undefined) {
                    clientRequestId = fileGetFromComputeNodeOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileGetFromComputeNodeOptions !== null && fileGetFromComputeNodeOptions !== undefined) {
                    returnClientRequestId = fileGetFromComputeNodeOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileGetFromComputeNodeOptions !== null && fileGetFromComputeNodeOptions !== undefined) {
                    ocpDate = fileGetFromComputeNodeOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (fileGetFromComputeNodeOptions !== null && fileGetFromComputeNodeOptions !== undefined) {
                    ocpRange = fileGetFromComputeNodeOptions.ocpRange;
                    if (ocpRange !== null && ocpRange !== undefined && typeof ocpRange.valueOf() !== 'string') {
                        throw new Error('ocpRange must be of type string.');
                    }
                }
                if (fileGetFromComputeNodeOptions !== null && fileGetFromComputeNodeOptions !== undefined) {
                    ifModifiedSince = fileGetFromComputeNodeOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (fileGetFromComputeNodeOptions !== null && fileGetFromComputeNodeOptions !== undefined) {
                    ifUnmodifiedSince = fileGetFromComputeNodeOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes/{nodeId}/files/{filePath}';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            requestUrl = requestUrl.replace('{nodeId}', encodeURIComponent(nodeId));
            requestUrl = requestUrl.replace('{filePath}', encodeURIComponent(filePath));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ocpRange !== undefined && ocpRange !== null) {
                httpRequest.headers['ocp-range'] = ocpRange;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            httpRequest.rawResponse = true;
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Unexpected status code: ${statusCode}`);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets the properties of the specified compute node file.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node that contains the file.
     *
     * @param {string} filePath The path to the compute node file that you want to
     * get the properties of.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.fileGetPropertiesFromComputeNodeOptions] Additional
     * parameters for the operation
     *
     * @param {number} [options.fileGetPropertiesFromComputeNodeOptions.timeout]
     * The maximum time that the server can spend processing the request, in
     * seconds. The default is 30 seconds.
     *
     * @param {string}
     * [options.fileGetPropertiesFromComputeNodeOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean}
     * [options.fileGetPropertiesFromComputeNodeOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.fileGetPropertiesFromComputeNodeOptions.ocpDate] The
     * time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {date}
     * [options.fileGetPropertiesFromComputeNodeOptions.ifModifiedSince] A
     * timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service
     * has been modified since the specified time.
     *
     * @param {date}
     * [options.fileGetPropertiesFromComputeNodeOptions.ifUnmodifiedSince] A
     * timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service
     * has not been modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getPropertiesFromComputeNodeWithHttpOperationResponse(poolId, nodeId, filePath, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let fileGetPropertiesFromComputeNodeOptions = (options && options.fileGetPropertiesFromComputeNodeOptions !== undefined) ? options.fileGetPropertiesFromComputeNodeOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (filePath === null || filePath === undefined || typeof filePath.valueOf() !== 'string') {
                    throw new Error('filePath cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (fileGetPropertiesFromComputeNodeOptions !== null && fileGetPropertiesFromComputeNodeOptions !== undefined) {
                    timeout = fileGetPropertiesFromComputeNodeOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (fileGetPropertiesFromComputeNodeOptions !== null && fileGetPropertiesFromComputeNodeOptions !== undefined) {
                    clientRequestId = fileGetPropertiesFromComputeNodeOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileGetPropertiesFromComputeNodeOptions !== null && fileGetPropertiesFromComputeNodeOptions !== undefined) {
                    returnClientRequestId = fileGetPropertiesFromComputeNodeOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileGetPropertiesFromComputeNodeOptions !== null && fileGetPropertiesFromComputeNodeOptions !== undefined) {
                    ocpDate = fileGetPropertiesFromComputeNodeOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (fileGetPropertiesFromComputeNodeOptions !== null && fileGetPropertiesFromComputeNodeOptions !== undefined) {
                    ifModifiedSince = fileGetPropertiesFromComputeNodeOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (fileGetPropertiesFromComputeNodeOptions !== null && fileGetPropertiesFromComputeNodeOptions !== undefined) {
                    ifUnmodifiedSince = fileGetPropertiesFromComputeNodeOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes/{nodeId}/files/{filePath}';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            requestUrl = requestUrl.replace('{nodeId}', encodeURIComponent(nodeId));
            requestUrl = requestUrl.replace('{filePath}', encodeURIComponent(filePath));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'HEAD';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the files in a task's directory on its compute node.
     *
     * @param {string} jobId The ID of the job that contains the task.
     *
     * @param {string} taskId The ID of the task whose files you want to list.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {boolean} [options.recursive] Whether to list children of the task
     * directory. This parameter can be used in combination with the filter
     * parameter to list specific type of files.
     *
     * @param {object} [options.fileListFromTaskOptions] Additional parameters for
     * the operation
     *
     * @param {string} [options.fileListFromTaskOptions.filter] An OData $filter
     * clause.
     *
     * @param {number} [options.fileListFromTaskOptions.maxResults] The maximum
     * number of items to return in the response. A maximum of 1000 files can be
     * returned.
     *
     * @param {number} [options.fileListFromTaskOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.fileListFromTaskOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.fileListFromTaskOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.fileListFromTaskOptions.ocpDate] The time the request
     * was issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<NodeFileListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listFromTaskWithHttpOperationResponse(jobId, taskId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let recursive = (options && options.recursive !== undefined) ? options.recursive : undefined;
            let fileListFromTaskOptions = (options && options.fileListFromTaskOptions !== undefined) ? options.fileListFromTaskOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (recursive !== null && recursive !== undefined && typeof recursive !== 'boolean') {
                    throw new Error('recursive must be of type boolean.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (fileListFromTaskOptions !== null && fileListFromTaskOptions !== undefined) {
                    filter = fileListFromTaskOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (fileListFromTaskOptions !== null && fileListFromTaskOptions !== undefined) {
                    maxResults = fileListFromTaskOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (fileListFromTaskOptions !== null && fileListFromTaskOptions !== undefined) {
                    timeout = fileListFromTaskOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (fileListFromTaskOptions !== null && fileListFromTaskOptions !== undefined) {
                    clientRequestId = fileListFromTaskOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileListFromTaskOptions !== null && fileListFromTaskOptions !== undefined) {
                    returnClientRequestId = fileListFromTaskOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileListFromTaskOptions !== null && fileListFromTaskOptions !== undefined) {
                    ocpDate = fileListFromTaskOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/tasks/{taskId}/files';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            requestUrl = requestUrl.replace('{taskId}', encodeURIComponent(taskId));
            let queryParameters = [];
            if (recursive !== null && recursive !== undefined) {
                queryParameters.push('recursive=' + encodeURIComponent(recursive.toString()));
            }
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (filter !== null && filter !== undefined) {
                queryParameters.push('$filter=' + encodeURIComponent(filter));
            }
            if (maxResults !== null && maxResults !== undefined) {
                queryParameters.push('maxresults=' + encodeURIComponent(maxResults.toString()));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["NodeFileListResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the files in task directories on the specified compute
     * node.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node whose files you want to
     * list.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {boolean} [options.recursive] Whether to list children of a
     * directory.
     *
     * @param {object} [options.fileListFromComputeNodeOptions] Additional
     * parameters for the operation
     *
     * @param {string} [options.fileListFromComputeNodeOptions.filter] An OData
     * $filter clause.
     *
     * @param {number} [options.fileListFromComputeNodeOptions.maxResults] The
     * maximum number of items to return in the response. A maximum of 1000 files
     * can be returned.
     *
     * @param {number} [options.fileListFromComputeNodeOptions.timeout] The maximum
     * time that the server can spend processing the request, in seconds. The
     * default is 30 seconds.
     *
     * @param {string} [options.fileListFromComputeNodeOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean}
     * [options.fileListFromComputeNodeOptions.returnClientRequestId] Whether the
     * server should return the client-request-id in the response.
     *
     * @param {date} [options.fileListFromComputeNodeOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<NodeFileListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listFromComputeNodeWithHttpOperationResponse(poolId, nodeId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let recursive = (options && options.recursive !== undefined) ? options.recursive : undefined;
            let fileListFromComputeNodeOptions = (options && options.fileListFromComputeNodeOptions !== undefined) ? options.fileListFromComputeNodeOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (recursive !== null && recursive !== undefined && typeof recursive !== 'boolean') {
                    throw new Error('recursive must be of type boolean.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (fileListFromComputeNodeOptions !== null && fileListFromComputeNodeOptions !== undefined) {
                    filter = fileListFromComputeNodeOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (fileListFromComputeNodeOptions !== null && fileListFromComputeNodeOptions !== undefined) {
                    maxResults = fileListFromComputeNodeOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (fileListFromComputeNodeOptions !== null && fileListFromComputeNodeOptions !== undefined) {
                    timeout = fileListFromComputeNodeOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (fileListFromComputeNodeOptions !== null && fileListFromComputeNodeOptions !== undefined) {
                    clientRequestId = fileListFromComputeNodeOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileListFromComputeNodeOptions !== null && fileListFromComputeNodeOptions !== undefined) {
                    returnClientRequestId = fileListFromComputeNodeOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileListFromComputeNodeOptions !== null && fileListFromComputeNodeOptions !== undefined) {
                    ocpDate = fileListFromComputeNodeOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes/{nodeId}/files';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            requestUrl = requestUrl.replace('{nodeId}', encodeURIComponent(nodeId));
            let queryParameters = [];
            if (recursive !== null && recursive !== undefined) {
                queryParameters.push('recursive=' + encodeURIComponent(recursive.toString()));
            }
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (filter !== null && filter !== undefined) {
                queryParameters.push('$filter=' + encodeURIComponent(filter));
            }
            if (maxResults !== null && maxResults !== undefined) {
                queryParameters.push('maxresults=' + encodeURIComponent(maxResults.toString()));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["NodeFileListResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the files in a task's directory on its compute node.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.fileListFromTaskNextOptions] Additional parameters
     * for the operation
     *
     * @param {string} [options.fileListFromTaskNextOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.fileListFromTaskNextOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.fileListFromTaskNextOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<NodeFileListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listFromTaskNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let fileListFromTaskNextOptions = (options && options.fileListFromTaskNextOptions !== undefined) ? options.fileListFromTaskNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (fileListFromTaskNextOptions !== null && fileListFromTaskNextOptions !== undefined) {
                    clientRequestId = fileListFromTaskNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileListFromTaskNextOptions !== null && fileListFromTaskNextOptions !== undefined) {
                    returnClientRequestId = fileListFromTaskNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileListFromTaskNextOptions !== null && fileListFromTaskNextOptions !== undefined) {
                    ocpDate = fileListFromTaskNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["NodeFileListResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the files in task directories on the specified compute
     * node.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.fileListFromComputeNodeNextOptions] Additional
     * parameters for the operation
     *
     * @param {string} [options.fileListFromComputeNodeNextOptions.clientRequestId]
     * The caller-generated request identity, in the form of a GUID with no
     * decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean}
     * [options.fileListFromComputeNodeNextOptions.returnClientRequestId] Whether
     * the server should return the client-request-id in the response.
     *
     * @param {date} [options.fileListFromComputeNodeNextOptions.ocpDate] The time
     * the request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<NodeFileListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listFromComputeNodeNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let fileListFromComputeNodeNextOptions = (options && options.fileListFromComputeNodeNextOptions !== undefined) ? options.fileListFromComputeNodeNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (fileListFromComputeNodeNextOptions !== null && fileListFromComputeNodeNextOptions !== undefined) {
                    clientRequestId = fileListFromComputeNodeNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (fileListFromComputeNodeNextOptions !== null && fileListFromComputeNodeNextOptions !== undefined) {
                    returnClientRequestId = fileListFromComputeNodeNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (fileListFromComputeNodeNextOptions !== null && fileListFromComputeNodeNextOptions !== undefined) {
                    ocpDate = fileListFromComputeNodeNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["NodeFileListResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    deleteFromTask(jobId, taskId, filePath, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteFromTaskWithHttpOperationResponse(jobId, taskId, filePath, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.deleteFromTaskWithHttpOperationResponse(jobId, taskId, filePath, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    getFromTask(jobId, taskId, filePath, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getFromTaskWithHttpOperationResponse(jobId, taskId, filePath, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsStream);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.getFromTaskWithHttpOperationResponse(jobId, taskId, filePath, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsStream;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    getPropertiesFromTask(jobId, taskId, filePath, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getPropertiesFromTaskWithHttpOperationResponse(jobId, taskId, filePath, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.getPropertiesFromTaskWithHttpOperationResponse(jobId, taskId, filePath, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    deleteFromComputeNode(poolId, nodeId, filePath, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteFromComputeNodeWithHttpOperationResponse(poolId, nodeId, filePath, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.deleteFromComputeNodeWithHttpOperationResponse(poolId, nodeId, filePath, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    getFromComputeNode(poolId, nodeId, filePath, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getFromComputeNodeWithHttpOperationResponse(poolId, nodeId, filePath, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsStream);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.getFromComputeNodeWithHttpOperationResponse(poolId, nodeId, filePath, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsStream;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    getPropertiesFromComputeNode(poolId, nodeId, filePath, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getPropertiesFromComputeNodeWithHttpOperationResponse(poolId, nodeId, filePath, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.getPropertiesFromComputeNodeWithHttpOperationResponse(poolId, nodeId, filePath, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listFromTask(jobId, taskId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listFromTaskWithHttpOperationResponse(jobId, taskId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.listFromTaskWithHttpOperationResponse(jobId, taskId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listFromComputeNode(poolId, nodeId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listFromComputeNodeWithHttpOperationResponse(poolId, nodeId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.listFromComputeNodeWithHttpOperationResponse(poolId, nodeId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listFromTaskNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listFromTaskNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.listFromTaskNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listFromComputeNodeNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listFromComputeNodeNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.listFromComputeNodeNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = File;



/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__models_mappers__ = __webpack_require__(1);
/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


const WebResource = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["WebResource"];
/** Class representing a JobSchedule. */
class JobSchedule {
    /**
     * Create a JobSchedule.
     * @param {BatchServiceClient} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Checks the specified job schedule exists.
     *
     * @param {string} jobScheduleId The ID of the job schedule which you want to
     * check.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.jobScheduleExistsOptions] Additional parameters for
     * the operation
     *
     * @param {number} [options.jobScheduleExistsOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.jobScheduleExistsOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.jobScheduleExistsOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.jobScheduleExistsOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {string} [options.jobScheduleExistsOptions.ifMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.
     *
     * @param {string} [options.jobScheduleExistsOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.jobScheduleExistsOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.jobScheduleExistsOptions.ifUnmodifiedSince] A
     * timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service
     * has not been modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<boolean>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    existsWithHttpOperationResponse(jobScheduleId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleExistsOptions = (options && options.jobScheduleExistsOptions !== undefined) ? options.jobScheduleExistsOptions : undefined;
            // Validate
            try {
                if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
                    throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined) {
                    timeout = jobScheduleExistsOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined) {
                    clientRequestId = jobScheduleExistsOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined) {
                    returnClientRequestId = jobScheduleExistsOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined) {
                    ocpDate = jobScheduleExistsOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined) {
                    ifMatch = jobScheduleExistsOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined) {
                    ifNoneMatch = jobScheduleExistsOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined) {
                    ifModifiedSince = jobScheduleExistsOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined) {
                    ifUnmodifiedSince = jobScheduleExistsOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobschedules/{jobScheduleId}';
            requestUrl = requestUrl.replace('{jobScheduleId}', encodeURIComponent(jobScheduleId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'HEAD';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200 && statusCode !== 404) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                operationRes.bodyAsJson = (statusCode === 200);
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Deletes a job schedule from the specified account.
     *
     * When you delete a job schedule, this also deletes all jobs and tasks under
     * that schedule. When tasks are deleted, all the files in their working
     * directories on the compute nodes are also deleted (the retention period is
     * ignored). The job schedule statistics are no longer accessible once the job
     * schedule is deleted, though they are still counted towards account lifetime
     * statistics.
     *
     * @param {string} jobScheduleId The ID of the job schedule to delete.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.jobScheduleDeleteMethodOptions] Additional
     * parameters for the operation
     *
     * @param {number} [options.jobScheduleDeleteMethodOptions.timeout] The maximum
     * time that the server can spend processing the request, in seconds. The
     * default is 30 seconds.
     *
     * @param {string} [options.jobScheduleDeleteMethodOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean}
     * [options.jobScheduleDeleteMethodOptions.returnClientRequestId] Whether the
     * server should return the client-request-id in the response.
     *
     * @param {date} [options.jobScheduleDeleteMethodOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {string} [options.jobScheduleDeleteMethodOptions.ifMatch] An ETag
     * value associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.
     *
     * @param {string} [options.jobScheduleDeleteMethodOptions.ifNoneMatch] An ETag
     * value associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.jobScheduleDeleteMethodOptions.ifModifiedSince] A
     * timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service
     * has been modified since the specified time.
     *
     * @param {date} [options.jobScheduleDeleteMethodOptions.ifUnmodifiedSince] A
     * timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service
     * has not been modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(jobScheduleId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleDeleteMethodOptions = (options && options.jobScheduleDeleteMethodOptions !== undefined) ? options.jobScheduleDeleteMethodOptions : undefined;
            // Validate
            try {
                if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
                    throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined) {
                    timeout = jobScheduleDeleteMethodOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined) {
                    clientRequestId = jobScheduleDeleteMethodOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined) {
                    returnClientRequestId = jobScheduleDeleteMethodOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined) {
                    ocpDate = jobScheduleDeleteMethodOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined) {
                    ifMatch = jobScheduleDeleteMethodOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined) {
                    ifNoneMatch = jobScheduleDeleteMethodOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined) {
                    ifModifiedSince = jobScheduleDeleteMethodOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined) {
                    ifUnmodifiedSince = jobScheduleDeleteMethodOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobschedules/{jobScheduleId}';
            requestUrl = requestUrl.replace('{jobScheduleId}', encodeURIComponent(jobScheduleId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'DELETE';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets information about the specified job schedule.
     *
     * @param {string} jobScheduleId The ID of the job schedule to get.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.jobScheduleGetOptions] Additional parameters for
     * the operation
     *
     * @param {string} [options.jobScheduleGetOptions.select] An OData $select
     * clause.
     *
     * @param {string} [options.jobScheduleGetOptions.expand] An OData $expand
     * clause.
     *
     * @param {number} [options.jobScheduleGetOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.jobScheduleGetOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.jobScheduleGetOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.jobScheduleGetOptions.ocpDate] The time the request
     * was issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.jobScheduleGetOptions.ifMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.
     *
     * @param {string} [options.jobScheduleGetOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.jobScheduleGetOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.jobScheduleGetOptions.ifUnmodifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has not been
     * modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<CloudJobSchedule>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(jobScheduleId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleGetOptions = (options && options.jobScheduleGetOptions !== undefined) ? options.jobScheduleGetOptions : undefined;
            // Validate
            try {
                if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
                    throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let select;
            let expand;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    select = jobScheduleGetOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    expand = jobScheduleGetOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    timeout = jobScheduleGetOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    clientRequestId = jobScheduleGetOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    returnClientRequestId = jobScheduleGetOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    ocpDate = jobScheduleGetOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    ifMatch = jobScheduleGetOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    ifNoneMatch = jobScheduleGetOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    ifModifiedSince = jobScheduleGetOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined) {
                    ifUnmodifiedSince = jobScheduleGetOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobschedules/{jobScheduleId}';
            requestUrl = requestUrl.replace('{jobScheduleId}', encodeURIComponent(jobScheduleId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (select !== null && select !== undefined) {
                queryParameters.push('$select=' + encodeURIComponent(select));
            }
            if (expand !== null && expand !== undefined) {
                queryParameters.push('$expand=' + encodeURIComponent(expand));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["CloudJobSchedule"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Updates the properties of the specified job schedule.
     *
     * This replaces only the job schedule properties specified in the request. For
     * example, if the schedule property is not specified with this request, then
     * the Batch service will keep the existing schedule. Changes to a job schedule
     * only impact jobs created by the schedule after the update has taken place;
     * currently running jobs are unaffected.
     *
     * @param {string} jobScheduleId The ID of the job schedule to update.
     *
     * @param {object} jobSchedulePatchParameter The parameters for the request.
     *
     * @param {object} [jobSchedulePatchParameter.schedule] The schedule according
     * to which jobs will be created. If you do not specify this element, the
     * existing schedule is left unchanged.
     *
     * @param {date} [jobSchedulePatchParameter.schedule.doNotRunUntil] The
     * earliest time at which any job may be created under this job schedule. If
     * you do not specify a doNotRunUntil time, the schedule becomes ready to
     * create jobs immediately.
     *
     * @param {date} [jobSchedulePatchParameter.schedule.doNotRunAfter] A time
     * after which no job will be created under this job schedule. The schedule
     * will move to the completed state as soon as this deadline is past and there
     * is no active job under this job schedule. If you do not specify a
     * doNotRunAfter time, and you are creating a recurring job schedule, the job
     * schedule will remain active until you explicitly terminate it.
     *
     * @param {moment.duration} [jobSchedulePatchParameter.schedule.startWindow]
     * The time interval, starting from the time at which the schedule indicates a
     * job should be created, within which a job must be created. If a job is not
     * created within the startWindow interval, then the 'opportunity' is lost; no
     * job will be created until the next recurrence of the schedule. If the
     * schedule is recurring, and the startWindow is longer than the recurrence
     * interval, then this is equivalent to an infinite startWindow, because the
     * job that is 'due' in one recurrenceInterval is not carried forward into the
     * next recurrence interval. The default is infinite. The minimum value is 1
     * minute. If you specify a lower value, the Batch service rejects the schedule
     * with an error; if you are calling the REST API directly, the HTTP status
     * code is 400 (Bad Request).
     *
     * @param {moment.duration}
     * [jobSchedulePatchParameter.schedule.recurrenceInterval] The time interval
     * between the start times of two successive jobs under the job schedule. A job
     * schedule can have at most one active job under it at any given time. Because
     * a job schedule can have at most one active job under it at any given time,
     * if it is time to create a new job under a job schedule, but the previous job
     * is still running, the Batch service will not create the new job until the
     * previous job finishes. If the previous job does not finish within the
     * startWindow period of the new recurrenceInterval, then no new job will be
     * scheduled for that interval. For recurring jobs, you should normally specify
     * a jobManagerTask in the jobSpecification. If you do not use jobManagerTask,
     * you will need an external process to monitor when jobs are created, add
     * tasks to the jobs and terminate the jobs ready for the next recurrence. The
     * default is that the schedule does not recur: one job is created, within the
     * startWindow after the doNotRunUntil time, and the schedule is complete as
     * soon as that job finishes. The minimum value is 1 minute. If you specify a
     * lower value, the Batch service rejects the schedule with an error; if you
     * are calling the REST API directly, the HTTP status code is 400 (Bad
     * Request).
     *
     * @param {object} [jobSchedulePatchParameter.jobSpecification] The details of
     * the jobs to be created on this schedule. Updates affect only jobs that are
     * started after the update has taken place. Any currently active job continues
     * with the older specification.
     *
     * @param {number} [jobSchedulePatchParameter.jobSpecification.priority] The
     * priority of jobs created under this schedule. Priority values can range from
     * -1000 to 1000, with -1000 being the lowest priority and 1000 being the
     * highest priority. The default value is 0. This priority is used as the
     * default for all jobs under the job schedule. You can update a job's priority
     * after it has been created using by using the update job API.
     *
     * @param {string} [jobSchedulePatchParameter.jobSpecification.displayName] The
     * display name for jobs created under this schedule. The name need not be
     * unique and can contain any Unicode characters up to a maximum length of
     * 1024.
     *
     * @param {boolean}
     * [jobSchedulePatchParameter.jobSpecification.usesTaskDependencies] Whether
     * tasks in the job can define dependencies on each other. The default is
     * false.
     *
     * @param {string}
     * [jobSchedulePatchParameter.jobSpecification.onAllTasksComplete] The action
     * the Batch service should take when all tasks in a job created under this
     * schedule are in the completed state. Note that if a job contains no tasks,
     * then all tasks are considered complete. This option is therefore most
     * commonly used with a Job Manager task; if you want to use automatic job
     * termination without a Job Manager, you should initially set
     * onAllTasksComplete to noAction and update the job properties to set
     * onAllTasksComplete to terminateJob once you have finished adding tasks. The
     * default is noAction. Possible values include: 'noAction', 'terminateJob'
     *
     * @param {string} [jobSchedulePatchParameter.jobSpecification.onTaskFailure]
     * The action the Batch service should take when any task fails in a job
     * created under this schedule. A task is considered to have failed if it have
     * failed if has a failureInfo. A failureInfo is set if the task completes with
     * a non-zero exit code after exhausting its retry count, or if there was an
     * error starting the task, for example due to a resource file download error.
     * The default is noAction. Possible values include: 'noAction',
     * 'performExitOptionsJobAction'
     *
     * @param {object} [jobSchedulePatchParameter.jobSpecification.constraints] The
     * execution constraints for jobs created under this schedule.
     *
     * @param {moment.duration}
     * [jobSchedulePatchParameter.jobSpecification.constraints.maxWallClockTime]
     * The maximum elapsed time that the job may run, measured from the time the
     * job is created. If the job does not complete within the time limit, the
     * Batch service terminates it and any tasks that are still running. In this
     * case, the termination reason will be MaxWallClockTimeExpiry. If this
     * property is not specified, there is no time limit on how long the job may
     * run.
     *
     * @param {number}
     * [jobSchedulePatchParameter.jobSpecification.constraints.maxTaskRetryCount]
     * The maximum number of times each task may be retried. The Batch service
     * retries a task if its exit code is nonzero. Note that this value
     * specifically controls the number of retries. The Batch service will try each
     * task once, and may then retry up to this limit. For example, if the maximum
     * retry count is 3, Batch tries a task up to 4 times (one initial try and 3
     * retries). If the maximum retry count is 0, the Batch service does not retry
     * tasks. If the maximum retry count is -1, the Batch service retries tasks
     * without limit. The default value is 0 (no retries).
     *
     * @param {object} [jobSchedulePatchParameter.jobSpecification.jobManagerTask]
     * The details of a Job Manager task to be launched when a job is started under
     * this schedule. If the job does not specify a Job Manager task, the user must
     * explicitly add tasks to the job using the Task API. If the job does specify
     * a Job Manager task, the Batch service creates the Job Manager task when the
     * job is created, and will try to schedule the Job Manager task before
     * scheduling other tasks in the job.
     *
     * @param {string} jobSchedulePatchParameter.jobSpecification.jobManagerTask.id
     * A string that uniquely identifies the Job Manager task within the job. The
     * ID can contain any combination of alphanumeric characters including hyphens
     * and underscores and cannot contain more than 64 characters.
     *
     * @param {string}
     * [jobSchedulePatchParameter.jobSpecification.jobManagerTask.displayName] The
     * display name of the Job Manager task. It need not be unique and can contain
     * any Unicode characters up to a maximum length of 1024.
     *
     * @param {string}
     * jobSchedulePatchParameter.jobSpecification.jobManagerTask.commandLine The
     * command line of the Job Manager task. The command line does not run under a
     * shell, and therefore cannot take advantage of shell features such as
     * environment variable expansion. If you want to take advantage of such
     * features, you should invoke the shell in the command line, for example using
     * "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux.
     *
     * @param {array}
     * [jobSchedulePatchParameter.jobSpecification.jobManagerTask.resourceFiles] A
     * list of files that the Batch service will download to the compute node
     * before running the command line. Files listed under this element are located
     * in the task's working directory.
     *
     * @param {array}
     * [jobSchedulePatchParameter.jobSpecification.jobManagerTask.outputFiles] A
     * list of files that the Batch service will upload from the compute node after
     * running the command line. For multi-instance tasks, the files will only be
     * uploaded from the compute node on which the primary task is executed.
     *
     * @param {array}
     * [jobSchedulePatchParameter.jobSpecification.jobManagerTask.environmentSettings]
     * A list of environment variable settings for the Job Manager task.
     *
     * @param {object}
     * [jobSchedulePatchParameter.jobSpecification.jobManagerTask.constraints]
     * Constraints that apply to the Job Manager task.
     *
     * @param {boolean}
     * [jobSchedulePatchParameter.jobSpecification.jobManagerTask.killJobOnCompletion]
     * Whether completion of the Job Manager task signifies completion of the
     * entire job. If true, when the Job Manager task completes, the Batch service
     * marks the job as complete. If any tasks are still running at this time
     * (other than Job Release), those tasks are terminated. If false, the
     * completion of the Job Manager task does not affect the job status. In this
     * case, you should either use the onAllTasksComplete attribute to terminate
     * the job, or have a client or user terminate the job explicitly. An example
     * of this is if the Job Manager creates a set of tasks but then takes no
     * further role in their execution. The default value is true. If you are using
     * the onAllTasksComplete and onTaskFailure attributes to control job lifetime,
     * and using the Job Manager task only to create the tasks for the job (not to
     * monitor progress), then it is important to set killJobOnCompletion to false.
     *
     * @param {object}
     * [jobSchedulePatchParameter.jobSpecification.jobManagerTask.userIdentity] The
     * user identity under which the Job Manager task runs. If omitted, the task
     * runs as a non-administrative user unique to the task.
     *
     * @param {boolean}
     * [jobSchedulePatchParameter.jobSpecification.jobManagerTask.runExclusive]
     * Whether the Job Manager task requires exclusive use of the compute node
     * where it runs. If true, no other tasks will run on the same compute node for
     * as long as the Job Manager is running. If false, other tasks can run
     * simultaneously with the Job Manager on a compute node. The Job Manager task
     * counts normally against the node's concurrent task limit, so this is only
     * relevant if the node allows multiple concurrent tasks. The default value is
     * true.
     *
     * @param {array}
     * [jobSchedulePatchParameter.jobSpecification.jobManagerTask.applicationPackageReferences]
     * A list of application packages that the Batch service will deploy to the
     * compute node before running the command line. Application packages are
     * downloaded and deployed to a shared directory, not the task working
     * directory. Therefore, if a referenced package is already on the compute
     * node, and is up to date, then it is not re-downloaded; the existing copy on
     * the compute node is used. If a referenced application package cannot be
     * installed, for example because the package has been deleted or because
     * download failed, the task fails.
     *
     * @param {object}
     * [jobSchedulePatchParameter.jobSpecification.jobManagerTask.authenticationTokenSettings]
     * The settings for an authentication token that the task can use to perform
     * Batch service operations. If this property is set, the Batch service
     * provides the task with an authentication token which can be used to
     * authenticate Batch service operations without requiring an account access
     * key. The token is provided via the AZ_BATCH_AUTHENTICATION_TOKEN environment
     * variable. The operations that the task can carry out using the token depend
     * on the settings. For example, a task can request job permissions in order to
     * add other tasks to the job, or check the status of the job or of other tasks
     * under the job.
     *
     * @param {array}
     * [jobSchedulePatchParameter.jobSpecification.jobManagerTask.authenticationTokenSettings.access]
     * The Batch resources to which the token grants access. The authentication
     * token grants access to a limited set of Batch service operations. Currently
     * the only supported value for the access property is 'job', which grants
     * access to all operations related to the job which contains the task.
     *
     * @param {boolean}
     * [jobSchedulePatchParameter.jobSpecification.jobManagerTask.allowLowPriorityNode]
     * Whether the Job Manager task may run on a low-priority compute node. The
     * default value is false.
     *
     * @param {object}
     * [jobSchedulePatchParameter.jobSpecification.jobPreparationTask] The Job
     * Preparation task for jobs created under this schedule. If a job has a Job
     * Preparation task, the Batch service will run the Job Preparation task on a
     * compute node before starting any tasks of that job on that compute node.
     *
     * @param {string}
     * [jobSchedulePatchParameter.jobSpecification.jobPreparationTask.id] A string
     * that uniquely identifies the Job Preparation task within the job. The ID can
     * contain any combination of alphanumeric characters including hyphens and
     * underscores and cannot contain more than 64 characters. If you do not
     * specify this property, the Batch service assigns a default value of
     * 'jobpreparation'. No other task in the job can have the same ID as the Job
     * Preparation task. If you try to submit a task with the same id, the Batch
     * service rejects the request with error code TaskIdSameAsJobPreparationTask;
     * if you are calling the REST API directly, the HTTP status code is 409
     * (Conflict).
     *
     * @param {string}
     * jobSchedulePatchParameter.jobSpecification.jobPreparationTask.commandLine
     * The command line of the Job Preparation task. The command line does not run
     * under a shell, and therefore cannot take advantage of shell features such as
     * environment variable expansion. If you want to take advantage of such
     * features, you should invoke the shell in the command line, for example using
     * "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux.
     *
     * @param {array}
     * [jobSchedulePatchParameter.jobSpecification.jobPreparationTask.resourceFiles]
     * A list of files that the Batch service will download to the compute node
     * before running the command line. Files listed under this element are located
     * in the task's working directory.
     *
     * @param {array}
     * [jobSchedulePatchParameter.jobSpecification.jobPreparationTask.environmentSettings]
     * A list of environment variable settings for the Job Preparation task.
     *
     * @param {object}
     * [jobSchedulePatchParameter.jobSpecification.jobPreparationTask.constraints]
     * Constraints that apply to the Job Preparation task.
     *
     * @param {moment.duration}
     * [jobSchedulePatchParameter.jobSpecification.jobPreparationTask.constraints.maxWallClockTime]
     * The maximum elapsed time that the task may run, measured from the time the
     * task starts. If the task does not complete within the time limit, the Batch
     * service terminates it. If this is not specified, there is no time limit on
     * how long the task may run.
     *
     * @param {moment.duration}
     * [jobSchedulePatchParameter.jobSpecification.jobPreparationTask.constraints.retentionTime]
     * The minimum time to retain the task directory on the compute node where it
     * ran, from the time it completes execution. After this time, the Batch
     * service may delete the task directory and all its contents. The default is
     * infinite, i.e. the task directory will be retained until the compute node is
     * removed or reimaged.
     *
     * @param {number}
     * [jobSchedulePatchParameter.jobSpecification.jobPreparationTask.constraints.maxTaskRetryCount]
     * The maximum number of times the task may be retried. The Batch service
     * retries a task if its exit code is nonzero. Note that this value
     * specifically controls the number of retries. The Batch service will try the
     * task once, and may then retry up to this limit. For example, if the maximum
     * retry count is 3, Batch tries the task up to 4 times (one initial try and 3
     * retries). If the maximum retry count is 0, the Batch service does not retry
     * the task. If the maximum retry count is -1, the Batch service retries the
     * task without limit.
     *
     * @param {boolean}
     * [jobSchedulePatchParameter.jobSpecification.jobPreparationTask.waitForSuccess]
     * Whether the Batch service should wait for the Job Preparation task to
     * complete successfully before scheduling any other tasks of the job on the
     * compute node. A Job Preparation task has completed successfully if it exits
     * with exit code 0. If true and the Job Preparation task fails on a compute
     * node, the Batch service retries the Job Preparation task up to its maximum
     * retry count (as specified in the constraints element). If the task has still
     * not completed successfully after all retries, then the Batch service will
     * not schedule tasks of the job to the compute node. The compute node remains
     * active and eligible to run tasks of other jobs. If false, the Batch service
     * will not wait for the Job Preparation task to complete. In this case, other
     * tasks of the job can start executing on the compute node while the Job
     * Preparation task is still running; and even if the Job Preparation task
     * fails, new tasks will continue to be scheduled on the node. The default
     * value is true.
     *
     * @param {object}
     * [jobSchedulePatchParameter.jobSpecification.jobPreparationTask.userIdentity]
     * The user identity under which the Job Preparation task runs. If omitted, the
     * task runs as a non-administrative user unique to the task on Windows nodes,
     * or a a non-administrative user unique to the pool on Linux nodes.
     *
     * @param {boolean}
     * [jobSchedulePatchParameter.jobSpecification.jobPreparationTask.rerunOnNodeRebootAfterSuccess]
     * Whether the Batch service should rerun the Job Preparation task after a
     * compute node reboots. The Job Preparation task is always rerun if a compute
     * node is reimaged, or if the Job Preparation task did not complete (e.g.
     * because the reboot occurred while the task was running). Therefore, you
     * should always write a Job Preparation task to be idempotent and to behave
     * correctly if run multiple times. The default value is true.
     *
     * @param {object} [jobSchedulePatchParameter.jobSpecification.jobReleaseTask]
     * The Job Release task for jobs created under this schedule. The primary
     * purpose of the Job Release task is to undo changes to compute nodes made by
     * the Job Preparation task. Example activities include deleting local files,
     * or shutting down services that were started as part of job preparation. A
     * Job Release task cannot be specified without also specifying a Job
     * Preparation task for the job. The Batch service runs the Job Release task on
     * the compute nodes that have run the Job Preparation task.
     *
     * @param {string}
     * [jobSchedulePatchParameter.jobSpecification.jobReleaseTask.id] A string that
     * uniquely identifies the Job Release task within the job. The ID can contain
     * any combination of alphanumeric characters including hyphens and underscores
     * and cannot contain more than 64 characters. If you do not specify this
     * property, the Batch service assigns a default value of 'jobrelease'. No
     * other task in the job can have the same ID as the Job Release task. If you
     * try to submit a task with the same id, the Batch service rejects the request
     * with error code TaskIdSameAsJobReleaseTask; if you are calling the REST API
     * directly, the HTTP status code is 409 (Conflict).
     *
     * @param {string}
     * jobSchedulePatchParameter.jobSpecification.jobReleaseTask.commandLine The
     * command line of the Job Release task. The command line does not run under a
     * shell, and therefore cannot take advantage of shell features such as
     * environment variable expansion. If you want to take advantage of such
     * features, you should invoke the shell in the command line, for example using
     * "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux.
     *
     * @param {array}
     * [jobSchedulePatchParameter.jobSpecification.jobReleaseTask.resourceFiles] A
     * list of files that the Batch service will download to the compute node
     * before running the command line. Files listed under this element are located
     * in the task's working directory.
     *
     * @param {array}
     * [jobSchedulePatchParameter.jobSpecification.jobReleaseTask.environmentSettings]
     * A list of environment variable settings for the Job Release task.
     *
     * @param {moment.duration}
     * [jobSchedulePatchParameter.jobSpecification.jobReleaseTask.maxWallClockTime]
     * The maximum elapsed time that the Job Release task may run on a given
     * compute node, measured from the time the task starts. If the task does not
     * complete within the time limit, the Batch service terminates it. The default
     * value is 15 minutes. You may not specify a timeout longer than 15 minutes.
     * If you do, the Batch service rejects it with an error; if you are calling
     * the REST API directly, the HTTP status code is 400 (Bad Request).
     *
     * @param {moment.duration}
     * [jobSchedulePatchParameter.jobSpecification.jobReleaseTask.retentionTime]
     * The minimum time to retain the task directory for the Job Release task on
     * the compute node. After this time, the Batch service may delete the task
     * directory and all its contents. The default is infinite, i.e. the task
     * directory will be retained until the compute node is removed or reimaged.
     *
     * @param {object}
     * [jobSchedulePatchParameter.jobSpecification.jobReleaseTask.userIdentity] The
     * user identity under which the Job Release task runs. If omitted, the task
     * runs as a non-administrative user unique to the task.
     *
     * @param {array}
     * [jobSchedulePatchParameter.jobSpecification.commonEnvironmentSettings] A
     * list of common environment variable settings. These environment variables
     * are set for all tasks in jobs created under this schedule (including the Job
     * Manager, Job Preparation and Job Release tasks). Individual tasks can
     * override an environment setting specified here by specifying the same
     * setting name with a different value.
     *
     * @param {object} jobSchedulePatchParameter.jobSpecification.poolInfo The pool
     * on which the Batch service runs the tasks of jobs created under this
     * schedule.
     *
     * @param {string} [jobSchedulePatchParameter.jobSpecification.poolInfo.poolId]
     * The ID of an existing pool. All the tasks of the job will run on the
     * specified pool. You must ensure that the pool referenced by this property
     * exists. If the pool does not exist at the time the Batch service tries to
     * schedule a job, no tasks for the job will run until you create a pool with
     * that id. Note that the Batch service will not reject the job request; it
     * will simply not run tasks until the pool exists. You must specify either the
     * pool ID or the auto pool specification, but not both.
     *
     * @param {object}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification]
     * Characteristics for a temporary 'auto pool'. The Batch service will create
     * this auto pool when the job is submitted. If auto pool creation fails, the
     * Batch service moves the job to a completed state, and the pool creation
     * error is set in the job's scheduling error property. The Batch service
     * manages the lifetime (both creation and, unless keepAlive is specified,
     * deletion) of the auto pool. Any user actions that affect the lifetime of the
     * auto pool while the job is active will result in unexpected behavior. You
     * must specify either the pool ID or the auto pool specification, but not
     * both.
     *
     * @param {string}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.autoPoolIdPrefix]
     * A prefix to be added to the unique identifier when a pool is automatically
     * created. The Batch service assigns each auto pool a unique identifier on
     * creation. To distinguish between pools created for different purposes, you
     * can specify this element to add a prefix to the ID that is assigned. The
     * prefix can be up to 20 characters long.
     *
     * @param {string}
     * jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.poolLifetimeOption
     * The minimum lifetime of created auto pools, and how multiple jobs on a
     * schedule are assigned to pools. When the pool lifetime is jobSchedule the
     * pool exists for the lifetime of the job schedule. The Batch Service creates
     * the pool when it creates the first job on the schedule. You may apply this
     * option only to job schedules, not to jobs. When the pool lifetime is job the
     * pool exists for the lifetime of the job to which it is dedicated. The Batch
     * service creates the pool when it creates the job. If the 'job' option is
     * applied to a job schedule, the Batch service creates a new auto pool for
     * every job created on the schedule. Possible values include: 'jobSchedule',
     * 'job'
     *
     * @param {boolean}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.keepAlive]
     * Whether to keep an auto pool alive after its lifetime expires. If false, the
     * Batch service deletes the pool once its lifetime (as determined by the
     * poolLifetimeOption setting) expires; that is, when the job or job schedule
     * completes. If true, the Batch service does not delete the pool
     * automatically. It is up to the user to delete auto pools created with this
     * option.
     *
     * @param {object}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool]
     * The pool specification for the auto pool.
     *
     * @param {string}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.displayName]
     * The display name for the pool. The display name need not be unique and can
     * contain any Unicode characters up to a maximum length of 1024.
     *
     * @param {string}
     * jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.vmSize
     * The size of the virtual machines in the pool. All virtual machines in a pool
     * are the same size. For information about available sizes of virtual machines
     * for Cloud Services pools (pools created with cloudServiceConfiguration), see
     * Sizes for Cloud Services
     * (http://azure.microsoft.com/documentation/articles/cloud-services-sizes-specs/).
     * Batch supports all Cloud Services VM sizes except ExtraSmall, A1V2 and A2V2.
     * For information about available VM sizes for pools using images from the
     * Virtual Machines Marketplace (pools created with
     * virtualMachineConfiguration) see Sizes for Virtual Machines (Linux)
     * (https://azure.microsoft.com/documentation/articles/virtual-machines-linux-sizes/)
     * or Sizes for Virtual Machines (Windows)
     * (https://azure.microsoft.com/documentation/articles/virtual-machines-windows-sizes/).
     * Batch supports all Azure VM sizes except STANDARD_A0 and those with premium
     * storage (STANDARD_GS, STANDARD_DS, and STANDARD_DSV2 series).
     *
     * @param {object}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration]
     * The cloud service configuration for the pool. This property must be
     * specified if the pool needs to be created with Azure PaaS VMs. This property
     * and virtualMachineConfiguration are mutually exclusive and one of the
     * properties must be specified. If neither is specified then the Batch service
     * returns an error; if you are calling the REST API directly, the HTTP status
     * code is 400 (Bad Request). This property cannot be specified if the Batch
     * account was created with its poolAllocationMode property set to
     * 'UserSubscription'.
     *
     * @param {string}
     * jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.osFamily
     * The Azure Guest OS family to be installed on the virtual machines in the
     * pool. Possible values are: 2 - OS Family 2, equivalent to Windows Server
     * 2008 R2 SP1. 3 - OS Family 3, equivalent to Windows Server 2012. 4 - OS
     * Family 4, equivalent to Windows Server 2012 R2. 5 - OS Family 5, equivalent
     * to Windows Server 2016. For more information, see Azure Guest OS Releases
     * (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
     *
     * @param {string}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.targetOSVersion]
     * The Azure Guest OS version to be installed on the virtual machines in the
     * pool. The default value is * which specifies the latest operating system
     * version for the specified OS family.
     *
     * @param {string}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.currentOSVersion]
     * The Azure Guest OS Version currently installed on the virtual machines in
     * the pool. This may differ from targetOSVersion if the pool state is
     * Upgrading. In this case some virtual machines may be on the targetOSVersion
     * and some may be on the currentOSVersion during the upgrade process. Once all
     * virtual machines have upgraded, currentOSVersion is updated to be the same
     * as targetOSVersion.
     *
     * @param {object}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration]
     * The virtual machine configuration for the pool. This property must be
     * specified if the pool needs to be created with Azure IaaS VMs. This property
     * and cloudServiceConfiguration are mutually exclusive and one of the
     * properties must be specified. If neither is specified then the Batch service
     * returns an error; if you are calling the REST API directly, the HTTP status
     * code is 400 (Bad Request).
     *
     * @param {object}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference]
     * A reference to the Azure Virtual Machines Marketplace image to use. This
     * property and osDisk are mutually exclusive and one of the properties must be
     * specified.
     *
     * @param {string}
     * jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.publisher
     * The publisher of the Azure Virtual Machines Marketplace image. For example,
     * Canonical or MicrosoftWindowsServer.
     *
     * @param {string}
     * jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.offer
     * The offer type of the Azure Virtual Machines Marketplace image. For example,
     * UbuntuServer or WindowsServer.
     *
     * @param {string}
     * jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.sku
     * The SKU of the Azure Virtual Machines Marketplace image. For example,
     * 14.04.0-LTS or 2012-R2-Datacenter.
     *
     * @param {string}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.version]
     * The version of the Azure Virtual Machines Marketplace image. A value of
     * 'latest' can be specified to select the latest version of an image. If
     * omitted, the default is 'latest'.
     *
     * @param {object}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.osDisk]
     * A reference to the OS disk image to use. This property can be specified only
     * if the Batch account was created with its poolAllocationMode property set to
     * 'UserSubscription'. This property and imageReference are mutually exclusive
     * and one of the properties must be specified.
     *
     * @param {array}
     * jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.osDisk.imageUris
     * The collection of Virtual Hard Disk (VHD) URIs. All the VHDs must be
     * identical and must reside in an Azure Storage account within the same
     * subscription and same region as the Batch account. For best performance, it
     * is recommended that each VHD resides in a separate Azure Storage account.
     * Each VHD can serve upto 20 Windows compute nodes or 40 Linux compute nodes.
     * You must supply enough VHD URIs to satisfy the 'targetDedicated' property of
     * the pool. If you do not supply enough VHD URIs, the pool will partially
     * allocate compute nodes, and a resize error will occur.
     *
     * @param {string}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.osDisk.caching]
     * The type of caching to enable for the OS disk. Values are:
     *
     * none - The caching mode for the disk is not enabled.
     * readOnly - The caching mode for the disk is read only.
     * readWrite - The caching mode for the disk is read and write.
     *
     * The default value for caching is none. For information about the caching
     * options see:
     * https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/27/exploring-windows-azure-drives-disks-and-images/.
     * Possible values include: 'none', 'readOnly', 'readWrite'
     *
     * @param {string}
     * jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.nodeAgentSKUId
     * The SKU of the Batch node agent to be provisioned on compute nodes in the
     * pool. The Batch node agent is a program that runs on each node in the pool,
     * and provides the command-and-control interface between the node and the
     * Batch service. There are different implementations of the node agent, known
     * as SKUs, for different operating systems. You must specify a node agent SKU
     * which matches the selected image reference. To get the list of supported
     * node agent SKUs along with their list of verified image references, see the
     * 'List supported node agent SKUs' operation.
     *
     * @param {object}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration]
     * Windows operating system settings on the virtual machine. This property must
     * not be specified if the imageReference or osDisk property specifies a Linux
     * OS image.
     *
     * @param {boolean}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration.enableAutomaticUpdates]
     * Whether automatic updates are enabled on the virtual machine. If omitted,
     * the default value is true.
     *
     * @param {number}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.maxTasksPerNode]
     * The maximum number of tasks that can run concurrently on a single compute
     * node in the pool. The default value is 1. The maximum value of this setting
     * depends on the size of the compute nodes in the pool (the vmSize setting).
     *
     * @param {object}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy]
     * How tasks are distributed across compute nodes in a pool.
     *
     * @param {string}
     * jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy.nodeFillType
     * How tasks are distributed across compute nodes in a pool. Values are:
     *
     * pack - As many tasks as possible (maxTasksPerNode) should be assigned to
     * each node in the pool before any tasks are assigned to the next node in the
     * pool.
     * spread - Tasks should be assigned evenly across all nodes in the pool.
     * Possible values include: 'spread', 'pack'
     *
     * @param {moment.duration}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.resizeTimeout]
     * The timeout for allocation of compute nodes to the pool. This timeout
     * applies only to manual scaling; it has no effect when enableAutoScale is set
     * to true. The default value is 15 minutes. The minimum value is 5 minutes. If
     * you specify a value less than 5 minutes, the Batch service rejects the
     * request with an error; if you are calling the REST API directly, the HTTP
     * status code is 400 (Bad Request).
     *
     * @param {number}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.targetDedicatedNodes]
     * The desired number of dedicated compute nodes in the pool. This property
     * must not be specified if enableAutoScale is set to true. If enableAutoScale
     * is set to false, then you must set either targetDedicatedNodes,
     * targetLowPriorityNodes, or both.
     *
     * @param {number}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.targetLowPriorityNodes]
     * The desired number of low-priority compute nodes in the pool. This property
     * must not be specified if enableAutoScale is set to true. If enableAutoScale
     * is set to false, then you must set either targetDedicatedNodes,
     * targetLowPriorityNodes, or both.
     *
     * @param {boolean}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.enableAutoScale]
     * Whether the pool size should automatically adjust over time. If false, at
     * least one of targetDedicateNodes and targetLowPriorityNodes must be
     * specified. If true, the autoScaleFormula element is required. The pool
     * automatically resizes according to the formula. The default value is false.
     *
     * @param {string}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.autoScaleFormula]
     * The formula for the desired number of compute nodes in the pool. This
     * property must not be specified if enableAutoScale is set to false. It is
     * required if enableAutoScale is set to true. The formula is checked for
     * validity before the pool is created. If the formula is not valid, the Batch
     * service rejects the request with detailed error information.
     *
     * @param {moment.duration}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.autoScaleEvaluationInterval]
     * The time interval at which to automatically adjust the pool size according
     * to the autoscale formula. The default value is 15 minutes. The minimum and
     * maximum value are 5 minutes and 168 hours respectively. If you specify a
     * value less than 5 minutes or greater than 168 hours, the Batch service
     * rejects the request with an invalid property value error; if you are calling
     * the REST API directly, the HTTP status code is 400 (Bad Request).
     *
     * @param {boolean}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.enableInterNodeCommunication]
     * Whether the pool permits direct communication between nodes. Enabling
     * inter-node communication limits the maximum size of the pool due to
     * deployment restrictions on the nodes of the pool. This may result in the
     * pool not reaching its desired size. The default value is false.
     *
     * @param {object}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.networkConfiguration]
     * The network configuration for the pool.
     *
     * @param {string}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.networkConfiguration.subnetId]
     * The ARM resource identifier of the virtual network subnet which the compute
     * nodes of the pool will join. This is of the form
     * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
     * The virtual network must be in the same region and subscription as the Azure
     * Batch account. The specified subnet should have enough free IP addresses to
     * accommodate the number of nodes in the pool. If the subnet doesn't have
     * enough free IP addresses, the pool will partially allocate compute nodes,
     * and a resize error will occur. The 'MicrosoftAzureBatch' service principal
     * must have the 'Classic Virtual Machine Contributor' Role-Based Access
     * Control (RBAC) role for the specified VNet. The specified subnet must allow
     * communication from the Azure Batch service to be able to schedule tasks on
     * the compute nodes. This can be verified by checking if the specified VNet
     * has any associated Network Security Groups (NSG). If communication to the
     * compute nodes in the specified subnet is denied by an NSG, then the Batch
     * service will set the state of the compute nodes to unusable. For pools
     * created via virtualMachineConfiguration the Batch account must have
     * poolAllocationMode userSubscription in order to use a VNet. If the specified
     * VNet has any associated Network Security Groups (NSG), then a few reserved
     * system ports must be enabled for inbound communication. For pools created
     * with a virtual machine configuration, enable ports 29876 and 29877, as well
     * as port 22 for Linux and port 3389 for Windows. For pools created with a
     * cloud service configuration, enable ports 10100, 20100, and 30100. Also
     * enable outbound connections to Azure Storage on port 443. For more details
     * see:
     * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration
     *
     * @param {object}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration]
     * The configuration for endpoints on compute nodes in the Batch pool. Pool
     * endpoint configuration is only supported on pools with the
     * virtualMachineConfiguration property.
     *
     * @param {array}
     * jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration.inboundNATPools
     * A list of inbound NAT pools that can be used to address specific ports on an
     * individual compute node externally. The maximum number of inbound NAT pools
     * per Batch pool is 5. If the maximum number of inbound NAT pools is exceeded
     * the request fails with HTTP status code 400.
     *
     * @param {object}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask]
     * A task to run on each compute node as it joins the pool. The task runs when
     * the node is added to the pool or when the node is restarted.
     *
     * @param {string}
     * jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.commandLine
     * The command line of the start task. The command line does not run under a
     * shell, and therefore cannot take advantage of shell features such as
     * environment variable expansion. If you want to take advantage of such
     * features, you should invoke the shell in the command line, for example using
     * "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux.
     *
     * @param {array}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.resourceFiles]
     * A list of files that the Batch service will download to the compute node
     * before running the command line. Files listed under this element are located
     * in the task's working directory.
     *
     * @param {array}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.environmentSettings]
     * A list of environment variable settings for the start task.
     *
     * @param {object}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.userIdentity]
     * The user identity under which the start task runs. If omitted, the task runs
     * as a non-administrative user unique to the task.
     *
     * @param {string}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.userName]
     * The name of the user identity under which the task is run. The userName and
     * autoUser properties are mutually exclusive; you must specify one but not
     * both.
     *
     * @param {object}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser]
     * The auto user under which the task is run. The userName and autoUser
     * properties are mutually exclusive; you must specify one but not both.
     *
     * @param {string}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.scope]
     * The scope for the auto user Values are:
     *
     * pool - specifies that the task runs as the common auto user account which is
     * created on every node in a pool.
     * task - specifies that the service should create a new user for the task.
     * The default value is task. Possible values include: 'task', 'pool'
     *
     * @param {string}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.elevationLevel]
     * The elevation level of the auto user. nonAdmin - The auto user is a standard
     * user without elevated access. admin - The auto user is a user with elevated
     * access and operates with full Administrator permissions. The default value
     * is nonAdmin. Possible values include: 'nonAdmin', 'admin'
     *
     * @param {number}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.maxTaskRetryCount]
     * The maximum number of times the task may be retried. The Batch service
     * retries a task if its exit code is nonzero. Note that this value
     * specifically controls the number of retries. The Batch service will try the
     * task once, and may then retry up to this limit. For example, if the maximum
     * retry count is 3, Batch tries the task up to 4 times (one initial try and 3
     * retries). If the maximum retry count is 0, the Batch service does not retry
     * the task. If the maximum retry count is -1, the Batch service retries the
     * task without limit.
     *
     * @param {boolean}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.waitForSuccess]
     * Whether the Batch service should wait for the start task to complete
     * successfully (that is, to exit with exit code 0) before scheduling any tasks
     * on the compute node. If true and the start task fails on a compute node, the
     * Batch service retries the start task up to its maximum retry count
     * (maxTaskRetryCount). If the task has still not completed successfully after
     * all retries, then the Batch service marks the compute node unusable, and
     * will not schedule tasks to it. This condition can be detected via the node
     * state and failure info details. If false, the Batch service will not wait
     * for the start task to complete. In this case, other tasks can start
     * executing on the compute node while the start task is still running; and
     * even if the start task fails, new tasks will continue to be scheduled on the
     * node. The default is false.
     *
     * @param {array}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.certificateReferences]
     * A list of certificates to be installed on each compute node in the pool. For
     * Windows compute nodes, the Batch service installs the certificates to the
     * specified certificate store and location. For Linux compute nodes, the
     * certificates are stored in a directory inside the task working directory and
     * an environment variable AZ_BATCH_CERTIFICATES_DIR is supplied to the task to
     * query for this location. For certificates with visibility of 'remoteUser', a
     * 'certs' directory is created in the user's home directory (e.g.,
     * /home/{user-name}/certs) and certificates are placed in that directory.
     *
     * @param {array}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.applicationPackageReferences]
     * The list of application packages to be installed on each compute node in the
     * pool.
     *
     * @param {array}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.applicationLicenses]
     * The list of application licenses the Batch service will make available on
     * each compute node in the pool. The list of application licenses must be a
     * subset of available Batch service application licenses. If a license is
     * requested which is not supported, pool creation will fail.
     *
     * @param {array}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.userAccounts]
     * The list of user accounts to be created on each node in the pool.
     *
     * @param {array}
     * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.metadata]
     * A list of name-value pairs associated with the pool as metadata. The Batch
     * service does not assign any meaning to metadata; it is solely for the use of
     * user code.
     *
     * @param {array} [jobSchedulePatchParameter.jobSpecification.metadata] A list
     * of name-value pairs associated with each job created under this schedule as
     * metadata. The Batch service does not assign any meaning to metadata; it is
     * solely for the use of user code.
     *
     * @param {array} [jobSchedulePatchParameter.metadata] A list of name-value
     * pairs associated with the job schedule as metadata. If you do not specify
     * this element, existing metadata is left unchanged.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.jobSchedulePatchOptions] Additional parameters for
     * the operation
     *
     * @param {number} [options.jobSchedulePatchOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.jobSchedulePatchOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.jobSchedulePatchOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.jobSchedulePatchOptions.ocpDate] The time the request
     * was issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.jobSchedulePatchOptions.ifMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.
     *
     * @param {string} [options.jobSchedulePatchOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.jobSchedulePatchOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.jobSchedulePatchOptions.ifUnmodifiedSince] A
     * timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service
     * has not been modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    patchWithHttpOperationResponse(jobScheduleId, jobSchedulePatchParameter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobSchedulePatchOptions = (options && options.jobSchedulePatchOptions !== undefined) ? options.jobSchedulePatchOptions : undefined;
            // Validate
            try {
                if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
                    throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
                }
                if (jobSchedulePatchParameter === null || jobSchedulePatchParameter === undefined) {
                    throw new Error('jobSchedulePatchParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined) {
                    timeout = jobSchedulePatchOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined) {
                    clientRequestId = jobSchedulePatchOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined) {
                    returnClientRequestId = jobSchedulePatchOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined) {
                    ocpDate = jobSchedulePatchOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined) {
                    ifMatch = jobSchedulePatchOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined) {
                    ifNoneMatch = jobSchedulePatchOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined) {
                    ifModifiedSince = jobSchedulePatchOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined) {
                    ifUnmodifiedSince = jobSchedulePatchOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobschedules/{jobScheduleId}';
            requestUrl = requestUrl.replace('{jobScheduleId}', encodeURIComponent(jobScheduleId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'PATCH';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (jobSchedulePatchParameter !== null && jobSchedulePatchParameter !== undefined) {
                    let requestModelMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["JobSchedulePatchParameter"];
                    requestModel = client.serializer.serialize(requestModelMapper, jobSchedulePatchParameter, 'jobSchedulePatchParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(jobSchedulePatchParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Updates the properties of the specified job schedule.
     *
     * This fully replaces all the updateable properties of the job schedule. For
     * example, if the schedule property is not specified with this request, then
     * the Batch service will remove the existing schedule. Changes to a job
     * schedule only impact jobs created by the schedule after the update has taken
     * place; currently running jobs are unaffected.
     *
     * @param {string} jobScheduleId The ID of the job schedule to update.
     *
     * @param {object} jobScheduleUpdateParameter The parameters for the request.
     *
     * @param {object} jobScheduleUpdateParameter.schedule The schedule according
     * to which jobs will be created. If you do not specify this element, it is
     * equivalent to passing the default schedule: that is, a single job scheduled
     * to run immediately.
     *
     * @param {date} [jobScheduleUpdateParameter.schedule.doNotRunUntil] The
     * earliest time at which any job may be created under this job schedule. If
     * you do not specify a doNotRunUntil time, the schedule becomes ready to
     * create jobs immediately.
     *
     * @param {date} [jobScheduleUpdateParameter.schedule.doNotRunAfter] A time
     * after which no job will be created under this job schedule. The schedule
     * will move to the completed state as soon as this deadline is past and there
     * is no active job under this job schedule. If you do not specify a
     * doNotRunAfter time, and you are creating a recurring job schedule, the job
     * schedule will remain active until you explicitly terminate it.
     *
     * @param {moment.duration} [jobScheduleUpdateParameter.schedule.startWindow]
     * The time interval, starting from the time at which the schedule indicates a
     * job should be created, within which a job must be created. If a job is not
     * created within the startWindow interval, then the 'opportunity' is lost; no
     * job will be created until the next recurrence of the schedule. If the
     * schedule is recurring, and the startWindow is longer than the recurrence
     * interval, then this is equivalent to an infinite startWindow, because the
     * job that is 'due' in one recurrenceInterval is not carried forward into the
     * next recurrence interval. The default is infinite. The minimum value is 1
     * minute. If you specify a lower value, the Batch service rejects the schedule
     * with an error; if you are calling the REST API directly, the HTTP status
     * code is 400 (Bad Request).
     *
     * @param {moment.duration}
     * [jobScheduleUpdateParameter.schedule.recurrenceInterval] The time interval
     * between the start times of two successive jobs under the job schedule. A job
     * schedule can have at most one active job under it at any given time. Because
     * a job schedule can have at most one active job under it at any given time,
     * if it is time to create a new job under a job schedule, but the previous job
     * is still running, the Batch service will not create the new job until the
     * previous job finishes. If the previous job does not finish within the
     * startWindow period of the new recurrenceInterval, then no new job will be
     * scheduled for that interval. For recurring jobs, you should normally specify
     * a jobManagerTask in the jobSpecification. If you do not use jobManagerTask,
     * you will need an external process to monitor when jobs are created, add
     * tasks to the jobs and terminate the jobs ready for the next recurrence. The
     * default is that the schedule does not recur: one job is created, within the
     * startWindow after the doNotRunUntil time, and the schedule is complete as
     * soon as that job finishes. The minimum value is 1 minute. If you specify a
     * lower value, the Batch service rejects the schedule with an error; if you
     * are calling the REST API directly, the HTTP status code is 400 (Bad
     * Request).
     *
     * @param {object} jobScheduleUpdateParameter.jobSpecification Details of the
     * jobs to be created on this schedule. Updates affect only jobs that are
     * started after the update has taken place. Any currently active job continues
     * with the older specification.
     *
     * @param {number} [jobScheduleUpdateParameter.jobSpecification.priority] The
     * priority of jobs created under this schedule. Priority values can range from
     * -1000 to 1000, with -1000 being the lowest priority and 1000 being the
     * highest priority. The default value is 0. This priority is used as the
     * default for all jobs under the job schedule. You can update a job's priority
     * after it has been created using by using the update job API.
     *
     * @param {string} [jobScheduleUpdateParameter.jobSpecification.displayName]
     * The display name for jobs created under this schedule. The name need not be
     * unique and can contain any Unicode characters up to a maximum length of
     * 1024.
     *
     * @param {boolean}
     * [jobScheduleUpdateParameter.jobSpecification.usesTaskDependencies] Whether
     * tasks in the job can define dependencies on each other. The default is
     * false.
     *
     * @param {string}
     * [jobScheduleUpdateParameter.jobSpecification.onAllTasksComplete] The action
     * the Batch service should take when all tasks in a job created under this
     * schedule are in the completed state. Note that if a job contains no tasks,
     * then all tasks are considered complete. This option is therefore most
     * commonly used with a Job Manager task; if you want to use automatic job
     * termination without a Job Manager, you should initially set
     * onAllTasksComplete to noAction and update the job properties to set
     * onAllTasksComplete to terminateJob once you have finished adding tasks. The
     * default is noAction. Possible values include: 'noAction', 'terminateJob'
     *
     * @param {string} [jobScheduleUpdateParameter.jobSpecification.onTaskFailure]
     * The action the Batch service should take when any task fails in a job
     * created under this schedule. A task is considered to have failed if it have
     * failed if has a failureInfo. A failureInfo is set if the task completes with
     * a non-zero exit code after exhausting its retry count, or if there was an
     * error starting the task, for example due to a resource file download error.
     * The default is noAction. Possible values include: 'noAction',
     * 'performExitOptionsJobAction'
     *
     * @param {object} [jobScheduleUpdateParameter.jobSpecification.constraints]
     * The execution constraints for jobs created under this schedule.
     *
     * @param {moment.duration}
     * [jobScheduleUpdateParameter.jobSpecification.constraints.maxWallClockTime]
     * The maximum elapsed time that the job may run, measured from the time the
     * job is created. If the job does not complete within the time limit, the
     * Batch service terminates it and any tasks that are still running. In this
     * case, the termination reason will be MaxWallClockTimeExpiry. If this
     * property is not specified, there is no time limit on how long the job may
     * run.
     *
     * @param {number}
     * [jobScheduleUpdateParameter.jobSpecification.constraints.maxTaskRetryCount]
     * The maximum number of times each task may be retried. The Batch service
     * retries a task if its exit code is nonzero. Note that this value
     * specifically controls the number of retries. The Batch service will try each
     * task once, and may then retry up to this limit. For example, if the maximum
     * retry count is 3, Batch tries a task up to 4 times (one initial try and 3
     * retries). If the maximum retry count is 0, the Batch service does not retry
     * tasks. If the maximum retry count is -1, the Batch service retries tasks
     * without limit. The default value is 0 (no retries).
     *
     * @param {object} [jobScheduleUpdateParameter.jobSpecification.jobManagerTask]
     * The details of a Job Manager task to be launched when a job is started under
     * this schedule. If the job does not specify a Job Manager task, the user must
     * explicitly add tasks to the job using the Task API. If the job does specify
     * a Job Manager task, the Batch service creates the Job Manager task when the
     * job is created, and will try to schedule the Job Manager task before
     * scheduling other tasks in the job.
     *
     * @param {string}
     * jobScheduleUpdateParameter.jobSpecification.jobManagerTask.id A string that
     * uniquely identifies the Job Manager task within the job. The ID can contain
     * any combination of alphanumeric characters including hyphens and underscores
     * and cannot contain more than 64 characters.
     *
     * @param {string}
     * [jobScheduleUpdateParameter.jobSpecification.jobManagerTask.displayName] The
     * display name of the Job Manager task. It need not be unique and can contain
     * any Unicode characters up to a maximum length of 1024.
     *
     * @param {string}
     * jobScheduleUpdateParameter.jobSpecification.jobManagerTask.commandLine The
     * command line of the Job Manager task. The command line does not run under a
     * shell, and therefore cannot take advantage of shell features such as
     * environment variable expansion. If you want to take advantage of such
     * features, you should invoke the shell in the command line, for example using
     * "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux.
     *
     * @param {array}
     * [jobScheduleUpdateParameter.jobSpecification.jobManagerTask.resourceFiles] A
     * list of files that the Batch service will download to the compute node
     * before running the command line. Files listed under this element are located
     * in the task's working directory.
     *
     * @param {array}
     * [jobScheduleUpdateParameter.jobSpecification.jobManagerTask.outputFiles] A
     * list of files that the Batch service will upload from the compute node after
     * running the command line. For multi-instance tasks, the files will only be
     * uploaded from the compute node on which the primary task is executed.
     *
     * @param {array}
     * [jobScheduleUpdateParameter.jobSpecification.jobManagerTask.environmentSettings]
     * A list of environment variable settings for the Job Manager task.
     *
     * @param {object}
     * [jobScheduleUpdateParameter.jobSpecification.jobManagerTask.constraints]
     * Constraints that apply to the Job Manager task.
     *
     * @param {boolean}
     * [jobScheduleUpdateParameter.jobSpecification.jobManagerTask.killJobOnCompletion]
     * Whether completion of the Job Manager task signifies completion of the
     * entire job. If true, when the Job Manager task completes, the Batch service
     * marks the job as complete. If any tasks are still running at this time
     * (other than Job Release), those tasks are terminated. If false, the
     * completion of the Job Manager task does not affect the job status. In this
     * case, you should either use the onAllTasksComplete attribute to terminate
     * the job, or have a client or user terminate the job explicitly. An example
     * of this is if the Job Manager creates a set of tasks but then takes no
     * further role in their execution. The default value is true. If you are using
     * the onAllTasksComplete and onTaskFailure attributes to control job lifetime,
     * and using the Job Manager task only to create the tasks for the job (not to
     * monitor progress), then it is important to set killJobOnCompletion to false.
     *
     * @param {object}
     * [jobScheduleUpdateParameter.jobSpecification.jobManagerTask.userIdentity]
     * The user identity under which the Job Manager task runs. If omitted, the
     * task runs as a non-administrative user unique to the task.
     *
     * @param {boolean}
     * [jobScheduleUpdateParameter.jobSpecification.jobManagerTask.runExclusive]
     * Whether the Job Manager task requires exclusive use of the compute node
     * where it runs. If true, no other tasks will run on the same compute node for
     * as long as the Job Manager is running. If false, other tasks can run
     * simultaneously with the Job Manager on a compute node. The Job Manager task
     * counts normally against the node's concurrent task limit, so this is only
     * relevant if the node allows multiple concurrent tasks. The default value is
     * true.
     *
     * @param {array}
     * [jobScheduleUpdateParameter.jobSpecification.jobManagerTask.applicationPackageReferences]
     * A list of application packages that the Batch service will deploy to the
     * compute node before running the command line. Application packages are
     * downloaded and deployed to a shared directory, not the task working
     * directory. Therefore, if a referenced package is already on the compute
     * node, and is up to date, then it is not re-downloaded; the existing copy on
     * the compute node is used. If a referenced application package cannot be
     * installed, for example because the package has been deleted or because
     * download failed, the task fails.
     *
     * @param {object}
     * [jobScheduleUpdateParameter.jobSpecification.jobManagerTask.authenticationTokenSettings]
     * The settings for an authentication token that the task can use to perform
     * Batch service operations. If this property is set, the Batch service
     * provides the task with an authentication token which can be used to
     * authenticate Batch service operations without requiring an account access
     * key. The token is provided via the AZ_BATCH_AUTHENTICATION_TOKEN environment
     * variable. The operations that the task can carry out using the token depend
     * on the settings. For example, a task can request job permissions in order to
     * add other tasks to the job, or check the status of the job or of other tasks
     * under the job.
     *
     * @param {array}
     * [jobScheduleUpdateParameter.jobSpecification.jobManagerTask.authenticationTokenSettings.access]
     * The Batch resources to which the token grants access. The authentication
     * token grants access to a limited set of Batch service operations. Currently
     * the only supported value for the access property is 'job', which grants
     * access to all operations related to the job which contains the task.
     *
     * @param {boolean}
     * [jobScheduleUpdateParameter.jobSpecification.jobManagerTask.allowLowPriorityNode]
     * Whether the Job Manager task may run on a low-priority compute node. The
     * default value is false.
     *
     * @param {object}
     * [jobScheduleUpdateParameter.jobSpecification.jobPreparationTask] The Job
     * Preparation task for jobs created under this schedule. If a job has a Job
     * Preparation task, the Batch service will run the Job Preparation task on a
     * compute node before starting any tasks of that job on that compute node.
     *
     * @param {string}
     * [jobScheduleUpdateParameter.jobSpecification.jobPreparationTask.id] A string
     * that uniquely identifies the Job Preparation task within the job. The ID can
     * contain any combination of alphanumeric characters including hyphens and
     * underscores and cannot contain more than 64 characters. If you do not
     * specify this property, the Batch service assigns a default value of
     * 'jobpreparation'. No other task in the job can have the same ID as the Job
     * Preparation task. If you try to submit a task with the same id, the Batch
     * service rejects the request with error code TaskIdSameAsJobPreparationTask;
     * if you are calling the REST API directly, the HTTP status code is 409
     * (Conflict).
     *
     * @param {string}
     * jobScheduleUpdateParameter.jobSpecification.jobPreparationTask.commandLine
     * The command line of the Job Preparation task. The command line does not run
     * under a shell, and therefore cannot take advantage of shell features such as
     * environment variable expansion. If you want to take advantage of such
     * features, you should invoke the shell in the command line, for example using
     * "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux.
     *
     * @param {array}
     * [jobScheduleUpdateParameter.jobSpecification.jobPreparationTask.resourceFiles]
     * A list of files that the Batch service will download to the compute node
     * before running the command line. Files listed under this element are located
     * in the task's working directory.
     *
     * @param {array}
     * [jobScheduleUpdateParameter.jobSpecification.jobPreparationTask.environmentSettings]
     * A list of environment variable settings for the Job Preparation task.
     *
     * @param {object}
     * [jobScheduleUpdateParameter.jobSpecification.jobPreparationTask.constraints]
     * Constraints that apply to the Job Preparation task.
     *
     * @param {moment.duration}
     * [jobScheduleUpdateParameter.jobSpecification.jobPreparationTask.constraints.maxWallClockTime]
     * The maximum elapsed time that the task may run, measured from the time the
     * task starts. If the task does not complete within the time limit, the Batch
     * service terminates it. If this is not specified, there is no time limit on
     * how long the task may run.
     *
     * @param {moment.duration}
     * [jobScheduleUpdateParameter.jobSpecification.jobPreparationTask.constraints.retentionTime]
     * The minimum time to retain the task directory on the compute node where it
     * ran, from the time it completes execution. After this time, the Batch
     * service may delete the task directory and all its contents. The default is
     * infinite, i.e. the task directory will be retained until the compute node is
     * removed or reimaged.
     *
     * @param {number}
     * [jobScheduleUpdateParameter.jobSpecification.jobPreparationTask.constraints.maxTaskRetryCount]
     * The maximum number of times the task may be retried. The Batch service
     * retries a task if its exit code is nonzero. Note that this value
     * specifically controls the number of retries. The Batch service will try the
     * task once, and may then retry up to this limit. For example, if the maximum
     * retry count is 3, Batch tries the task up to 4 times (one initial try and 3
     * retries). If the maximum retry count is 0, the Batch service does not retry
     * the task. If the maximum retry count is -1, the Batch service retries the
     * task without limit.
     *
     * @param {boolean}
     * [jobScheduleUpdateParameter.jobSpecification.jobPreparationTask.waitForSuccess]
     * Whether the Batch service should wait for the Job Preparation task to
     * complete successfully before scheduling any other tasks of the job on the
     * compute node. A Job Preparation task has completed successfully if it exits
     * with exit code 0. If true and the Job Preparation task fails on a compute
     * node, the Batch service retries the Job Preparation task up to its maximum
     * retry count (as specified in the constraints element). If the task has still
     * not completed successfully after all retries, then the Batch service will
     * not schedule tasks of the job to the compute node. The compute node remains
     * active and eligible to run tasks of other jobs. If false, the Batch service
     * will not wait for the Job Preparation task to complete. In this case, other
     * tasks of the job can start executing on the compute node while the Job
     * Preparation task is still running; and even if the Job Preparation task
     * fails, new tasks will continue to be scheduled on the node. The default
     * value is true.
     *
     * @param {object}
     * [jobScheduleUpdateParameter.jobSpecification.jobPreparationTask.userIdentity]
     * The user identity under which the Job Preparation task runs. If omitted, the
     * task runs as a non-administrative user unique to the task on Windows nodes,
     * or a a non-administrative user unique to the pool on Linux nodes.
     *
     * @param {boolean}
     * [jobScheduleUpdateParameter.jobSpecification.jobPreparationTask.rerunOnNodeRebootAfterSuccess]
     * Whether the Batch service should rerun the Job Preparation task after a
     * compute node reboots. The Job Preparation task is always rerun if a compute
     * node is reimaged, or if the Job Preparation task did not complete (e.g.
     * because the reboot occurred while the task was running). Therefore, you
     * should always write a Job Preparation task to be idempotent and to behave
     * correctly if run multiple times. The default value is true.
     *
     * @param {object} [jobScheduleUpdateParameter.jobSpecification.jobReleaseTask]
     * The Job Release task for jobs created under this schedule. The primary
     * purpose of the Job Release task is to undo changes to compute nodes made by
     * the Job Preparation task. Example activities include deleting local files,
     * or shutting down services that were started as part of job preparation. A
     * Job Release task cannot be specified without also specifying a Job
     * Preparation task for the job. The Batch service runs the Job Release task on
     * the compute nodes that have run the Job Preparation task.
     *
     * @param {string}
     * [jobScheduleUpdateParameter.jobSpecification.jobReleaseTask.id] A string
     * that uniquely identifies the Job Release task within the job. The ID can
     * contain any combination of alphanumeric characters including hyphens and
     * underscores and cannot contain more than 64 characters. If you do not
     * specify this property, the Batch service assigns a default value of
     * 'jobrelease'. No other task in the job can have the same ID as the Job
     * Release task. If you try to submit a task with the same id, the Batch
     * service rejects the request with error code TaskIdSameAsJobReleaseTask; if
     * you are calling the REST API directly, the HTTP status code is 409
     * (Conflict).
     *
     * @param {string}
     * jobScheduleUpdateParameter.jobSpecification.jobReleaseTask.commandLine The
     * command line of the Job Release task. The command line does not run under a
     * shell, and therefore cannot take advantage of shell features such as
     * environment variable expansion. If you want to take advantage of such
     * features, you should invoke the shell in the command line, for example using
     * "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux.
     *
     * @param {array}
     * [jobScheduleUpdateParameter.jobSpecification.jobReleaseTask.resourceFiles] A
     * list of files that the Batch service will download to the compute node
     * before running the command line. Files listed under this element are located
     * in the task's working directory.
     *
     * @param {array}
     * [jobScheduleUpdateParameter.jobSpecification.jobReleaseTask.environmentSettings]
     * A list of environment variable settings for the Job Release task.
     *
     * @param {moment.duration}
     * [jobScheduleUpdateParameter.jobSpecification.jobReleaseTask.maxWallClockTime]
     * The maximum elapsed time that the Job Release task may run on a given
     * compute node, measured from the time the task starts. If the task does not
     * complete within the time limit, the Batch service terminates it. The default
     * value is 15 minutes. You may not specify a timeout longer than 15 minutes.
     * If you do, the Batch service rejects it with an error; if you are calling
     * the REST API directly, the HTTP status code is 400 (Bad Request).
     *
     * @param {moment.duration}
     * [jobScheduleUpdateParameter.jobSpecification.jobReleaseTask.retentionTime]
     * The minimum time to retain the task directory for the Job Release task on
     * the compute node. After this time, the Batch service may delete the task
     * directory and all its contents. The default is infinite, i.e. the task
     * directory will be retained until the compute node is removed or reimaged.
     *
     * @param {object}
     * [jobScheduleUpdateParameter.jobSpecification.jobReleaseTask.userIdentity]
     * The user identity under which the Job Release task runs. If omitted, the
     * task runs as a non-administrative user unique to the task.
     *
     * @param {array}
     * [jobScheduleUpdateParameter.jobSpecification.commonEnvironmentSettings] A
     * list of common environment variable settings. These environment variables
     * are set for all tasks in jobs created under this schedule (including the Job
     * Manager, Job Preparation and Job Release tasks). Individual tasks can
     * override an environment setting specified here by specifying the same
     * setting name with a different value.
     *
     * @param {object} jobScheduleUpdateParameter.jobSpecification.poolInfo The
     * pool on which the Batch service runs the tasks of jobs created under this
     * schedule.
     *
     * @param {string}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.poolId] The ID of an
     * existing pool. All the tasks of the job will run on the specified pool. You
     * must ensure that the pool referenced by this property exists. If the pool
     * does not exist at the time the Batch service tries to schedule a job, no
     * tasks for the job will run until you create a pool with that id. Note that
     * the Batch service will not reject the job request; it will simply not run
     * tasks until the pool exists. You must specify either the pool ID or the auto
     * pool specification, but not both.
     *
     * @param {object}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification]
     * Characteristics for a temporary 'auto pool'. The Batch service will create
     * this auto pool when the job is submitted. If auto pool creation fails, the
     * Batch service moves the job to a completed state, and the pool creation
     * error is set in the job's scheduling error property. The Batch service
     * manages the lifetime (both creation and, unless keepAlive is specified,
     * deletion) of the auto pool. Any user actions that affect the lifetime of the
     * auto pool while the job is active will result in unexpected behavior. You
     * must specify either the pool ID or the auto pool specification, but not
     * both.
     *
     * @param {string}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.autoPoolIdPrefix]
     * A prefix to be added to the unique identifier when a pool is automatically
     * created. The Batch service assigns each auto pool a unique identifier on
     * creation. To distinguish between pools created for different purposes, you
     * can specify this element to add a prefix to the ID that is assigned. The
     * prefix can be up to 20 characters long.
     *
     * @param {string}
     * jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.poolLifetimeOption
     * The minimum lifetime of created auto pools, and how multiple jobs on a
     * schedule are assigned to pools. When the pool lifetime is jobSchedule the
     * pool exists for the lifetime of the job schedule. The Batch Service creates
     * the pool when it creates the first job on the schedule. You may apply this
     * option only to job schedules, not to jobs. When the pool lifetime is job the
     * pool exists for the lifetime of the job to which it is dedicated. The Batch
     * service creates the pool when it creates the job. If the 'job' option is
     * applied to a job schedule, the Batch service creates a new auto pool for
     * every job created on the schedule. Possible values include: 'jobSchedule',
     * 'job'
     *
     * @param {boolean}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.keepAlive]
     * Whether to keep an auto pool alive after its lifetime expires. If false, the
     * Batch service deletes the pool once its lifetime (as determined by the
     * poolLifetimeOption setting) expires; that is, when the job or job schedule
     * completes. If true, the Batch service does not delete the pool
     * automatically. It is up to the user to delete auto pools created with this
     * option.
     *
     * @param {object}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool]
     * The pool specification for the auto pool.
     *
     * @param {string}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.displayName]
     * The display name for the pool. The display name need not be unique and can
     * contain any Unicode characters up to a maximum length of 1024.
     *
     * @param {string}
     * jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.vmSize
     * The size of the virtual machines in the pool. All virtual machines in a pool
     * are the same size. For information about available sizes of virtual machines
     * for Cloud Services pools (pools created with cloudServiceConfiguration), see
     * Sizes for Cloud Services
     * (http://azure.microsoft.com/documentation/articles/cloud-services-sizes-specs/).
     * Batch supports all Cloud Services VM sizes except ExtraSmall, A1V2 and A2V2.
     * For information about available VM sizes for pools using images from the
     * Virtual Machines Marketplace (pools created with
     * virtualMachineConfiguration) see Sizes for Virtual Machines (Linux)
     * (https://azure.microsoft.com/documentation/articles/virtual-machines-linux-sizes/)
     * or Sizes for Virtual Machines (Windows)
     * (https://azure.microsoft.com/documentation/articles/virtual-machines-windows-sizes/).
     * Batch supports all Azure VM sizes except STANDARD_A0 and those with premium
     * storage (STANDARD_GS, STANDARD_DS, and STANDARD_DSV2 series).
     *
     * @param {object}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration]
     * The cloud service configuration for the pool. This property must be
     * specified if the pool needs to be created with Azure PaaS VMs. This property
     * and virtualMachineConfiguration are mutually exclusive and one of the
     * properties must be specified. If neither is specified then the Batch service
     * returns an error; if you are calling the REST API directly, the HTTP status
     * code is 400 (Bad Request). This property cannot be specified if the Batch
     * account was created with its poolAllocationMode property set to
     * 'UserSubscription'.
     *
     * @param {string}
     * jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.osFamily
     * The Azure Guest OS family to be installed on the virtual machines in the
     * pool. Possible values are: 2 - OS Family 2, equivalent to Windows Server
     * 2008 R2 SP1. 3 - OS Family 3, equivalent to Windows Server 2012. 4 - OS
     * Family 4, equivalent to Windows Server 2012 R2. 5 - OS Family 5, equivalent
     * to Windows Server 2016. For more information, see Azure Guest OS Releases
     * (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
     *
     * @param {string}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.targetOSVersion]
     * The Azure Guest OS version to be installed on the virtual machines in the
     * pool. The default value is * which specifies the latest operating system
     * version for the specified OS family.
     *
     * @param {string}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.currentOSVersion]
     * The Azure Guest OS Version currently installed on the virtual machines in
     * the pool. This may differ from targetOSVersion if the pool state is
     * Upgrading. In this case some virtual machines may be on the targetOSVersion
     * and some may be on the currentOSVersion during the upgrade process. Once all
     * virtual machines have upgraded, currentOSVersion is updated to be the same
     * as targetOSVersion.
     *
     * @param {object}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration]
     * The virtual machine configuration for the pool. This property must be
     * specified if the pool needs to be created with Azure IaaS VMs. This property
     * and cloudServiceConfiguration are mutually exclusive and one of the
     * properties must be specified. If neither is specified then the Batch service
     * returns an error; if you are calling the REST API directly, the HTTP status
     * code is 400 (Bad Request).
     *
     * @param {object}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference]
     * A reference to the Azure Virtual Machines Marketplace image to use. This
     * property and osDisk are mutually exclusive and one of the properties must be
     * specified.
     *
     * @param {string}
     * jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.publisher
     * The publisher of the Azure Virtual Machines Marketplace image. For example,
     * Canonical or MicrosoftWindowsServer.
     *
     * @param {string}
     * jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.offer
     * The offer type of the Azure Virtual Machines Marketplace image. For example,
     * UbuntuServer or WindowsServer.
     *
     * @param {string}
     * jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.sku
     * The SKU of the Azure Virtual Machines Marketplace image. For example,
     * 14.04.0-LTS or 2012-R2-Datacenter.
     *
     * @param {string}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.version]
     * The version of the Azure Virtual Machines Marketplace image. A value of
     * 'latest' can be specified to select the latest version of an image. If
     * omitted, the default is 'latest'.
     *
     * @param {object}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.osDisk]
     * A reference to the OS disk image to use. This property can be specified only
     * if the Batch account was created with its poolAllocationMode property set to
     * 'UserSubscription'. This property and imageReference are mutually exclusive
     * and one of the properties must be specified.
     *
     * @param {array}
     * jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.osDisk.imageUris
     * The collection of Virtual Hard Disk (VHD) URIs. All the VHDs must be
     * identical and must reside in an Azure Storage account within the same
     * subscription and same region as the Batch account. For best performance, it
     * is recommended that each VHD resides in a separate Azure Storage account.
     * Each VHD can serve upto 20 Windows compute nodes or 40 Linux compute nodes.
     * You must supply enough VHD URIs to satisfy the 'targetDedicated' property of
     * the pool. If you do not supply enough VHD URIs, the pool will partially
     * allocate compute nodes, and a resize error will occur.
     *
     * @param {string}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.osDisk.caching]
     * The type of caching to enable for the OS disk. Values are:
     *
     * none - The caching mode for the disk is not enabled.
     * readOnly - The caching mode for the disk is read only.
     * readWrite - The caching mode for the disk is read and write.
     *
     * The default value for caching is none. For information about the caching
     * options see:
     * https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/27/exploring-windows-azure-drives-disks-and-images/.
     * Possible values include: 'none', 'readOnly', 'readWrite'
     *
     * @param {string}
     * jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.nodeAgentSKUId
     * The SKU of the Batch node agent to be provisioned on compute nodes in the
     * pool. The Batch node agent is a program that runs on each node in the pool,
     * and provides the command-and-control interface between the node and the
     * Batch service. There are different implementations of the node agent, known
     * as SKUs, for different operating systems. You must specify a node agent SKU
     * which matches the selected image reference. To get the list of supported
     * node agent SKUs along with their list of verified image references, see the
     * 'List supported node agent SKUs' operation.
     *
     * @param {object}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration]
     * Windows operating system settings on the virtual machine. This property must
     * not be specified if the imageReference or osDisk property specifies a Linux
     * OS image.
     *
     * @param {boolean}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration.enableAutomaticUpdates]
     * Whether automatic updates are enabled on the virtual machine. If omitted,
     * the default value is true.
     *
     * @param {number}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.maxTasksPerNode]
     * The maximum number of tasks that can run concurrently on a single compute
     * node in the pool. The default value is 1. The maximum value of this setting
     * depends on the size of the compute nodes in the pool (the vmSize setting).
     *
     * @param {object}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy]
     * How tasks are distributed across compute nodes in a pool.
     *
     * @param {string}
     * jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy.nodeFillType
     * How tasks are distributed across compute nodes in a pool. Values are:
     *
     * pack - As many tasks as possible (maxTasksPerNode) should be assigned to
     * each node in the pool before any tasks are assigned to the next node in the
     * pool.
     * spread - Tasks should be assigned evenly across all nodes in the pool.
     * Possible values include: 'spread', 'pack'
     *
     * @param {moment.duration}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.resizeTimeout]
     * The timeout for allocation of compute nodes to the pool. This timeout
     * applies only to manual scaling; it has no effect when enableAutoScale is set
     * to true. The default value is 15 minutes. The minimum value is 5 minutes. If
     * you specify a value less than 5 minutes, the Batch service rejects the
     * request with an error; if you are calling the REST API directly, the HTTP
     * status code is 400 (Bad Request).
     *
     * @param {number}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.targetDedicatedNodes]
     * The desired number of dedicated compute nodes in the pool. This property
     * must not be specified if enableAutoScale is set to true. If enableAutoScale
     * is set to false, then you must set either targetDedicatedNodes,
     * targetLowPriorityNodes, or both.
     *
     * @param {number}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.targetLowPriorityNodes]
     * The desired number of low-priority compute nodes in the pool. This property
     * must not be specified if enableAutoScale is set to true. If enableAutoScale
     * is set to false, then you must set either targetDedicatedNodes,
     * targetLowPriorityNodes, or both.
     *
     * @param {boolean}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.enableAutoScale]
     * Whether the pool size should automatically adjust over time. If false, at
     * least one of targetDedicateNodes and targetLowPriorityNodes must be
     * specified. If true, the autoScaleFormula element is required. The pool
     * automatically resizes according to the formula. The default value is false.
     *
     * @param {string}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.autoScaleFormula]
     * The formula for the desired number of compute nodes in the pool. This
     * property must not be specified if enableAutoScale is set to false. It is
     * required if enableAutoScale is set to true. The formula is checked for
     * validity before the pool is created. If the formula is not valid, the Batch
     * service rejects the request with detailed error information.
     *
     * @param {moment.duration}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.autoScaleEvaluationInterval]
     * The time interval at which to automatically adjust the pool size according
     * to the autoscale formula. The default value is 15 minutes. The minimum and
     * maximum value are 5 minutes and 168 hours respectively. If you specify a
     * value less than 5 minutes or greater than 168 hours, the Batch service
     * rejects the request with an invalid property value error; if you are calling
     * the REST API directly, the HTTP status code is 400 (Bad Request).
     *
     * @param {boolean}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.enableInterNodeCommunication]
     * Whether the pool permits direct communication between nodes. Enabling
     * inter-node communication limits the maximum size of the pool due to
     * deployment restrictions on the nodes of the pool. This may result in the
     * pool not reaching its desired size. The default value is false.
     *
     * @param {object}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.networkConfiguration]
     * The network configuration for the pool.
     *
     * @param {string}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.networkConfiguration.subnetId]
     * The ARM resource identifier of the virtual network subnet which the compute
     * nodes of the pool will join. This is of the form
     * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
     * The virtual network must be in the same region and subscription as the Azure
     * Batch account. The specified subnet should have enough free IP addresses to
     * accommodate the number of nodes in the pool. If the subnet doesn't have
     * enough free IP addresses, the pool will partially allocate compute nodes,
     * and a resize error will occur. The 'MicrosoftAzureBatch' service principal
     * must have the 'Classic Virtual Machine Contributor' Role-Based Access
     * Control (RBAC) role for the specified VNet. The specified subnet must allow
     * communication from the Azure Batch service to be able to schedule tasks on
     * the compute nodes. This can be verified by checking if the specified VNet
     * has any associated Network Security Groups (NSG). If communication to the
     * compute nodes in the specified subnet is denied by an NSG, then the Batch
     * service will set the state of the compute nodes to unusable. For pools
     * created via virtualMachineConfiguration the Batch account must have
     * poolAllocationMode userSubscription in order to use a VNet. If the specified
     * VNet has any associated Network Security Groups (NSG), then a few reserved
     * system ports must be enabled for inbound communication. For pools created
     * with a virtual machine configuration, enable ports 29876 and 29877, as well
     * as port 22 for Linux and port 3389 for Windows. For pools created with a
     * cloud service configuration, enable ports 10100, 20100, and 30100. Also
     * enable outbound connections to Azure Storage on port 443. For more details
     * see:
     * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration
     *
     * @param {object}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration]
     * The configuration for endpoints on compute nodes in the Batch pool. Pool
     * endpoint configuration is only supported on pools with the
     * virtualMachineConfiguration property.
     *
     * @param {array}
     * jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration.inboundNATPools
     * A list of inbound NAT pools that can be used to address specific ports on an
     * individual compute node externally. The maximum number of inbound NAT pools
     * per Batch pool is 5. If the maximum number of inbound NAT pools is exceeded
     * the request fails with HTTP status code 400.
     *
     * @param {object}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask]
     * A task to run on each compute node as it joins the pool. The task runs when
     * the node is added to the pool or when the node is restarted.
     *
     * @param {string}
     * jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.commandLine
     * The command line of the start task. The command line does not run under a
     * shell, and therefore cannot take advantage of shell features such as
     * environment variable expansion. If you want to take advantage of such
     * features, you should invoke the shell in the command line, for example using
     * "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux.
     *
     * @param {array}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.resourceFiles]
     * A list of files that the Batch service will download to the compute node
     * before running the command line. Files listed under this element are located
     * in the task's working directory.
     *
     * @param {array}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.environmentSettings]
     * A list of environment variable settings for the start task.
     *
     * @param {object}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.userIdentity]
     * The user identity under which the start task runs. If omitted, the task runs
     * as a non-administrative user unique to the task.
     *
     * @param {string}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.userName]
     * The name of the user identity under which the task is run. The userName and
     * autoUser properties are mutually exclusive; you must specify one but not
     * both.
     *
     * @param {object}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser]
     * The auto user under which the task is run. The userName and autoUser
     * properties are mutually exclusive; you must specify one but not both.
     *
     * @param {string}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.scope]
     * The scope for the auto user Values are:
     *
     * pool - specifies that the task runs as the common auto user account which is
     * created on every node in a pool.
     * task - specifies that the service should create a new user for the task.
     * The default value is task. Possible values include: 'task', 'pool'
     *
     * @param {string}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.elevationLevel]
     * The elevation level of the auto user. nonAdmin - The auto user is a standard
     * user without elevated access. admin - The auto user is a user with elevated
     * access and operates with full Administrator permissions. The default value
     * is nonAdmin. Possible values include: 'nonAdmin', 'admin'
     *
     * @param {number}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.maxTaskRetryCount]
     * The maximum number of times the task may be retried. The Batch service
     * retries a task if its exit code is nonzero. Note that this value
     * specifically controls the number of retries. The Batch service will try the
     * task once, and may then retry up to this limit. For example, if the maximum
     * retry count is 3, Batch tries the task up to 4 times (one initial try and 3
     * retries). If the maximum retry count is 0, the Batch service does not retry
     * the task. If the maximum retry count is -1, the Batch service retries the
     * task without limit.
     *
     * @param {boolean}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.waitForSuccess]
     * Whether the Batch service should wait for the start task to complete
     * successfully (that is, to exit with exit code 0) before scheduling any tasks
     * on the compute node. If true and the start task fails on a compute node, the
     * Batch service retries the start task up to its maximum retry count
     * (maxTaskRetryCount). If the task has still not completed successfully after
     * all retries, then the Batch service marks the compute node unusable, and
     * will not schedule tasks to it. This condition can be detected via the node
     * state and failure info details. If false, the Batch service will not wait
     * for the start task to complete. In this case, other tasks can start
     * executing on the compute node while the start task is still running; and
     * even if the start task fails, new tasks will continue to be scheduled on the
     * node. The default is false.
     *
     * @param {array}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.certificateReferences]
     * A list of certificates to be installed on each compute node in the pool. For
     * Windows compute nodes, the Batch service installs the certificates to the
     * specified certificate store and location. For Linux compute nodes, the
     * certificates are stored in a directory inside the task working directory and
     * an environment variable AZ_BATCH_CERTIFICATES_DIR is supplied to the task to
     * query for this location. For certificates with visibility of 'remoteUser', a
     * 'certs' directory is created in the user's home directory (e.g.,
     * /home/{user-name}/certs) and certificates are placed in that directory.
     *
     * @param {array}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.applicationPackageReferences]
     * The list of application packages to be installed on each compute node in the
     * pool.
     *
     * @param {array}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.applicationLicenses]
     * The list of application licenses the Batch service will make available on
     * each compute node in the pool. The list of application licenses must be a
     * subset of available Batch service application licenses. If a license is
     * requested which is not supported, pool creation will fail.
     *
     * @param {array}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.userAccounts]
     * The list of user accounts to be created on each node in the pool.
     *
     * @param {array}
     * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.metadata]
     * A list of name-value pairs associated with the pool as metadata. The Batch
     * service does not assign any meaning to metadata; it is solely for the use of
     * user code.
     *
     * @param {array} [jobScheduleUpdateParameter.jobSpecification.metadata] A list
     * of name-value pairs associated with each job created under this schedule as
     * metadata. The Batch service does not assign any meaning to metadata; it is
     * solely for the use of user code.
     *
     * @param {array} [jobScheduleUpdateParameter.metadata] A list of name-value
     * pairs associated with the job schedule as metadata. If you do not specify
     * this element, it takes the default value of an empty list; in effect, any
     * existing metadata is deleted.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.jobScheduleUpdateOptions] Additional parameters for
     * the operation
     *
     * @param {number} [options.jobScheduleUpdateOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.jobScheduleUpdateOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.jobScheduleUpdateOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.jobScheduleUpdateOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {string} [options.jobScheduleUpdateOptions.ifMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.
     *
     * @param {string} [options.jobScheduleUpdateOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.jobScheduleUpdateOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.jobScheduleUpdateOptions.ifUnmodifiedSince] A
     * timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service
     * has not been modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updateWithHttpOperationResponse(jobScheduleId, jobScheduleUpdateParameter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleUpdateOptions = (options && options.jobScheduleUpdateOptions !== undefined) ? options.jobScheduleUpdateOptions : undefined;
            // Validate
            try {
                if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
                    throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
                }
                if (jobScheduleUpdateParameter === null || jobScheduleUpdateParameter === undefined) {
                    throw new Error('jobScheduleUpdateParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined) {
                    timeout = jobScheduleUpdateOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined) {
                    clientRequestId = jobScheduleUpdateOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined) {
                    returnClientRequestId = jobScheduleUpdateOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined) {
                    ocpDate = jobScheduleUpdateOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined) {
                    ifMatch = jobScheduleUpdateOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined) {
                    ifNoneMatch = jobScheduleUpdateOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined) {
                    ifModifiedSince = jobScheduleUpdateOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined) {
                    ifUnmodifiedSince = jobScheduleUpdateOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobschedules/{jobScheduleId}';
            requestUrl = requestUrl.replace('{jobScheduleId}', encodeURIComponent(jobScheduleId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'PUT';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (jobScheduleUpdateParameter !== null && jobScheduleUpdateParameter !== undefined) {
                    let requestModelMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["JobScheduleUpdateParameter"];
                    requestModel = client.serializer.serialize(requestModelMapper, jobScheduleUpdateParameter, 'jobScheduleUpdateParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(jobScheduleUpdateParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Disables a job schedule.
     *
     * No new jobs will be created until the job schedule is enabled again.
     *
     * @param {string} jobScheduleId The ID of the job schedule to disable.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.jobScheduleDisableOptions] Additional parameters
     * for the operation
     *
     * @param {number} [options.jobScheduleDisableOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.jobScheduleDisableOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.jobScheduleDisableOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.jobScheduleDisableOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {string} [options.jobScheduleDisableOptions.ifMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.
     *
     * @param {string} [options.jobScheduleDisableOptions.ifNoneMatch] An ETag
     * value associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.jobScheduleDisableOptions.ifModifiedSince] A
     * timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service
     * has been modified since the specified time.
     *
     * @param {date} [options.jobScheduleDisableOptions.ifUnmodifiedSince] A
     * timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service
     * has not been modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    disableWithHttpOperationResponse(jobScheduleId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleDisableOptions = (options && options.jobScheduleDisableOptions !== undefined) ? options.jobScheduleDisableOptions : undefined;
            // Validate
            try {
                if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
                    throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined) {
                    timeout = jobScheduleDisableOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined) {
                    clientRequestId = jobScheduleDisableOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined) {
                    returnClientRequestId = jobScheduleDisableOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined) {
                    ocpDate = jobScheduleDisableOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined) {
                    ifMatch = jobScheduleDisableOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined) {
                    ifNoneMatch = jobScheduleDisableOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined) {
                    ifModifiedSince = jobScheduleDisableOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined) {
                    ifUnmodifiedSince = jobScheduleDisableOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobschedules/{jobScheduleId}/disable';
            requestUrl = requestUrl.replace('{jobScheduleId}', encodeURIComponent(jobScheduleId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 204) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Enables a job schedule.
     *
     * @param {string} jobScheduleId The ID of the job schedule to enable.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.jobScheduleEnableOptions] Additional parameters for
     * the operation
     *
     * @param {number} [options.jobScheduleEnableOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.jobScheduleEnableOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.jobScheduleEnableOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.jobScheduleEnableOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {string} [options.jobScheduleEnableOptions.ifMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.
     *
     * @param {string} [options.jobScheduleEnableOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.jobScheduleEnableOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.jobScheduleEnableOptions.ifUnmodifiedSince] A
     * timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service
     * has not been modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    enableWithHttpOperationResponse(jobScheduleId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleEnableOptions = (options && options.jobScheduleEnableOptions !== undefined) ? options.jobScheduleEnableOptions : undefined;
            // Validate
            try {
                if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
                    throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined) {
                    timeout = jobScheduleEnableOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined) {
                    clientRequestId = jobScheduleEnableOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined) {
                    returnClientRequestId = jobScheduleEnableOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined) {
                    ocpDate = jobScheduleEnableOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined) {
                    ifMatch = jobScheduleEnableOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined) {
                    ifNoneMatch = jobScheduleEnableOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined) {
                    ifModifiedSince = jobScheduleEnableOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined) {
                    ifUnmodifiedSince = jobScheduleEnableOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobschedules/{jobScheduleId}/enable';
            requestUrl = requestUrl.replace('{jobScheduleId}', encodeURIComponent(jobScheduleId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 204) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Terminates a job schedule.
     *
     * @param {string} jobScheduleId The ID of the job schedule to terminates.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.jobScheduleTerminateOptions] Additional parameters
     * for the operation
     *
     * @param {number} [options.jobScheduleTerminateOptions.timeout] The maximum
     * time that the server can spend processing the request, in seconds. The
     * default is 30 seconds.
     *
     * @param {string} [options.jobScheduleTerminateOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.jobScheduleTerminateOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.jobScheduleTerminateOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {string} [options.jobScheduleTerminateOptions.ifMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.
     *
     * @param {string} [options.jobScheduleTerminateOptions.ifNoneMatch] An ETag
     * value associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.jobScheduleTerminateOptions.ifModifiedSince] A
     * timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service
     * has been modified since the specified time.
     *
     * @param {date} [options.jobScheduleTerminateOptions.ifUnmodifiedSince] A
     * timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service
     * has not been modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    terminateWithHttpOperationResponse(jobScheduleId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleTerminateOptions = (options && options.jobScheduleTerminateOptions !== undefined) ? options.jobScheduleTerminateOptions : undefined;
            // Validate
            try {
                if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
                    throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined) {
                    timeout = jobScheduleTerminateOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined) {
                    clientRequestId = jobScheduleTerminateOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined) {
                    returnClientRequestId = jobScheduleTerminateOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined) {
                    ocpDate = jobScheduleTerminateOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined) {
                    ifMatch = jobScheduleTerminateOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined) {
                    ifNoneMatch = jobScheduleTerminateOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined) {
                    ifModifiedSince = jobScheduleTerminateOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined) {
                    ifUnmodifiedSince = jobScheduleTerminateOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobschedules/{jobScheduleId}/terminate';
            requestUrl = requestUrl.replace('{jobScheduleId}', encodeURIComponent(jobScheduleId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Adds a job schedule to the specified account.
     *
     * @param {object} cloudJobSchedule The job schedule to be added.
     *
     * @param {string} cloudJobSchedule.id A string that uniquely identifies the
     * schedule within the account. The ID can contain any combination of
     * alphanumeric characters including hyphens and underscores, and cannot
     * contain more than 64 characters. The ID is case-preserving and
     * case-insensitive (that is, you may not have two IDs within an account that
     * differ only by case).
     *
     * @param {string} [cloudJobSchedule.displayName] The display name for the
     * schedule. The display name need not be unique and can contain any Unicode
     * characters up to a maximum length of 1024.
     *
     * @param {object} cloudJobSchedule.schedule The schedule according to which
     * jobs will be created.
     *
     * @param {date} [cloudJobSchedule.schedule.doNotRunUntil] The earliest time at
     * which any job may be created under this job schedule. If you do not specify
     * a doNotRunUntil time, the schedule becomes ready to create jobs immediately.
     *
     * @param {date} [cloudJobSchedule.schedule.doNotRunAfter] A time after which
     * no job will be created under this job schedule. The schedule will move to
     * the completed state as soon as this deadline is past and there is no active
     * job under this job schedule. If you do not specify a doNotRunAfter time, and
     * you are creating a recurring job schedule, the job schedule will remain
     * active until you explicitly terminate it.
     *
     * @param {moment.duration} [cloudJobSchedule.schedule.startWindow] The time
     * interval, starting from the time at which the schedule indicates a job
     * should be created, within which a job must be created. If a job is not
     * created within the startWindow interval, then the 'opportunity' is lost; no
     * job will be created until the next recurrence of the schedule. If the
     * schedule is recurring, and the startWindow is longer than the recurrence
     * interval, then this is equivalent to an infinite startWindow, because the
     * job that is 'due' in one recurrenceInterval is not carried forward into the
     * next recurrence interval. The default is infinite. The minimum value is 1
     * minute. If you specify a lower value, the Batch service rejects the schedule
     * with an error; if you are calling the REST API directly, the HTTP status
     * code is 400 (Bad Request).
     *
     * @param {moment.duration} [cloudJobSchedule.schedule.recurrenceInterval] The
     * time interval between the start times of two successive jobs under the job
     * schedule. A job schedule can have at most one active job under it at any
     * given time. Because a job schedule can have at most one active job under it
     * at any given time, if it is time to create a new job under a job schedule,
     * but the previous job is still running, the Batch service will not create the
     * new job until the previous job finishes. If the previous job does not finish
     * within the startWindow period of the new recurrenceInterval, then no new job
     * will be scheduled for that interval. For recurring jobs, you should normally
     * specify a jobManagerTask in the jobSpecification. If you do not use
     * jobManagerTask, you will need an external process to monitor when jobs are
     * created, add tasks to the jobs and terminate the jobs ready for the next
     * recurrence. The default is that the schedule does not recur: one job is
     * created, within the startWindow after the doNotRunUntil time, and the
     * schedule is complete as soon as that job finishes. The minimum value is 1
     * minute. If you specify a lower value, the Batch service rejects the schedule
     * with an error; if you are calling the REST API directly, the HTTP status
     * code is 400 (Bad Request).
     *
     * @param {object} cloudJobSchedule.jobSpecification The details of the jobs to
     * be created on this schedule.
     *
     * @param {number} [cloudJobSchedule.jobSpecification.priority] The priority of
     * jobs created under this schedule. Priority values can range from -1000 to
     * 1000, with -1000 being the lowest priority and 1000 being the highest
     * priority. The default value is 0. This priority is used as the default for
     * all jobs under the job schedule. You can update a job's priority after it
     * has been created using by using the update job API.
     *
     * @param {string} [cloudJobSchedule.jobSpecification.displayName] The display
     * name for jobs created under this schedule. The name need not be unique and
     * can contain any Unicode characters up to a maximum length of 1024.
     *
     * @param {boolean} [cloudJobSchedule.jobSpecification.usesTaskDependencies]
     * Whether tasks in the job can define dependencies on each other. The default
     * is false.
     *
     * @param {string} [cloudJobSchedule.jobSpecification.onAllTasksComplete] The
     * action the Batch service should take when all tasks in a job created under
     * this schedule are in the completed state. Note that if a job contains no
     * tasks, then all tasks are considered complete. This option is therefore most
     * commonly used with a Job Manager task; if you want to use automatic job
     * termination without a Job Manager, you should initially set
     * onAllTasksComplete to noAction and update the job properties to set
     * onAllTasksComplete to terminateJob once you have finished adding tasks. The
     * default is noAction. Possible values include: 'noAction', 'terminateJob'
     *
     * @param {string} [cloudJobSchedule.jobSpecification.onTaskFailure] The action
     * the Batch service should take when any task fails in a job created under
     * this schedule. A task is considered to have failed if it have failed if has
     * a failureInfo. A failureInfo is set if the task completes with a non-zero
     * exit code after exhausting its retry count, or if there was an error
     * starting the task, for example due to a resource file download error. The
     * default is noAction. Possible values include: 'noAction',
     * 'performExitOptionsJobAction'
     *
     * @param {object} [cloudJobSchedule.jobSpecification.constraints] The
     * execution constraints for jobs created under this schedule.
     *
     * @param {moment.duration}
     * [cloudJobSchedule.jobSpecification.constraints.maxWallClockTime] The maximum
     * elapsed time that the job may run, measured from the time the job is
     * created. If the job does not complete within the time limit, the Batch
     * service terminates it and any tasks that are still running. In this case,
     * the termination reason will be MaxWallClockTimeExpiry. If this property is
     * not specified, there is no time limit on how long the job may run.
     *
     * @param {number}
     * [cloudJobSchedule.jobSpecification.constraints.maxTaskRetryCount] The
     * maximum number of times each task may be retried. The Batch service retries
     * a task if its exit code is nonzero. Note that this value specifically
     * controls the number of retries. The Batch service will try each task once,
     * and may then retry up to this limit. For example, if the maximum retry count
     * is 3, Batch tries a task up to 4 times (one initial try and 3 retries). If
     * the maximum retry count is 0, the Batch service does not retry tasks. If the
     * maximum retry count is -1, the Batch service retries tasks without limit.
     * The default value is 0 (no retries).
     *
     * @param {object} [cloudJobSchedule.jobSpecification.jobManagerTask] The
     * details of a Job Manager task to be launched when a job is started under
     * this schedule. If the job does not specify a Job Manager task, the user must
     * explicitly add tasks to the job using the Task API. If the job does specify
     * a Job Manager task, the Batch service creates the Job Manager task when the
     * job is created, and will try to schedule the Job Manager task before
     * scheduling other tasks in the job.
     *
     * @param {string} cloudJobSchedule.jobSpecification.jobManagerTask.id A string
     * that uniquely identifies the Job Manager task within the job. The ID can
     * contain any combination of alphanumeric characters including hyphens and
     * underscores and cannot contain more than 64 characters.
     *
     * @param {string}
     * [cloudJobSchedule.jobSpecification.jobManagerTask.displayName] The display
     * name of the Job Manager task. It need not be unique and can contain any
     * Unicode characters up to a maximum length of 1024.
     *
     * @param {string} cloudJobSchedule.jobSpecification.jobManagerTask.commandLine
     * The command line of the Job Manager task. The command line does not run
     * under a shell, and therefore cannot take advantage of shell features such as
     * environment variable expansion. If you want to take advantage of such
     * features, you should invoke the shell in the command line, for example using
     * "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux.
     *
     * @param {array}
     * [cloudJobSchedule.jobSpecification.jobManagerTask.resourceFiles] A list of
     * files that the Batch service will download to the compute node before
     * running the command line. Files listed under this element are located in the
     * task's working directory.
     *
     * @param {array}
     * [cloudJobSchedule.jobSpecification.jobManagerTask.outputFiles] A list of
     * files that the Batch service will upload from the compute node after running
     * the command line. For multi-instance tasks, the files will only be uploaded
     * from the compute node on which the primary task is executed.
     *
     * @param {array}
     * [cloudJobSchedule.jobSpecification.jobManagerTask.environmentSettings] A
     * list of environment variable settings for the Job Manager task.
     *
     * @param {object}
     * [cloudJobSchedule.jobSpecification.jobManagerTask.constraints] Constraints
     * that apply to the Job Manager task.
     *
     * @param {boolean}
     * [cloudJobSchedule.jobSpecification.jobManagerTask.killJobOnCompletion]
     * Whether completion of the Job Manager task signifies completion of the
     * entire job. If true, when the Job Manager task completes, the Batch service
     * marks the job as complete. If any tasks are still running at this time
     * (other than Job Release), those tasks are terminated. If false, the
     * completion of the Job Manager task does not affect the job status. In this
     * case, you should either use the onAllTasksComplete attribute to terminate
     * the job, or have a client or user terminate the job explicitly. An example
     * of this is if the Job Manager creates a set of tasks but then takes no
     * further role in their execution. The default value is true. If you are using
     * the onAllTasksComplete and onTaskFailure attributes to control job lifetime,
     * and using the Job Manager task only to create the tasks for the job (not to
     * monitor progress), then it is important to set killJobOnCompletion to false.
     *
     * @param {object}
     * [cloudJobSchedule.jobSpecification.jobManagerTask.userIdentity] The user
     * identity under which the Job Manager task runs. If omitted, the task runs as
     * a non-administrative user unique to the task.
     *
     * @param {boolean}
     * [cloudJobSchedule.jobSpecification.jobManagerTask.runExclusive] Whether the
     * Job Manager task requires exclusive use of the compute node where it runs.
     * If true, no other tasks will run on the same compute node for as long as the
     * Job Manager is running. If false, other tasks can run simultaneously with
     * the Job Manager on a compute node. The Job Manager task counts normally
     * against the node's concurrent task limit, so this is only relevant if the
     * node allows multiple concurrent tasks. The default value is true.
     *
     * @param {array}
     * [cloudJobSchedule.jobSpecification.jobManagerTask.applicationPackageReferences]
     * A list of application packages that the Batch service will deploy to the
     * compute node before running the command line. Application packages are
     * downloaded and deployed to a shared directory, not the task working
     * directory. Therefore, if a referenced package is already on the compute
     * node, and is up to date, then it is not re-downloaded; the existing copy on
     * the compute node is used. If a referenced application package cannot be
     * installed, for example because the package has been deleted or because
     * download failed, the task fails.
     *
     * @param {object}
     * [cloudJobSchedule.jobSpecification.jobManagerTask.authenticationTokenSettings]
     * The settings for an authentication token that the task can use to perform
     * Batch service operations. If this property is set, the Batch service
     * provides the task with an authentication token which can be used to
     * authenticate Batch service operations without requiring an account access
     * key. The token is provided via the AZ_BATCH_AUTHENTICATION_TOKEN environment
     * variable. The operations that the task can carry out using the token depend
     * on the settings. For example, a task can request job permissions in order to
     * add other tasks to the job, or check the status of the job or of other tasks
     * under the job.
     *
     * @param {array}
     * [cloudJobSchedule.jobSpecification.jobManagerTask.authenticationTokenSettings.access]
     * The Batch resources to which the token grants access. The authentication
     * token grants access to a limited set of Batch service operations. Currently
     * the only supported value for the access property is 'job', which grants
     * access to all operations related to the job which contains the task.
     *
     * @param {boolean}
     * [cloudJobSchedule.jobSpecification.jobManagerTask.allowLowPriorityNode]
     * Whether the Job Manager task may run on a low-priority compute node. The
     * default value is false.
     *
     * @param {object} [cloudJobSchedule.jobSpecification.jobPreparationTask] The
     * Job Preparation task for jobs created under this schedule. If a job has a
     * Job Preparation task, the Batch service will run the Job Preparation task on
     * a compute node before starting any tasks of that job on that compute node.
     *
     * @param {string} [cloudJobSchedule.jobSpecification.jobPreparationTask.id] A
     * string that uniquely identifies the Job Preparation task within the job. The
     * ID can contain any combination of alphanumeric characters including hyphens
     * and underscores and cannot contain more than 64 characters. If you do not
     * specify this property, the Batch service assigns a default value of
     * 'jobpreparation'. No other task in the job can have the same ID as the Job
     * Preparation task. If you try to submit a task with the same id, the Batch
     * service rejects the request with error code TaskIdSameAsJobPreparationTask;
     * if you are calling the REST API directly, the HTTP status code is 409
     * (Conflict).
     *
     * @param {string}
     * cloudJobSchedule.jobSpecification.jobPreparationTask.commandLine The command
     * line of the Job Preparation task. The command line does not run under a
     * shell, and therefore cannot take advantage of shell features such as
     * environment variable expansion. If you want to take advantage of such
     * features, you should invoke the shell in the command line, for example using
     * "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux.
     *
     * @param {array}
     * [cloudJobSchedule.jobSpecification.jobPreparationTask.resourceFiles] A list
     * of files that the Batch service will download to the compute node before
     * running the command line. Files listed under this element are located in the
     * task's working directory.
     *
     * @param {array}
     * [cloudJobSchedule.jobSpecification.jobPreparationTask.environmentSettings] A
     * list of environment variable settings for the Job Preparation task.
     *
     * @param {object}
     * [cloudJobSchedule.jobSpecification.jobPreparationTask.constraints]
     * Constraints that apply to the Job Preparation task.
     *
     * @param {moment.duration}
     * [cloudJobSchedule.jobSpecification.jobPreparationTask.constraints.maxWallClockTime]
     * The maximum elapsed time that the task may run, measured from the time the
     * task starts. If the task does not complete within the time limit, the Batch
     * service terminates it. If this is not specified, there is no time limit on
     * how long the task may run.
     *
     * @param {moment.duration}
     * [cloudJobSchedule.jobSpecification.jobPreparationTask.constraints.retentionTime]
     * The minimum time to retain the task directory on the compute node where it
     * ran, from the time it completes execution. After this time, the Batch
     * service may delete the task directory and all its contents. The default is
     * infinite, i.e. the task directory will be retained until the compute node is
     * removed or reimaged.
     *
     * @param {number}
     * [cloudJobSchedule.jobSpecification.jobPreparationTask.constraints.maxTaskRetryCount]
     * The maximum number of times the task may be retried. The Batch service
     * retries a task if its exit code is nonzero. Note that this value
     * specifically controls the number of retries. The Batch service will try the
     * task once, and may then retry up to this limit. For example, if the maximum
     * retry count is 3, Batch tries the task up to 4 times (one initial try and 3
     * retries). If the maximum retry count is 0, the Batch service does not retry
     * the task. If the maximum retry count is -1, the Batch service retries the
     * task without limit.
     *
     * @param {boolean}
     * [cloudJobSchedule.jobSpecification.jobPreparationTask.waitForSuccess]
     * Whether the Batch service should wait for the Job Preparation task to
     * complete successfully before scheduling any other tasks of the job on the
     * compute node. A Job Preparation task has completed successfully if it exits
     * with exit code 0. If true and the Job Preparation task fails on a compute
     * node, the Batch service retries the Job Preparation task up to its maximum
     * retry count (as specified in the constraints element). If the task has still
     * not completed successfully after all retries, then the Batch service will
     * not schedule tasks of the job to the compute node. The compute node remains
     * active and eligible to run tasks of other jobs. If false, the Batch service
     * will not wait for the Job Preparation task to complete. In this case, other
     * tasks of the job can start executing on the compute node while the Job
     * Preparation task is still running; and even if the Job Preparation task
     * fails, new tasks will continue to be scheduled on the node. The default
     * value is true.
     *
     * @param {object}
     * [cloudJobSchedule.jobSpecification.jobPreparationTask.userIdentity] The user
     * identity under which the Job Preparation task runs. If omitted, the task
     * runs as a non-administrative user unique to the task on Windows nodes, or a
     * a non-administrative user unique to the pool on Linux nodes.
     *
     * @param {boolean}
     * [cloudJobSchedule.jobSpecification.jobPreparationTask.rerunOnNodeRebootAfterSuccess]
     * Whether the Batch service should rerun the Job Preparation task after a
     * compute node reboots. The Job Preparation task is always rerun if a compute
     * node is reimaged, or if the Job Preparation task did not complete (e.g.
     * because the reboot occurred while the task was running). Therefore, you
     * should always write a Job Preparation task to be idempotent and to behave
     * correctly if run multiple times. The default value is true.
     *
     * @param {object} [cloudJobSchedule.jobSpecification.jobReleaseTask] The Job
     * Release task for jobs created under this schedule. The primary purpose of
     * the Job Release task is to undo changes to compute nodes made by the Job
     * Preparation task. Example activities include deleting local files, or
     * shutting down services that were started as part of job preparation. A Job
     * Release task cannot be specified without also specifying a Job Preparation
     * task for the job. The Batch service runs the Job Release task on the compute
     * nodes that have run the Job Preparation task.
     *
     * @param {string} [cloudJobSchedule.jobSpecification.jobReleaseTask.id] A
     * string that uniquely identifies the Job Release task within the job. The ID
     * can contain any combination of alphanumeric characters including hyphens and
     * underscores and cannot contain more than 64 characters. If you do not
     * specify this property, the Batch service assigns a default value of
     * 'jobrelease'. No other task in the job can have the same ID as the Job
     * Release task. If you try to submit a task with the same id, the Batch
     * service rejects the request with error code TaskIdSameAsJobReleaseTask; if
     * you are calling the REST API directly, the HTTP status code is 409
     * (Conflict).
     *
     * @param {string} cloudJobSchedule.jobSpecification.jobReleaseTask.commandLine
     * The command line of the Job Release task. The command line does not run
     * under a shell, and therefore cannot take advantage of shell features such as
     * environment variable expansion. If you want to take advantage of such
     * features, you should invoke the shell in the command line, for example using
     * "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux.
     *
     * @param {array}
     * [cloudJobSchedule.jobSpecification.jobReleaseTask.resourceFiles] A list of
     * files that the Batch service will download to the compute node before
     * running the command line. Files listed under this element are located in the
     * task's working directory.
     *
     * @param {array}
     * [cloudJobSchedule.jobSpecification.jobReleaseTask.environmentSettings] A
     * list of environment variable settings for the Job Release task.
     *
     * @param {moment.duration}
     * [cloudJobSchedule.jobSpecification.jobReleaseTask.maxWallClockTime] The
     * maximum elapsed time that the Job Release task may run on a given compute
     * node, measured from the time the task starts. If the task does not complete
     * within the time limit, the Batch service terminates it. The default value is
     * 15 minutes. You may not specify a timeout longer than 15 minutes. If you do,
     * the Batch service rejects it with an error; if you are calling the REST API
     * directly, the HTTP status code is 400 (Bad Request).
     *
     * @param {moment.duration}
     * [cloudJobSchedule.jobSpecification.jobReleaseTask.retentionTime] The minimum
     * time to retain the task directory for the Job Release task on the compute
     * node. After this time, the Batch service may delete the task directory and
     * all its contents. The default is infinite, i.e. the task directory will be
     * retained until the compute node is removed or reimaged.
     *
     * @param {object}
     * [cloudJobSchedule.jobSpecification.jobReleaseTask.userIdentity] The user
     * identity under which the Job Release task runs. If omitted, the task runs as
     * a non-administrative user unique to the task.
     *
     * @param {array} [cloudJobSchedule.jobSpecification.commonEnvironmentSettings]
     * A list of common environment variable settings. These environment variables
     * are set for all tasks in jobs created under this schedule (including the Job
     * Manager, Job Preparation and Job Release tasks). Individual tasks can
     * override an environment setting specified here by specifying the same
     * setting name with a different value.
     *
     * @param {object} cloudJobSchedule.jobSpecification.poolInfo The pool on which
     * the Batch service runs the tasks of jobs created under this schedule.
     *
     * @param {string} [cloudJobSchedule.jobSpecification.poolInfo.poolId] The ID
     * of an existing pool. All the tasks of the job will run on the specified
     * pool. You must ensure that the pool referenced by this property exists. If
     * the pool does not exist at the time the Batch service tries to schedule a
     * job, no tasks for the job will run until you create a pool with that id.
     * Note that the Batch service will not reject the job request; it will simply
     * not run tasks until the pool exists. You must specify either the pool ID or
     * the auto pool specification, but not both.
     *
     * @param {object}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification]
     * Characteristics for a temporary 'auto pool'. The Batch service will create
     * this auto pool when the job is submitted. If auto pool creation fails, the
     * Batch service moves the job to a completed state, and the pool creation
     * error is set in the job's scheduling error property. The Batch service
     * manages the lifetime (both creation and, unless keepAlive is specified,
     * deletion) of the auto pool. Any user actions that affect the lifetime of the
     * auto pool while the job is active will result in unexpected behavior. You
     * must specify either the pool ID or the auto pool specification, but not
     * both.
     *
     * @param {string}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.autoPoolIdPrefix]
     * A prefix to be added to the unique identifier when a pool is automatically
     * created. The Batch service assigns each auto pool a unique identifier on
     * creation. To distinguish between pools created for different purposes, you
     * can specify this element to add a prefix to the ID that is assigned. The
     * prefix can be up to 20 characters long.
     *
     * @param {string}
     * cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.poolLifetimeOption
     * The minimum lifetime of created auto pools, and how multiple jobs on a
     * schedule are assigned to pools. When the pool lifetime is jobSchedule the
     * pool exists for the lifetime of the job schedule. The Batch Service creates
     * the pool when it creates the first job on the schedule. You may apply this
     * option only to job schedules, not to jobs. When the pool lifetime is job the
     * pool exists for the lifetime of the job to which it is dedicated. The Batch
     * service creates the pool when it creates the job. If the 'job' option is
     * applied to a job schedule, the Batch service creates a new auto pool for
     * every job created on the schedule. Possible values include: 'jobSchedule',
     * 'job'
     *
     * @param {boolean}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.keepAlive]
     * Whether to keep an auto pool alive after its lifetime expires. If false, the
     * Batch service deletes the pool once its lifetime (as determined by the
     * poolLifetimeOption setting) expires; that is, when the job or job schedule
     * completes. If true, the Batch service does not delete the pool
     * automatically. It is up to the user to delete auto pools created with this
     * option.
     *
     * @param {object}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool] The
     * pool specification for the auto pool.
     *
     * @param {string}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.displayName]
     * The display name for the pool. The display name need not be unique and can
     * contain any Unicode characters up to a maximum length of 1024.
     *
     * @param {string}
     * cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.vmSize
     * The size of the virtual machines in the pool. All virtual machines in a pool
     * are the same size. For information about available sizes of virtual machines
     * for Cloud Services pools (pools created with cloudServiceConfiguration), see
     * Sizes for Cloud Services
     * (http://azure.microsoft.com/documentation/articles/cloud-services-sizes-specs/).
     * Batch supports all Cloud Services VM sizes except ExtraSmall, A1V2 and A2V2.
     * For information about available VM sizes for pools using images from the
     * Virtual Machines Marketplace (pools created with
     * virtualMachineConfiguration) see Sizes for Virtual Machines (Linux)
     * (https://azure.microsoft.com/documentation/articles/virtual-machines-linux-sizes/)
     * or Sizes for Virtual Machines (Windows)
     * (https://azure.microsoft.com/documentation/articles/virtual-machines-windows-sizes/).
     * Batch supports all Azure VM sizes except STANDARD_A0 and those with premium
     * storage (STANDARD_GS, STANDARD_DS, and STANDARD_DSV2 series).
     *
     * @param {object}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration]
     * The cloud service configuration for the pool. This property must be
     * specified if the pool needs to be created with Azure PaaS VMs. This property
     * and virtualMachineConfiguration are mutually exclusive and one of the
     * properties must be specified. If neither is specified then the Batch service
     * returns an error; if you are calling the REST API directly, the HTTP status
     * code is 400 (Bad Request). This property cannot be specified if the Batch
     * account was created with its poolAllocationMode property set to
     * 'UserSubscription'.
     *
     * @param {string}
     * cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.osFamily
     * The Azure Guest OS family to be installed on the virtual machines in the
     * pool. Possible values are: 2 - OS Family 2, equivalent to Windows Server
     * 2008 R2 SP1. 3 - OS Family 3, equivalent to Windows Server 2012. 4 - OS
     * Family 4, equivalent to Windows Server 2012 R2. 5 - OS Family 5, equivalent
     * to Windows Server 2016. For more information, see Azure Guest OS Releases
     * (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
     *
     * @param {string}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.targetOSVersion]
     * The Azure Guest OS version to be installed on the virtual machines in the
     * pool. The default value is * which specifies the latest operating system
     * version for the specified OS family.
     *
     * @param {string}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.currentOSVersion]
     * The Azure Guest OS Version currently installed on the virtual machines in
     * the pool. This may differ from targetOSVersion if the pool state is
     * Upgrading. In this case some virtual machines may be on the targetOSVersion
     * and some may be on the currentOSVersion during the upgrade process. Once all
     * virtual machines have upgraded, currentOSVersion is updated to be the same
     * as targetOSVersion.
     *
     * @param {object}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration]
     * The virtual machine configuration for the pool. This property must be
     * specified if the pool needs to be created with Azure IaaS VMs. This property
     * and cloudServiceConfiguration are mutually exclusive and one of the
     * properties must be specified. If neither is specified then the Batch service
     * returns an error; if you are calling the REST API directly, the HTTP status
     * code is 400 (Bad Request).
     *
     * @param {object}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference]
     * A reference to the Azure Virtual Machines Marketplace image to use. This
     * property and osDisk are mutually exclusive and one of the properties must be
     * specified.
     *
     * @param {string}
     * cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.publisher
     * The publisher of the Azure Virtual Machines Marketplace image. For example,
     * Canonical or MicrosoftWindowsServer.
     *
     * @param {string}
     * cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.offer
     * The offer type of the Azure Virtual Machines Marketplace image. For example,
     * UbuntuServer or WindowsServer.
     *
     * @param {string}
     * cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.sku
     * The SKU of the Azure Virtual Machines Marketplace image. For example,
     * 14.04.0-LTS or 2012-R2-Datacenter.
     *
     * @param {string}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.version]
     * The version of the Azure Virtual Machines Marketplace image. A value of
     * 'latest' can be specified to select the latest version of an image. If
     * omitted, the default is 'latest'.
     *
     * @param {object}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.osDisk]
     * A reference to the OS disk image to use. This property can be specified only
     * if the Batch account was created with its poolAllocationMode property set to
     * 'UserSubscription'. This property and imageReference are mutually exclusive
     * and one of the properties must be specified.
     *
     * @param {array}
     * cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.osDisk.imageUris
     * The collection of Virtual Hard Disk (VHD) URIs. All the VHDs must be
     * identical and must reside in an Azure Storage account within the same
     * subscription and same region as the Batch account. For best performance, it
     * is recommended that each VHD resides in a separate Azure Storage account.
     * Each VHD can serve upto 20 Windows compute nodes or 40 Linux compute nodes.
     * You must supply enough VHD URIs to satisfy the 'targetDedicated' property of
     * the pool. If you do not supply enough VHD URIs, the pool will partially
     * allocate compute nodes, and a resize error will occur.
     *
     * @param {string}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.osDisk.caching]
     * The type of caching to enable for the OS disk. Values are:
     *
     * none - The caching mode for the disk is not enabled.
     * readOnly - The caching mode for the disk is read only.
     * readWrite - The caching mode for the disk is read and write.
     *
     * The default value for caching is none. For information about the caching
     * options see:
     * https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/27/exploring-windows-azure-drives-disks-and-images/.
     * Possible values include: 'none', 'readOnly', 'readWrite'
     *
     * @param {string}
     * cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.nodeAgentSKUId
     * The SKU of the Batch node agent to be provisioned on compute nodes in the
     * pool. The Batch node agent is a program that runs on each node in the pool,
     * and provides the command-and-control interface between the node and the
     * Batch service. There are different implementations of the node agent, known
     * as SKUs, for different operating systems. You must specify a node agent SKU
     * which matches the selected image reference. To get the list of supported
     * node agent SKUs along with their list of verified image references, see the
     * 'List supported node agent SKUs' operation.
     *
     * @param {object}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration]
     * Windows operating system settings on the virtual machine. This property must
     * not be specified if the imageReference or osDisk property specifies a Linux
     * OS image.
     *
     * @param {boolean}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration.enableAutomaticUpdates]
     * Whether automatic updates are enabled on the virtual machine. If omitted,
     * the default value is true.
     *
     * @param {number}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.maxTasksPerNode]
     * The maximum number of tasks that can run concurrently on a single compute
     * node in the pool. The default value is 1. The maximum value of this setting
     * depends on the size of the compute nodes in the pool (the vmSize setting).
     *
     * @param {object}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy]
     * How tasks are distributed across compute nodes in a pool.
     *
     * @param {string}
     * cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy.nodeFillType
     * How tasks are distributed across compute nodes in a pool. Values are:
     *
     * pack - As many tasks as possible (maxTasksPerNode) should be assigned to
     * each node in the pool before any tasks are assigned to the next node in the
     * pool.
     * spread - Tasks should be assigned evenly across all nodes in the pool.
     * Possible values include: 'spread', 'pack'
     *
     * @param {moment.duration}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.resizeTimeout]
     * The timeout for allocation of compute nodes to the pool. This timeout
     * applies only to manual scaling; it has no effect when enableAutoScale is set
     * to true. The default value is 15 minutes. The minimum value is 5 minutes. If
     * you specify a value less than 5 minutes, the Batch service rejects the
     * request with an error; if you are calling the REST API directly, the HTTP
     * status code is 400 (Bad Request).
     *
     * @param {number}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.targetDedicatedNodes]
     * The desired number of dedicated compute nodes in the pool. This property
     * must not be specified if enableAutoScale is set to true. If enableAutoScale
     * is set to false, then you must set either targetDedicatedNodes,
     * targetLowPriorityNodes, or both.
     *
     * @param {number}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.targetLowPriorityNodes]
     * The desired number of low-priority compute nodes in the pool. This property
     * must not be specified if enableAutoScale is set to true. If enableAutoScale
     * is set to false, then you must set either targetDedicatedNodes,
     * targetLowPriorityNodes, or both.
     *
     * @param {boolean}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.enableAutoScale]
     * Whether the pool size should automatically adjust over time. If false, at
     * least one of targetDedicateNodes and targetLowPriorityNodes must be
     * specified. If true, the autoScaleFormula element is required. The pool
     * automatically resizes according to the formula. The default value is false.
     *
     * @param {string}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.autoScaleFormula]
     * The formula for the desired number of compute nodes in the pool. This
     * property must not be specified if enableAutoScale is set to false. It is
     * required if enableAutoScale is set to true. The formula is checked for
     * validity before the pool is created. If the formula is not valid, the Batch
     * service rejects the request with detailed error information.
     *
     * @param {moment.duration}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.autoScaleEvaluationInterval]
     * The time interval at which to automatically adjust the pool size according
     * to the autoscale formula. The default value is 15 minutes. The minimum and
     * maximum value are 5 minutes and 168 hours respectively. If you specify a
     * value less than 5 minutes or greater than 168 hours, the Batch service
     * rejects the request with an invalid property value error; if you are calling
     * the REST API directly, the HTTP status code is 400 (Bad Request).
     *
     * @param {boolean}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.enableInterNodeCommunication]
     * Whether the pool permits direct communication between nodes. Enabling
     * inter-node communication limits the maximum size of the pool due to
     * deployment restrictions on the nodes of the pool. This may result in the
     * pool not reaching its desired size. The default value is false.
     *
     * @param {object}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.networkConfiguration]
     * The network configuration for the pool.
     *
     * @param {string}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.networkConfiguration.subnetId]
     * The ARM resource identifier of the virtual network subnet which the compute
     * nodes of the pool will join. This is of the form
     * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
     * The virtual network must be in the same region and subscription as the Azure
     * Batch account. The specified subnet should have enough free IP addresses to
     * accommodate the number of nodes in the pool. If the subnet doesn't have
     * enough free IP addresses, the pool will partially allocate compute nodes,
     * and a resize error will occur. The 'MicrosoftAzureBatch' service principal
     * must have the 'Classic Virtual Machine Contributor' Role-Based Access
     * Control (RBAC) role for the specified VNet. The specified subnet must allow
     * communication from the Azure Batch service to be able to schedule tasks on
     * the compute nodes. This can be verified by checking if the specified VNet
     * has any associated Network Security Groups (NSG). If communication to the
     * compute nodes in the specified subnet is denied by an NSG, then the Batch
     * service will set the state of the compute nodes to unusable. For pools
     * created via virtualMachineConfiguration the Batch account must have
     * poolAllocationMode userSubscription in order to use a VNet. If the specified
     * VNet has any associated Network Security Groups (NSG), then a few reserved
     * system ports must be enabled for inbound communication. For pools created
     * with a virtual machine configuration, enable ports 29876 and 29877, as well
     * as port 22 for Linux and port 3389 for Windows. For pools created with a
     * cloud service configuration, enable ports 10100, 20100, and 30100. Also
     * enable outbound connections to Azure Storage on port 443. For more details
     * see:
     * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration
     *
     * @param {object}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration]
     * The configuration for endpoints on compute nodes in the Batch pool. Pool
     * endpoint configuration is only supported on pools with the
     * virtualMachineConfiguration property.
     *
     * @param {array}
     * cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration.inboundNATPools
     * A list of inbound NAT pools that can be used to address specific ports on an
     * individual compute node externally. The maximum number of inbound NAT pools
     * per Batch pool is 5. If the maximum number of inbound NAT pools is exceeded
     * the request fails with HTTP status code 400.
     *
     * @param {object}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask]
     * A task to run on each compute node as it joins the pool. The task runs when
     * the node is added to the pool or when the node is restarted.
     *
     * @param {string}
     * cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.commandLine
     * The command line of the start task. The command line does not run under a
     * shell, and therefore cannot take advantage of shell features such as
     * environment variable expansion. If you want to take advantage of such
     * features, you should invoke the shell in the command line, for example using
     * "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux.
     *
     * @param {array}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.resourceFiles]
     * A list of files that the Batch service will download to the compute node
     * before running the command line. Files listed under this element are located
     * in the task's working directory.
     *
     * @param {array}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.environmentSettings]
     * A list of environment variable settings for the start task.
     *
     * @param {object}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.userIdentity]
     * The user identity under which the start task runs. If omitted, the task runs
     * as a non-administrative user unique to the task.
     *
     * @param {string}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.userName]
     * The name of the user identity under which the task is run. The userName and
     * autoUser properties are mutually exclusive; you must specify one but not
     * both.
     *
     * @param {object}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser]
     * The auto user under which the task is run. The userName and autoUser
     * properties are mutually exclusive; you must specify one but not both.
     *
     * @param {string}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.scope]
     * The scope for the auto user Values are:
     *
     * pool - specifies that the task runs as the common auto user account which is
     * created on every node in a pool.
     * task - specifies that the service should create a new user for the task.
     * The default value is task. Possible values include: 'task', 'pool'
     *
     * @param {string}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.elevationLevel]
     * The elevation level of the auto user. nonAdmin - The auto user is a standard
     * user without elevated access. admin - The auto user is a user with elevated
     * access and operates with full Administrator permissions. The default value
     * is nonAdmin. Possible values include: 'nonAdmin', 'admin'
     *
     * @param {number}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.maxTaskRetryCount]
     * The maximum number of times the task may be retried. The Batch service
     * retries a task if its exit code is nonzero. Note that this value
     * specifically controls the number of retries. The Batch service will try the
     * task once, and may then retry up to this limit. For example, if the maximum
     * retry count is 3, Batch tries the task up to 4 times (one initial try and 3
     * retries). If the maximum retry count is 0, the Batch service does not retry
     * the task. If the maximum retry count is -1, the Batch service retries the
     * task without limit.
     *
     * @param {boolean}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.waitForSuccess]
     * Whether the Batch service should wait for the start task to complete
     * successfully (that is, to exit with exit code 0) before scheduling any tasks
     * on the compute node. If true and the start task fails on a compute node, the
     * Batch service retries the start task up to its maximum retry count
     * (maxTaskRetryCount). If the task has still not completed successfully after
     * all retries, then the Batch service marks the compute node unusable, and
     * will not schedule tasks to it. This condition can be detected via the node
     * state and failure info details. If false, the Batch service will not wait
     * for the start task to complete. In this case, other tasks can start
     * executing on the compute node while the start task is still running; and
     * even if the start task fails, new tasks will continue to be scheduled on the
     * node. The default is false.
     *
     * @param {array}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.certificateReferences]
     * A list of certificates to be installed on each compute node in the pool. For
     * Windows compute nodes, the Batch service installs the certificates to the
     * specified certificate store and location. For Linux compute nodes, the
     * certificates are stored in a directory inside the task working directory and
     * an environment variable AZ_BATCH_CERTIFICATES_DIR is supplied to the task to
     * query for this location. For certificates with visibility of 'remoteUser', a
     * 'certs' directory is created in the user's home directory (e.g.,
     * /home/{user-name}/certs) and certificates are placed in that directory.
     *
     * @param {array}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.applicationPackageReferences]
     * The list of application packages to be installed on each compute node in the
     * pool.
     *
     * @param {array}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.applicationLicenses]
     * The list of application licenses the Batch service will make available on
     * each compute node in the pool. The list of application licenses must be a
     * subset of available Batch service application licenses. If a license is
     * requested which is not supported, pool creation will fail.
     *
     * @param {array}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.userAccounts]
     * The list of user accounts to be created on each node in the pool.
     *
     * @param {array}
     * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.metadata]
     * A list of name-value pairs associated with the pool as metadata. The Batch
     * service does not assign any meaning to metadata; it is solely for the use of
     * user code.
     *
     * @param {array} [cloudJobSchedule.jobSpecification.metadata] A list of
     * name-value pairs associated with each job created under this schedule as
     * metadata. The Batch service does not assign any meaning to metadata; it is
     * solely for the use of user code.
     *
     * @param {array} [cloudJobSchedule.metadata] A list of name-value pairs
     * associated with the schedule as metadata. The Batch service does not assign
     * any meaning to metadata; it is solely for the use of user code.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.jobScheduleAddOptions] Additional parameters for
     * the operation
     *
     * @param {number} [options.jobScheduleAddOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.jobScheduleAddOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.jobScheduleAddOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.jobScheduleAddOptions.ocpDate] The time the request
     * was issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addWithHttpOperationResponse(cloudJobSchedule, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleAddOptions = (options && options.jobScheduleAddOptions !== undefined) ? options.jobScheduleAddOptions : undefined;
            // Validate
            try {
                if (cloudJobSchedule === null || cloudJobSchedule === undefined) {
                    throw new Error('cloudJobSchedule cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobScheduleAddOptions !== null && jobScheduleAddOptions !== undefined) {
                    timeout = jobScheduleAddOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobScheduleAddOptions !== null && jobScheduleAddOptions !== undefined) {
                    clientRequestId = jobScheduleAddOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleAddOptions !== null && jobScheduleAddOptions !== undefined) {
                    returnClientRequestId = jobScheduleAddOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleAddOptions !== null && jobScheduleAddOptions !== undefined) {
                    ocpDate = jobScheduleAddOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobschedules';
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (cloudJobSchedule !== null && cloudJobSchedule !== undefined) {
                    let requestModelMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["JobScheduleAddParameter"];
                    requestModel = client.serializer.serialize(requestModelMapper, cloudJobSchedule, 'cloudJobSchedule');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(cloudJobSchedule, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 201) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the job schedules in the specified account.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.jobScheduleListOptions] Additional parameters for
     * the operation
     *
     * @param {string} [options.jobScheduleListOptions.filter] An OData $filter
     * clause.
     *
     * @param {string} [options.jobScheduleListOptions.select] An OData $select
     * clause.
     *
     * @param {string} [options.jobScheduleListOptions.expand] An OData $expand
     * clause.
     *
     * @param {number} [options.jobScheduleListOptions.maxResults] The maximum
     * number of items to return in the response. A maximum of 1000 job schedules
     * can be returned.
     *
     * @param {number} [options.jobScheduleListOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.jobScheduleListOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.jobScheduleListOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.jobScheduleListOptions.ocpDate] The time the request
     * was issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<CloudJobScheduleListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleListOptions = (options && options.jobScheduleListOptions !== undefined) ? options.jobScheduleListOptions : undefined;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let select;
            let expand;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined) {
                    filter = jobScheduleListOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined) {
                    select = jobScheduleListOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined) {
                    expand = jobScheduleListOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined) {
                    maxResults = jobScheduleListOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined) {
                    timeout = jobScheduleListOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined) {
                    clientRequestId = jobScheduleListOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined) {
                    returnClientRequestId = jobScheduleListOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined) {
                    ocpDate = jobScheduleListOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobschedules';
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (filter !== null && filter !== undefined) {
                queryParameters.push('$filter=' + encodeURIComponent(filter));
            }
            if (select !== null && select !== undefined) {
                queryParameters.push('$select=' + encodeURIComponent(select));
            }
            if (expand !== null && expand !== undefined) {
                queryParameters.push('$expand=' + encodeURIComponent(expand));
            }
            if (maxResults !== null && maxResults !== undefined) {
                queryParameters.push('maxresults=' + encodeURIComponent(maxResults.toString()));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["CloudJobScheduleListResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the job schedules in the specified account.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.jobScheduleListNextOptions] Additional parameters
     * for the operation
     *
     * @param {string} [options.jobScheduleListNextOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.jobScheduleListNextOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.jobScheduleListNextOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<CloudJobScheduleListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let jobScheduleListNextOptions = (options && options.jobScheduleListNextOptions !== undefined) ? options.jobScheduleListNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (jobScheduleListNextOptions !== null && jobScheduleListNextOptions !== undefined) {
                    clientRequestId = jobScheduleListNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (jobScheduleListNextOptions !== null && jobScheduleListNextOptions !== undefined) {
                    returnClientRequestId = jobScheduleListNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (jobScheduleListNextOptions !== null && jobScheduleListNextOptions !== undefined) {
                    ocpDate = jobScheduleListNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["CloudJobScheduleListResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    exists(jobScheduleId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.existsWithHttpOperationResponse(jobScheduleId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.existsWithHttpOperationResponse(jobScheduleId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    deleteMethod(jobScheduleId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteMethodWithHttpOperationResponse(jobScheduleId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.deleteMethodWithHttpOperationResponse(jobScheduleId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    get(jobScheduleId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(jobScheduleId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.getWithHttpOperationResponse(jobScheduleId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    patch(jobScheduleId, jobSchedulePatchParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.patchWithHttpOperationResponse(jobScheduleId, jobSchedulePatchParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.patchWithHttpOperationResponse(jobScheduleId, jobSchedulePatchParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    update(jobScheduleId, jobScheduleUpdateParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.updateWithHttpOperationResponse(jobScheduleId, jobScheduleUpdateParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.updateWithHttpOperationResponse(jobScheduleId, jobScheduleUpdateParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    disable(jobScheduleId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.disableWithHttpOperationResponse(jobScheduleId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.disableWithHttpOperationResponse(jobScheduleId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    enable(jobScheduleId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.enableWithHttpOperationResponse(jobScheduleId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.enableWithHttpOperationResponse(jobScheduleId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    terminate(jobScheduleId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.terminateWithHttpOperationResponse(jobScheduleId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.terminateWithHttpOperationResponse(jobScheduleId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    add(cloudJobSchedule, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.addWithHttpOperationResponse(cloudJobSchedule, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.addWithHttpOperationResponse(cloudJobSchedule, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    list(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.listWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.listNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = JobSchedule;



/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__models_mappers__ = __webpack_require__(1);
/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


const WebResource = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["WebResource"];
/** Class representing a Task. */
class Task {
    /**
     * Create a Task.
     * @param {BatchServiceClient} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Adds a task to the specified job.
     *
     * @param {string} jobId The ID of the job to which the task is to be added.
     *
     * @param {object} task The task to be added.
     *
     * @param {string} task.id A string that uniquely identifies the task within
     * the job. The ID can contain any combination of alphanumeric characters
     * including hyphens and underscores, and cannot contain more than 64
     * characters. The ID is case-preserving and case-insensitive (that is, you may
     * not have two IDs within a job that differ only by case).
     *
     * @param {string} [task.displayName] A display name for the task. The display
     * name need not be unique and can contain any Unicode characters up to a
     * maximum length of 1024.
     *
     * @param {string} task.commandLine The command line of the task. For
     * multi-instance tasks, the command line is executed as the primary task,
     * after the primary task and all subtasks have finished executing the
     * coordination command line. The command line does not run under a shell, and
     * therefore cannot take advantage of shell features such as environment
     * variable expansion. If you want to take advantage of such features, you
     * should invoke the shell in the command line, for example using "cmd /c
     * MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux.
     *
     * @param {object} [task.exitConditions] How the Batch service should respond
     * when the task completes.
     *
     * @param {array} [task.exitConditions.exitCodes] A list of individual task
     * exit codes and how the Batch service should respond to them.
     *
     * @param {array} [task.exitConditions.exitCodeRanges] A list of task exit code
     * ranges and how the Batch service should respond to them.
     *
     * @param {object} [task.exitConditions.preProcessingError] How the Batch
     * service should respond if the task fails to start due to an error.
     *
     * @param {object} [task.exitConditions.fileUploadError] How the Batch service
     * should respond if a file upload error occurs. If the task exited with an
     * exit code that was specified via exitCodes or exitCodeRanges, and then
     * encountered a file upload error, then the action specified by the exit code
     * takes precedence.
     *
     * @param {object} [task.exitConditions.default] How the Batch service should
     * respond if the task fails with an exit condition not covered by any of the
     * other properties. This value is used if the task exits with any nonzero exit
     * code not listed in the exitCodes or exitCodeRanges collection, with a
     * pre-processing error if the preProcessingError property is not present, or
     * with a file upload error if the fileUploadError property is not present. If
     * you want non-default behaviour on exit code 0, you must list it explicitly
     * using the exitCodes or exitCodeRanges collection.
     *
     * @param {string} [task.exitConditions.default.jobAction] An action to take on
     * the job containing the task, if the task completes with the given exit
     * condition and the job's onTaskFailed property is
     * 'performExitOptionsJobAction'. Values are:
     *
     * none - Take no action.
     * disable - Disable the job. This is equivalent to calling the disable job
     * API, with a disableTasks value of requeue.
     * terminate - Terminate the job. The terminateReason in the job's
     * executionInfo is set to "TaskFailed". The default is none for exit code 0
     * and terminate for all other exit conditions.
     *
     * If the job's onTaskFailed property is noAction, then specifying this
     * property returns an error and the add task request fails with an invalid
     * property value error; if you are calling the REST API directly, the HTTP
     * status code is 400 (Bad Request). Possible values include: 'none',
     * 'disable', 'terminate'
     *
     * @param {string} [task.exitConditions.default.dependencyAction] An action
     * that the Batch service performs on tasks that depend on this task. Values
     * are:
     *
     * satisfy - Satisfy the task's dependencies.
     * block - Block the task's dependencies.
     *
     * The default is 'satisfy' for exit code 0, and 'block' for all other exit
     * conditions. If the job's usesTaskDependencies property is set to false, then
     * specifying the dependencyAction property returns an erro and the add task
     * request fails with an invalid property value error; if you are calling the
     * REST API directly, the HTTP status code is 400  (Bad Request). Possible
     * values include: 'satisfy', 'block'
     *
     * @param {array} [task.resourceFiles] A list of files that the Batch service
     * will download to the compute node before running the command line. For
     * multi-instance tasks, the resource files will only be downloaded to the
     * compute node on which the primary task is executed.
     *
     * @param {array} [task.outputFiles] A list of files that the Batch service
     * will upload from the compute node after running the command line. For
     * multi-instance tasks, the files will only be uploaded from the compute node
     * on which the primary task is executed.
     *
     * @param {array} [task.environmentSettings] A list of environment variable
     * settings for the task.
     *
     * @param {object} [task.affinityInfo] A locality hint that can be used by the
     * Batch service to select a compute node on which to start the new task.
     *
     * @param {string} task.affinityInfo.affinityId An opaque string representing
     * the location of a compute node or a task that has run previously. You can
     * pass the affinityId of a compute node to indicate that this task needs to
     * run on that compute node. Note that this is just a soft affinity. If the
     * target node is busy or unavailable at the time the task is scheduled, then
     * the task will be scheduled elsewhere.
     *
     * @param {object} [task.constraints] The execution constraints that apply to
     * this task. If you do not specify constraints, the maxTaskRetryCount is the
     * maxTaskRetryCount specified for the job, and the maxWallClockTime and
     * retentionTime are infinite.
     *
     * @param {moment.duration} [task.constraints.maxWallClockTime] The maximum
     * elapsed time that the task may run, measured from the time the task starts.
     * If the task does not complete within the time limit, the Batch service
     * terminates it. If this is not specified, there is no time limit on how long
     * the task may run.
     *
     * @param {moment.duration} [task.constraints.retentionTime] The minimum time
     * to retain the task directory on the compute node where it ran, from the time
     * it completes execution. After this time, the Batch service may delete the
     * task directory and all its contents. The default is infinite, i.e. the task
     * directory will be retained until the compute node is removed or reimaged.
     *
     * @param {number} [task.constraints.maxTaskRetryCount] The maximum number of
     * times the task may be retried. The Batch service retries a task if its exit
     * code is nonzero. Note that this value specifically controls the number of
     * retries. The Batch service will try the task once, and may then retry up to
     * this limit. For example, if the maximum retry count is 3, Batch tries the
     * task up to 4 times (one initial try and 3 retries). If the maximum retry
     * count is 0, the Batch service does not retry the task. If the maximum retry
     * count is -1, the Batch service retries the task without limit.
     *
     * @param {object} [task.userIdentity] The user identity under which the task
     * runs. If omitted, the task runs as a non-administrative user unique to the
     * task.
     *
     * @param {string} [task.userIdentity.userName] The name of the user identity
     * under which the task is run. The userName and autoUser properties are
     * mutually exclusive; you must specify one but not both.
     *
     * @param {object} [task.userIdentity.autoUser] The auto user under which the
     * task is run. The userName and autoUser properties are mutually exclusive;
     * you must specify one but not both.
     *
     * @param {string} [task.userIdentity.autoUser.scope] The scope for the auto
     * user Values are:
     *
     * pool - specifies that the task runs as the common auto user account which is
     * created on every node in a pool.
     * task - specifies that the service should create a new user for the task.
     * The default value is task. Possible values include: 'task', 'pool'
     *
     * @param {string} [task.userIdentity.autoUser.elevationLevel] The elevation
     * level of the auto user. nonAdmin - The auto user is a standard user without
     * elevated access. admin - The auto user is a user with elevated access and
     * operates with full Administrator permissions. The default value is nonAdmin.
     * Possible values include: 'nonAdmin', 'admin'
     *
     * @param {object} [task.multiInstanceSettings] An object that indicates that
     * the task is a multi-instance task, and contains information about how to run
     * the multi-instance task.
     *
     * @param {number} task.multiInstanceSettings.numberOfInstances The number of
     * compute nodes required by the task.
     *
     * @param {string} [task.multiInstanceSettings.coordinationCommandLine] The
     * command line to run on all the compute nodes to enable them to coordinate
     * when the primary runs the main task command. A typical coordination command
     * line launches a background service and verifies that the service is ready to
     * process inter-node messages.
     *
     * @param {array} [task.multiInstanceSettings.commonResourceFiles] A list of
     * files that the Batch service will download before running the coordination
     * command line. The difference between common resource files and task resource
     * files is that common resource files are downloaded for all subtasks
     * including the primary, whereas task resource files are downloaded only for
     * the primary. Also note that these resource files are not downloaded to the
     * task working directory, but instead are downloaded to the task root
     * directory (one directory above the working directory).
     *
     * @param {object} [task.dependsOn] The tasks that this task depends on. This
     * task will not be scheduled until all tasks that it depends on have completed
     * successfully. If any of those tasks fail and exhaust their retry counts,
     * this task will never be scheduled. If the job does not have
     * usesTaskDependencies set to true, and this element is present, the request
     * fails with error code TaskDependenciesNotSpecifiedOnJob.
     *
     * @param {array} [task.dependsOn.taskIds] The list of task IDs that this task
     * depends on. All tasks in this list must complete successfully before the
     * dependent task can be scheduled. The taskIds collection is limited to 64000
     * characters total (i.e. the combined length of all task IDs). If the taskIds
     * collection exceeds the maximum length, the Add Task request fails with error
     * code TaskDependencyListTooLong. In this case consider using task ID ranges
     * instead.
     *
     * @param {array} [task.dependsOn.taskIdRanges] The list of task ID ranges that
     * this task depends on. All tasks in all ranges must complete successfully
     * before the dependent task can be scheduled.
     *
     * @param {array} [task.applicationPackageReferences] A list of application
     * packages that the Batch service will deploy to the compute node before
     * running the command line. Application packages are downloaded and deployed
     * to a shared directory, not the task working directory. Therefore, if a
     * referenced package is already on the compute node, and is up to date, then
     * it is not re-downloaded; the existing copy on the compute node is used. If a
     * referenced application package cannot be installed, for example because the
     * package has been deleted or because download failed, the task fails.
     *
     * @param {object} [task.authenticationTokenSettings] The settings for an
     * authentication token that the task can use to perform Batch service
     * operations. If this property is set, the Batch service provides the task
     * with an authentication token which can be used to authenticate Batch service
     * operations without requiring an account access key. The token is provided
     * via the AZ_BATCH_AUTHENTICATION_TOKEN environment variable. The operations
     * that the task can carry out using the token depend on the settings. For
     * example, a task can request job permissions in order to add other tasks to
     * the job, or check the status of the job or of other tasks under the job.
     *
     * @param {array} [task.authenticationTokenSettings.access] The Batch resources
     * to which the token grants access. The authentication token grants access to
     * a limited set of Batch service operations. Currently the only supported
     * value for the access property is 'job', which grants access to all
     * operations related to the job which contains the task.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.taskAddOptions] Additional parameters for the
     * operation
     *
     * @param {number} [options.taskAddOptions.timeout] The maximum time that the
     * server can spend processing the request, in seconds. The default is 30
     * seconds.
     *
     * @param {string} [options.taskAddOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.taskAddOptions.returnClientRequestId] Whether the
     * server should return the client-request-id in the response.
     *
     * @param {date} [options.taskAddOptions.ocpDate] The time the request was
     * issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addWithHttpOperationResponse(jobId, task, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let taskAddOptions = (options && options.taskAddOptions !== undefined) ? options.taskAddOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (task === null || task === undefined) {
                    throw new Error('task cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (taskAddOptions !== null && taskAddOptions !== undefined) {
                    timeout = taskAddOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (taskAddOptions !== null && taskAddOptions !== undefined) {
                    clientRequestId = taskAddOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskAddOptions !== null && taskAddOptions !== undefined) {
                    returnClientRequestId = taskAddOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskAddOptions !== null && taskAddOptions !== undefined) {
                    ocpDate = taskAddOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/tasks';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (task !== null && task !== undefined) {
                    let requestModelMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["TaskAddParameter"];
                    requestModel = client.serializer.serialize(requestModelMapper, task, 'task');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(task, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 201) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the tasks that are associated with the specified job.
     *
     * For multi-instance tasks, information such as affinityId, executionInfo and
     * nodeInfo refer to the primary task. Use the list subtasks API to retrieve
     * information about subtasks.
     *
     * @param {string} jobId The ID of the job.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.taskListOptions] Additional parameters for the
     * operation
     *
     * @param {string} [options.taskListOptions.filter] An OData $filter clause.
     *
     * @param {string} [options.taskListOptions.select] An OData $select clause.
     *
     * @param {string} [options.taskListOptions.expand] An OData $expand clause.
     *
     * @param {number} [options.taskListOptions.maxResults] The maximum number of
     * items to return in the response. A maximum of 1000 tasks can be returned.
     *
     * @param {number} [options.taskListOptions.timeout] The maximum time that the
     * server can spend processing the request, in seconds. The default is 30
     * seconds.
     *
     * @param {string} [options.taskListOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.taskListOptions.returnClientRequestId] Whether the
     * server should return the client-request-id in the response.
     *
     * @param {date} [options.taskListOptions.ocpDate] The time the request was
     * issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<CloudTaskListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(jobId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let taskListOptions = (options && options.taskListOptions !== undefined) ? options.taskListOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let select;
            let expand;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (taskListOptions !== null && taskListOptions !== undefined) {
                    filter = taskListOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (taskListOptions !== null && taskListOptions !== undefined) {
                    select = taskListOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (taskListOptions !== null && taskListOptions !== undefined) {
                    expand = taskListOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (taskListOptions !== null && taskListOptions !== undefined) {
                    maxResults = taskListOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (taskListOptions !== null && taskListOptions !== undefined) {
                    timeout = taskListOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (taskListOptions !== null && taskListOptions !== undefined) {
                    clientRequestId = taskListOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskListOptions !== null && taskListOptions !== undefined) {
                    returnClientRequestId = taskListOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskListOptions !== null && taskListOptions !== undefined) {
                    ocpDate = taskListOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/tasks';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (filter !== null && filter !== undefined) {
                queryParameters.push('$filter=' + encodeURIComponent(filter));
            }
            if (select !== null && select !== undefined) {
                queryParameters.push('$select=' + encodeURIComponent(select));
            }
            if (expand !== null && expand !== undefined) {
                queryParameters.push('$expand=' + encodeURIComponent(expand));
            }
            if (maxResults !== null && maxResults !== undefined) {
                queryParameters.push('maxresults=' + encodeURIComponent(maxResults.toString()));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["CloudTaskListResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Adds a collection of tasks to the specified job.
     *
     * Note that each task must have a unique ID. The Batch service may not return
     * the results for each task in the same order the tasks were submitted in this
     * request. If the server times out or the connection is closed during the
     * request, the request may have been partially or fully processed, or not at
     * all. In such cases, the user should re-issue the request. Note that it is up
     * to the user to correctly handle failures when re-issuing a request. For
     * example, you should use the same task IDs during a retry so that if the
     * prior operation succeeded, the retry will not create extra tasks
     * unexpectedly. If the response contains any tasks which failed to add, a
     * client can retry the request. In a retry, it is most efficient to resubmit
     * only tasks that failed to add, and to omit tasks that were successfully
     * added on the first attempt.
     *
     * @param {string} jobId The ID of the job to which the task collection is to
     * be added.
     *
     * @param {array} value The collection of tasks to add. The total serialized
     * size of this collection must be less than 4MB. If it is greater than 4MB
     * (for example if each task has 100's of resource files or environment
     * variables), the request will fail with code 'RequestBodyTooLarge' and should
     * be retried again with fewer tasks.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.taskAddCollectionOptions] Additional parameters for
     * the operation
     *
     * @param {number} [options.taskAddCollectionOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.taskAddCollectionOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.taskAddCollectionOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.taskAddCollectionOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<TaskAddCollectionResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addCollectionWithHttpOperationResponse(jobId, value, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let taskAddCollectionOptions = (options && options.taskAddCollectionOptions !== undefined) ? options.taskAddCollectionOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (value !== null && value !== undefined) {
                    if (value.length > 100) {
                        throw new Error('"value" should satisfy the constraint - "MaxItems": 100');
                    }
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let taskCollection = {};
            try {
                if (taskAddCollectionOptions !== null && taskAddCollectionOptions !== undefined) {
                    timeout = taskAddCollectionOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (taskAddCollectionOptions !== null && taskAddCollectionOptions !== undefined) {
                    clientRequestId = taskAddCollectionOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskAddCollectionOptions !== null && taskAddCollectionOptions !== undefined) {
                    returnClientRequestId = taskAddCollectionOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskAddCollectionOptions !== null && taskAddCollectionOptions !== undefined) {
                    ocpDate = taskAddCollectionOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (value !== null && value !== undefined) {
                    taskCollection.value = value;
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/addtaskcollection';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (taskCollection !== null && taskCollection !== undefined) {
                    let requestModelMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["TaskAddCollectionParameter"];
                    requestModel = client.serializer.serialize(requestModelMapper, taskCollection, 'taskCollection');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(taskCollection, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["TaskAddCollectionResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Deletes a task from the specified job.
     *
     * When a task is deleted, all of the files in its directory on the compute
     * node where it ran are also deleted (regardless of the retention time). For
     * multi-instance tasks, the delete task operation applies synchronously to the
     * primary task; subtasks and their files are then deleted asynchronously in
     * the background.
     *
     * @param {string} jobId The ID of the job from which to delete the task.
     *
     * @param {string} taskId The ID of the task to delete.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.taskDeleteMethodOptions] Additional parameters for
     * the operation
     *
     * @param {number} [options.taskDeleteMethodOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.taskDeleteMethodOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.taskDeleteMethodOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.taskDeleteMethodOptions.ocpDate] The time the request
     * was issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.taskDeleteMethodOptions.ifMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.
     *
     * @param {string} [options.taskDeleteMethodOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.taskDeleteMethodOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.taskDeleteMethodOptions.ifUnmodifiedSince] A
     * timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service
     * has not been modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(jobId, taskId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let taskDeleteMethodOptions = (options && options.taskDeleteMethodOptions !== undefined) ? options.taskDeleteMethodOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (taskDeleteMethodOptions !== null && taskDeleteMethodOptions !== undefined) {
                    timeout = taskDeleteMethodOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (taskDeleteMethodOptions !== null && taskDeleteMethodOptions !== undefined) {
                    clientRequestId = taskDeleteMethodOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskDeleteMethodOptions !== null && taskDeleteMethodOptions !== undefined) {
                    returnClientRequestId = taskDeleteMethodOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskDeleteMethodOptions !== null && taskDeleteMethodOptions !== undefined) {
                    ocpDate = taskDeleteMethodOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (taskDeleteMethodOptions !== null && taskDeleteMethodOptions !== undefined) {
                    ifMatch = taskDeleteMethodOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (taskDeleteMethodOptions !== null && taskDeleteMethodOptions !== undefined) {
                    ifNoneMatch = taskDeleteMethodOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (taskDeleteMethodOptions !== null && taskDeleteMethodOptions !== undefined) {
                    ifModifiedSince = taskDeleteMethodOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (taskDeleteMethodOptions !== null && taskDeleteMethodOptions !== undefined) {
                    ifUnmodifiedSince = taskDeleteMethodOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/tasks/{taskId}';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            requestUrl = requestUrl.replace('{taskId}', encodeURIComponent(taskId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'DELETE';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets information about the specified task.
     *
     * For multi-instance tasks, information such as affinityId, executionInfo and
     * nodeInfo refer to the primary task. Use the list subtasks API to retrieve
     * information about subtasks.
     *
     * @param {string} jobId The ID of the job that contains the task.
     *
     * @param {string} taskId The ID of the task to get information about.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.taskGetOptions] Additional parameters for the
     * operation
     *
     * @param {string} [options.taskGetOptions.select] An OData $select clause.
     *
     * @param {string} [options.taskGetOptions.expand] An OData $expand clause.
     *
     * @param {number} [options.taskGetOptions.timeout] The maximum time that the
     * server can spend processing the request, in seconds. The default is 30
     * seconds.
     *
     * @param {string} [options.taskGetOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.taskGetOptions.returnClientRequestId] Whether the
     * server should return the client-request-id in the response.
     *
     * @param {date} [options.taskGetOptions.ocpDate] The time the request was
     * issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.taskGetOptions.ifMatch] An ETag value associated
     * with the version of the resource known to the client. The operation will be
     * performed only if the resource's current ETag on the service exactly matches
     * the value specified by the client.
     *
     * @param {string} [options.taskGetOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.taskGetOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.taskGetOptions.ifUnmodifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has not been
     * modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<CloudTask>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(jobId, taskId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let taskGetOptions = (options && options.taskGetOptions !== undefined) ? options.taskGetOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let select;
            let expand;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    select = taskGetOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    expand = taskGetOptions.expand;
                    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
                        throw new Error('expand must be of type string.');
                    }
                }
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    timeout = taskGetOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    clientRequestId = taskGetOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    returnClientRequestId = taskGetOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    ocpDate = taskGetOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    ifMatch = taskGetOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    ifNoneMatch = taskGetOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    ifModifiedSince = taskGetOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (taskGetOptions !== null && taskGetOptions !== undefined) {
                    ifUnmodifiedSince = taskGetOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/tasks/{taskId}';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            requestUrl = requestUrl.replace('{taskId}', encodeURIComponent(taskId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (select !== null && select !== undefined) {
                queryParameters.push('$select=' + encodeURIComponent(select));
            }
            if (expand !== null && expand !== undefined) {
                queryParameters.push('$expand=' + encodeURIComponent(expand));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["CloudTask"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Updates the properties of the specified task.
     *
     * @param {string} jobId The ID of the job containing the task.
     *
     * @param {string} taskId The ID of the task to update.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.constraints] Constraints that apply to this task.
     * If omitted, the task is given the default constraints. For multi-instance
     * tasks, updating the retention time applies only to the primary task and not
     * subtasks.
     *
     * @param {moment.duration} [options.constraints.maxWallClockTime] The maximum
     * elapsed time that the task may run, measured from the time the task starts.
     * If the task does not complete within the time limit, the Batch service
     * terminates it. If this is not specified, there is no time limit on how long
     * the task may run.
     *
     * @param {moment.duration} [options.constraints.retentionTime] The minimum
     * time to retain the task directory on the compute node where it ran, from the
     * time it completes execution. After this time, the Batch service may delete
     * the task directory and all its contents. The default is infinite, i.e. the
     * task directory will be retained until the compute node is removed or
     * reimaged.
     *
     * @param {number} [options.constraints.maxTaskRetryCount] The maximum number
     * of times the task may be retried. The Batch service retries a task if its
     * exit code is nonzero. Note that this value specifically controls the number
     * of retries. The Batch service will try the task once, and may then retry up
     * to this limit. For example, if the maximum retry count is 3, Batch tries the
     * task up to 4 times (one initial try and 3 retries). If the maximum retry
     * count is 0, the Batch service does not retry the task. If the maximum retry
     * count is -1, the Batch service retries the task without limit.
     *
     * @param {object} [options.taskUpdateOptions] Additional parameters for the
     * operation
     *
     * @param {number} [options.taskUpdateOptions.timeout] The maximum time that
     * the server can spend processing the request, in seconds. The default is 30
     * seconds.
     *
     * @param {string} [options.taskUpdateOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.taskUpdateOptions.returnClientRequestId] Whether
     * the server should return the client-request-id in the response.
     *
     * @param {date} [options.taskUpdateOptions.ocpDate] The time the request was
     * issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.taskUpdateOptions.ifMatch] An ETag value associated
     * with the version of the resource known to the client. The operation will be
     * performed only if the resource's current ETag on the service exactly matches
     * the value specified by the client.
     *
     * @param {string} [options.taskUpdateOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.taskUpdateOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.taskUpdateOptions.ifUnmodifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has not been
     * modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updateWithHttpOperationResponse(jobId, taskId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let constraints = (options && options.constraints !== undefined) ? options.constraints : undefined;
            let taskUpdateOptions = (options && options.taskUpdateOptions !== undefined) ? options.taskUpdateOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            let taskUpdateParameter = {};
            try {
                if (taskUpdateOptions !== null && taskUpdateOptions !== undefined) {
                    timeout = taskUpdateOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (taskUpdateOptions !== null && taskUpdateOptions !== undefined) {
                    clientRequestId = taskUpdateOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskUpdateOptions !== null && taskUpdateOptions !== undefined) {
                    returnClientRequestId = taskUpdateOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskUpdateOptions !== null && taskUpdateOptions !== undefined) {
                    ocpDate = taskUpdateOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (taskUpdateOptions !== null && taskUpdateOptions !== undefined) {
                    ifMatch = taskUpdateOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (taskUpdateOptions !== null && taskUpdateOptions !== undefined) {
                    ifNoneMatch = taskUpdateOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (taskUpdateOptions !== null && taskUpdateOptions !== undefined) {
                    ifModifiedSince = taskUpdateOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (taskUpdateOptions !== null && taskUpdateOptions !== undefined) {
                    ifUnmodifiedSince = taskUpdateOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
                if (constraints !== null && constraints !== undefined) {
                    taskUpdateParameter.constraints = constraints;
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/tasks/{taskId}';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            requestUrl = requestUrl.replace('{taskId}', encodeURIComponent(taskId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'PUT';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (taskUpdateParameter !== null && taskUpdateParameter !== undefined) {
                    let requestModelMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["TaskUpdateParameter"];
                    requestModel = client.serializer.serialize(requestModelMapper, taskUpdateParameter, 'taskUpdateParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(taskUpdateParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the subtasks that are associated with the specified
     * multi-instance task.
     *
     * If the task is not a multi-instance task then this returns an empty
     * collection.
     *
     * @param {string} jobId The ID of the job.
     *
     * @param {string} taskId The ID of the task.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.taskListSubtasksOptions] Additional parameters for
     * the operation
     *
     * @param {string} [options.taskListSubtasksOptions.select] An OData $select
     * clause.
     *
     * @param {number} [options.taskListSubtasksOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.taskListSubtasksOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.taskListSubtasksOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.taskListSubtasksOptions.ocpDate] The time the request
     * was issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<CloudTaskListSubtasksResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listSubtasksWithHttpOperationResponse(jobId, taskId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let taskListSubtasksOptions = (options && options.taskListSubtasksOptions !== undefined) ? options.taskListSubtasksOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let select;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (taskListSubtasksOptions !== null && taskListSubtasksOptions !== undefined) {
                    select = taskListSubtasksOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (taskListSubtasksOptions !== null && taskListSubtasksOptions !== undefined) {
                    timeout = taskListSubtasksOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (taskListSubtasksOptions !== null && taskListSubtasksOptions !== undefined) {
                    clientRequestId = taskListSubtasksOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskListSubtasksOptions !== null && taskListSubtasksOptions !== undefined) {
                    returnClientRequestId = taskListSubtasksOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskListSubtasksOptions !== null && taskListSubtasksOptions !== undefined) {
                    ocpDate = taskListSubtasksOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/tasks/{taskId}/subtasksinfo';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            requestUrl = requestUrl.replace('{taskId}', encodeURIComponent(taskId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (select !== null && select !== undefined) {
                queryParameters.push('$select=' + encodeURIComponent(select));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["CloudTaskListSubtasksResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Terminates the specified task.
     *
     * When the task has been terminated, it moves to the completed state. For
     * multi-instance tasks, the terminate task operation applies synchronously to
     * the primary task; subtasks are then terminated asynchronously in the
     * background.
     *
     * @param {string} jobId The ID of the job containing the task.
     *
     * @param {string} taskId The ID of the task to terminate.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.taskTerminateOptions] Additional parameters for the
     * operation
     *
     * @param {number} [options.taskTerminateOptions.timeout] The maximum time that
     * the server can spend processing the request, in seconds. The default is 30
     * seconds.
     *
     * @param {string} [options.taskTerminateOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.taskTerminateOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.taskTerminateOptions.ocpDate] The time the request
     * was issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.taskTerminateOptions.ifMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.
     *
     * @param {string} [options.taskTerminateOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.taskTerminateOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.taskTerminateOptions.ifUnmodifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has not been
     * modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    terminateWithHttpOperationResponse(jobId, taskId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let taskTerminateOptions = (options && options.taskTerminateOptions !== undefined) ? options.taskTerminateOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (taskTerminateOptions !== null && taskTerminateOptions !== undefined) {
                    timeout = taskTerminateOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (taskTerminateOptions !== null && taskTerminateOptions !== undefined) {
                    clientRequestId = taskTerminateOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskTerminateOptions !== null && taskTerminateOptions !== undefined) {
                    returnClientRequestId = taskTerminateOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskTerminateOptions !== null && taskTerminateOptions !== undefined) {
                    ocpDate = taskTerminateOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (taskTerminateOptions !== null && taskTerminateOptions !== undefined) {
                    ifMatch = taskTerminateOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (taskTerminateOptions !== null && taskTerminateOptions !== undefined) {
                    ifNoneMatch = taskTerminateOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (taskTerminateOptions !== null && taskTerminateOptions !== undefined) {
                    ifModifiedSince = taskTerminateOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (taskTerminateOptions !== null && taskTerminateOptions !== undefined) {
                    ifUnmodifiedSince = taskTerminateOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/tasks/{taskId}/terminate';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            requestUrl = requestUrl.replace('{taskId}', encodeURIComponent(taskId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 204) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Reactivates a task, allowing it to run again even if its retry
     * count has been exhausted.
     *
     * Reactivation makes a task eligible to be retried again up to its maximum
     * retry count. The task's state is changed to active. As the task is no longer
     * in the completed state, any previous exit code or failure information is no
     * longer available after reactivation. Each time a task is reactivated, its
     * retry count is reset to 0. Reactivation will fail for tasks that are not
     * completed or that previously completed successfully (with an exit code of
     * 0). Additionally, it will fail if the job has completed (or is terminating
     * or deleting).
     *
     * @param {string} jobId The ID of the job containing the task.
     *
     * @param {string} taskId The ID of the task to reactivate.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.taskReactivateOptions] Additional parameters for
     * the operation
     *
     * @param {number} [options.taskReactivateOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.taskReactivateOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.taskReactivateOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.taskReactivateOptions.ocpDate] The time the request
     * was issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {string} [options.taskReactivateOptions.ifMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.
     *
     * @param {string} [options.taskReactivateOptions.ifNoneMatch] An ETag value
     * associated with the version of the resource known to the client. The
     * operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.
     *
     * @param {date} [options.taskReactivateOptions.ifModifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has been
     * modified since the specified time.
     *
     * @param {date} [options.taskReactivateOptions.ifUnmodifiedSince] A timestamp
     * indicating the last modified time of the resource known to the client. The
     * operation will be performed only if the resource on the service has not been
     * modified since the specified time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    reactivateWithHttpOperationResponse(jobId, taskId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let taskReactivateOptions = (options && options.taskReactivateOptions !== undefined) ? options.taskReactivateOptions : undefined;
            // Validate
            try {
                if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
                    throw new Error('jobId cannot be null or undefined and it must be of type string.');
                }
                if (taskId === null || taskId === undefined || typeof taskId.valueOf() !== 'string') {
                    throw new Error('taskId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let ifMatch;
            let ifNoneMatch;
            let ifModifiedSince;
            let ifUnmodifiedSince;
            try {
                if (taskReactivateOptions !== null && taskReactivateOptions !== undefined) {
                    timeout = taskReactivateOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (taskReactivateOptions !== null && taskReactivateOptions !== undefined) {
                    clientRequestId = taskReactivateOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskReactivateOptions !== null && taskReactivateOptions !== undefined) {
                    returnClientRequestId = taskReactivateOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskReactivateOptions !== null && taskReactivateOptions !== undefined) {
                    ocpDate = taskReactivateOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (taskReactivateOptions !== null && taskReactivateOptions !== undefined) {
                    ifMatch = taskReactivateOptions.ifMatch;
                    if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
                        throw new Error('ifMatch must be of type string.');
                    }
                }
                if (taskReactivateOptions !== null && taskReactivateOptions !== undefined) {
                    ifNoneMatch = taskReactivateOptions.ifNoneMatch;
                    if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
                        throw new Error('ifNoneMatch must be of type string.');
                    }
                }
                if (taskReactivateOptions !== null && taskReactivateOptions !== undefined) {
                    ifModifiedSince = taskReactivateOptions.ifModifiedSince;
                    if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
                        (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
                        throw new Error('ifModifiedSince must be of type date.');
                    }
                }
                if (taskReactivateOptions !== null && taskReactivateOptions !== undefined) {
                    ifUnmodifiedSince = taskReactivateOptions.ifUnmodifiedSince;
                    if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
                        (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
                        throw new Error('ifUnmodifiedSince must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/tasks/{taskId}/reactivate';
            requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
            requestUrl = requestUrl.replace('{taskId}', encodeURIComponent(taskId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                httpRequest.headers['If-Match'] = ifMatch;
            }
            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                httpRequest.headers['If-None-Match'] = ifNoneMatch;
            }
            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                httpRequest.headers['If-Modified-Since'] = ifModifiedSince instanceof Date ? ifModifiedSince.toUTCString() : ifModifiedSince;
            }
            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince instanceof Date ? ifUnmodifiedSince.toUTCString() : ifUnmodifiedSince;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 204) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists all of the tasks that are associated with the specified job.
     *
     * For multi-instance tasks, information such as affinityId, executionInfo and
     * nodeInfo refer to the primary task. Use the list subtasks API to retrieve
     * information about subtasks.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.taskListNextOptions] Additional parameters for the
     * operation
     *
     * @param {string} [options.taskListNextOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.taskListNextOptions.returnClientRequestId] Whether
     * the server should return the client-request-id in the response.
     *
     * @param {date} [options.taskListNextOptions.ocpDate] The time the request was
     * issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<CloudTaskListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let taskListNextOptions = (options && options.taskListNextOptions !== undefined) ? options.taskListNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (taskListNextOptions !== null && taskListNextOptions !== undefined) {
                    clientRequestId = taskListNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (taskListNextOptions !== null && taskListNextOptions !== undefined) {
                    returnClientRequestId = taskListNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (taskListNextOptions !== null && taskListNextOptions !== undefined) {
                    ocpDate = taskListNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["CloudTaskListResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    add(jobId, task, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.addWithHttpOperationResponse(jobId, task, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.addWithHttpOperationResponse(jobId, task, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    list(jobId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listWithHttpOperationResponse(jobId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.listWithHttpOperationResponse(jobId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    addCollection(jobId, value, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.addCollectionWithHttpOperationResponse(jobId, value, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.addCollectionWithHttpOperationResponse(jobId, value, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    deleteMethod(jobId, taskId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteMethodWithHttpOperationResponse(jobId, taskId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.deleteMethodWithHttpOperationResponse(jobId, taskId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    get(jobId, taskId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(jobId, taskId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.getWithHttpOperationResponse(jobId, taskId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    update(jobId, taskId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.updateWithHttpOperationResponse(jobId, taskId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.updateWithHttpOperationResponse(jobId, taskId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listSubtasks(jobId, taskId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listSubtasksWithHttpOperationResponse(jobId, taskId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.listSubtasksWithHttpOperationResponse(jobId, taskId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    terminate(jobId, taskId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.terminateWithHttpOperationResponse(jobId, taskId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.terminateWithHttpOperationResponse(jobId, taskId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    reactivate(jobId, taskId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.reactivateWithHttpOperationResponse(jobId, taskId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.reactivateWithHttpOperationResponse(jobId, taskId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.listNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Task;



/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__models_mappers__ = __webpack_require__(1);
/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


const WebResource = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["WebResource"];
/** Class representing a ComputeNodeOperations. */
class ComputeNodeOperations {
    /**
     * Create a ComputeNodeOperations.
     * @param {BatchServiceClient} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @summary Adds a user account to the specified compute node.
     *
     * You can add a user account to a node only when it is in the idle or running
     * state.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the machine on which you want to create a
     * user account.
     *
     * @param {object} user The user account to be created.
     *
     * @param {string} user.name The user name of the account.
     *
     * @param {boolean} [user.isAdmin] Whether the account should be an
     * administrator on the compute node. The default value is false.
     *
     * @param {date} [user.expiryTime] The time at which the account should expire.
     * If omitted, the default is 1 day from the current time. For Linux compute
     * nodes, the expiryTime has a precision up to a day.
     *
     * @param {string} [user.password] The password of the account. The password is
     * required for Windows nodes (those created with 'cloudServiceConfiguration',
     * or created with 'virtualMachineConfiguration' using a Windows image
     * reference). For Linux compute nodes, the password can optionally be
     * specified along with the sshPublicKey property.
     *
     * @param {string} [user.sshPublicKey] The SSH public key that can be used for
     * remote login to the compute node. The public key should be compatible with
     * OpenSSH encoding and should be base 64 encoded. This property can be
     * specified only for Linux nodes. If this is specified for a Windows node,
     * then the Batch service rejects the request; if you are calling the REST API
     * directly, the HTTP status code is 400 (Bad Request).
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.computeNodeAddUserOptions] Additional parameters
     * for the operation
     *
     * @param {number} [options.computeNodeAddUserOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.computeNodeAddUserOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.computeNodeAddUserOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.computeNodeAddUserOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addUserWithHttpOperationResponse(poolId, nodeId, user, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let computeNodeAddUserOptions = (options && options.computeNodeAddUserOptions !== undefined) ? options.computeNodeAddUserOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (user === null || user === undefined) {
                    throw new Error('user cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeAddUserOptions !== null && computeNodeAddUserOptions !== undefined) {
                    timeout = computeNodeAddUserOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeAddUserOptions !== null && computeNodeAddUserOptions !== undefined) {
                    clientRequestId = computeNodeAddUserOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeAddUserOptions !== null && computeNodeAddUserOptions !== undefined) {
                    returnClientRequestId = computeNodeAddUserOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeAddUserOptions !== null && computeNodeAddUserOptions !== undefined) {
                    ocpDate = computeNodeAddUserOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes/{nodeId}/users';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            requestUrl = requestUrl.replace('{nodeId}', encodeURIComponent(nodeId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (user !== null && user !== undefined) {
                    let requestModelMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["ComputeNodeUser"];
                    requestModel = client.serializer.serialize(requestModelMapper, user, 'user');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(user, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 201) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Deletes a user account from the specified compute node.
     *
     * You can delete a user account to a node only when it is in the idle or
     * running state.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the machine on which you want to delete a
     * user account.
     *
     * @param {string} userName The name of the user account to delete.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.computeNodeDeleteUserOptions] Additional parameters
     * for the operation
     *
     * @param {number} [options.computeNodeDeleteUserOptions.timeout] The maximum
     * time that the server can spend processing the request, in seconds. The
     * default is 30 seconds.
     *
     * @param {string} [options.computeNodeDeleteUserOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean}
     * [options.computeNodeDeleteUserOptions.returnClientRequestId] Whether the
     * server should return the client-request-id in the response.
     *
     * @param {date} [options.computeNodeDeleteUserOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteUserWithHttpOperationResponse(poolId, nodeId, userName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let computeNodeDeleteUserOptions = (options && options.computeNodeDeleteUserOptions !== undefined) ? options.computeNodeDeleteUserOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (userName === null || userName === undefined || typeof userName.valueOf() !== 'string') {
                    throw new Error('userName cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeDeleteUserOptions !== null && computeNodeDeleteUserOptions !== undefined) {
                    timeout = computeNodeDeleteUserOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeDeleteUserOptions !== null && computeNodeDeleteUserOptions !== undefined) {
                    clientRequestId = computeNodeDeleteUserOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeDeleteUserOptions !== null && computeNodeDeleteUserOptions !== undefined) {
                    returnClientRequestId = computeNodeDeleteUserOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeDeleteUserOptions !== null && computeNodeDeleteUserOptions !== undefined) {
                    ocpDate = computeNodeDeleteUserOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes/{nodeId}/users/{userName}';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            requestUrl = requestUrl.replace('{nodeId}', encodeURIComponent(nodeId));
            requestUrl = requestUrl.replace('{userName}', encodeURIComponent(userName));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'DELETE';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Updates the password and expiration time of a user account on the
     * specified compute node.
     *
     * This operation replaces of all the updateable properties of the account. For
     * example, if the expiryTime element is not specified, the current value is
     * replaced with the default value, not left unmodified. You can update a user
     * account on a node only when it is in the idle or running state.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the machine on which you want to update a
     * user account.
     *
     * @param {string} userName The name of the user account to update.
     *
     * @param {object} nodeUpdateUserParameter The parameters for the request.
     *
     * @param {string} [nodeUpdateUserParameter.password] The password of the
     * account. The password is required for Windows nodes (those created with
     * 'cloudServiceConfiguration', or created with 'virtualMachineConfiguration'
     * using a Windows image reference). For Linux compute nodes, the password can
     * optionally be specified along with the sshPublicKey property. If omitted,
     * any existing password is removed.
     *
     * @param {date} [nodeUpdateUserParameter.expiryTime] The time at which the
     * account should expire. If omitted, the default is 1 day from the current
     * time. For Linux compute nodes, the expiryTime has a precision up to a day.
     *
     * @param {string} [nodeUpdateUserParameter.sshPublicKey] The SSH public key
     * that can be used for remote login to the compute node. The public key should
     * be compatible with OpenSSH encoding and should be base 64 encoded. This
     * property can be specified only for Linux nodes. If this is specified for a
     * Windows node, then the Batch service rejects the request; if you are calling
     * the REST API directly, the HTTP status code is 400 (Bad Request). If
     * omitted, any existing SSH public key is removed.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.computeNodeUpdateUserOptions] Additional parameters
     * for the operation
     *
     * @param {number} [options.computeNodeUpdateUserOptions.timeout] The maximum
     * time that the server can spend processing the request, in seconds. The
     * default is 30 seconds.
     *
     * @param {string} [options.computeNodeUpdateUserOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean}
     * [options.computeNodeUpdateUserOptions.returnClientRequestId] Whether the
     * server should return the client-request-id in the response.
     *
     * @param {date} [options.computeNodeUpdateUserOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updateUserWithHttpOperationResponse(poolId, nodeId, userName, nodeUpdateUserParameter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let computeNodeUpdateUserOptions = (options && options.computeNodeUpdateUserOptions !== undefined) ? options.computeNodeUpdateUserOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (userName === null || userName === undefined || typeof userName.valueOf() !== 'string') {
                    throw new Error('userName cannot be null or undefined and it must be of type string.');
                }
                if (nodeUpdateUserParameter === null || nodeUpdateUserParameter === undefined) {
                    throw new Error('nodeUpdateUserParameter cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeUpdateUserOptions !== null && computeNodeUpdateUserOptions !== undefined) {
                    timeout = computeNodeUpdateUserOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeUpdateUserOptions !== null && computeNodeUpdateUserOptions !== undefined) {
                    clientRequestId = computeNodeUpdateUserOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeUpdateUserOptions !== null && computeNodeUpdateUserOptions !== undefined) {
                    returnClientRequestId = computeNodeUpdateUserOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeUpdateUserOptions !== null && computeNodeUpdateUserOptions !== undefined) {
                    ocpDate = computeNodeUpdateUserOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes/{nodeId}/users/{userName}';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            requestUrl = requestUrl.replace('{nodeId}', encodeURIComponent(nodeId));
            requestUrl = requestUrl.replace('{userName}', encodeURIComponent(userName));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'PUT';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (nodeUpdateUserParameter !== null && nodeUpdateUserParameter !== undefined) {
                    let requestModelMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["NodeUpdateUserParameter"];
                    requestModel = client.serializer.serialize(requestModelMapper, nodeUpdateUserParameter, 'nodeUpdateUserParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(nodeUpdateUserParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets information about the specified compute node.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node that you want to get
     * information about.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.computeNodeGetOptions] Additional parameters for
     * the operation
     *
     * @param {string} [options.computeNodeGetOptions.select] An OData $select
     * clause.
     *
     * @param {number} [options.computeNodeGetOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.computeNodeGetOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.computeNodeGetOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.computeNodeGetOptions.ocpDate] The time the request
     * was issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<ComputeNode>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(poolId, nodeId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let computeNodeGetOptions = (options && options.computeNodeGetOptions !== undefined) ? options.computeNodeGetOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let select;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeGetOptions !== null && computeNodeGetOptions !== undefined) {
                    select = computeNodeGetOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (computeNodeGetOptions !== null && computeNodeGetOptions !== undefined) {
                    timeout = computeNodeGetOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeGetOptions !== null && computeNodeGetOptions !== undefined) {
                    clientRequestId = computeNodeGetOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeGetOptions !== null && computeNodeGetOptions !== undefined) {
                    returnClientRequestId = computeNodeGetOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeGetOptions !== null && computeNodeGetOptions !== undefined) {
                    ocpDate = computeNodeGetOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes/{nodeId}';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            requestUrl = requestUrl.replace('{nodeId}', encodeURIComponent(nodeId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (select !== null && select !== undefined) {
                queryParameters.push('$select=' + encodeURIComponent(select));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["ComputeNode"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Restarts the specified compute node.
     *
     * You can restart a node only if it is in an idle or running state.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node that you want to restart.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.nodeRebootOption] When to reboot the compute node
     * and what to do with currently running tasks. Values are:
     *
     * requeue - Terminate running task processes and requeue the tasks. The tasks
     * will run again when a node is available. Restart the node as soon as tasks
     * have been terminated.
     * terminate - Terminate running tasks. The tasks will not run again. Restart
     * the node as soon as tasks have been terminated.
     * taskcompletion - Allow currently running tasks to complete. Schedule no new
     * tasks while waiting. Restart the node when all tasks have completed.
     * retaineddata - Allow currently running tasks to complete, then wait for all
     * task data retention periods to expire. Schedule no new tasks while waiting.
     * Restart the node when all task retention periods have expired.
     *
     * The default value is requeue. Possible values include: 'requeue',
     * 'terminate', 'taskCompletion', 'retainedData'
     *
     * @param {object} [options.computeNodeRebootOptions] Additional parameters for
     * the operation
     *
     * @param {number} [options.computeNodeRebootOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.computeNodeRebootOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.computeNodeRebootOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.computeNodeRebootOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    rebootWithHttpOperationResponse(poolId, nodeId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let nodeRebootOption = (options && options.nodeRebootOption !== undefined) ? options.nodeRebootOption : undefined;
            let computeNodeRebootOptions = (options && options.computeNodeRebootOptions !== undefined) ? options.computeNodeRebootOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (nodeRebootOption) {
                    let allowedValues = ['requeue', 'terminate', 'taskCompletion', 'retainedData'];
                    if (!allowedValues.some(function (item) { return item === nodeRebootOption; })) {
                        throw new Error(nodeRebootOption + ' is not a valid value. The valid values are: ' + allowedValues);
                    }
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let nodeRebootParameter;
            try {
                if (computeNodeRebootOptions !== null && computeNodeRebootOptions !== undefined) {
                    timeout = computeNodeRebootOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeRebootOptions !== null && computeNodeRebootOptions !== undefined) {
                    clientRequestId = computeNodeRebootOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeRebootOptions !== null && computeNodeRebootOptions !== undefined) {
                    returnClientRequestId = computeNodeRebootOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeRebootOptions !== null && computeNodeRebootOptions !== undefined) {
                    ocpDate = computeNodeRebootOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (nodeRebootOption !== null && nodeRebootOption !== undefined) {
                    nodeRebootParameter = {};
                    nodeRebootParameter.nodeRebootOption = nodeRebootOption;
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes/{nodeId}/reboot';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            requestUrl = requestUrl.replace('{nodeId}', encodeURIComponent(nodeId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (nodeRebootParameter !== null && nodeRebootParameter !== undefined) {
                    let requestModelMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["NodeRebootParameter"];
                    requestModel = client.serializer.serialize(requestModelMapper, nodeRebootParameter, 'nodeRebootParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(nodeRebootParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Reinstalls the operating system on the specified compute node.
     *
     * You can reinstall the operating system on a node only if it is in an idle or
     * running state. This API can be invoked only on pools created with the cloud
     * service configuration property.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node that you want to restart.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.nodeReimageOption] When to reimage the compute node
     * and what to do with currently running tasks. Values are:
     *
     * requeue - Terminate running task processes and requeue the tasks. The tasks
     * will run again when a node is available. Reimage the node as soon as tasks
     * have been terminated.
     * terminate - Terminate running tasks. The tasks will not run again. Reimage
     * the node as soon as tasks have been terminated.
     * taskcompletion - Allow currently running tasks to complete. Schedule no new
     * tasks while waiting. Reimage the node when all tasks have completed.
     * retaineddata - Allow currently running tasks to complete, then wait for all
     * task data retention periods to expire. Schedule no new tasks while waiting.
     * Reimage the node when all task retention periods have expired.
     *
     * The default value is requeue. Possible values include: 'requeue',
     * 'terminate', 'taskCompletion', 'retainedData'
     *
     * @param {object} [options.computeNodeReimageOptions] Additional parameters
     * for the operation
     *
     * @param {number} [options.computeNodeReimageOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.computeNodeReimageOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.computeNodeReimageOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.computeNodeReimageOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    reimageWithHttpOperationResponse(poolId, nodeId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let nodeReimageOption = (options && options.nodeReimageOption !== undefined) ? options.nodeReimageOption : undefined;
            let computeNodeReimageOptions = (options && options.computeNodeReimageOptions !== undefined) ? options.computeNodeReimageOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (nodeReimageOption) {
                    let allowedValues = ['requeue', 'terminate', 'taskCompletion', 'retainedData'];
                    if (!allowedValues.some(function (item) { return item === nodeReimageOption; })) {
                        throw new Error(nodeReimageOption + ' is not a valid value. The valid values are: ' + allowedValues);
                    }
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let nodeReimageParameter;
            try {
                if (computeNodeReimageOptions !== null && computeNodeReimageOptions !== undefined) {
                    timeout = computeNodeReimageOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeReimageOptions !== null && computeNodeReimageOptions !== undefined) {
                    clientRequestId = computeNodeReimageOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeReimageOptions !== null && computeNodeReimageOptions !== undefined) {
                    returnClientRequestId = computeNodeReimageOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeReimageOptions !== null && computeNodeReimageOptions !== undefined) {
                    ocpDate = computeNodeReimageOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (nodeReimageOption !== null && nodeReimageOption !== undefined) {
                    nodeReimageParameter = {};
                    nodeReimageParameter.nodeReimageOption = nodeReimageOption;
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes/{nodeId}/reimage';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            requestUrl = requestUrl.replace('{nodeId}', encodeURIComponent(nodeId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (nodeReimageParameter !== null && nodeReimageParameter !== undefined) {
                    let requestModelMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["NodeReimageParameter"];
                    requestModel = client.serializer.serialize(requestModelMapper, nodeReimageParameter, 'nodeReimageParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(nodeReimageParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 202) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Disables task scheduling on the specified compute node.
     *
     * You can disable task scheduling on a node only if its current scheduling
     * state is enabled.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node on which you want to
     * disable task scheduling.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.nodeDisableSchedulingOption] What to do with
     * currently running tasks when disabling task scheduling on the compute node.
     * Values are:
     *
     * requeue - Terminate running task processes and requeue the tasks. The tasks
     * may run again on other compute nodes, or when task scheduling is re-enabled
     * on this node. Enter offline state as soon as tasks have been terminated.
     * terminate - Terminate running tasks. The tasks will not run again. Enter
     * offline state as soon as tasks have been terminated.
     * taskcompletion - Allow currently running tasks to complete. Schedule no new
     * tasks while waiting. Enter offline state when all tasks have completed.
     *
     * The default value is requeue. Possible values include: 'requeue',
     * 'terminate', 'taskCompletion'
     *
     * @param {object} [options.computeNodeDisableSchedulingOptions] Additional
     * parameters for the operation
     *
     * @param {number} [options.computeNodeDisableSchedulingOptions.timeout] The
     * maximum time that the server can spend processing the request, in seconds.
     * The default is 30 seconds.
     *
     * @param {string}
     * [options.computeNodeDisableSchedulingOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean}
     * [options.computeNodeDisableSchedulingOptions.returnClientRequestId] Whether
     * the server should return the client-request-id in the response.
     *
     * @param {date} [options.computeNodeDisableSchedulingOptions.ocpDate] The time
     * the request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    disableSchedulingWithHttpOperationResponse(poolId, nodeId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let nodeDisableSchedulingOption = (options && options.nodeDisableSchedulingOption !== undefined) ? options.nodeDisableSchedulingOption : undefined;
            let computeNodeDisableSchedulingOptions = (options && options.computeNodeDisableSchedulingOptions !== undefined) ? options.computeNodeDisableSchedulingOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (nodeDisableSchedulingOption) {
                    let allowedValues = ['requeue', 'terminate', 'taskCompletion'];
                    if (!allowedValues.some(function (item) { return item === nodeDisableSchedulingOption; })) {
                        throw new Error(nodeDisableSchedulingOption + ' is not a valid value. The valid values are: ' + allowedValues);
                    }
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            let nodeDisableSchedulingParameter;
            try {
                if (computeNodeDisableSchedulingOptions !== null && computeNodeDisableSchedulingOptions !== undefined) {
                    timeout = computeNodeDisableSchedulingOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeDisableSchedulingOptions !== null && computeNodeDisableSchedulingOptions !== undefined) {
                    clientRequestId = computeNodeDisableSchedulingOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeDisableSchedulingOptions !== null && computeNodeDisableSchedulingOptions !== undefined) {
                    returnClientRequestId = computeNodeDisableSchedulingOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeDisableSchedulingOptions !== null && computeNodeDisableSchedulingOptions !== undefined) {
                    ocpDate = computeNodeDisableSchedulingOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
                if (nodeDisableSchedulingOption !== null && nodeDisableSchedulingOption !== undefined) {
                    nodeDisableSchedulingParameter = {};
                    nodeDisableSchedulingParameter.nodeDisableSchedulingOption = nodeDisableSchedulingOption;
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes/{nodeId}/disablescheduling';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            requestUrl = requestUrl.replace('{nodeId}', encodeURIComponent(nodeId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (nodeDisableSchedulingParameter !== null && nodeDisableSchedulingParameter !== undefined) {
                    let requestModelMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["NodeDisableSchedulingParameter"];
                    requestModel = client.serializer.serialize(requestModelMapper, nodeDisableSchedulingParameter, 'nodeDisableSchedulingParameter');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(nodeDisableSchedulingParameter, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Enables task scheduling on the specified compute node.
     *
     * You can enable task scheduling on a node only if its current scheduling
     * state is disabled
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node on which you want to
     * enable task scheduling.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.computeNodeEnableSchedulingOptions] Additional
     * parameters for the operation
     *
     * @param {number} [options.computeNodeEnableSchedulingOptions.timeout] The
     * maximum time that the server can spend processing the request, in seconds.
     * The default is 30 seconds.
     *
     * @param {string} [options.computeNodeEnableSchedulingOptions.clientRequestId]
     * The caller-generated request identity, in the form of a GUID with no
     * decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean}
     * [options.computeNodeEnableSchedulingOptions.returnClientRequestId] Whether
     * the server should return the client-request-id in the response.
     *
     * @param {date} [options.computeNodeEnableSchedulingOptions.ocpDate] The time
     * the request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    enableSchedulingWithHttpOperationResponse(poolId, nodeId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let computeNodeEnableSchedulingOptions = (options && options.computeNodeEnableSchedulingOptions !== undefined) ? options.computeNodeEnableSchedulingOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeEnableSchedulingOptions !== null && computeNodeEnableSchedulingOptions !== undefined) {
                    timeout = computeNodeEnableSchedulingOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeEnableSchedulingOptions !== null && computeNodeEnableSchedulingOptions !== undefined) {
                    clientRequestId = computeNodeEnableSchedulingOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeEnableSchedulingOptions !== null && computeNodeEnableSchedulingOptions !== undefined) {
                    returnClientRequestId = computeNodeEnableSchedulingOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeEnableSchedulingOptions !== null && computeNodeEnableSchedulingOptions !== undefined) {
                    ocpDate = computeNodeEnableSchedulingOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes/{nodeId}/enablescheduling';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            requestUrl = requestUrl.replace('{nodeId}', encodeURIComponent(nodeId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets the settings required for remote login to a compute node.
     *
     * Before you can remotely login to a node using the remote login settings, you
     * must create a user account on the node. This API can be invoked only on
     * pools created with the virtual machine configuration property. For pools
     * created with a cloud service configuration, see the GetRemoteDesktop API.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node for which to obtain the
     * remote login settings.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.computeNodeGetRemoteLoginSettingsOptions]
     * Additional parameters for the operation
     *
     * @param {number} [options.computeNodeGetRemoteLoginSettingsOptions.timeout]
     * The maximum time that the server can spend processing the request, in
     * seconds. The default is 30 seconds.
     *
     * @param {string}
     * [options.computeNodeGetRemoteLoginSettingsOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean}
     * [options.computeNodeGetRemoteLoginSettingsOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.computeNodeGetRemoteLoginSettingsOptions.ocpDate] The
     * time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<ComputeNodeGetRemoteLoginSettingsResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getRemoteLoginSettingsWithHttpOperationResponse(poolId, nodeId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let computeNodeGetRemoteLoginSettingsOptions = (options && options.computeNodeGetRemoteLoginSettingsOptions !== undefined) ? options.computeNodeGetRemoteLoginSettingsOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeGetRemoteLoginSettingsOptions !== null && computeNodeGetRemoteLoginSettingsOptions !== undefined) {
                    timeout = computeNodeGetRemoteLoginSettingsOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeGetRemoteLoginSettingsOptions !== null && computeNodeGetRemoteLoginSettingsOptions !== undefined) {
                    clientRequestId = computeNodeGetRemoteLoginSettingsOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeGetRemoteLoginSettingsOptions !== null && computeNodeGetRemoteLoginSettingsOptions !== undefined) {
                    returnClientRequestId = computeNodeGetRemoteLoginSettingsOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeGetRemoteLoginSettingsOptions !== null && computeNodeGetRemoteLoginSettingsOptions !== undefined) {
                    ocpDate = computeNodeGetRemoteLoginSettingsOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes/{nodeId}/remoteloginsettings';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            requestUrl = requestUrl.replace('{nodeId}', encodeURIComponent(nodeId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["ComputeNodeGetRemoteLoginSettingsResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets the Remote Desktop Protocol file for the specified compute
     * node.
     *
     * Before you can access a node by using the RDP file, you must create a user
     * account on the node. This API can only be invoked on pools created with a
     * cloud service configuration. For pools created with a virtual machine
     * configuration, see the GetRemoteLoginSettings API.
     *
     * @param {string} poolId The ID of the pool that contains the compute node.
     *
     * @param {string} nodeId The ID of the compute node for which you want to get
     * the Remote Desktop Protocol file.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.computeNodeGetRemoteDesktopOptions] Additional
     * parameters for the operation
     *
     * @param {number} [options.computeNodeGetRemoteDesktopOptions.timeout] The
     * maximum time that the server can spend processing the request, in seconds.
     * The default is 30 seconds.
     *
     * @param {string} [options.computeNodeGetRemoteDesktopOptions.clientRequestId]
     * The caller-generated request identity, in the form of a GUID with no
     * decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean}
     * [options.computeNodeGetRemoteDesktopOptions.returnClientRequestId] Whether
     * the server should return the client-request-id in the response.
     *
     * @param {date} [options.computeNodeGetRemoteDesktopOptions.ocpDate] The time
     * the request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<ReadableStream>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getRemoteDesktopWithHttpOperationResponse(poolId, nodeId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let computeNodeGetRemoteDesktopOptions = (options && options.computeNodeGetRemoteDesktopOptions !== undefined) ? options.computeNodeGetRemoteDesktopOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (nodeId === null || nodeId === undefined || typeof nodeId.valueOf() !== 'string') {
                    throw new Error('nodeId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeGetRemoteDesktopOptions !== null && computeNodeGetRemoteDesktopOptions !== undefined) {
                    timeout = computeNodeGetRemoteDesktopOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeGetRemoteDesktopOptions !== null && computeNodeGetRemoteDesktopOptions !== undefined) {
                    clientRequestId = computeNodeGetRemoteDesktopOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeGetRemoteDesktopOptions !== null && computeNodeGetRemoteDesktopOptions !== undefined) {
                    returnClientRequestId = computeNodeGetRemoteDesktopOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeGetRemoteDesktopOptions !== null && computeNodeGetRemoteDesktopOptions !== undefined) {
                    ocpDate = computeNodeGetRemoteDesktopOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes/{nodeId}/rdp';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            requestUrl = requestUrl.replace('{nodeId}', encodeURIComponent(nodeId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            httpRequest.rawResponse = true;
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Unexpected status code: ${statusCode}`);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the compute nodes in the specified pool.
     *
     * @param {string} poolId The ID of the pool from which you want to list nodes.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.computeNodeListOptions] Additional parameters for
     * the operation
     *
     * @param {string} [options.computeNodeListOptions.filter] An OData $filter
     * clause..
     *
     * @param {string} [options.computeNodeListOptions.select] An OData $select
     * clause.
     *
     * @param {number} [options.computeNodeListOptions.maxResults] The maximum
     * number of items to return in the response. A maximum of 1000 nodes can be
     * returned.
     *
     * @param {number} [options.computeNodeListOptions.timeout] The maximum time
     * that the server can spend processing the request, in seconds. The default is
     * 30 seconds.
     *
     * @param {string} [options.computeNodeListOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.computeNodeListOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.computeNodeListOptions.ocpDate] The time the request
     * was issued. Client libraries typically set this to the current system clock
     * time; set it explicitly if you are calling the REST API directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<ComputeNodeListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(poolId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let computeNodeListOptions = (options && options.computeNodeListOptions !== undefined) ? options.computeNodeListOptions : undefined;
            // Validate
            try {
                if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
                    throw new Error('poolId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let filter;
            let select;
            let maxResults;
            let timeout;
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeListOptions !== null && computeNodeListOptions !== undefined) {
                    filter = computeNodeListOptions.filter;
                    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
                        throw new Error('filter must be of type string.');
                    }
                }
                if (computeNodeListOptions !== null && computeNodeListOptions !== undefined) {
                    select = computeNodeListOptions.select;
                    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
                        throw new Error('select must be of type string.');
                    }
                }
                if (computeNodeListOptions !== null && computeNodeListOptions !== undefined) {
                    maxResults = computeNodeListOptions.maxResults;
                    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
                        throw new Error('maxResults must be of type number.');
                    }
                }
                if (computeNodeListOptions !== null && computeNodeListOptions !== undefined) {
                    timeout = computeNodeListOptions.timeout;
                    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
                        throw new Error('timeout must be of type number.');
                    }
                }
                if (computeNodeListOptions !== null && computeNodeListOptions !== undefined) {
                    clientRequestId = computeNodeListOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeListOptions !== null && computeNodeListOptions !== undefined) {
                    returnClientRequestId = computeNodeListOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeListOptions !== null && computeNodeListOptions !== undefined) {
                    ocpDate = computeNodeListOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/nodes';
            requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
            let queryParameters = [];
            queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (filter !== null && filter !== undefined) {
                queryParameters.push('$filter=' + encodeURIComponent(filter));
            }
            if (select !== null && select !== undefined) {
                queryParameters.push('$select=' + encodeURIComponent(select));
            }
            if (maxResults !== null && maxResults !== undefined) {
                queryParameters.push('maxresults=' + encodeURIComponent(maxResults.toString()));
            }
            if (timeout !== null && timeout !== undefined) {
                queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
            }
            if (queryParameters.length > 0) {
                requestUrl += '?' + queryParameters.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["ComputeNodeListResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Lists the compute nodes in the specified pool.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.computeNodeListNextOptions] Additional parameters
     * for the operation
     *
     * @param {string} [options.computeNodeListNextOptions.clientRequestId] The
     * caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     *
     * @param {boolean} [options.computeNodeListNextOptions.returnClientRequestId]
     * Whether the server should return the client-request-id in the response.
     *
     * @param {date} [options.computeNodeListNextOptions.ocpDate] The time the
     * request was issued. Client libraries typically set this to the current
     * system clock time; set it explicitly if you are calling the REST API
     * directly.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<ComputeNodeListResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let computeNodeListNextOptions = (options && options.computeNodeListNextOptions !== undefined) ? options.computeNodeListNextOptions : undefined;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let clientRequestId;
            let returnClientRequestId;
            let ocpDate;
            try {
                if (computeNodeListNextOptions !== null && computeNodeListNextOptions !== undefined) {
                    clientRequestId = computeNodeListNextOptions.clientRequestId;
                    if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["isValidUuid"](clientRequestId))) {
                        throw new Error('clientRequestId must be of type string and must be a valid string.');
                    }
                }
                if (computeNodeListNextOptions !== null && computeNodeListNextOptions !== undefined) {
                    returnClientRequestId = computeNodeListNextOptions.returnClientRequestId;
                    if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
                        throw new Error('returnClientRequestId must be of type boolean.');
                    }
                }
                if (computeNodeListNextOptions !== null && computeNodeListNextOptions !== undefined) {
                    ocpDate = computeNodeListNextOptions.ocpDate;
                    if (ocpDate && !(ocpDate instanceof Date ||
                        (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
                        throw new Error('ocpDate must be of type date.');
                    }
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['client-request-id'] = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["generateUuid"]();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                httpRequest.headers['client-request-id'] = clientRequestId.toString();
            }
            if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
                httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
            }
            if (ocpDate !== undefined && ocpDate !== null) {
                httpRequest.headers['ocp-date'] = ocpDate instanceof Date ? ocpDate.toUTCString() : ocpDate;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                    error.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            let internalError = null;
                            if (parsedErrorResponse.error)
                                internalError = parsedErrorResponse.error;
                            error.code = internalError ? internalError.code : parsedErrorResponse.code;
                            error.message = internalError ? internalError.message : parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["BatchError"];
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = __WEBPACK_IMPORTED_MODULE_1__models_mappers__["ComputeNodeListResult"];
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["RestError"](`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripRequest"](httpRequest);
                        deserializationError.response = __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["stripResponse"](response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    addUser(poolId, nodeId, user, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.addUserWithHttpOperationResponse(poolId, nodeId, user, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.addUserWithHttpOperationResponse(poolId, nodeId, user, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    deleteUser(poolId, nodeId, userName, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteUserWithHttpOperationResponse(poolId, nodeId, userName, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.deleteUserWithHttpOperationResponse(poolId, nodeId, userName, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    updateUser(poolId, nodeId, userName, nodeUpdateUserParameter, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.updateUserWithHttpOperationResponse(poolId, nodeId, userName, nodeUpdateUserParameter, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.updateUserWithHttpOperationResponse(poolId, nodeId, userName, nodeUpdateUserParameter, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    get(poolId, nodeId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(poolId, nodeId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.getWithHttpOperationResponse(poolId, nodeId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    reboot(poolId, nodeId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.rebootWithHttpOperationResponse(poolId, nodeId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.rebootWithHttpOperationResponse(poolId, nodeId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    reimage(poolId, nodeId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.reimageWithHttpOperationResponse(poolId, nodeId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.reimageWithHttpOperationResponse(poolId, nodeId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    disableScheduling(poolId, nodeId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.disableSchedulingWithHttpOperationResponse(poolId, nodeId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.disableSchedulingWithHttpOperationResponse(poolId, nodeId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    enableScheduling(poolId, nodeId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.enableSchedulingWithHttpOperationResponse(poolId, nodeId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.enableSchedulingWithHttpOperationResponse(poolId, nodeId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    getRemoteLoginSettings(poolId, nodeId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getRemoteLoginSettingsWithHttpOperationResponse(poolId, nodeId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.getRemoteLoginSettingsWithHttpOperationResponse(poolId, nodeId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    getRemoteDesktop(poolId, nodeId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getRemoteDesktopWithHttpOperationResponse(poolId, nodeId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsStream);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.getRemoteDesktopWithHttpOperationResponse(poolId, nodeId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsStream;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    list(poolId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listWithHttpOperationResponse(poolId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.listWithHttpOperationResponse(poolId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0_ms_rest_ts__["promiseToCallback"](this.listNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ComputeNodeOperations;



/***/ })
/******/ ]);
//# sourceMappingURL=bundle.js.map